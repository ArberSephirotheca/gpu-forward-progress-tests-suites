#!amber

DEVICE_FEATURE SubgroupSizeControl.subgroupSizeControl

SET ENGINE_DATA fence_timeout_ms 10000

SHADER compute test GLSL
#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_maximal_reconvergence : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer Checker {
 uint checker[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
  return;
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  {
   switch(_GLF_SWITCH(_GLF_IDENTITY(0, (0) >> 0)))
    {
     case 33:
     {
      {
       bvec4(true, false, true, true);
      }
      for(      true;
 (mat4x3(4.7, 6372.4474, -7.7, -1.0, -5.6, 8834.0786, -1.7, 868.130, 1.7, -52.15, 428.446, 72.83) == mat4x3(4138.1648, 440.451, 2675.3949, 1867.9377, -744.656, -944.331, 754.653, 250.981, 8815.3825, -20.87, -3966.8802, 2.5)); mat4(970.159, -1.2, 5.3, -8471.8689, 4345.9731, -7.6, 45.51, -718.101, -445.128, -7201.3174, -3.0, 771.470, -1.9, 334.190, 304.996, -0.6))
       {
        bvec4 _GLF_SWITCH_5_0v;
        uvec2(136167u, 70467u)[1];
        if(true)
         {
         }
        else
         {
          uint _GLF_SWITCH_5_1v, _GLF_SWITCH_5_2v[85];
          ;
          mat2x3(1.4, 38.34, -27.66, -8150.8566, -8.2, -8768.8869);
         }
        mat4x3 _GLF_SWITCH_5_3v, _GLF_SWITCH_5_4v[99], _GLF_SWITCH_5_5v;
        while(true)
         {
          mat4 _GLF_SWITCH_5_6v;
         }
        if(false)
         {
          ivec3 _GLF_SWITCH_5_7v[71], _GLF_SWITCH_5_8v, _GLF_SWITCH_5_9v[41];
          max(uvec2(94637u, 135219u), uvec2(159606u, 108936u));
         }
        else
         {
         }
       }
      ivec4(-26431, -2951, -17331, 28783);
      (+ mat2x4(-4402.1536, -9678.4765, 1.1, 47.77, 5.5, -85.73, -9.7, 3884.4169));
      (-74251 & ivec2(20052, 76331));
      if((1568.9448 != 82.67))
       {
        {
         log2(log2(float(false)));
         asin(-84.28);
         ;
         bvec4 _GLF_SWITCH_5_10v;
        }
       }
      ;
     }
     case 0:
     case 4:
     case 1:
     if(_GLF_DEAD(false))
      return;
     case 85:
     barrier();
     break;
     case 27:
     bvec3(true, false, true);
     case 45:
     {
     }
     default:
     1;
    }
  }
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = _GLF_IDENTITY(gl_NumWorkGroups, _GLF_IDENTITY(max(_GLF_IDENTITY(gl_NumWorkGroups, max(gl_NumWorkGroups, gl_NumWorkGroups)), _GLF_IDENTITY(gl_NumWorkGroups, uvec3(0u, 0u, 0u) + (gl_NumWorkGroups))), max(_GLF_IDENTITY(max(_GLF_IDENTITY(gl_NumWorkGroups, max(gl_NumWorkGroups, gl_NumWorkGroups)), _GLF_IDENTITY(gl_NumWorkGroups, uvec3(0u, 0u, 0u) + (gl_NumWorkGroups))), (max(_GLF_IDENTITY(gl_NumWorkGroups, max(gl_NumWorkGroups, gl_NumWorkGroups)), _GLF_IDENTITY(gl_NumWorkGroups, uvec3(0u, 0u, 0u) + (gl_NumWorkGroups)))) | (uvec3(0u, 0u, 0u) << _GLF_IDENTITY(uvec3(5u), uvec3(5u)))), max(_GLF_IDENTITY(gl_NumWorkGroups, max(gl_NumWorkGroups, gl_NumWorkGroups)), _GLF_IDENTITY(gl_NumWorkGroups, uvec3(0u, 0u, 0u) + (gl_NumWorkGroups)))))).x;
 uint workgroup_size = gl_WorkGroupSize.x;
 uint workgroup_id = gl_WorkGroupID.x;
 if(_GLF_DEAD(false))
  return;
 uint workgroup_base = _GLF_IDENTITY(workgroup_size * workgroup_id, min(workgroup_size * workgroup_id, workgroup_size * workgroup_id));
 if(_GLF_DEAD(false))
  barrier();
 do
  {
   switch(_GLF_SWITCH((0 << _GLF_IDENTITY(int(7), int(7)))))
    {
     case 71:
     for(bvec4 _GLF_SWITCH_5_0v; (ivec3(-85290, -60863, 86079) == ivec3(77255, 66594, -21460)); uvec3(133445u, 180148u, 135741u).tt)
      {
       while(true)
        {
         float _GLF_SWITCH_5_1v, _GLF_SWITCH_5_2v, _GLF_SWITCH_5_3v[65];
        }
       (num_workgroup & uvec2(190587u, 115650u));
       if(true)
        {
         if(false)
          {
           (mat2x4(9.5, 7.7, 824.051, -85.26, -9.0, 1.5, 87.85, 1.3) + 1.3);
           (mat2(-945.147, 4423.7266, 25.27, -113.434) - mat2(-1.4, -3.6, 75.94, 776.256));
           bvec4 _GLF_SWITCH_5_4v[34], _GLF_SWITCH_5_5v;
           mat2x3 _GLF_SWITCH_5_6v;
           mat4x3(acos(-47.21));
           bool _GLF_SWITCH_5_7v[88];
           uvec4(147212u, 131816u, 190914u, 162374u);
           vec2 _GLF_SWITCH_5_8v, _GLF_SWITCH_5_9v[22], _GLF_SWITCH_5_10v;
          }
         else
          {
           min(ivec4(-91833, 94116, 14157, -69401), (-48037 | -47618));
           int _GLF_SWITCH_5_11v, _GLF_SWITCH_5_12v;
           (atanh(5.8) / mat4(2943.7459, 5.3, 34.65, -809.608, 63.48, -51.36, 583.817, 7514.3524, -2.2, 60.55, -33.65, 8.6, -4764.9158, 5368.8312, 43.35, -4.0));
           ivec2(58107, -53398);
          }
         if((((mat2x4(-5.9, -7.8, -4.1, 3137.4515, 3.6, 0.4, -3.3, 4.7)) + -83.57) != mat2x4(mat4x3(29.22, 9.8, -35.12, 3234.7935, -307.433, 4.7, -39.51, -4.8, 4.0, 7526.1646, 3.9, -9695.3145))))
          {
           min(uvec2(181158u, 169517u), packHalf2x16(vec2(376.238, 9.4)));
           (-6.7 - mat3x2(vec2(-5889.4864, 7523.4107), injectionSwitch, vec2(5.1, 77.45)));
           mat3x2(78.23, 335.974, 6337.3402, 9770.0170, 59.13, 5745.8135);
           vec3(6.9, 33.57, -1.9);
           uvec3(7973u, 15707u, 106405u);
           mat2x3(765.777, 1.1, 2231.2020, -8.9, 5.0, 8557.4946);
           1.7;
           ;
           uvec2 _GLF_SWITCH_5_13v[3], _GLF_SWITCH_5_14v[17], _GLF_SWITCH_5_15v[13];
          }
        }
       if((false ^^ (ivec3(91455, 53504, -96912) == ivec3(60377, 62690, 42909))))
        {
         ((-1313.1591 + mat3(-797.730, -4.1, 5.0, 894.292, -7.0, 2040.4972, -106.026, -888.683, 4.2)) , ivec2(98924, 51953));
         if(isinf(-81.60))
          {
           (mat3(-89.36, 2835.3494, 6.0, -59.27, 1.4, -3.6, -368.715, 3.6, -4439.6447));
           injectionSwitch;
           vec3 _GLF_SWITCH_5_16v;
           float _GLF_SWITCH_5_17v[97], _GLF_SWITCH_5_18v, _GLF_SWITCH_5_19v[18];
           mat4x3 _GLF_SWITCH_5_20v, _GLF_SWITCH_5_21v, _GLF_SWITCH_5_22v;
          }
         else
          {
           (-5.7 - mat3x2(-198.072, -6991.4307, 2650.2574, -5438.0297, -7027.2665, 3311.2234));
           (max(ivec3(49750, -23615, 30632), ivec3(67980, -72624, -29807)) >> ivec3(-35510, 65582, -83398));
           vec4 _GLF_SWITCH_5_23v[64], _GLF_SWITCH_5_24v[75];
           ((ivec4(-21876, -46891, -45184, -20671) | -96472) << ivec4(-23022, -67375, -39425, -59037))[2];
           outerProduct(vec4(-803.979, -746.678, 6.1, -23.01), vec2(4739.2503, 3.1));
           uvec4(136888u, 59400u, 120376u, 173530u);
           bvec2(true, true);
           uvec3(134301u, 184908u, 156734u);
           ;
          }
         {
          (distance(vec3(-58.05, -0.6, 28.09), vec3(-565.645, -407.085, -0.5)) >= trunc(-5.8));
          ;
          -274.736;
          (mat2x4(189.732, 2225.5577, 9145.2493, -30.06, -807.446, 942.241, -3.6, -159.528) * mat2(-3.5, 27.55, 7.0, 7380.4369));
          outerProduct(vec3(-0.6, 703.742, -8945.7789), vec3(4693.6827, 3.0, 8096.2595));
         }
        }
       {
        ;
        for(        34.08;
 (mat3(0.9, -2.0, 31.05, 2.0, 7.2, -79.29, -2009.3796, 3.9, -393.783) != mat3(-421.263, -416.181, -0.1, -8556.6720, -56.93, 2.6, 873.006, -8.9, -26.75)); bvec2(false, true))
         {
          ivec3(99536, 43416, 74114);
         }
       }
       for(       ivec4(-74884, -45639, 46249, -97903);
 (subgroup_size < workgroup_size); mat2(4.0, -9745.6907, 7.5, -75.54))
        {
         for(         (- ivec3(-69648, 66894, -95505));
 bool(workgroup_base); tanh(vec2(1.6, -6128.3326)))
          {
           mat4 _GLF_SWITCH_5_25v;
           (-3217 ^ ivec4(-46666, -51346, 82847, 44157));
           mat2x3 _GLF_SWITCH_5_26v[94], _GLF_SWITCH_5_27v;
          }
         do
          {
          }
         while((true));
         for(         atomicMax(num_workgroup, (++ subgroup_local_id));
 false; mat3x2(mat4x2(-3.6, 2.6, 7.4, -1.4, 551.798, -0.9, 7.7, 9.9)))
          {
           84605;
           mat2x4(-2.7, -6.0, 99.69, 8.5, 941.767, -3123.9562, 486.765, 2.3);
          }
         if((mat3(71.86, 107.946, 20.56, 48.93, -1.3, -30.15, 2.5, -8.3, 4.0) == mat3(2.1, 3.2, -98.89, 699.887, -98.60, 465.596, -2281.4716, 9.6, -8.2)))
          {
           mat3x2(mat4x3(3.0, -1.3, 7.5, -98.58, -0.3, -16.72, 8319.5859, 63.20, -0.4, 839.014, -108.285, 1.2));
           (mat3(105.774, 51.12, 8369.8092, 4946.0153, -114.321, -1.8, 8304.0193, -100.471, -57.14) + 8605.5647);
           ivec3 _GLF_SWITCH_5_28v;
           uvec3 _GLF_SWITCH_5_29v[33], _GLF_SWITCH_5_30v[6];
           equal(uvec2(69108u, 35956u), (uvec2(34821u, 103360u) ^ workgroup_base));
           bvec2(false, true);
           mat2 _GLF_SWITCH_5_31v, _GLF_SWITCH_5_32v;
           mat3x4 _GLF_SWITCH_5_33v[71];
          }
        }
      }
     case 0:
     case 80:
     case 94:
     case 56:
     case 42:
     case 19:
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        continue;
       return;
      }
     break;
     case 22:
     while(false)
      {
       for(mat3x4 _GLF_SWITCH_5_34v, _GLF_SWITCH_5_35v, _GLF_SWITCH_5_36v; (mat2(2514.0882, 5.4, -2628.0484, -778.406) == mat2(-284.830, -1471.2780, -77.10, -9.7)); uvec2(126271u, 9157u).xx)
        {
         ivec2(92880, 31463);
         ((- mat2x4(-3.3, 972.121, -41.51, -413.136, 16.60, -887.491, -5.1, -5.0)) + 35.06);
         {
          mat3x4((mat4x2(8.5, 50.85, -8.7, -9.2, -966.856, 0.7, 831.927, 230.283) - -269.496));
          ivec3(83285, -9127, 82394);
          mat2 _GLF_SWITCH_5_37v;
         }
         vec3 _GLF_SWITCH_5_38v;
         ;
         if((step(vec3(-1.9, 5.9, -229.289), _GLF_SWITCH_5_38v) == _GLF_SWITCH_5_38v))
          {
           mat2x3 _GLF_SWITCH_5_39v, _GLF_SWITCH_5_40v[40], _GLF_SWITCH_5_41v;
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             mat2(251.608, 28.80, 1531.9439, -1.6);
            }
           vec3 _GLF_SWITCH_5_42v, _GLF_SWITCH_5_43v, _GLF_SWITCH_5_44v;
           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 & int(_GLF_ONE(1.0, injectionSwitch.y)))); _injected_loop_counter ++)
            {
             findMSB(uvec2(59286u, 74040u));
            }
          }
         else
          {
          }
         {
          abs(ivec3(-23471, -46893, 40724));
         }
         while(bvec2(false, true)[0])
          {
           _GLF_SWITCH_5_36v[2];
           ;
           ;
           ceil(_GLF_SWITCH_5_38v);
           mat3x4 _GLF_SWITCH_5_45v[22], _GLF_SWITCH_5_46v[39], _GLF_SWITCH_5_47v[58];
           ivec2 _GLF_SWITCH_5_48v;
           lessThanEqual(floatBitsToUint(injectionSwitch), uvec2(109709u, 102979u));
          }
        }
      }
     default:
     1;
    }
  }
 while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, bool(bvec3(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false)))));
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    return;
   return;
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 uint subgroup_base = subgroup_id * subgroup_size;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     barrier();
    }
  }
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   return;
  }
 uint virtual_gid = workgroup_base + subgroup_base + subgroup_local_id;
 uint next_virtual_gid = workgroup_base + subgroup_base + ((subgroup_local_id + 1) % subgroup_size);
 if(_GLF_DEAD(false))
  return;
 uint read = atomicLoad(buf[virtual_gid], 4, _GLF_IDENTITY(64, _GLF_IDENTITY(int(ivec2(64, 1)), (int(ivec2(64, 1))) ^ 0)), 2);
 if((subgroup_local_id % 2) == 0)
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_DEAD(false))
      barrier();
    }
   else
    {
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, clamp(_GLF_IDENTITY(injectionSwitch.y, (injectionSwitch.y) - 0.0), _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.y, 1.0 * (_GLF_IDENTITY(injectionSwitch.y, 1.0 * (injectionSwitch.y)))), clamp(_GLF_IDENTITY(injectionSwitch.y, 1.0 * (_GLF_IDENTITY(injectionSwitch.y, 1.0 * (injectionSwitch.y)))), _GLF_IDENTITY(injectionSwitch.y, 1.0 * (_GLF_IDENTITY(injectionSwitch.y, 1.0 * (injectionSwitch.y)))), _GLF_IDENTITY(injectionSwitch.y, 1.0 * (_GLF_IDENTITY(injectionSwitch.y, 1.0 * (injectionSwitch.y)))))), injectionSwitch.y))))))
    {
     do
      {
       if(_GLF_DEAD(false))
        return;
       barrier();
      }
     while(_GLF_WRAPPED_LOOP(false));
     if(_GLF_DEAD(false))
      return;
    }
   atomicStore(buf[next_virtual_gid], uint(1), 4, 64, 4);
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
    {
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(false))
      return;
     barrier();
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || false)))
        barrier();
       barrier();
      }
    }
  }
 else
  {
   switch(_GLF_SWITCH(_GLF_IDENTITY(0, (0) - (73814 & 0))))
    {
     case 17:
     ;
     case 0:
     atomicStore(buf[next_virtual_gid], uint(1), 4, 64, 4);
     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
      return;
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
        }
       else
        {
         switch(_GLF_SWITCH((0 >> _GLF_IDENTITY(int(7), int(7)))))
          {
           case 42:
           mat3 _GLF_SWITCH_4_0v;
           case 83:
           vec3 _GLF_SWITCH_4_1v;
           case 0:
           case 3:
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              return;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             return;
            }
           barrier();
           break;
           case 16:
           if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
            return;
           if(false)
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               do
                {
                 return;
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             uvec4 _GLF_SWITCH_4_2v[93];
             uvec2 _GLF_SWITCH_4_3v;
             mat3(mat3x4(5.0, -874.623, -7.1, 30.90, -1.4, -817.086, 5255.0243, -261.216, 1.6, 6897.7517, 9.9, -8.9));
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             uvec3(165195u, 28852u, 98790u);
             vec2(-90.59, 420.856);
            }
           else
            {
             bvec3 _GLF_SWITCH_4_4v[94];
             8.3;
             mat2x4(4978.9967, 87.83, 3.6, -0.9, 27.60, 256.510, 27.00, 8.3);
             (lessThanEqual(ivec3(2905, -80415, -19202), ivec3(52275, -24813, -66590)) == equal(atanh(vec3(5.0, 336.644, 3399.6411)), _GLF_SWITCH_4_1v));
             uvec2 _GLF_SWITCH_4_5v, _GLF_SWITCH_4_6v;
             ((354.654 + mat2(-73.17, -5898.1841, 8.6, 4034.1391)) - mat2(-39.45, -8745.0041, 233.087, -5.7));
             mat2x3 _GLF_SWITCH_4_7v;
             if(_GLF_DEAD(false))
              return;
             ivec3 _GLF_SWITCH_4_8v, _GLF_SWITCH_4_9v;
             uvec4(159180u, 113813u, 58394u, 85904u);
            }
           case 31:
           {
            if(_GLF_DEAD(false))
             barrier();
           }
           default:
           1;
          }
        }
      }
     break;
     case 70:
     if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, ! (! (true)))))
      {
       (+ mat3(-929.599, 127.401, 4357.6383, -4.3, -36.67, 1.7, 9.8, -8.4, -32.80));
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          return;
         return;
        }
       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true)))
          barrier();
         return;
        }
       if(_GLF_IDENTITY((virtual_gid != workgroup_size), ! (! ((virtual_gid != workgroup_size)))))
        {
         if(_GLF_DEAD(false))
          barrier();
         switch(_GLF_SWITCH(0))
          {
           case 47:
           if(_GLF_DEAD(false))
            barrier();
           mat4x3 _GLF_SWITCH_1_0v[48], _GLF_SWITCH_1_1v;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           case 62:
           mat2x3((mat3x4(_GLF_IDENTITY(477.893, max(477.893, 477.893)), 96.34, -0.4, -246.989, 63.50, -4.4, 622.026, 9879.7689, 8248.9301, -54.42, _GLF_IDENTITY(-2.6, clamp(-2.6, -2.6, -2.6)), -4.4) / mat3x4(26.49, 6.6, -75.12, -193.101, 1.2, 538.001, 5.2, 9075.5030, _GLF_IDENTITY(-1.8, (false ? _GLF_FUZZED(-2.7) : -1.8)), -650.490, 92.91, 57.33)));
           case 0:
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               switch(_GLF_SWITCH(0))
                {
                 case 0:
                 case 2:
                 if(false)
                  {
                   vec4(-84.26, -9.1, 379.131, -21.24).ttqp;
                   if(_GLF_DEAD(false))
                    barrier();
                   ;
                   (workgroup_base + uvec2(75319u, 39019u))[0];
                   bvec4((_GLF_IDENTITY((mat4(-0.9, -3.8, -4.0, -787.644, -8.6, _GLF_IDENTITY(-63.10, max(-63.10, _GLF_IDENTITY(-63.10, 0.0 + _GLF_IDENTITY((-63.10), ((-63.10)) / 1.0)))), 869.372, 1253.5290, 5.4, -80.17, -42.77, -3.8, 52.69, -9.1, _GLF_IDENTITY(978.074, (true ? _GLF_IDENTITY(978.074, (978.074) / exp(0.0)) : _GLF_FUZZED(tan(-44.99)))), 6.5) / mat4(1.2, 0.5, _GLF_IDENTITY(1200.1268, float(mat4x2(_GLF_IDENTITY(1200.1268, (false ? _GLF_FUZZED(-7.9) : _GLF_IDENTITY(1200.1268, mix(float(_GLF_FUZZED(7.9)), float(1200.1268), bool(true))))), 0.0, 0.0, 1.0, length(vec3(0.0, 0.0, 0.0)), 0.0, _GLF_ONE(1.0, injectionSwitch.y), 0.0))), 2.9, _GLF_IDENTITY(-578.104, (-578.104) * _GLF_ONE(1.0, injectionSwitch.y)), 4.3, 915.560, -9.4, 0.7, 5882.1920, -619.698, -7.0, 9.6, 948.963, 4.3, 4210.4967)), (_GLF_IDENTITY(true, (true) || false) ? (mat4(-0.9, -3.8, -4.0, _GLF_IDENTITY(-787.644, min(_GLF_IDENTITY(-787.644, _GLF_IDENTITY(float(vec4(-787.644, 1.0, 0.0, 1.0)), min(float(vec4(-787.644, 1.0, 0.0, 1.0)), float(vec4(-787.644, 1.0, 0.0, 1.0))))), -787.644)), -8.6, _GLF_IDENTITY(-63.10, max(-63.10, _GLF_IDENTITY(-63.10, 0.0 + _GLF_IDENTITY(_GLF_IDENTITY((-63.10), ((-63.10)) * 1.0), min(_GLF_IDENTITY((-63.10), ((-63.10)) * 1.0), _GLF_IDENTITY((-63.10), ((-63.10)) * 1.0)))))), 869.372, 1253.5290, 5.4, -80.17, -42.77, -3.8, 52.69, -9.1, 978.074, 6.5) / _GLF_IDENTITY(mat4(1.2, 0.5, _GLF_IDENTITY(1200.1268, float(mat4x2(_GLF_IDENTITY(1200.1268, (false ? _GLF_FUZZED(-7.9) : _GLF_IDENTITY(1200.1268, mix(float(_GLF_FUZZED(7.9)), float(1200.1268), bool(true))))), 0.0, 0.0, 1.0, length(vec3(0.0, 0.0, 0.0)), 0.0, _GLF_ONE(1.0, injectionSwitch.y), 0.0))), 2.9, -578.104, _GLF_IDENTITY(4.3, (4.3) - 0.0), 915.560, -9.4, _GLF_IDENTITY(0.7, min(_GLF_IDENTITY(0.7, (0.7) / 1.0), 0.7)), 5882.1920, -619.698, -7.0, 9.6, 948.963, 4.3, 4210.4967), (false ? _GLF_FUZZED(mat4(3.4, 1.9, -6.7, -7267.5077, -7372.2680, -2.3, 3.0, -5.8, 887.225, -6816.2242, -2.5, -78.09, 9.7, -8.6, 20.91, -9055.6858)) : mat4(1.2, 0.5, _GLF_IDENTITY(1200.1268, float(mat4x2(_GLF_IDENTITY(1200.1268, (false ? _GLF_FUZZED(-7.9) : _GLF_IDENTITY(1200.1268, mix(float(_GLF_FUZZED(7.9)), float(1200.1268), bool(true))))), 0.0, 0.0, 1.0, length(vec3(0.0, 0.0, 0.0)), 0.0, _GLF_ONE(1.0, injectionSwitch.y), 0.0))), 2.9, -578.104, _GLF_IDENTITY(4.3, (4.3) - 0.0), 915.560, -9.4, _GLF_IDENTITY(0.7, min(_GLF_IDENTITY(0.7, (0.7) / 1.0), 0.7)), 5882.1920, -619.698, -7.0, 9.6, 948.963, 4.3, 4210.4967)))) : _GLF_FUZZED(mat4(-361.270, 4518.5574, _GLF_IDENTITY(-451.091, min(-451.091, -451.091)), -875.087, 9.4, -0.6, 1.9, 4.4, 21.00, 383.569, -2.5, 3.3, 8.6, -181.685, -5.8, -352.808)))) == mat4(-6.4, 91.05, -4.6, -6.0, -717.733, -7.5, 5.0, -346.948, 2.4, 5.2, -479.198, -66.64, -8.9, -1829.9723, -9.0, 775.505)), true, bvec2(false, true));
                   if(_GLF_DEAD(false))
                    return;
                  }
                 else
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     return;
                    }
                   switch(_GLF_SWITCH(0))
                    {
                     case 0:
                     case 50:
                     mat4 _GLF_SWITCH_0_0v[40], _GLF_SWITCH_0_1v, _GLF_SWITCH_0_2v[65];
                     case 38:
                     ivec4(-66742, -76693, -55688, _GLF_IDENTITY(55442, (_GLF_IDENTITY(55442, min(55442, _GLF_IDENTITY(55442, (false ? _GLF_FUZZED(-75831) : 55442))))) | _GLF_IDENTITY((55442), _GLF_IDENTITY(int(ivec2((55442), 0)), min(int(ivec2((55442), 0)), int(ivec2((55442), 0)))))));
                     for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), true && (_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), false || ((injectionSwitch.x > injectionSwitch.y))))))))
                        barrier();
                      }
                     break;
                     default:
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      return;
                     1;
                     if(_GLF_DEAD(false))
                      return;
                    }
                  }
                 break;
                 case 94:
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 if(_GLF_DEAD(false))
                  return;
                 mat2x4(mat4x2(470.994, 274.125, 2.8, -9.2, -496.819, -1.0, 1.5, -380.983));
                 case 21:
                 -96423;
                 default:
                 if(_GLF_DEAD(false))
                  return;
                 do
                  {
                   1;
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                }
              }
            }
           while(_GLF_IDENTITY(true, (_GLF_IDENTITY(true, ! (! (true)))) || _GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false || (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! _GLF_IDENTITY((false), bool(_GLF_IDENTITY(bool((false)), (bool((false))) || false)))))))
              continue;
             switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
              {
               case 8:
               int _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v;
               case 22:
               (_GLF_IDENTITY(ivec3(-2, 85927, -58384) - ivec3(-60129, -85759, -91103), min(_GLF_IDENTITY(ivec3(-2, 85927, -58384) - ivec3(-60129, -85759, -91103), ~ (~ (ivec3(-2, 85927, -58384) - ivec3(-60129, -85759, -91103)))), ivec3(-2, 85927, -58384) - ivec3(-60129, -85759, -91103))));
               case 0:
               mat3x2(-190.274, 7.8, -98.12, 8.2, -118.303, 8.6);
               case 30:
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 break;
                }
               mat2x3 _GLF_SWITCH_0_3v[78], _GLF_SWITCH_0_4v, _GLF_SWITCH_0_5v;
               mat2(273.381, _GLF_IDENTITY(-5.7, clamp(-5.7, -5.7, -5.7)), 117.313, -7.1);
               case 12:
               if(_GLF_DEAD(false))
                {
                 switch(_GLF_SWITCH(0))
                  {
                   case 0:
                   case 47:
                   case 56:
                   case 96:
                   case 19:
                   case 26:
                   case 38:
                   case 80:
                   case 25:
                   case 41:
                   do
                    {
                     barrier();
                    }
                   while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                   break;
                   case 94:
                   (43.34 - cos(vec4(-733.129, 2485.9068, 913.315, -7.1)));
                   case 3:
                   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                    {
                     mat2(-7427.0504, 416.543, 0.9, 809.087);
                    }
                   default:
                   1;
                  }
                }
               case 23:
               ;
               case 91:
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                return;
               vec3 _GLF_SWITCH_0_6v;
               if(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(false), (_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(false), ! (! (_GLF_WRAPPED_IF_FALSE(false))))) || false))
                {
                }
               else
                {
                 uvec3(65791u, 36868u, 60128u);
                }
               if(_GLF_DEAD(false))
                return;
               break;
               case 19:
               bvec3(false, true, true);
               if(_GLF_DEAD(false))
                return;
               default:
               _GLF_IDENTITY(1, clamp(1, 1, 1));
              }
            }
           bvec3 _GLF_SWITCH_0_7v[7], _GLF_SWITCH_0_8v;
           if(_GLF_DEAD(false))
            barrier();
           break;
           case 56:
           _GLF_IDENTITY(54472u, (54472u) | 0u);
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           case 36:
           ivec2 _GLF_SWITCH_1_2v, _GLF_SWITCH_1_3v;
           default:
           if(_GLF_IDENTITY(_GLF_DEAD(false), bool(bool(_GLF_DEAD(false)))))
            return;
           if(_GLF_DEAD(false))
            barrier();
           1;
          }
        }
       else
        {
         mat2x3 _GLF_SWITCH_0_9v, _GLF_SWITCH_0_10v[13], _GLF_SWITCH_0_11v;
         mat3x4 _GLF_SWITCH_0_12v;
         for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(4), int(4))); _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 & 1)); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         vec3(243.948, 8.0, 4.5);
         if(false)
          {
           switch(_GLF_SWITCH((int(_GLF_ZERO(0.0, injectionSwitch.x)) >> _GLF_IDENTITY(int(5), int(5)))))
            {
             case 15:
             equal(uvec4(27084u, 9931u, 13050u, 77303u), uvec4(79233u, 148738u, 125474u, 176772u));
             case 93:
             uvec3 _GLF_SWITCH_2_0v;
             case 0:
             case 5:
             case 10:
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
             float _GLF_SWITCH_0_13v[46], _GLF_SWITCH_0_14v[56];
             case 78:
             do
              {
               min(uvec2(_GLF_IDENTITY(105276u, uint(uvec2(105276u, 0u))), _GLF_IDENTITY(79722u, clamp(_GLF_IDENTITY(79722u, 0u | (79722u)), 79722u, 79722u))), workgroup_id);
              }
             while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) || false)));
             case 38:
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             ivec4 _GLF_SWITCH_0_15v;
             uint _GLF_SWITCH_0_16v, _GLF_SWITCH_0_17v, _GLF_SWITCH_0_18v[18];
             case 88:
             case 19:
             mat2 _GLF_SWITCH_0_19v, _GLF_SWITCH_0_20v[50], _GLF_SWITCH_0_21v[33];
             vec2 _GLF_SWITCH_0_22v;
             if(_GLF_DEAD(false))
              return;
             break;
             case 47:
             if(_GLF_DEAD(false))
              return;
             mat3 _GLF_SWITCH_2_1v[22];
             if(_GLF_DEAD(false))
              return;
             case 49:
             if(_GLF_DEAD(false))
              barrier();
             mat4(761.090, 8.4, -9321.2512, -4.7, 5578.0914, 579.977, 5122.2206, 237.342, 5.5, 0.5, -8.7, 22.66, 778.757, 2.0, 228.077, -9.8);
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             if(_GLF_DEAD(false))
              return;
             default:
             1;
            }
          }
         else
          {
           switch(_GLF_SWITCH(0))
            {
             case 50:
             min(workgroup_size, workgroup_size);
             case 27:
             if(_GLF_DEAD(false))
              return;
             uvec2 _GLF_SWITCH_3_0v[65], _GLF_SWITCH_3_1v, _GLF_SWITCH_3_2v[23];
             case 0:
             mat4 _GLF_SWITCH_0_23v, _GLF_SWITCH_0_24v;
             mat4x3 _GLF_SWITCH_0_25v, _GLF_SWITCH_0_26v[82], _GLF_SWITCH_0_27v;
             ;
             if(_GLF_DEAD(false))
              return;
             break;
             case 54:
             bvec4(true, true, true, true).yxwz;
             default:
             1;
            }
          }
         if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && true))
          return;
         ;
         do
          {
           injectionSwitch;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
          }
         while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) && true)));
         mat3(-8.0, 62.24, 68.47, -97.96, 86.49, -3.9, -69.36, -20.42, 406.280);
        }
       uvec4(148641u, 123072u, 173430u, 20853u);
      }
     else
      {
      }
     case 44:
     while(_GLF_IDENTITY(false, ! (! _GLF_IDENTITY((false), ((false)) || false))))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, _GLF_IDENTITY(_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), _GLF_IDENTITY(bool(_GLF_IDENTITY(bool((injectionSwitch.x > injectionSwitch.y)), bool(bvec4(bool((injectionSwitch.x > injectionSwitch.y)), false, false, false)))), true && (bool(bool((injectionSwitch.x > injectionSwitch.y)))))), ! (! (_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), _GLF_IDENTITY(bool(_GLF_IDENTITY(bool((injectionSwitch.x > injectionSwitch.y)), bool(bvec4(bool((injectionSwitch.x > injectionSwitch.y)), false, false, false)))), true && (bool(bool((injectionSwitch.x > injectionSwitch.y)))))))))), bool(bool(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
        {
         if(_GLF_DEAD(false))
          return;
         break;
        }
       if(_GLF_DEAD(false))
        barrier();
       uvec3 _GLF_SWITCH_0_28v, _GLF_SWITCH_0_29v;
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        barrier();
       if((-36872 != 66359))
        {
         bvec2 _GLF_SWITCH_0_30v[66], _GLF_SWITCH_0_31v;
         if(_GLF_DEAD(false))
          barrier();
         uvec2 _GLF_SWITCH_0_32v, _GLF_SWITCH_0_33v;
         while((bitfieldReverse(read) >= uaddCarry(subgroup_id, subgroup_local_id, workgroup_id)))
          {
           if(_GLF_DEAD(false))
            break;
          }
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           (mat3(72.51, -3.5, -36.26, 743.413, -605.942, 2403.4468, 3.9, -5118.2836, -937.642) - fract(-3.2));
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           break;
          }
         vec4 _GLF_SWITCH_0_34v, _GLF_SWITCH_0_35v;
         mat3 _GLF_SWITCH_0_36v, _GLF_SWITCH_0_37v[22];
         ivec3(_GLF_IDENTITY(58928, 0 | (58928)), _GLF_IDENTITY(87313, 0 | (_GLF_IDENTITY(87313, int(ivec2(87313, 1))))), 42670);
        }
       else
        {
         do
          {
           switch(_GLF_SWITCH(0))
            {
             case 1:
             mat2(-88.96, 55.84, -161.113, -13.65);
             case 0:
             case 40:
             case 33:
             case 22:
             case 2:
             case 60:
             case 53:
             case 85:
             case 43:
             case 52:
             switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
              {
               case 91:
               vec4(injectionSwitch, (vec2(100.236, -287.059) / vec2(6.4, -730.936)));
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 continue;
                }
               case 0:
               if(_GLF_DEAD(false))
                continue;
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_IDENTITY(_GLF_IDENTITY(false, (false) && _GLF_IDENTITY(true, bool(bool(true)))), ! (! (_GLF_IDENTITY(_GLF_IDENTITY(false, (false) && true), false || (_GLF_IDENTITY(false, (false) && true)))))))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   break;
                  }
                 mat2 _GLF_SWITCH_0_38v[62], _GLF_SWITCH_0_39v;
                 mat4x3 _GLF_SWITCH_0_40v[30], _GLF_SWITCH_0_41v, _GLF_SWITCH_0_42v;
                 uvec2 _GLF_SWITCH_0_43v, _GLF_SWITCH_0_44v;
                }
               else
                {
                 do
                  {
                   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true && (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
                    break;
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_WRAPPED_IF_TRUE(true))
                    {
                     next_virtual_gid;
                    }
                   else
                    {
                     if(_GLF_DEAD(false))
                      continue;
                    }
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                 if(_GLF_DEAD(false))
                  barrier();
                 mat4x2(72.28, -6.4, 58.52, -538.544, 3179.2445, 6042.7618, -4.6, -9197.1993);
                 if(_GLF_DEAD(false))
                  break;
                }
               if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bool(bool(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                 if(_GLF_DEAD(false))
                  barrier();
                 barrier();
                 if(_GLF_DEAD(false))
                  barrier();
                }
               bool _GLF_SWITCH_0_45v, _GLF_SWITCH_0_46v[18], _GLF_SWITCH_0_47v;
               if(_GLF_DEAD(false))
                continue;
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   do
                    {
                     if(_GLF_DEAD(false))
                      return;
                     bvec4(true, false, false, true);
                    }
                   while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, true && (false))));
                   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), false || (! (false))))), ! (_GLF_IDENTITY(! (false), ! (! (! (false))))))))
                    barrier();
                  }
                 else
                  {
                  }
                }
               else
                {
                }
               ivec2 _GLF_SWITCH_0_48v;
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                {
                 if(_GLF_DEAD(false))
                  break;
                 barrier();
                }
               case 9:
               {
                switch(_GLF_SWITCH(0))
                 {
                  case 0:
                  case 87:
                  case 73:
                  case 75:
                  case 55:
                  case 71:
                  case 56:
                  case 86:
                  case 52:
                  switch(_GLF_SWITCH((1 ^ 1)))
                   {
                    case 0:
                    case 6:
                    case 46:
                    case 74:
                    case 65:
                    if(_GLF_DEAD(false))
                     {
                      if(_GLF_DEAD(false))
                       barrier();
                      return;
                     }
                    if(_GLF_DEAD(false))
                     continue;
                    case 4:
                    case 44:
                    case 51:
                    case 34:
                    if(_GLF_DEAD(false))
                     barrier();
                    if(_GLF_DEAD(false))
                     barrier();
                    switch(_GLF_SWITCH((0 << _GLF_IDENTITY(int(8), int(8)))))
                     {
                      case 0:
                      case 38:
                      case 68:
                      if(_GLF_DEAD(false))
                       barrier();
                      case 34:
                      if(_GLF_DEAD(false))
                       {
                        switch(_GLF_SWITCH(0))
                         {
                          case 68:
                          if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec3(false, false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bvec3(bvec3(bvec3(false, false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))))))
                           barrier();
                          _GLF_SWITCH_0_47v;
                          case 0:
                          case 37:
                          case 25:
                          case 60:
                          case 1:
                          if(_GLF_DEAD(false))
                           barrier();
                          case 88:
                          case 67:
                          case 31:
                          return;
                          break;
                          case 99:
                          (3.6 + ((3.5 - mat3x4(-4061.6156, -7.7, 2.0, -3500.9000, 77.26, 731.864, -2.8, 4.4, 312.739, -6749.8333, 6753.5532, 9707.2528)) - mat3x4(1.3, -373.263, 758.014, -8858.4466, 6.7, -693.847, -910.811, 1469.1401, 2735.5025, -680.416, _GLF_IDENTITY(-7590.3409, (-7590.3409) / 1.0), -1.3)));
                          case 21:
                          mix(7.0, -253.843, -71.76);
                          default:
                          1;
                         }
                        if(_GLF_DEAD(false))
                         break;
                       }
                      case 72:
                      if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, (injectionSwitch) + vec2(_GLF_IDENTITY(0.0, min(0.0, _GLF_IDENTITY(0.0, float(mat2x4(0.0, _GLF_IDENTITY(dot(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0)), dot(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0))), 0.0, _GLF_ONE(1.0, injectionSwitch.y), 1.0, 1.0, 1.0, 0.0))))), 0.0)).x, clamp(_GLF_IDENTITY(injectionSwitch, (injectionSwitch) + vec2(_GLF_IDENTITY(0.0, min(0.0, _GLF_IDENTITY(0.0, float(mat2x4(0.0, _GLF_IDENTITY(dot(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0)), dot(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0))), 0.0, _GLF_ONE(1.0, injectionSwitch.y), 1.0, 1.0, 1.0, 0.0))))), 0.0)).x, _GLF_IDENTITY(injectionSwitch, (injectionSwitch) + vec2(_GLF_IDENTITY(0.0, min(0.0, _GLF_IDENTITY(0.0, float(mat2x4(0.0, _GLF_IDENTITY(dot(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0)), dot(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0))), 0.0, _GLF_ONE(1.0, injectionSwitch.y), 1.0, 1.0, 1.0, 0.0))))), 0.0)).x, _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, (injectionSwitch) + vec2(_GLF_IDENTITY(0.0, min(0.0, _GLF_IDENTITY(0.0, float(mat2x4(0.0, _GLF_IDENTITY(dot(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0)), dot(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0))), 0.0, _GLF_ONE(1.0, injectionSwitch.y), 1.0, 1.0, 1.0, 0.0))))), 0.0)).x, float(vec2(_GLF_IDENTITY(injectionSwitch, (injectionSwitch) + vec2(_GLF_IDENTITY(0.0, min(0.0, _GLF_IDENTITY(0.0, float(mat2x4(0.0, _GLF_IDENTITY(dot(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0)), dot(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0))), 0.0, _GLF_ONE(1.0, injectionSwitch.y), 1.0, 1.0, 1.0, 0.0))))), 0.0)).x, 1.0))))) > _GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(vec2(vec4(_GLF_IDENTITY(injectionSwitch, clamp(injectionSwitch, injectionSwitch, injectionSwitch)), length(0.0), 0.0)), _GLF_IDENTITY(vec2(mat2(vec2(vec4(_GLF_IDENTITY(injectionSwitch, clamp(injectionSwitch, injectionSwitch, injectionSwitch)), length(0.0), 0.0)), _GLF_ONE(1.0, injectionSwitch.y), 1.0)), (true ? vec2(mat2(vec2(vec4(_GLF_IDENTITY(injectionSwitch, clamp(injectionSwitch, injectionSwitch, injectionSwitch)), length(0.0), 0.0)), _GLF_ONE(1.0, injectionSwitch.y), 1.0)) : _GLF_FUZZED(injectionSwitch))))).y))))
                       break;
                      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                       return;
                      case 19:
                      if(_GLF_DEAD(false))
                       continue;
                      _GLF_SWITCH_0_28v;
                      case 41:
                      if(_GLF_DEAD(false))
                       continue;
                      case 14:
                      case 57:
                      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                       break;
                      bool _GLF_SWITCH_0_49v;
                      break;
                      case 11:
                      if(_GLF_DEAD(false))
                       barrier();
                      uvec2(171515u, 146852u).xx;
                      case 92:
                      outerProduct(_GLF_IDENTITY(vec3(-2204.4082, 927.722, 8.3), (vec3(-2204.4082, 927.722, 8.3)) + vec3(0.0, 0.0, 0.0)), vec2(-78.49, 8.9));
                      default:
                      1;
                     }
                    if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     continue;
                    if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     break;
                    break;
                    default:
                    _GLF_IDENTITY(1, max(1, _GLF_IDENTITY(1, _GLF_IDENTITY((1) | (_GLF_IDENTITY(1, (1) / 1)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) ? _GLF_FUZZED(-14694) : _GLF_IDENTITY((1) | (_GLF_IDENTITY(1, (1) / 1)), ((1) | (_GLF_IDENTITY(1, (1) / 1))) | ((1) | (_GLF_IDENTITY(1, (1) / 1)))))))));
                   }
                  if(_GLF_DEAD(false))
                   barrier();
                  break;
                  case 95:
                  mat3x2(mat2x4(6.8, -2989.6376, 2.8, -1729.6401, 8021.9638, -47.67, -7.8, -787.444));
                  default:
                  1;
                 }
               }
               uint _GLF_SWITCH_0_50v;
               break;
               case 38:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
               unpackUnorm2x16(workgroup_id);
               if(_GLF_DEAD(false))
                return;
               case 93:
               ivec3(-66781, 91648, -39119);
               default:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               do
                {
                 _GLF_IDENTITY(1, 1 * (1));
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             break;
             default:
             1;
            }
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
        }
       bool _GLF_SWITCH_0_51v;
       do
        {
         if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))
          return;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), bool(bool((injectionSwitch.x > injectionSwitch.y)))))))
            break;
           barrier();
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             barrier();
            }
           else
            {
            }
          }
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        continue;
       if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, (false) && true)))
        {
        }
       else
        {
         ((mat2x4(1.3, -794.135, 5.4, 47.11, -4.8, -3.3, -70.36, -20.39) * outerProduct(vec2(_GLF_IDENTITY(5.7, min(_GLF_IDENTITY(5.7, mix(float(5.7), float(_GLF_FUZZED((-8.9 * 63.89))), bool(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), 5.7)), 206.758), vec3(810.359, -20.57, -53.74))) - mat3x4(_GLF_IDENTITY(-8.7, mix(float(-8.7), float(_GLF_FUZZED((- (0.8 + 434.579)))), _GLF_IDENTITY(bool(false), bool(bvec2(bool(false), false))))), -324.831, 3.9, -769.584, -6310.6451, 2.7, 97.55, _GLF_IDENTITY(35.71, (true ? 35.71 : _GLF_IDENTITY(_GLF_FUZZED((16.27)), clamp(_GLF_FUZZED((16.27)), _GLF_FUZZED((16.27)), _GLF_FUZZED((16.27)))))), _GLF_IDENTITY(58.43, 0.0 + (_GLF_IDENTITY(58.43, clamp(58.43, 58.43, _GLF_IDENTITY(58.43, max(58.43, 58.43)))))), 1.6, 6.6, 17.68));
         normalize(vec3(470.195, 7993.1790, 167.488));
         for(mat3 _GLF_SWITCH_0_52v, _GLF_SWITCH_0_53v[72], _GLF_SWITCH_0_54v[39]; true; (_GLF_IDENTITY(transpose(mat4(-8121.9120, 744.786, 45.58, 26.09, 7.4, 6.1, -99.03, -585.800, -3.8, -445.158, -159.519, -6.9, 3.1, 204.635, -7.3, -9465.9038)) - 571.982, (false ? _GLF_FUZZED(mat4(144.914, 9273.5712, 7.9, -1967.5119, -8127.1023, -2597.4394, 6281.0128, -8.6, -8.2, 4.4, -55.33, 280.857, -949.694, 0.5, 1132.5225, 8644.4623)) : transpose(mat4(-8121.9120, 744.786, 45.58, 26.09, 7.4, 6.1, -99.03, -585.800, -3.8, -445.158, -159.519, -6.9, _GLF_IDENTITY(3.1, mix(float(_GLF_FUZZED(-4441.8674)), float(_GLF_IDENTITY(3.1, (3.1) - determinant(mat3(0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)))), bool(true))), 204.635, -7.3, -9465.9038)) - 571.982))))
          {
           if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), ! (! (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bool(false), (bool(false)) || false)))))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 break;
                 if(_GLF_DEAD(false))
                  return;
                }
               break;
              }
             _GLF_IDENTITY(-1888.7664, max(-1888.7664, -1888.7664));
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           else
            {
             if(_GLF_DEAD(false))
              return;
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, (true ? injectionSwitch.x : _GLF_FUZZED(round(15.89)))) > injectionSwitch.y))))
            barrier();
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             (bvec4(true, false, true, _GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (true), bool(bvec3(! (true), false, false)))))) != bvec4(true, false, true, true));
            }
           else
            {
             if(_GLF_DEAD(false))
              barrier();
            }
          }
         if(_GLF_DEAD(false))
          return;
         for(         _GLF_IDENTITY((28006 % ivec2(10025, 92492)), (_GLF_TRUE(true, (injectionSwitch.x < _GLF_IDENTITY(injectionSwitch, vec2(vec3(injectionSwitch, 0.0))).y)) ? (28006 % ivec2(10025, 92492)) : _GLF_IDENTITY(_GLF_FUZZED(ivec2(_GLF_IDENTITY(70805, (70805) / 1), 40540)), (_GLF_FUZZED(ivec2(70805, 40540))) >> ivec2(0, 0))));
 _GLF_SWITCH_0_51v; _GLF_SWITCH_0_29v)
          {
           ;
           vec3 _GLF_SWITCH_0_55v, _GLF_SWITCH_0_56v, _GLF_SWITCH_0_57v;
           if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, ! (! (false))), (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           bvec2(_GLF_SWITCH_0_51v, (mat2x4(-2074.8275, -5353.1657, -7.9, 7981.3892, -256.731, 0.9, 3131.6083, -246.524) == mat2x4(-3.0, -9.0, 4.3, _GLF_IDENTITY(_GLF_IDENTITY(329.200, mix(float(329.200), float(_GLF_FUZZED(49.30)), bool(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), float(_GLF_IDENTITY(mat2x3(329.200, sqrt(0.0), 1.0, 1.0, 1.0, abs(0.0)), transpose(transpose(mat2x3(329.200, sqrt(0.0), 1.0, _GLF_IDENTITY(1.0, min(1.0, 1.0)), 1.0, _GLF_IDENTITY(abs(0.0), clamp(abs(0.0), abs(0.0), _GLF_IDENTITY(abs(0.0), (true ? abs(0.0) : _GLF_FUZZED(-0.2))))))))))), 9.7, 842.476, 0.5, 1.7)));
           (mat4x3(-2937.9958, _GLF_IDENTITY(50.35, (false ? _GLF_FUZZED(-5.6) : 50.35)), 22.20, 329.571, 567.208, -6688.2110, 3.7, 2.4, 59.69, 6.1, -4732.8475, 9836.3069) * mat3x4(33.83, 5.1, 7882.0999, -57.24, 4.8, -1.6, -7.0, _GLF_IDENTITY(-6.0, min(-6.0, -6.0)), 5.0, 1301.3737, -4270.4087, _GLF_IDENTITY(5.3, min(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_IDENTITY(5.3, mix(float(_GLF_IDENTITY(5.3, max(5.3, 5.3))), float(_GLF_FUZZED(-2.9)), bool(false))), mix(float(_GLF_FUZZED(_GLF_IDENTITY(-93.85, float(_GLF_IDENTITY(mat4(_GLF_IDENTITY(-93.85, clamp(-93.85, -93.85, -93.85)), 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, log(1.0), sqrt(1.0), sqrt(0.0), 1.0, 1.0, _GLF_IDENTITY(dot(vec2(0.0, 1.0), vec2(0.0, 1.0)), dot(vec2(0.0, 1.0), vec2(0.0, 1.0))), sqrt(0.0)), transpose(transpose(mat4(_GLF_IDENTITY(-93.85, clamp(-93.85, -93.85, -93.85)), 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, log(1.0), sqrt(1.0), sqrt(0.0), 1.0, 1.0, _GLF_IDENTITY(dot(vec2(0.0, 1.0), vec2(0.0, 1.0)), dot(vec2(0.0, 1.0), vec2(0.0, 1.0))), sqrt(0.0))))))))), float(5.3), bool(true))), float(mat4x3(5.3, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0))), 5.3))));
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
            barrier();
          }
         for(int _GLF_SWITCH_0_58v, _GLF_SWITCH_0_59v, _GLF_SWITCH_0_60v; (findLSB(ivec3(_GLF_IDENTITY(-81993, (-81993) | (-81993)), 25380, 58113)) == ivec3(40376, 82381, 78408).bgr); vec3(-984.830, -4893.1029, -8553.5624))
          {
           switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
            {
             case 0:
             case 17:
             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, bool(bvec3(injectionSwitch.x > injectionSwitch.y, false, true)))) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
              continue;
             case 97:
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(4), int(_GLF_IDENTITY(4, min(4, 4))))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (true ? _GLF_IDENTITY(int(4), (int(4)) - 0) : _GLF_FUZZED(_GLF_IDENTITY(_GLF_SWITCH_0_59v, ~ (_GLF_IDENTITY(~ (_GLF_SWITCH_0_59v), 0 | (~ (_GLF_SWITCH_0_59v))))))))))); _injected_loop_counter ++)
              {
               switch(_GLF_SWITCH((0 | 0)))
                {
                 case 60:
                 mat4x2(1.0, -179.369, -8335.1719, 1392.7431, 42.46, -7941.0770, -20.66, 2244.6302);
                 case 0:
                 case 80:
                 case 26:
                 case 22:
                 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY((_GLF_IDENTITY((1 << _GLF_IDENTITY(int(2), _GLF_IDENTITY(_GLF_IDENTITY(int(2), (_GLF_IDENTITY(int(2), 0 ^ (_GLF_IDENTITY(int(2), (int(2)) | 0)))) | 0), (int(2)) >> 0))) >> _GLF_IDENTITY(int(2), int(2)), (true ? (1 << _GLF_IDENTITY(int(2), _GLF_IDENTITY(_GLF_IDENTITY(int(2), (int(2)) >> 0), (_GLF_IDENTITY(_GLF_IDENTITY(int(2), (int(2)) >> 0), (_GLF_IDENTITY(int(2), (int(2)) >> 0)) + 0)) ^ 0))) >> _GLF_IDENTITY(int(2), int(2)) : _GLF_FUZZED(_injected_loop_counter)))), ~ (_GLF_IDENTITY(~ (((1 << _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), (int(2)) >> 0))) >> _GLF_IDENTITY(int(2), int(2)))), (~ (((1 << _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), (int(2)) >> 0))) >> _GLF_IDENTITY(int(2), int(2))))) ^ 0)))); _injected_loop_counter ++)
                  {
                   uvec2(128263u, 48347u);
                  }
                 break;
                 case 93:
                 vec4(1.0, 2.1, 193.384, 42.58).gb;
                 default:
                 1;
                }
              }
             case 60:
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             mat2x3(50.43, 40.67, 5.9, -6.5, 9.4, 9135.3126);
             case 90:
             case 49:
             ;
             float _GLF_SWITCH_0_61v, _GLF_SWITCH_0_62v, _GLF_SWITCH_0_63v[76];
             break;
             case 84:
             if(_GLF_DEAD(false))
              barrier();
             bool _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v, _GLF_SWITCH_2_2v;
             default:
             1;
            }
          }
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = _GLF_IDENTITY(0, (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) ? _GLF_FUZZED(-13356) : 0)); _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
            {
             barrier();
            }
          }
         bvec4 _GLF_SWITCH_0_64v, _GLF_SWITCH_0_65v[44];
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = _GLF_IDENTITY(0, 1 * (_GLF_IDENTITY(0, 0 + (0)))); _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 ^ 0)); _injected_loop_counter ++)
              {
               barrier();
              }
            }
          }
         else
          {
          }
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, clamp(injectionSwitch.x, injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
        continue;
       {
        switch(_GLF_SWITCH((_GLF_IDENTITY(0, (0) ^ 0) >> _GLF_IDENTITY(int(0), int(0)))))
         {
          case 62:
          dot(vec2(2625.9497, -32.71), injectionSwitch);
          case 4:
          bvec3(false, false, false);
          case 0:
          if(_GLF_DEAD(false))
           continue;
          mat3(-43.76, 7.2, -2101.0537, 8.8, 7.3, 7943.5148, _GLF_IDENTITY(_GLF_IDENTITY(-10.16, max(-10.16, _GLF_IDENTITY(-10.16, (-10.16) / 1.0))), min(-10.16, _GLF_IDENTITY(_GLF_IDENTITY(-10.16, (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) ? -10.16 : _GLF_FUZZED(9.7))), max(-10.16, -10.16)))), -245.697, 4.5);
          case 79:
          if(_GLF_DEAD(false))
           barrier();
          while(bvec4(false, _GLF_IDENTITY(false, bool(bvec3(false, true, true))), true, _GLF_IDENTITY(true, bool(bvec4(_GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (true), true && (! (true))))), _GLF_IDENTITY(false, (false) || false), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), true)))).s)
           {
            _GLF_IDENTITY((_GLF_IDENTITY(uvec3(7026u, 32269u, 184318u) % (subgroup_size + subgroup_base), (uvec3(7026u, 32269u, 184318u) % (subgroup_size + subgroup_base)) ^ _GLF_IDENTITY(uvec3(0u, 0u, 0u), (uvec3(0u, 0u, 0u)) * ((((uvec3(1u, 1u, 1u) << _GLF_IDENTITY(uvec3(3u), uvec3(3u))) >> _GLF_IDENTITY(uvec3(3u), uvec3(3u))) << _GLF_IDENTITY(uvec3(1u), uvec3(1u))) >> _GLF_IDENTITY(uvec3(1u), uvec3(1u)))))), uvec3(uvec3((_GLF_IDENTITY(uvec3(7026u, 32269u, 184318u) % (subgroup_size + subgroup_base), (uvec3(7026u, 32269u, 184318u) % (subgroup_size + subgroup_base)) ^ uvec3(0u, 0u, 0u))))));
            ivec3(-24979, -97466, -10000);
            if(_GLF_WRAPPED_IF_FALSE(false))
             {
             }
            else
             {
              -20076;
             }
            bvec4 _GLF_SWITCH_0_66v, _GLF_SWITCH_0_67v;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             return;
            bvec2(true, true);
            bvec4 _GLF_SWITCH_0_68v[61], _GLF_SWITCH_0_69v;
            ivec3 _GLF_SWITCH_0_70v[86];
            uvec2(41436u, 9813u);
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
              if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
               {
                barrier();
               }
              else
               {
               }
             }
            (++ _GLF_SWITCH_0_29v);
           }
          case 84:
          vec2 _GLF_SWITCH_0_71v;
          if(_GLF_DEAD(false))
           continue;
          case 14:
          if(_GLF_DEAD(false))
           return;
          case 64:
          if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(false, true, false, true)))))
           {
            if(_GLF_DEAD(false))
             barrier();
            break;
           }
          if(_GLF_DEAD(false))
           {
            if(_GLF_DEAD(false))
             return;
            continue;
           }
          case 36:
          case 23:
          if(_GLF_DEAD(false))
           barrier();
          if(_GLF_DEAD(false))
           barrier();
          {
           switch(_GLF_SWITCH((0 & (false ? -99243 : 66543))))
            {
             case 6:
             mat4x3(5.6, 5.3, 400.671, -8.8, -4.1, 771.659, 52.23, 8.2, -824.665, 1650.5368, -4.2, 1.0);
             case 0:
             case 51:
             case 24:
             case 82:
             vec2 _GLF_SWITCH_0_72v;
             break;
             case 25:
             mat4x2 _GLF_SWITCH_1_0v[46], _GLF_SWITCH_1_1v[57], _GLF_SWITCH_1_2v[83];
             default:
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
              {
               1;
              }
            }
           if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
            break;
          }
          break;
          case 10:
          _GLF_SWITCH_0_29v.br.g;
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           return;
          default:
          1;
         }
       }
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, min(injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y))))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(4), int(4))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(false))
            return;
          }
         return;
        }
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        continue;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        return;
       return;
      }
     default:
     1;
     if(_GLF_DEAD(false))
      return;
    }
  }
 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
  {
   switch(_GLF_SWITCH(0))
    {
     case 0:
     subgroupBarrier();
     if(_GLF_DEAD(false))
      return;
     break;
     default:
     if(_GLF_DEAD(false))
      barrier();
     1;
    }
  }
 else
  {
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  return;
 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
  {
   atomicStore(checker[virtual_gid], read, _GLF_IDENTITY(4, (4) * 1), 64, 4);
  }
 if(_GLF_DEAD(false))
  return;
}

END

BUFFER tester DATA_TYPE uint32 SIZE 8388096 FILL 0
BUFFER expected DATA_TYPE uint32 SIZE 8388096 FILL 2
BUFFER injection DATA_TYPE vec2<float> DATA
 0.0 1.0
END
BUFFER checker DATA_TYPE uint32 SIZE 8388096 FILL 0
BUFFER expected_checker DATA_TYPE uint32 SIZE 8388096 FILL 0

PIPELINE compute test_pipe
  ATTACH test
  BIND BUFFER tester AS storage DESCRIPTOR_SET 0 BINDING 0 
  BIND BUFFER injection AS uniform DESCRIPTOR_SET 0 BINDING 1 
  BIND BUFFER checker AS storage DESCRIPTOR_SET 0 BINDING 2 

  SUBGROUP test
	  VARYING_SIZE on
  END
END

RUN test_pipe 65532 1 1
EXPECT checker EQ_BUFFER expected_checker
