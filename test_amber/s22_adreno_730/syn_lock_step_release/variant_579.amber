#!amber

SET ENGINE_DATA fence_timeout_ms 10000

SHADER compute test GLSL
#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if(_GLF_DEAD(false))
  {
   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 & 1)); _injected_loop_counter ++)
    {
     do
      {
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
        {
         return;
        }
      }
     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
    }
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       return;
      }
     else
      {
      }
    }
   if(_GLF_DEAD(false))
    {
     do
      {
       return;
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
  }
 for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(false))
      continue;
     for(int _injected_loop_counter = (-88587 & 0); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        continue;
      }
     return;
     if(_GLF_DEAD(false))
      barrier();
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   if(_GLF_DEAD(false))
    break;
  }
 uint subgroup_id = gl_SubgroupID;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   barrier();
  }
 uint subgroup_size = gl_SubgroupSize;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 uint subgroup_local_id = gl_SubgroupInvocationID;
 if(_GLF_DEAD(false))
  {
   do
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
        {
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(false))
            break;
           return;
           if(_GLF_DEAD(false))
            continue;
          }
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        continue;
       if(_GLF_DEAD(false))
        return;
       return;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        break;
       if(_GLF_DEAD(false))
        barrier();
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     barrier();
     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
      return;
    }
   while(_GLF_WRAPPED_LOOP(false));
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    barrier();
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   return;
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
  }
 if(_GLF_DEAD(false))
  {
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
    {
     barrier();
    }
  }
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_DEAD(false))
    return;
  }
 for(int _injected_loop_counter = (-89575 & 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < ((_GLF_IDENTITY(1, (1) - 0) << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), int(0)))); _injected_loop_counter ++)
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true)))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           return;
          }
        }
       barrier();
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        return;
       return;
      }
     if(_GLF_DEAD(false))
      {
       do
        {
         return;
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          return;
         barrier();
        }
       barrier();
      }
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 << _GLF_IDENTITY(int(1), _GLF_IDENTITY(int(1), (int(1)) | 0)))); _injected_loop_counter --)
        {
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
            {
             do
              {
               if(_GLF_DEAD(false))
                continue;
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    continue;
                   return;
                  }
                 barrier();
                }
               return;
               if(_GLF_DEAD(false))
                barrier();
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
            }
          }
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       if(_GLF_DEAD(false))
        return;
      }
     else
      {
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
         if(_GLF_DEAD(false))
          {
           do
            {
             return;
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
        }
       else
        {
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(false))
          barrier();
         return;
        }
      }
     if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, ! (! (true)))))
      {
       if(_GLF_DEAD(false))
        return;
       return;
       if(_GLF_DEAD(false))
        return;
      }
     else
      {
       if(_GLF_DEAD(false))
        return;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(false))
      {
       do
        {
         barrier();
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
    }
  }
 if(_GLF_DEAD(false))
  barrier();
 uint num_workgroup = gl_NumWorkGroups.x;
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             do
              {
               barrier();
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_DEAD(false))
              return;
            }
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             return;
             if(_GLF_DEAD(false))
              return;
            }
           if(_GLF_DEAD(false))
            return;
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
            barrier();
           barrier();
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(false))
          barrier();
        }
       else
        {
        }
      }
     else
      {
      }
     return;
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         barrier();
        }
      }
     if(_GLF_DEAD(false))
      return;
    }
  }
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     return;
    }
   switch(_GLF_SWITCH(0))
    {
     case 20:
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      barrier();
     {
      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
       return;
      for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(3), _GLF_IDENTITY(int(3), (int(3)) / (0 ^ 1)))) >> _GLF_IDENTITY(int(3), _GLF_IDENTITY(int(3), max(int(3), int(3))))); _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
       {
        for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(7), int(7))) >> _GLF_IDENTITY(int(7), _GLF_IDENTITY(int(7), (true ? int(7) : _GLF_FUZZED(bitfieldInsert(-18951, _injected_loop_counter, -6232, 82847)))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
         {
          (mat2(2188.8621, 7.0, -24.05, -52.59) == mat2(-827.602, -409.260, 8.4, -6177.7650));
         }
        if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, false)))))
         return;
       }
      if(_GLF_DEAD(false))
       barrier();
      if(_GLF_DEAD(false))
       return;
      for(      ivec4(46571, 41594, -94188, 55340);
 mix(bool(atomicMin(subgroup_local_id, subgroup_id)), false, false); (ivec2(48812, -13621) != ivec2(-42368, 94583)))
       {
        do
         {
          if(_GLF_WRAPPED_IF_TRUE(true))
           {
            if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
             }
            else
             {
              if(_GLF_DEAD(false))
               return;
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               barrier();
             }
           }
          else
           {
           }
         }
        while(_GLF_WRAPPED_LOOP(false));
        if(_GLF_DEAD(false))
         barrier();
        if(_GLF_DEAD(false))
         break;
        true;
        if(_GLF_DEAD(false))
         break;
        if(_GLF_DEAD(false))
         {
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           return;
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           {
            for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(6), (int(6)) ^ 0))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
             {
              barrier();
             }
           }
          continue;
         }
        if(_GLF_DEAD(false))
         return;
        if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, false || (false))))
         {
         }
        else
         {
          do
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             break;
            ivec3(8128, 5585, -37992);
           }
          while(_GLF_WRAPPED_LOOP(false));
          if(_GLF_DEAD(false))
           return;
         }
        mat3x4 _GLF_SWITCH_1_0v;
        uvec3 _GLF_SWITCH_1_1v, _GLF_SWITCH_1_2v;
        if(_GLF_DEAD(false))
         {
          switch(_GLF_SWITCH((0 | 0)))
           {
            case 15:
            mat2x4 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v[40];
            case 0:
            case 44:
            case 40:
            if(_GLF_DEAD(false))
             return;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            case 27:
            case 76:
            if(_GLF_WRAPPED_IF_FALSE(false))
             {
             }
            else
             {
              barrier();
              if(_GLF_DEAD(false))
               return;
             }
            if(_GLF_DEAD(false))
             continue;
            break;
            case 26:
            mat4 _GLF_SWITCH_4_2v[8];
            case 29:
            if(_GLF_DEAD(false))
             continue;
            ;
            default:
            if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
             continue;
            1;
            if(_GLF_DEAD(false))
             return;
           }
         }
        ivec4(-97410, 729, 10700, 46993);
       }
      if(_GLF_WRAPPED_IF_TRUE(true))
       {
        if(_GLF_DEAD(false))
         {
          if(_GLF_DEAD(false))
           barrier();
          barrier();
         }
       }
      else
       {
       }
      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
       {
        if(_GLF_WRAPPED_IF_FALSE(false))
         {
         }
        else
         {
          barrier();
         }
       }
      if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
       return;
      if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
       {
        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         barrier();
        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         return;
       }
      else
       {
        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         {
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           return;
          barrier();
         }
        if(_GLF_WRAPPED_IF_TRUE(true))
         {
          if(_GLF_DEAD(false))
           return;
         }
        else
         {
          if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           {
           }
          else
           {
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               return;
              barrier();
             }
           }
         }
        if(_GLF_DEAD(false))
         {
          if(_GLF_DEAD(false))
           return;
          barrier();
         }
        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         barrier();
        clamp(ivec2(-92675, -72979), -40004, -76666);
       }
      if(_GLF_DEAD(false))
       return;
      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
       {
        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         {
          if(_GLF_DEAD(false))
           return;
          if(_GLF_DEAD(false))
           return;
          if(_GLF_WRAPPED_IF_FALSE(false))
           {
           }
          else
           {
            barrier();
            if(_GLF_DEAD(false))
             return;
           }
         }
        return;
       }
      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
       barrier();
      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
       return;
     }
     case 0:
     if(_GLF_DEAD(false))
      {
       do
        {
         barrier();
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       barrier();
      }
     case 7:
     if(_GLF_DEAD(false))
      barrier();
     for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           barrier();
          }
         else
          {
          }
        }
      }
     case 29:
     if(_GLF_DEAD(false))
      return;
     case 98:
     case 60:
     if(_GLF_DEAD(false))
      {
       do
        {
         return;
        }
       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       barrier();
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
        barrier();
       barrier();
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         return;
         if(_GLF_DEAD(false))
          return;
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               if(_GLF_DEAD(false))
                return;
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 return;
                }
               else
                {
                }
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
            }
          }
        }
       else
        {
        }
       if(_GLF_DEAD(false))
        return;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(false))
      return;
     break;
     if(_GLF_DEAD(false))
      return;
     case 92:
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        return;
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(false))
          return;
         switch(_GLF_SWITCH(0))
          {
           case 0:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           case 69:
           case 71:
           case 70:
           case 46:
           case 26:
           case 32:
           case 17:
           case 87:
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           break;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           case 5:
           do
            {
             subgroup_size;
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           default:
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
              {
               return;
              }
            }
           1;
          }
        }
       else
        {
        }
      }
     else
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          return;
         return;
        }
       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), ! (! (! (false))))))))
        return;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     mat4 _GLF_SWITCH_1_3v;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             return;
            }
           else
            {
            }
          }
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           return;
          }
         else
          {
          }
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         barrier();
        }
       return;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY(0, (0) >> (0 | 0))); _injected_loop_counter --)
          {
           barrier();
          }
        }
      }
     if(_GLF_DEAD(false))
      barrier();
     default:
     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
      barrier();
     if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, (false) && true), (_GLF_IDENTITY(false, (false) && true)) && true)))
      barrier();
     1;
    }
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    return;
   switch(_GLF_SWITCH(0))
    {
     case 67:
     if((mat4x3(67.28, 544.541, -3774.7098, 56.81, -66.79, 347.988, 9516.2013, 24.25, 690.225, -628.351, 3.8, 9.0) != mat4x3(602.415, -0.3, -7.3, 3.3, -25.51, 8.1, 1.1, -63.55, 821.397, -94.46, 1289.0461, 92.27)))
      {
       bvec4 _GLF_SWITCH_4_0v;
       bvec3(true, true, true);
       floatBitsToInt(vec4(-3205.9151, 4.8, -554.260, -64.81));
       uvec4 _GLF_SWITCH_4_1v[15], _GLF_SWITCH_4_2v;
       if(_GLF_DEAD(false))
        return;
       {
        while(false)
         {
          ;
          if(_GLF_DEAD(false))
           return;
          uint _GLF_SWITCH_4_3v;
          ;
          ;
         }
        if(true)
         {
          ivec3(-13443, -61063, 90243);
          if(_GLF_DEAD(false))
           return;
          mat4 _GLF_SWITCH_4_4v, _GLF_SWITCH_4_5v;
          (+ mat2(2.7, 9.3, 4266.0822, -2427.3528));
          mat3x4(mat4(7910.3061, 59.82, 718.896, -9.2, -74.16, -9194.3153, 62.31, -681.354, 9.0, 1.0, 334.466, 9.8, -52.55, 7.2, 8522.8911, -5.6));
          (13.46 - mat2x4(-5.3, 2.6, 28.25, -150.274, 2.6, 621.902, 5.3, 310.585));
          ivec2 _GLF_SWITCH_4_6v, _GLF_SWITCH_4_7v;
         }
        if(true)
         {
          bool _GLF_SWITCH_4_8v, _GLF_SWITCH_4_9v[76], _GLF_SWITCH_4_10v[45];
          (min(uvec2(137936u, 24789u), num_workgroup) ^ 20457u);
          if(_GLF_DEAD(false))
           return;
         }
        else
         {
          false;
          ;
         }
        mat3x4(mat4x3(-5176.4931, -203.482, -0.5, -3.9, -17.99, -4.3, 40.46, -4693.7918, -1.8, 6508.8263, 1.8, -90.17));
       }
       for(bvec3 _GLF_SWITCH_4_11v, _GLF_SWITCH_4_12v[68]; false; ((uvec2(83704u, 63908u) / subgroup_id) , 22588))
        {
         if((subgroup_size > subgroup_local_id))
          {
           vec4(vec2(-8.0, -2031.4898), injectionSwitch);
           bitfieldExtract(-41537, -46543, -7152);
           round(vec3(9.0, 6.8, -3341.3282));
           _GLF_SWITCH_4_2v;
           if(_GLF_DEAD(false))
            break;
           mat4x2(mat2x4(3.3, -9.9, -1638.1990, 72.40, 7.5, 2291.3328, -386.720, -37.74));
           vec3 _GLF_SWITCH_4_13v, _GLF_SWITCH_4_14v[8];
           if(_GLF_DEAD(false))
            return;
           mat2x3 _GLF_SWITCH_4_15v[44];
           float _GLF_SWITCH_4_16v[36], _GLF_SWITCH_4_17v, _GLF_SWITCH_4_18v[19];
          }
        }
       if(false)
        {
        }
       else
        {
         do
          {
           if(_GLF_DEAD(false))
            return;
           uvec3(178397u, 52384u, 123164u);
           mat3x4(4469.0594, 7383.2249, 3.5, 57.16, 237.115, -17.80, 0.1, 7576.4396, 0.5, 714.051, -2.9, -5437.0027);
          }
         while(_GLF_WRAPPED_LOOP(false));
         ivec2 _GLF_SWITCH_4_19v, _GLF_SWITCH_4_20v, _GLF_SWITCH_4_21v;
         if(false)
          {
           vec3 _GLF_SWITCH_4_22v;
           bvec4 _GLF_SWITCH_4_23v;
           if(_GLF_DEAD(false))
            return;
           ivec3(22267, 55482, -63736);
           if(_GLF_DEAD(false))
            return;
           do
            {
             (mat4x2(651.869, -6.8, -43.92, 275.395, 55.09, 3597.7361, 3225.4435, -4200.7481));
            }
           while(_GLF_WRAPPED_LOOP(false));
           bvec2 _GLF_SWITCH_4_24v, _GLF_SWITCH_4_25v;
          }
         else
          {
           if(_GLF_DEAD(false))
            return;
           mat4x3 _GLF_SWITCH_4_26v[84], _GLF_SWITCH_4_27v, _GLF_SWITCH_4_28v;
           int _GLF_SWITCH_4_29v, _GLF_SWITCH_4_30v, _GLF_SWITCH_4_31v;
           equal(ivec3(-49213, 52810, 36525), ivec3(-10786, 70444, 53958));
           -81588;
           vec2 _GLF_SWITCH_4_32v;
           (subgroup_id - _GLF_SWITCH_4_2v);
           ivec3 _GLF_SWITCH_4_33v, _GLF_SWITCH_4_34v[62];
          }
        }
      }
     case 0:
     case 86:
     do
      {
       if(_GLF_DEAD(false))
        return;
      }
     while(_GLF_WRAPPED_LOOP(false));
     case 73:
     if(_GLF_DEAD(false))
      {
       do
        {
         barrier();
        }
       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
      }
     case 2:
     case 87:
     barrier();
     if(_GLF_DEAD(false))
      return;
     break;
     if(_GLF_DEAD(false))
      return;
     case 54:
     ivec2 _GLF_SWITCH_4_35v;
     case 99:
     mat2x4(6033.5341, 4.6, 11.39, 8.3, 5173.9216, 93.04, -7716.5701, -95.43);
     default:
     if(_GLF_DEAD(false))
      return;
     1;
     if(_GLF_DEAD(false))
      return;
    }
  }
 if(_GLF_DEAD(false))
  return;
 do
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    continue;
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
      {
       switch(_GLF_SWITCH(((0 << _GLF_IDENTITY(int(0), int(0))) ^ 0)))
        {
         case 45:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         do
          {
           if(true)
            {
             {
              bvec3 _GLF_SWITCH_4_0v[69], _GLF_SWITCH_4_1v, _GLF_SWITCH_4_2v[95];
             }
            }
          }
         while(_GLF_WRAPPED_LOOP(false));
         if(_GLF_DEAD(false))
          continue;
         case 41:
         false;
         case 0:
         case 30:
         case 91:
         case 82:
         case 36:
         if(_GLF_DEAD(false))
          break;
         if(_GLF_DEAD(false))
          barrier();
         case 79:
         case 92:
         if(_GLF_DEAD(false))
          return;
         barrier();
         break;
         default:
         1;
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      break;
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        break;
       barrier();
      }
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
      {
       switch(_GLF_SWITCH(0))
        {
         case 33:
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           ;
          }
         else
          {
          }
         case 0:
         case 26:
         case 88:
         case 59:
         case 4:
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            continue;
           continue;
          }
         if(_GLF_DEAD(false))
          continue;
         case 70:
         if(_GLF_DEAD(false))
          return;
         case 37:
         case 3:
         case 54:
         do
          {
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(_GLF_IDENTITY(false, (false) || false), (_GLF_IDENTITY(false, (false) || false)) && true)))
              {
              }
             else
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 << _GLF_IDENTITY(int(5), int(5)))); _injected_loop_counter --)
                  {
                   barrier();
                  }
                }
               else
                {
                }
              }
            }
          }
         while(_GLF_WRAPPED_LOOP(false));
         break;
         case 77:
         if(isinf(3020.8721))
          {
           while(false)
            {
             if(_GLF_DEAD(false))
              return;
             mat2x3 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v[96], _GLF_SWITCH_4_2v;
             ivec4(-89034, -253, 23067, -53349);
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                  }
                 else
                  {
                   return;
                  }
                }
               -53.91;
              }
             vec4 _GLF_SWITCH_4_3v, _GLF_SWITCH_4_4v[79];
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             36802;
             if(_GLF_DEAD(false))
              continue;
             -25737;
             uvec3 _GLF_SWITCH_4_5v, _GLF_SWITCH_4_6v[9];
            }
          }
         case 18:
         uvec3(109213u, 138485u, 124086u);
         default:
         1;
        }
       if(_GLF_DEAD(false))
        break;
      }
     else
      {
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         barrier();
         if(_GLF_DEAD(false))
          break;
        }
       else
        {
        }
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        barrier();
      }
     if(_GLF_DEAD(false))
      break;
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
        }
       else
        {
         barrier();
        }
      }
     break;
    }
   do
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
        }
       else
        {
         barrier();
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
    }
   while(_GLF_WRAPPED_LOOP(false));
   switch(_GLF_SWITCH(0))
    {
     case 97:
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
      {
       do
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             barrier();
            }
          }
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(false))
        return;
      }
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          return;
         barrier();
        }
      }
     else
      {
      }
     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
          {
           barrier();
          }
        }
      }
     if(_GLF_DEAD(false))
      break;
     if(_GLF_DEAD(false))
      barrier();
     {
      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
       break;
      do
       {
        do
         {
          if(_GLF_WRAPPED_IF_TRUE(true))
           {
            mat2x4((mat4(113.566, -9.5, 5.6, -3005.9503, 9.9, -7.6, -7.1, 2.5, 6307.3564, -6.8, -37.41, 6.5, 58.46, -7.3, 5.1, 509.917) + -1816.0875));
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             continue;
           }
          else
           {
           }
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           {
            if(_GLF_DEAD(false))
             break;
            barrier();
           }
          if(true)
           {
            (60.92 - mat3x2(-5875.6058, -49.94, 6.2, 5.4, -8490.8141, 4040.9733));
            bvec4 _GLF_SWITCH_0_0v, _GLF_SWITCH_0_1v, _GLF_SWITCH_0_2v;
            ivec2 _GLF_SWITCH_0_3v, _GLF_SWITCH_0_4v;
            if(_GLF_WRAPPED_IF_TRUE(true))
             {
              uvec4(32751u, 95348u, 174137u, 6257u);
             }
            else
             {
             }
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             continue;
            if(_GLF_DEAD(false))
             barrier();
            if(_GLF_WRAPPED_IF_FALSE(false))
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               continue;
             }
            else
             {
              for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
               {
                if(_GLF_DEAD(false))
                 {
                  if(_GLF_DEAD(false))
                   break;
                  return;
                 }
                if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, true && (true))))
                 {
                  (-7.4 - mat3(-7.5, 0.8, 12.65, 26.22, 9.0, -688.584, 2898.9782, -8.3, 3697.2013));
                 }
                else
                 {
                 }
                if(_GLF_DEAD(false))
                 return;
               }
              if(_GLF_DEAD(false))
               break;
             }
            uvec4 _GLF_SWITCH_0_5v, _GLF_SWITCH_0_6v, _GLF_SWITCH_0_7v;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             continue;
            for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
             {
              if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
               break;
              for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(6), int(6))) >> _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 barrier();
               }
             }
            ;
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(false))
               break;
              if(_GLF_WRAPPED_IF_TRUE(true))
               {
                return;
               }
              else
               {
               }
             }
            if(_GLF_DEAD(false))
             break;
            mat4x2 _GLF_SWITCH_0_8v[92], _GLF_SWITCH_0_9v;
           }
          else
           {
            if(_GLF_DEAD(false))
             continue;
           }
          if(_GLF_DEAD(false))
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             break;
            continue;
           }
          if(_GLF_DEAD(false))
           break;
          ;
          do
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             return;
           }
          while(_GLF_WRAPPED_LOOP(false));
         }
        while(true);
       }
      while(_GLF_WRAPPED_LOOP(false));
      if(_GLF_DEAD(false))
       barrier();
      if(_GLF_DEAD(false))
       {
        if(_GLF_DEAD(false))
         {
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           return;
          return;
         }
        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         barrier();
        break;
       }
      if(_GLF_WRAPPED_IF_FALSE(false))
       {
        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         continue;
        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         break;
       }
      else
       {
        for(        (~ uvec2(67230u, 30834u));
 false; bvec3(false, false, false))
         {
          {
           mat2 _GLF_SWITCH_0_10v, _GLF_SWITCH_0_11v, _GLF_SWITCH_0_12v[22];
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(false))
                  return;
                }
               else
                {
                }
               barrier();
              }
             break;
             if(_GLF_DEAD(false))
              barrier();
             for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(1), int(1))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
              {
               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                }
               else
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   do
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      continue;
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                   barrier();
                  }
                }
              }
            }
           ;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                  {
                   if(_GLF_DEAD(false))
                    break;
                   return;
                  }
                 barrier();
                 if(_GLF_DEAD(false))
                  break;
                }
               else
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
               if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, ! (! (false)))) || false)))
                return;
               if(_GLF_DEAD(false))
                barrier();
              }
             break;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              {
               do
                {
                 do
                  {
                   switch(_GLF_SWITCH((1 ^ 1)))
                    {
                     case 57:
                     mat3 _GLF_SWITCH_3_0v;
                     case 0:
                     case 14:
                     case 46:
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_DEAD(false))
                        continue;
                       break;
                      }
                     case 64:
                     case 10:
                     case 5:
                     case 66:
                     case 74:
                     case 45:
                     barrier();
                     if(_GLF_DEAD(false))
                      break;
                     break;
                     default:
                     1;
                    }
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    break;
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
              }
             if(_GLF_DEAD(false))
              continue;
            }
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(false))
            continue;
           do
            {
             76336;
            }
           while(_GLF_WRAPPED_LOOP(false));
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              break;
             barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
            }
           ;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   return;
                  }
                }
               for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(5), int(5))) >> _GLF_IDENTITY(int(5), int(5))); _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                {
                 barrier();
                }
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             barrier();
            }
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           mat4x2 _GLF_SWITCH_0_13v, _GLF_SWITCH_0_14v, _GLF_SWITCH_0_15v[65];
           do
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 return;
                }
               else
                {
                }
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(false))
                continue;
               if(_GLF_DEAD(false))
                return;
               barrier();
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             continue;
            }
           exp(injectionSwitch);
           if(_GLF_DEAD(false))
            {
             do
              {
               barrier();
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
           min(vec4(24.75, 1.2, -1407.4670, 22.49), vec4(-46.54, -79.51, 694.243, -76.79));
          }
          vec3 _GLF_SWITCH_0_16v, _GLF_SWITCH_0_17v[31], _GLF_SWITCH_0_18v;
          if(_GLF_DEAD(false))
           break;
          if(_GLF_WRAPPED_IF_TRUE(true))
           {
            bvec3(true, (bvec2(false, true) == bvec2(true, true)), false);
           }
          else
           {
           }
          if(_GLF_DEAD(false))
           barrier();
          if(_GLF_DEAD(false))
           {
            switch(_GLF_SWITCH(((-86618 << 5446) & 0)))
             {
              case 53:
              atomicMax(subgroup_size, subgroup_local_id);
              case 0:
              case 78:
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 break;
                barrier();
               }
              case 27:
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               break;
              case 40:
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 {
                  do
                   {
                    barrier();
                   }
                  while(_GLF_WRAPPED_LOOP(false));
                 }
                if(_GLF_DEAD(false))
                 return;
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 {
                  if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   {
                   }
                  else
                   {
                    barrier();
                   }
                 }
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 {
                  if(_GLF_DEAD(false))
                   break;
                  do
                   {
                    if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     {
                     }
                    else
                     {
                      if(_GLF_DEAD(false))
                       barrier();
                      barrier();
                     }
                   }
                  while(_GLF_WRAPPED_LOOP(false));
                  if(_GLF_DEAD(false))
                   barrier();
                  if(_GLF_DEAD(false))
                   return;
                 }
                barrier();
                if(_GLF_DEAD(false))
                 continue;
               }
              case 66:
              if(_GLF_DEAD(false))
               {
                switch(_GLF_SWITCH(0))
                 {
                  case 0:
                  if(_GLF_DEAD(false))
                   break;
                  case 73:
                  case 44:
                  if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
                   continue;
                  case 99:
                  case 95:
                  if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                   continue;
                  if(_GLF_DEAD(false))
                   continue;
                  case 29:
                  case 38:
                  if(_GLF_WRAPPED_IF_TRUE(true))
                   {
                    if(_GLF_DEAD(false))
                     barrier();
                   }
                  else
                   {
                   }
                  case 92:
                  case 37:
                  case 65:
                  barrier();
                  if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                   return;
                  break;
                  if(_GLF_DEAD(false))
                   continue;
                  case 25:
                  mat3x4(586.916, -2345.1528, 3.8, -5144.2626, 0.4, -1.7, -6.2, 3.8, 71.27, 49.64, 196.033, 85.10);
                  default:
                  1;
                 }
                if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                 break;
               }
              case 39:
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               continue;
              continue;
              if(_GLF_DEAD(false))
               break;
              if(_GLF_DEAD(false))
               continue;
              if(_GLF_DEAD(false))
               barrier();
              case 84:
              case 67:
              case 42:
              case 17:
              if(_GLF_DEAD(false))
               continue;
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
                switch(_GLF_SWITCH(0))
                 {
                  case 23:
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   return;
                  (uvec3(169469u, 176611u, 123370u) != min(uvec3(124718u, 178186u, 29201u), num_workgroup));
                  case 26:
                  ;
                  case 0:
                  if(_GLF_DEAD(false))
                   continue;
                  if(_GLF_DEAD(false))
                   return;
                  barrier();
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   return;
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   break;
                  break;
                  case 52:
                  (+ mat2(-694.104, -7.3, 92.96, 1.8));
                  case 62:
                  if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                   break;
                  ((ivec2(77737, 27266) << ivec2(-31383, -38583)) ^ ivec2(71524, -84591));
                  default:
                  if(_GLF_DEAD(false))
                   barrier();
                  if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                   {
                    1;
                   }
                  else
                   {
                   }
                  if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                   {
                    if(_GLF_WRAPPED_IF_FALSE(false))
                     {
                     }
                    else
                     {
                      barrier();
                     }
                   }
                 }
               }
              break;
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               break;
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_DEAD(false))
               continue;
              if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
               {
                if(_GLF_DEAD(false))
                 {
                  if(_GLF_WRAPPED_IF_TRUE(true))
                   {
                    barrier();
                   }
                  else
                   {
                   }
                 }
                break;
                if(_GLF_DEAD(false))
                 break;
               }
              if(_GLF_DEAD(false))
               barrier();
              case 98:
              bvec3 _GLF_SWITCH_2_0v[61], _GLF_SWITCH_2_1v, _GLF_SWITCH_2_2v;
              default:
              if(_GLF_DEAD(false))
               barrier();
              1;
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               return;
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
                if(_GLF_DEAD(false))
                 barrier();
                continue;
               }
              if(_GLF_DEAD(false))
               continue;
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 break;
                return;
               }
             }
           }
          if(_GLF_DEAD(false))
           return;
          if(_GLF_DEAD(false))
           {
            if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
             {
             }
            else
             {
              if(_GLF_DEAD(false))
               return;
             }
            if(_GLF_DEAD(false))
             break;
            if(_GLF_DEAD(false))
             barrier();
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             continue;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
             {
              return;
             }
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             break;
           }
          if(_GLF_DEAD(false))
           break;
          if(_GLF_DEAD(false))
           continue;
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           barrier();
          if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
           barrier();
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           {
            if(_GLF_DEAD(false))
             break;
            continue;
           }
          for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
           {
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               barrier();
              if(_GLF_WRAPPED_IF_FALSE(false))
               {
               }
              else
               {
                if(_GLF_DEAD(false))
                 return;
               }
              barrier();
             }
           }
          for(          (+ (mat4x3(-211.073, -3.4, 2.5, 9271.5345, 4.3, -36.38, -2.9, 7.6, 5472.9070, -52.60, -280.945, 5970.9943) / -6.1));
 true; min(ivec2(-15603, -21244), ivec2(74650, -38385)))
           {
            (uvec3(128077u, 140968u, 174992u) % uvec3(125951u, 45790u, 59709u));
            bvec2(false, true);
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             break;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               break;
              if(_GLF_DEAD(false))
               continue;
              barrier();
             }
            mat4x3 _GLF_SWITCH_0_19v, _GLF_SWITCH_0_20v;
            if(_GLF_DEAD(false))
             break;
            if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
             {
              if(_GLF_DEAD(false))
               return;
              if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true && (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
               {
                do
                 {
                  barrier();
                 }
                while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) && true)));
               }
             }
            else
             {
             }
            if(_GLF_DEAD(false))
             break;
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(false))
               barrier();
              continue;
             }
            if(_GLF_DEAD(false))
             {
              if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
               }
              else
               {
                return;
               }
             }
            if(_GLF_DEAD(false))
             barrier();
            mat3x4 _GLF_SWITCH_0_21v, _GLF_SWITCH_0_22v;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             continue;
            if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
             }
            else
             {
              bvec4(false, false, false, false);
             }
            if(_GLF_DEAD(false))
             barrier();
            if(_GLF_DEAD(false))
             continue;
            mat4 _GLF_SWITCH_0_23v;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             break;
            mat4x2 _GLF_SWITCH_0_24v;
            if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
             break;
           }
         }
       }
      (ivec4(-16895, -37626, -39403, 71413) & -32358);
      (12494u >> subgroup_id);
      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
       {
        if(_GLF_DEAD(false))
         break;
        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         barrier();
        if(_GLF_DEAD(false))
         continue;
        if(_GLF_WRAPPED_IF_FALSE(false))
         {
         }
        else
         {
          if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
           {
           }
          else
           {
            if(_GLF_WRAPPED_IF_FALSE(false))
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               continue;
             }
            else
             {
              if(_GLF_DEAD(false))
               barrier();
              return;
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               return;
             }
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             continue;
           }
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           continue;
         }
        if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
         return;
       }
      if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, bool(bvec3(true, false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))))
       {
        if(_GLF_DEAD(false))
         barrier();
       }
      else
       {
       }
      if(_GLF_DEAD(false))
       continue;
      ivec4(-88588, -82365, -2840, -4877);
      43022u;
      for(      mat3x2(967.104, 6.2, -42.28, -6053.9518, -8794.0578, -70.48);
 any(bvec3(false, false, false)); mat4x2(2.9, 141.719, 2.1, -388.421, 9536.8132, 3.4, -2.1, 8.9))
       {
        while((mat3x4(-83.82, -894.384, 278.024, 6.9, -7.6, 6.4, 86.98, 9.7, -1.3, 8.3, -1.7, -37.51) == mat3x4(-7821.6626, -2.8, 5.8, -727.147, -8.1, -55.39, -1.2, 5.9, 3139.7855, 9.6, 913.377, -34.03)))
         {
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           break;
          bvec3 _GLF_SWITCH_0_25v, _GLF_SWITCH_0_26v, _GLF_SWITCH_0_27v[35];
          uvec2 _GLF_SWITCH_0_28v;
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           {
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(false))
               break;
              continue;
             }
            if(_GLF_DEAD(false))
             break;
            continue;
           }
          if(_GLF_DEAD(false))
           continue;
          if(_GLF_DEAD(false))
           continue;
          if(_GLF_DEAD(false))
           return;
          mat3x2 _GLF_SWITCH_0_29v;
          if(_GLF_WRAPPED_IF_FALSE(false))
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             return;
           }
          else
           {
            if(_GLF_DEAD(false))
             return;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             return;
           }
          if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, (false) && true)))
           {
           }
          else
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
              if(_GLF_DEAD(false))
               barrier();
              barrier();
              if(_GLF_DEAD(false))
               {
                if(_GLF_WRAPPED_IF_FALSE(false))
                 {
                 }
                else
                 {
                  barrier();
                 }
               }
             }
           }
          do
           {
            if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
             barrier();
           }
          while(_GLF_WRAPPED_LOOP(false));
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           {
            do
             {
              barrier();
             }
            while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           }
          bvec2(true, true);
          bvec3(true, true, false);
          if(_GLF_DEAD(false))
           {
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(false))
               break;
              barrier();
             }
            if(_GLF_DEAD(false))
             {
              for(int _injected_loop_counter = _GLF_IDENTITY(int(_GLF_ZERO(0.0, injectionSwitch.x)), (false ? _GLF_FUZZED(int(subgroup_size)) : int(_GLF_ZERO(0.0, injectionSwitch.x)))); _GLF_WRAPPED_LOOP(_injected_loop_counter != (((1 << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), int(0))) & 1)); _injected_loop_counter ++)
               {
                return;
               }
             }
            if(_GLF_WRAPPED_IF_FALSE(false))
             {
             }
            else
             {
              return;
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               break;
             }
            if(_GLF_DEAD(false))
             barrier();
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
              if(_GLF_WRAPPED_IF_TRUE(true))
               {
                return;
               }
              else
               {
               }
             }
           }
          if(_GLF_DEAD(false))
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
             }
            else
             {
              for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 | 0)); _injected_loop_counter --)
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 {
                  do
                   {
                    if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     continue;
                    barrier();
                   }
                  while(_GLF_WRAPPED_LOOP(false));
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   continue;
                  if(_GLF_DEAD(false))
                   continue;
                 }
                if(_GLF_DEAD(false))
                 return;
                do
                 {
                  return;
                 }
                while(_GLF_WRAPPED_LOOP(false));
               }
             }
           }
          if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
           {
            vec3(-72.94, 6.7, -959.118);
           }
          else
           {
           }
          if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec2(false, true)), true && (bool(bvec2(false, true)))))))
           {
            if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), true && (! (false)))))))
             return;
            continue;
           }
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           {
            if(_GLF_DEAD(false))
             break;
            if(_GLF_DEAD(false))
             barrier();
            continue;
           }
          -3.9;
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           barrier();
          if(_GLF_DEAD(false))
           return;
          if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (_GLF_IDENTITY(! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bool(bool(! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))))))
           break;
          if(_GLF_DEAD(false))
           {
            do
             {
              barrier();
             }
            while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           }
         }
        if(_GLF_DEAD(false))
         return;
        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         continue;
        ivec2 _GLF_SWITCH_0_30v;
        if(_GLF_DEAD(false))
         barrier();
        do
         {
          switch(_GLF_SWITCH((0 & 8977)))
           {
            case 0:
            if(_GLF_DEAD(false))
             return;
            case 70:
            case 86:
            findMSB(86411);
            case 16:
            if(_GLF_DEAD(false))
             return;
            case 55:
            case 19:
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bool(false)), bool(bool(bool(bool(false))))))))
               break;
              barrier();
             }
            break;
            case 21:
            -18.06;
            if(_GLF_DEAD(false))
             {
              do
               {
                do
                 {
                  barrier();
                 }
                while(_GLF_WRAPPED_LOOP(false));
               }
              while(_GLF_WRAPPED_LOOP(false));
             }
            case 25:
            mat2x4(2.9, -264.977, -76.77, 7582.8043, 87.70, -8.7, -797.021, -4521.2356);
            default:
            1;
           }
         }
        while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
        if(_GLF_DEAD(false))
         continue;
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
          continue;
         if(_GLF_DEAD(false))
          barrier();
         vec3 _GLF_SWITCH_0_31v[29], _GLF_SWITCH_0_32v, _GLF_SWITCH_0_33v[93];
         if(_GLF_DEAD(false))
          {
           switch(_GLF_SWITCH(0))
            {
             case 0:
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             case 50:
             case 25:
             case 66:
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(false))
                barrier();
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             if(_GLF_DEAD(false))
              continue;
             case 89:
             case 90:
             case 9:
             case 14:
             for(int _injected_loop_counter = _GLF_IDENTITY((0 | 0), ((0 | 0)) | (_GLF_IDENTITY((0 | 0), ~ (~ ((0 | 0)))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 barrier();
                }
              }
             break;
             case 46:
             bvec3(bvec4(true, true, true, true));
             default:
             1;
            }
           if(_GLF_DEAD(false))
            continue;
          }
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = (1 | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter > (int(_GLF_ZERO(0.0, injectionSwitch.x)) << _GLF_IDENTITY(int(8), int(8)))); _injected_loop_counter --)
              {
               barrier();
              }
            }
           if(_GLF_DEAD(false))
            break;
          }
         else
          {
          }
         uvec2(20065u, 139329u);
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_IDENTITY(bool(bvec3(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true), true, true)), ! (! (bool(bvec3(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true), true, true))))))))
            break;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              break;
             continue;
            }
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              break;
             if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, (false) && true)))
              {
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   barrier();
                  }
                 else
                  {
                  }
                }
              }
             barrier();
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_DEAD(false))
          break;
         ivec3 _GLF_SWITCH_0_34v[73];
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
             if(_GLF_DEAD(false))
              break;
            }
           else
            {
             (57993);
            }
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              break;
             barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           if(_GLF_DEAD(false))
            {
             do
              {
               barrier();
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
           return;
          }
         mat4 _GLF_SWITCH_0_35v, _GLF_SWITCH_0_36v;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
           if(_GLF_DEAD(false))
            continue;
          }
         bvec2 _GLF_SWITCH_0_37v[28], _GLF_SWITCH_0_38v, _GLF_SWITCH_0_39v;
         if(_GLF_DEAD(false))
          break;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            return;
           barrier();
          }
         if(_GLF_DEAD(false))
          break;
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           do
            {
             (- mat3x4(-29.12, 1.5, 46.83, 573.305, -16.27, 3.3, 1.2, 8.8, 8734.8614, -299.232, -4340.6906, 22.70));
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
         else
          {
          }
         ivec3(47371, 88788, 86222);
        }
        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         {
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           return;
          switch(_GLF_SWITCH(0))
           {
            case 66:
            if(_GLF_WRAPPED_IF_FALSE(false))
             {
             }
            else
             {
              mat4x2(1.5, -4015.7821, -6.2, 5.7, -281.687, -8.1, -5336.9179, -8489.2508);
             }
            case 95:
            if(_GLF_DEAD(false))
             return;
            if(_GLF_DEAD(false))
             continue;
            (mat2x4(3.5, -6028.6609, 3211.3380, -3.2, 57.82, 6.0, 5.3, 3.5) , vec4(-7825.7837, -692.305, 852.061, 6333.1952));
            case 0:
            if(_GLF_DEAD(false))
             break;
            case 14:
            case 1:
            case 99:
            case 11:
            case 82:
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             break;
            if(_GLF_DEAD(false))
             barrier();
            case 72:
            continue;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             return;
            break;
            case 59:
            ivec3 _GLF_SWITCH_3_0v;
            if(_GLF_DEAD(false))
             return;
            case 39:
            vec2 _GLF_SWITCH_3_1v[39], _GLF_SWITCH_3_2v, _GLF_SWITCH_3_3v;
            if(_GLF_DEAD(false))
             continue;
            if(_GLF_DEAD(false))
             continue;
            if(_GLF_DEAD(false))
             return;
            default:
            1;
           }
         }
        if(_GLF_DEAD(false))
         barrier();
        ldexp(injectionSwitch, ivec2(-97003, -39870));
        if(_GLF_DEAD(false))
         {
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           barrier();
          continue;
         }
        if(_GLF_DEAD(false))
         barrier();
        if(_GLF_DEAD(false))
         {
          switch(_GLF_SWITCH(((0 << _GLF_IDENTITY(int(1), int(1))) & 91591)))
           {
            case 0:
            case 1:
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             continue;
            case 94:
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
                do
                 {
                  return;
                 }
                while(_GLF_WRAPPED_LOOP(false));
               }
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               barrier();
              barrier();
             }
            case 38:
            case 58:
            case 53:
            case 92:
            case 71:
            case 87:
            return;
            break;
            case 46:
            uvec2(144154u, 145358u);
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             continue;
            default:
            1;
           }
         }
        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         continue;
        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         {
          if(_GLF_DEAD(false))
           {
            if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, bool(bvec2(false, false)))) || false)))
             break;
            barrier();
           }
          if(_GLF_DEAD(false))
           continue;
          continue;
          if(_GLF_DEAD(false))
           continue;
         }
        if(_GLF_DEAD(false))
         {
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           continue;
          barrier();
         }
        for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(8), int(8))); _GLF_WRAPPED_LOOP(_injected_loop_counter < ((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(6), int(6))) >> _GLF_IDENTITY(int(6), int(6)))); _injected_loop_counter ++)
         {
          switch(_GLF_SWITCH((0 | (0 >> _GLF_IDENTITY(int(0), int(0))))))
           {
            case 17:
            (ivec4(15195, 23458, -19510, -53022) == ivec4(97043, -34582, -44737, 6042));
            case 9:
            if(_GLF_DEAD(false))
             return;
            uvec2 _GLF_SWITCH_1_0v, _GLF_SWITCH_1_1v, _GLF_SWITCH_1_2v;
            if(_GLF_DEAD(false))
             break;
            if(_GLF_DEAD(false))
             barrier();
            case 0:
            case 40:
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             return;
            case 49:
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            case 37:
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            case 67:
            if(_GLF_DEAD(false))
             {
              do
               {
                barrier();
               }
              while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
             }
            case 16:
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, bool(bvec3(false, true, false)))) && true)))
             {
              if(_GLF_DEAD(false))
               continue;
              barrier();
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               continue;
             }
            case 59:
            case 92:
            if(_GLF_DEAD(false))
             break;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
              if(_GLF_DEAD(false))
               barrier();
              return;
             }
            case 44:
            case 83:
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(false))
               continue;
              break;
             }
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
              if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, true)))))
               continue;
              barrier();
             }
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
              switch(_GLF_SWITCH(0))
               {
                case 13:
                int _GLF_SWITCH_4_0v[15];
                if(_GLF_DEAD(false))
                 return;
                case 47:
                mat4x2 _GLF_SWITCH_4_1v, _GLF_SWITCH_4_2v;
                case 0:
                case 4:
                case 35:
                case 93:
                case 90:
                case 39:
                case 38:
                case 36:
                if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(bvec4(false, true, false, false)))))
                 {
                 }
                else
                 {
                  if(_GLF_DEAD(false))
                   continue;
                  if(_GLF_DEAD(false))
                   break;
                  barrier();
                  if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, ! (! (false))))))))
                   barrier();
                 }
                break;
                default:
                1;
                if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
                 break;
               }
              if(_GLF_DEAD(false))
               continue;
             }
            if(false)
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               barrier();
              int _GLF_SWITCH_0_40v, _GLF_SWITCH_0_41v[26], _GLF_SWITCH_0_42v;
              for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
               {
                if(_GLF_DEAD(false))
                 barrier();
               }
              if(_GLF_DEAD(false))
               {
                if(_GLF_WRAPPED_IF_TRUE(true))
                 {
                  return;
                 }
                else
                 {
                 }
               }
              ;
              mat2x4 _GLF_SWITCH_0_43v[54], _GLF_SWITCH_0_44v[32], _GLF_SWITCH_0_45v[20];
              for(int _injected_loop_counter = (int(_GLF_ONE(1.0, injectionSwitch.y)) ^ 0); _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
               {
                vec4(-8.8, 117.550, 6622.7698, -303.941);
               }
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 barrier();
                barrier();
                if(_GLF_DEAD(false))
                 break;
               }
              if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
               continue;
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               break;
              if(_GLF_DEAD(false))
               return;
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               break;
              if(_GLF_WRAPPED_IF_TRUE(true))
               {
                if(_GLF_DEAD(false))
                 {
                  if(_GLF_DEAD(false))
                   {
                    if(_GLF_DEAD(false))
                     barrier();
                    if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     {
                     }
                    else
                     {
                      barrier();
                     }
                   }
                  barrier();
                 }
               }
              else
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 continue;
               }
              ;
              if(_GLF_DEAD(false))
               break;
              ivec2 _GLF_SWITCH_0_46v[50];
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               continue;
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               return;
              if(_GLF_DEAD(false))
               continue;
              bvec4 _GLF_SWITCH_0_47v[36];
              bool _GLF_SWITCH_0_48v[93];
              mat3x2 _GLF_SWITCH_0_49v;
              if(_GLF_DEAD(false))
               {
                if(_GLF_WRAPPED_IF_FALSE(false))
                 {
                 }
                else
                 {
                  barrier();
                 }
               }
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 break;
                return;
               }
              if(_GLF_DEAD(false))
               break;
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_WRAPPED_IF_FALSE(false))
               {
                if(_GLF_DEAD(false))
                 return;
               }
              else
               {
                if(_GLF_DEAD(false))
                 barrier();
                switch(_GLF_SWITCH(0))
                 {
                  case 31:
                  if(_GLF_DEAD(false))
                   {
                    if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     {
                      if(_GLF_DEAD(false))
                       break;
                      barrier();
                     }
                    return;
                   }
                  if(_GLF_DEAD(false))
                   barrier();
                  for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                   {
                    if(_GLF_DEAD(false))
                     barrier();
                   }
                  if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, bool(bool(true)))))
                   {
                    if(_GLF_DEAD(false))
                     {
                      if(_GLF_WRAPPED_IF_FALSE(false))
                       {
                       }
                      else
                       {
                        return;
                       }
                     }
                    if(_GLF_DEAD(false))
                     continue;
                    if(_GLF_DEAD(false))
                     break;
                    if(_GLF_DEAD(false))
                     return;
                    bvec2(false, false);
                    if(_GLF_DEAD(false))
                     break;
                    if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     barrier();
                   }
                  else
                   {
                   }
                  if(_GLF_DEAD(false))
                   return;
                  if(_GLF_DEAD(false))
                   barrier();
                  case 0:
                  case 88:
                  case 85:
                  if(_GLF_DEAD(false))
                   {
                    if(_GLF_WRAPPED_IF_TRUE(true))
                     {
                      if(_GLF_DEAD(false))
                       return;
                      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                       barrier();
                      if(_GLF_DEAD(false))
                       continue;
                      switch(_GLF_SWITCH(_GLF_IDENTITY(0, clamp(_GLF_IDENTITY(0, min(0, 0)), 0, _GLF_IDENTITY(0, min(0, 0))))))
                       {
                        case 0:
                        if(_GLF_DEAD(false))
                         break;
                        if(_GLF_DEAD(false))
                         continue;
                        if(_GLF_DEAD(false))
                         {
                          if(_GLF_DEAD(false))
                           {
                            if(_GLF_DEAD(false))
                             break;
                            barrier();
                           }
                          barrier();
                         }
                        case 36:
                        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                         break;
                        case 92:
                        case 74:
                        case 29:
                        case 46:
                        case 11:
                        if(_GLF_DEAD(false))
                         continue;
                        do
                         {
                          if(_GLF_DEAD(false))
                           return;
                         }
                        while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) || false)));
                        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                         {
                          if(_GLF_DEAD(false))
                           continue;
                          barrier();
                         }
                        case 94:
                        if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (false))))
                         barrier();
                        if(_GLF_DEAD(false))
                         return;
                        case 13:
                        if(_GLF_WRAPPED_IF_FALSE(false))
                         {
                          if(_GLF_DEAD(false))
                           break;
                         }
                        else
                         {
                          if(_GLF_DEAD(false))
                           break;
                          return;
                         }
                        if(_GLF_DEAD(false))
                         return;
                        break;
                        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                         continue;
                        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                         break;
                        if(_GLF_DEAD(false))
                         {
                          if(_GLF_DEAD(false))
                           {
                            if(_GLF_WRAPPED_IF_TRUE(true))
                             {
                              return;
                             }
                            else
                             {
                             }
                           }
                          barrier();
                         }
                        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                         continue;
                        if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
                         {
                          if(_GLF_WRAPPED_IF_TRUE(true))
                           {
                            barrier();
                           }
                          else
                           {
                           }
                         }
                        default:
                        1;
                       }
                     }
                    else
                     {
                      if(_GLF_DEAD(false))
                       continue;
                     }
                   }
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   return;
                  break;
                  if(_GLF_DEAD(false))
                   break;
                  if(_GLF_DEAD(false))
                   {
                    if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     break;
                    continue;
                   }
                  case 93:
                  if(_GLF_DEAD(false))
                   barrier();
                  vec3 _GLF_SWITCH_1_0v, _GLF_SWITCH_1_1v;
                  default:
                  for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                   {
                    for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                     {
                      1;
                     }
                   }
                 }
               }
             }
            else
             {
              do
               {
                if(_GLF_DEAD(false))
                 {
                  do
                   {
                    if(_GLF_DEAD(false))
                     return;
                    do
                     {
                      barrier();
                     }
                    while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                   }
                  while(_GLF_WRAPPED_LOOP(false));
                 }
                (ivec2(-72075, -87600) != _GLF_SWITCH_0_30v);
               }
              while(_GLF_WRAPPED_LOOP(false));
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
               {
                if(_GLF_DEAD(false))
                 continue;
                mat4(297.614, -66.08, -5.9, -8.5, -635.064, -50.19, -8.6, -24.10, 52.58, -10.81, 18.57, -8.5, -1669.5090, -6.9, -2765.7489, 79.28);
               }
              else
               {
               }
              if(_GLF_DEAD(false))
               {
                for(int _injected_loop_counter = ((0 >> _GLF_IDENTITY(int(7), int(7))) ^ 1); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                 {
                  barrier();
                 }
               }
              mat3 _GLF_SWITCH_0_50v;
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))
                 barrier();
                for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(8), int(8))); _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 & 1)); _injected_loop_counter ++)
                 {
                  return;
                 }
               }
              mat2(-9.7, -5.1, 5.6, -724.737);
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               barrier();
              bvec2 _GLF_SWITCH_0_51v, _GLF_SWITCH_0_52v, _GLF_SWITCH_0_53v;
              if(_GLF_WRAPPED_IF_TRUE(true))
               {
                if(_GLF_DEAD(false))
                 return;
               }
              else
               {
               }
              if(_GLF_DEAD(false))
               {
                for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                 {
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   return;
                 }
                barrier();
               }
              if(_GLF_DEAD(false))
               continue;
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 break;
                break;
               }
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_WRAPPED_IF_TRUE(true))
               {
                if(_GLF_DEAD(false))
                 break;
                (-56835 , bvec2(false, true));
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 break;
               }
              else
               {
               }
              if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 barrier();
                break;
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 continue;
               }
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 {
                  if(_GLF_DEAD(false))
                   continue;
                  return;
                 }
                barrier();
               }
              do
               {
                if(_GLF_DEAD(false))
                 barrier();
               }
              while(_GLF_WRAPPED_LOOP(false));
              if(_GLF_DEAD(false))
               return;
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               break;
              do
               {
                if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                 break;
                ((true ? mat3x4(-54.61, -95.96, -911.547, -6.1, 39.13, 7.6, 9.5, 9.2, 9258.2680, -3.3, -7.3, -633.444) : mat3x4(827.866, 4.1, 26.77, -26.45, -13.46, 802.225, -7.2, 453.955, -5.8, 8716.3798, -8.6, -9.2)) * (-694.431 - (9.3 + _GLF_SWITCH_0_50v)));
               }
              while(_GLF_WRAPPED_LOOP(false));
              for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != ((((1 << _GLF_IDENTITY(int(6), int(6))) >> _GLF_IDENTITY(int(6), int(6))) << _GLF_IDENTITY(int(3), _GLF_IDENTITY(int(3), 0 ^ (int(3))))) >> _GLF_IDENTITY(int(3), int(3)))); _injected_loop_counter ++)
               {
                if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                 barrier();
               }
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 return;
                barrier();
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 return;
               }
              if(_GLF_DEAD(false))
               break;
              mat2x4 _GLF_SWITCH_0_54v, _GLF_SWITCH_0_55v;
              if(_GLF_DEAD(false))
               break;
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 barrier();
                continue;
               }
              if(_GLF_DEAD(false))
               break;
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 break;
                barrier();
               }
              if(_GLF_DEAD(false))
               barrier();
             }
            break;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            if(_GLF_DEAD(false))
             return;
            if(_GLF_DEAD(false))
             break;
            default:
            for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
             {
              1;
             }
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            if(_GLF_DEAD(false))
             return;
            if(_GLF_DEAD(false))
             return;
            if(_GLF_DEAD(false))
             continue;
            if(_GLF_DEAD(false))
             return;
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(false))
               barrier();
              barrier();
             }
           }
         }
        uvec3 _GLF_SWITCH_0_56v;
        if(_GLF_DEAD(false))
         break;
       }
      if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
       break;
     }
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(false, true, false, false)))))
        return;
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
          return;
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, (false) || false))))))
          {
           if(_GLF_DEAD(false))
            break;
           continue;
          }
         barrier();
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       continue;
       if(_GLF_DEAD(false))
        continue;
      }
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     else
      {
      }
     if(_GLF_DEAD(false))
      break;
     case 0:
     if(_GLF_DEAD(false))
      return;
     case 35:
     if(_GLF_DEAD(false))
      continue;
     if(_GLF_DEAD(false))
      break;
     case 78:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      break;
     if(_GLF_DEAD(false))
      return;
     case 74:
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             return;
            }
           else
            {
            }
          }
         barrier();
        }
       if(_GLF_DEAD(false))
        return;
      }
     else
      {
       if(_GLF_DEAD(false))
        break;
       do
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            continue;
           barrier();
          }
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
     case 54:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      break;
     if(_GLF_DEAD(false))
      {
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
        {
         barrier();
        }
      }
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         barrier();
        }
      }
     else
      {
      }
     case 56:
     if(_GLF_DEAD(false))
      break;
     case 69:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            break;
           return;
          }
         return;
        }
       break;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        continue;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(false))
        break;
       if(_GLF_DEAD(false))
        barrier();
       for(int _injected_loop_counter = (0 ^ 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         if(_GLF_DEAD(false))
          break;
         barrier();
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             return;
            }
           else
            {
            }
          }
         if(_GLF_DEAD(false))
          continue;
         barrier();
        }
      }
     case 87:
     case 99:
     if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
      continue;
     case 60:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        break;
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            break;
           continue;
          }
         barrier();
         if(_GLF_DEAD(false))
          continue;
        }
       return;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        break;
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
          {
           barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
          }
         if(_GLF_DEAD(false))
          continue;
        }
       barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         barrier();
        }
      }
     if(_GLF_DEAD(false))
      continue;
     if(_GLF_DEAD(false))
      {
       switch(_GLF_SWITCH(0))
        {
         case 0:
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              continue;
             for(int _injected_loop_counter = (1 | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
              {
               if(_GLF_DEAD(false))
                return;
               barrier();
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
              }
             if(_GLF_DEAD(false))
              continue;
            }
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(false))
            break;
           do
            {
             return;
            }
           while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (false))));
           if(_GLF_DEAD(false))
            continue;
          }
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               return;
              }
            }
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
              barrier();
             barrier();
             if(_GLF_DEAD(false))
              return;
            }
           if(_GLF_DEAD(false))
            continue;
          }
         else
          {
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
            }
           else
            {
             barrier();
            }
          }
         if(_GLF_DEAD(false))
          barrier();
         break;
         default:
         1;
        }
      }
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
            }
           else
            {
             return;
            }
          }
        }
       if(_GLF_DEAD(false))
        return;
      }
     if(_GLF_DEAD(false))
      {
       do
        {
         return;
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bool(false)), (bool(bool(false))) || false))))
        return;
       continue;
      }
     if(_GLF_DEAD(false))
      barrier();
     break;
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        break;
       break;
      }
     case 95:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        return;
       continue;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      break;
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             return;
            }
           else
            {
            }
          }
         if(_GLF_DEAD(false))
          barrier();
         continue;
        }
       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
        }
       else
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          break;
         if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(bvec4(false, false, true, true)))))
          {
          }
         else
          {
           if(_GLF_DEAD(false))
            barrier();
          }
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             do
              {
               barrier();
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
            }
           if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
            continue;
           break;
          }
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            barrier();
           barrier();
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(false))
            continue;
          }
         else
          {
           if(_GLF_DEAD(false))
            return;
          }
         if(_GLF_DEAD(false))
          continue;
        }
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(_GLF_IDENTITY(false, bool(bvec3(false, false, true))), true, true)))))
          continue;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            break;
           barrier();
          }
         barrier();
        }
       else
        {
         if(_GLF_DEAD(false))
          break;
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true && (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
          break;
        }
      }
     float _GLF_SWITCH_0_57v, _GLF_SWITCH_0_58v;
     if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
      return;
     case 88:
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         barrier();
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
        return;
       if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
        continue;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       break;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     do
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        break;
       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
        {
         if(_GLF_DEAD(false))
          barrier();
         barrier();
        }
       switch(_GLF_SWITCH(0))
        {
         case 0:
         if(_GLF_DEAD(false))
          continue;
         case 6:
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
             continue;
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
              return;
             return;
            }
           else
            {
            }
          }
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            return;
          }
         else
          {
          }
         case 68:
         case 12:
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               barrier();
              }
             else
              {
              }
            }
           return;
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              continue;
             barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
            }
           continue;
           if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec3(false, false, true)), (bool(bvec3(false, false, true))) || false))))
            continue;
          }
         break;
         if(_GLF_DEAD(false))
          continue;
         case 32:
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             barrier();
            }
           else
            {
            }
          }
         if(_GLF_DEAD(false))
          continue;
         vec4 _GLF_SWITCH_2_0v[21];
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           continue;
          }
         do
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, false, true)))))
            return;
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
         default:
         1;
        }
      }
     while(_GLF_WRAPPED_LOOP(false));
     for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
      {
       if(_GLF_DEAD(false))
        barrier();
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        continue;
       return;
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         barrier();
        }
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
            {
             barrier();
            }
          }
         break;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       barrier();
      }
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       for(mat3x4 _GLF_SWITCH_0_59v; true; 96361)
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          break;
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           return;
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
              }
             return;
            }
           if(_GLF_DEAD(false))
            return;
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
            {
             barrier();
            }
          }
         length(step(-737.218, vec2(199.566, 919.484)));
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           ivec2(-25770, -3021);
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) && (false))))
            barrier();
           for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(7), int(7))) >> _GLF_IDENTITY(int(7), int(7))); _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 >> _GLF_IDENTITY(int(4), int(4)))); _injected_loop_counter --)
            {
             if(_GLF_DEAD(false))
              return;
             if(_GLF_DEAD(false))
              barrier();
            }
          }
         if(_GLF_DEAD(false))
          break;
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
            {
             case 38:
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, (false) && true), (_GLF_IDENTITY(false, (false) && true)) && true)))
              {
               for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                {
                 barrier();
                }
              }
             mat2x4 _GLF_SWITCH_3_0v;
             case 0:
             case 39:
             case 37:
             if(_GLF_DEAD(false))
              return;
             break;
             if(_GLF_DEAD(false))
              break;
             case 96:
             min(uvec3(144242u, 54661u, 68704u), num_workgroup);
             default:
             1;
            }
          }
         else
          {
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
            continue;
          }
         do
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
              }
             else
              {
               switch(_GLF_SWITCH(0))
                {
                 case 0:
                 case 18:
                 case 12:
                 case 7:
                 if(_GLF_DEAD(false))
                  {
                   switch(_GLF_SWITCH(0))
                    {
                     case 69:
                     _GLF_SWITCH_0_57v;
                     case 0:
                     case 42:
                     case 53:
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          continue;
                         return;
                        }
                       barrier();
                       if(_GLF_DEAD(false))
                        continue;
                      }
                     if(_GLF_DEAD(false))
                      barrier();
                     case 46:
                     case 89:
                     return;
                     break;
                     if(_GLF_DEAD(false))
                      continue;
                     if(_GLF_DEAD(false))
                      continue;
                     case 79:
                     mat2x4 _GLF_SWITCH_3_0v;
                     case 5:
                     ;
                     default:
                     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      {
                       if(_GLF_DEAD(false))
                        break;
                      }
                     else
                      {
                       if(_GLF_DEAD(false))
                        continue;
                       if(_GLF_DEAD(false))
                        barrier();
                      }
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_DEAD(false))
                        continue;
                       continue;
                      }
                     1;
                    }
                   if(_GLF_DEAD(false))
                    return;
                  }
                 break;
                 case 88:
                 (- mat4x2(mat3x4(975.193, 7.2, 84.40, -4.1, 5.9, 47.11, -959.395, -3116.9164, -70.59, 73.23, 13.41, 59.25)));
                 default:
                 if(_GLF_DEAD(false))
                  break;
                 1;
                 if(_GLF_DEAD(false))
                  return;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                }
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               barrier();
              }
             else
              {
              }
            }
           if(_GLF_DEAD(false))
            return;
          }
         while(_GLF_WRAPPED_LOOP(false));
         if(_GLF_DEAD(false))
          barrier();
         vec3 _GLF_SWITCH_0_60v, _GLF_SWITCH_0_61v;
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
              {
               barrier();
              }
            }
          }
         do
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 barrier();
                }
              }
            }
           else
            {
            }
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
      }
     default:
     1;
     if(_GLF_DEAD(false))
      break;
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
      }
     else
      {
      }
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, bool(bool(false))))))))
      continue;
     if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
      continue;
     if(_GLF_DEAD(_GLF_IDENTITY(false, true && (_GLF_IDENTITY(false, false || (false))))))
      barrier();
     continue;
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   if(_GLF_DEAD(false))
    {
     do
      {
       for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
        {
         if(_GLF_DEAD(false))
          continue;
         barrier();
         if(_GLF_DEAD(false))
          return;
        }
      }
     while(_GLF_WRAPPED_LOOP(false));
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      break;
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         return;
        }
       else
        {
        }
      }
    }
   if(_GLF_DEAD(false))
    break;
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        break;
       continue;
      }
     barrier();
    }
   if(_GLF_DEAD(false))
    barrier();
  }
 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
 if(_GLF_DEAD(false))
  return;
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_DEAD(false))
    {
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
      {
       if(_GLF_DEAD(false))
        return;
      }
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (false))))
        barrier();
       switch(_GLF_SWITCH(0))
        {
         case 74:
         mat2(mat3x4(-1.3, 8776.9373, 9.4, -5.5, -7100.2115, -4890.4313, 942.208, -1641.9266, 109.145, 267.141, 7644.8781, -896.264));
         case 0:
         if(_GLF_DEAD(false))
          {
           do
            {
             if(_GLF_DEAD(false))
              return;
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), int(0)))); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               return;
              }
            }
          }
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           barrier();
          }
         else
          {
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 return;
                }
               else
                {
                }
              }
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               return;
              }
            }
          }
         break;
         default:
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
            {
             barrier();
            }
          }
         1;
        }
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
        {
         if(_GLF_DEAD(false))
          return;
        }
      }
     else
      {
      }
    }
  }
 uint workgroup_size = gl_WorkGroupSize.x;
 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
  {
   if(_GLF_DEAD(false))
    barrier();
  }
 else
  {
  }
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    return;
   barrier();
  }
 uint workgroup_id = gl_WorkGroupID.x;
 if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, false, false)))))
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      return;
     for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(8), int(8))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
      {
       barrier();
      }
    }
   barrier();
   if(_GLF_DEAD(false))
    barrier();
  }
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        return;
       barrier();
      }
     if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
      {
       if(_GLF_DEAD(false))
        return;
       return;
      }
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      barrier();
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
      {
       do
        {
         for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              break;
             barrier();
            }
           return;
          }
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(false))
        continue;
      }
    }
  }
 else
  {
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    return;
   barrier();
  }
 uint workgroup_base = workgroup_size * workgroup_id;
 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 & 66979)); _injected_loop_counter --)
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 uint virtual_gid = workgroup_base + subgroup_id * subgroup_size + subgroup_local_id;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
  barrier();
 if(_GLF_DEAD(false))
  return;
 for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(3), int(3))) >> _GLF_IDENTITY(int(3), int(3))); _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
  {
   if(_GLF_DEAD(false))
    return;
  }
 uint next_virtual_gid = workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size);
 do
  {
   if(_GLF_DEAD(false))
    {
     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
      {
       if(_GLF_DEAD(false))
        break;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     do
      {
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != ((((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), int(1))) << _GLF_IDENTITY(int(7), int(7))) >> _GLF_IDENTITY(int(7), int(7)))); _injected_loop_counter ++)
        {
         return;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
      }
     while(_GLF_WRAPPED_LOOP(false));
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        return;
       return;
      }
     if(_GLF_DEAD(false))
      barrier();
    }
  }
 while(_GLF_WRAPPED_LOOP(false));
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(false))
      barrier();
     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 ^ 1)); _injected_loop_counter --)
      {
       barrier();
      }
    }
   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
    {
     if(_GLF_DEAD(false))
      break;
     return;
    }
  }
 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
  }
 else
  {
   if(_GLF_DEAD(false))
    {
     do
      {
       return;
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   buf[virtual_gid] = 1;
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      return;
     return;
    }
   if(_GLF_DEAD(false))
    barrier();
  }
 atomicStore(buf[next_virtual_gid], uint(2), 4, 64, 4);
 if(_GLF_DEAD(false))
  return;
 do
  {
   if(_GLF_DEAD(false))
    break;
   switch(_GLF_SWITCH(0))
    {
     case 38:
     if(_GLF_DEAD(false))
      break;
     vec2(-722.974, -3.9);
     if(_GLF_DEAD(false))
      {
       do
        {
         return;
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        break;
       barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        break;
      }
     case 0:
     case 30:
     case 18:
     case 60:
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         return;
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          break;
         return;
        }
       barrier();
       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, (false) && true))))))
        continue;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        continue;
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         return;
        }
      }
     if(_GLF_DEAD(false))
      return;
     break;
     default:
     if(_GLF_DEAD(false))
      continue;
     1;
     if(_GLF_DEAD(false))
      break;
    }
   if(_GLF_DEAD(false))
    return;
  }
 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
 for(int _injected_loop_counter = (1 ^ (0 >> _GLF_IDENTITY(int(0), int(0)))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
  {
   if(_GLF_DEAD(false))
    {
     do
      {
       do
        {
         switch(_GLF_SWITCH((((1 | 1) & 1) ^ 1)))
          {
           case 7:
           {
            while((ivec3(-19231, 93072, -74850) != ivec3(47900, -3295, 35844)))
             {
              if(bool(cos(-2796.8025)))
               {
                if(_GLF_DEAD(false))
                 return;
                if(_GLF_DEAD(false))
                 break;
                bool _GLF_SWITCH_4_0v[24], _GLF_SWITCH_4_1v[7];
               }
             }
            vec3 _GLF_SWITCH_4_2v, _GLF_SWITCH_4_3v;
            if(_GLF_WRAPPED_IF_TRUE(true))
             {
              ;
             }
            else
             {
             }
           }
           case 0:
           case 77:
           case 57:
           case 98:
           case 8:
           if(_GLF_DEAD(false))
            return;
           case 81:
           do
            {
             barrier();
            }
           while(_GLF_WRAPPED_LOOP(false));
           break;
           if(_GLF_DEAD(false))
            break;
           case 93:
           bvec4(true, false, false, true);
           case 91:
           lessThanEqual(uvec4(32592u, 29521u, 135191u, 121079u), uvec4(92385u, 48071u, 187543u, 62626u));
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              return;
            }
           default:
           1;
          }
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
     while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, false || (_GLF_IDENTITY(false, ! (! (false)))))));
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        return;
       return;
      }
    }
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
}

END

BUFFER tester DATA_TYPE uint32 SIZE 8388096 FILL 0
BUFFER expected DATA_TYPE uint32 SIZE 8388096 FILL 2
BUFFER injection DATA_TYPE vec2<float> DATA
 0.0 1.0
END

PIPELINE compute test_pipe
  ATTACH test
  BIND BUFFER tester AS storage DESCRIPTOR_SET 0 BINDING 0 
  BIND BUFFER injection AS uniform DESCRIPTOR_SET 0 BINDING 1 

END

RUN test_pipe 65532 1 1
EXPECT tester EQ_BUFFER expected
