#!amber

DEVICE_FEATURE SubgroupSizeControl.subgroupSizeControl

SET ENGINE_DATA fence_timeout_ms 10000

SHADER compute test GLSL
#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer Checker {
 uint checker[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       return;
      }
     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
      barrier();
    }
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    barrier();
   return;
  }
 uint subgroup_id = gl_SubgroupID;
 if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true && (_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).x > injectionSwitch.y)))))))))
  {
   switch(_GLF_SWITCH(0))
    {
     case 44:
     if(false)
      {
       not(bvec2(false, true));
       for(mat3x4 _GLF_SWITCH_3_0v[67], _GLF_SWITCH_3_1v; false; (mat2x4(vec4(-906.407, 73.15, -96.35, -79.33), vec4(9.1, -8.7, -711.364, 512.203)) + mat2x4(5.0, 163.644, -7.7, -3.6, -307.966, 461.870, -466.081, 2202.3548)))
        {
         {
          mat2x4(-205.577, -4.2, 3.6, -1764.2877, -8.1, 2036.2000, 3.0, -6.1);
          mat3x2 _GLF_SWITCH_3_2v, _GLF_SWITCH_3_3v[20], _GLF_SWITCH_3_4v;
          (-- (_GLF_SWITCH_3_1v));
          ivec4(77716, 63465, 59393, 9740);
         }
        }
       {
        ivec3 _GLF_SWITCH_3_5v[85], _GLF_SWITCH_3_6v;
        matrixCompMult(mat3(-91.63, -9155.4201, 3.0, 610.774, 79.75, -8506.0424, 73.07, -37.89, 1.1), mat3(-834.537, -464.626, -94.52, -4758.3787, 174.570, -5087.3441, 6955.8813, -870.736, -1.6));
        while(false)
         {
          mat3x4 _GLF_SWITCH_3_7v;
          int _GLF_SWITCH_3_8v;
          uvec4 _GLF_SWITCH_3_9v[63];
          _GLF_SWITCH_3_6v.y;
         }
       }
       for(bvec4 _GLF_SWITCH_3_10v, _GLF_SWITCH_3_11v[36]; false; bvec4(true, false, false, false))
        {
         do
          {
           ivec3(-11766, 84237, -39903);
           uvec4 _GLF_SWITCH_3_12v, _GLF_SWITCH_3_13v, _GLF_SWITCH_3_14v;
           uvec3 _GLF_SWITCH_3_15v;
          }
         while(true);
        }
       if(false)
        {
         do
          {
           mat2 _GLF_SWITCH_3_16v, _GLF_SWITCH_3_17v, _GLF_SWITCH_3_18v;
           ivec2 _GLF_SWITCH_3_19v, _GLF_SWITCH_3_20v;
           ivec2 _GLF_SWITCH_3_21v, _GLF_SWITCH_3_22v, _GLF_SWITCH_3_23v;
           distance(6.0, -2420.5478);
           notEqual(vec3(-1.2, -85.48, -792.664), vec3(-8.6, 9.6, -0.7));
          }
         while(false);
        }
       else
        {
         if(all(bvec2(true, false)))
          {
           vec4(4.0, 694.921, 8623.0750, -77.40);
           bvec2(false, false);
           bool _GLF_SWITCH_3_24v[37], _GLF_SWITCH_3_25v;
           -7.5;
           mat4(-907.390, -5074.6232, -13.81, 717.258, -469.601, -2.8, 3100.4407, -5.9, -1.5, 99.12, -50.01, -3.8, 290.105, 19.99, 52.51, 3.2);
           subgroup_id;
          }
         mat3x4 _GLF_SWITCH_3_26v, _GLF_SWITCH_3_27v, _GLF_SWITCH_3_28v;
         isinf(vec3(108.676, -1.8, -719.419));
         degrees(-4.7);
         {
          mat2x4((mat3x2(-3990.9477, 774.662, -5.7, -235.318, 7.6, -4.6)));
          mat2 _GLF_SWITCH_3_29v;
          bvec3(false, true, false);
          ivec2 _GLF_SWITCH_3_30v, _GLF_SWITCH_3_31v[23];
         }
         ivec2(30627, -55041);
         for(         bool(packUnorm2x16((injectionSwitch - injectionSwitch)));
 true; bvec2(false, false))
          {
           bvec2 _GLF_SWITCH_3_32v, _GLF_SWITCH_3_33v, _GLF_SWITCH_3_34v;
           mat2(-433.298, 5.2, -35.06, -6.9);
          }
        }
       while(true)
        {
         {
          max(9802u, 144104u);
         }
        }
       ivec3 _GLF_SWITCH_3_35v[95], _GLF_SWITCH_3_36v;
       bvec3(true, false, true);
      }
     case 0:
     case 67:
     case 33:
     case 60:
     if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false, false))))))))
      {
       do
        {
         barrier();
        }
       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, false || (injectionSwitch.x > injectionSwitch.y))))));
      }
     case 39:
     if(_GLF_DEAD(false))
      barrier();
     case 93:
     barrier();
     break;
     case 12:
     matrixCompMult(mat4x3(3.8, -770.131, -0.1, 618.712, 9540.4144, 58.08, -4537.2338, 2557.0949, 98.76, 397.867, 43.85, 7105.1536), mat4x3(-6.6, -1940.7482, 4.7, 4.4, 0.4, 0.9, 1.6, -1.3, 829.168, 3.5, -8.5, 7.9));
     case 2:
     (uvec3(25532u, 199488u, 193646u) + subgroup_id);
     default:
     1;
    }
  }
 uint subgroup_size = gl_SubgroupSize;
 if(_GLF_DEAD(false))
  {
   for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > (1 ^ 1)); _injected_loop_counter --)
    {
     switch(_GLF_SWITCH(0))
      {
       case 0:
       case 42:
       case 94:
       if(_GLF_DEAD(false))
        {
         switch(_GLF_SWITCH(0))
          {
           case 95:
           (bvec4(true, false, true, true) , bvec4(false, true, false, true));
           case 0:
           case 15:
           case 7:
           case 48:
           case 72:
           if(_GLF_DEAD(false))
            barrier();
           case 14:
           case 76:
           case 88:
           case 38:
           return;
           break;
           default:
           1;
          }
        }
       break;
       case 82:
       -6.1;
       case 90:
       (mat3(-2682.3434, 4.2, -95.07, -4923.9394, 9694.6635, -638.573, -2933.6280, -6.1, 391.829) + mat3(238.817, -3.1, 9.2, -7824.6217, -8.6, 330.564, -15.73, -0.2, -744.003));
       default:
       1;
      }
    }
   return;
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     do
      {
       switch(_GLF_SWITCH(int(_GLF_ZERO(_GLF_IDENTITY(0.0, (0.0) / 1.0), injectionSwitch.x))))
        {
         case 0:
         case 49:
         case 17:
         case 69:
         case 90:
         case 68:
         case 39:
         case 20:
         case 62:
         case 42:
         if(_GLF_DEAD(false))
          {
           switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
            {
             case 19:
             mat2x3(76.64, 72.06, -74.82, -0.6, -2.2, -9.9);
             case 76:
             uvec4(25679u, 60050u, 77569u, 63181u);
             case 0:
             case 72:
             if(_GLF_DEAD(false))
              return;
             case 83:
             case 37:
             case 65:
             barrier();
             break;
             case 29:
             mat4x3 _GLF_SWITCH_3_0v;
             default:
             1;
            }
          }
         break;
         case 59:
         mat2x3(vec3(-836.664, 8.7, -22.51), refract(vec3(8274.2810, 911.597, 4.0), vec3(8.8, -2265.0292, -41.88), 70.86));
         case 91:
         ivec4 _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v[24], _GLF_SWITCH_2_2v;
         default:
         1;
        }
      }
     while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) && true)));
     barrier();
    }
   else
    {
     if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, false || (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, clamp(_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)), injectionSwitch, _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED(-1.4), _GLF_FUZZED(-1.1)), bvec2(false, false))), min(_GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED(-1.4), _GLF_FUZZED(-1.1)), bvec2(false, false))), _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED(-1.4), _GLF_FUZZED(-1.1)), bvec2(false, false))), vec2(vec4(_GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED(-1.4), _GLF_FUZZED(-1.1)), bvec2(false, false))), 0.0, 1.0))))))).y) && true)))), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) && ((_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, false || (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, _GLF_IDENTITY((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, clamp(_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)), injectionSwitch, _GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED(-1.4), _GLF_FUZZED(-1.1)), bvec2(false, false))))).y), ! (_GLF_IDENTITY(! ((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, clamp(_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)), injectionSwitch, _GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED(-1.4), _GLF_FUZZED(-1.1)), bvec2(false, false))))).y)), bool(bvec2(! ((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, clamp(_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)), injectionSwitch, _GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED(-1.4), _GLF_FUZZED(-1.1)), bvec2(false, false))))).y)), true))))) && true)))))))))
      {
       switch(_GLF_SWITCH(0))
        {
         case 0:
         case 50:
         case 89:
         case 83:
         case 23:
         switch(_GLF_IDENTITY(_GLF_SWITCH(0), 0 | (_GLF_IDENTITY(_GLF_SWITCH(0), ~ (~ (_GLF_SWITCH(0)))))))
          {
           case 0:
           case 8:
           case 72:
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || false)) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))
            barrier();
           if(_GLF_DEAD(false))
            return;
           case 47:
           case 20:
           barrier();
           break;
           case 98:
           {
            for(bvec2 _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v[63], _GLF_SWITCH_2_2v; true; true)
             {
              vec3 _GLF_SWITCH_2_3v, _GLF_SWITCH_2_4v, _GLF_SWITCH_2_5v;
             }
            if(true)
             {
              mat3(-73.08, 8.9, 5.3, 5.5, 96.82, 8.8, 7.3, -5.1, -2997.7904);
              ivec2(17, 73805);
              bvec2(false, false);
              bvec3(true, true, false);
              mat4 _GLF_SWITCH_2_6v, _GLF_SWITCH_2_7v;
              uvec3 _GLF_SWITCH_2_8v;
              bvec3((15452 == 41766));
              bvec3(true, false, true);
              mat3x2 _GLF_SWITCH_2_9v[5], _GLF_SWITCH_2_10v, _GLF_SWITCH_2_11v;
             }
            else
             {
             }
            ;
            uvec2(102031u, 158524u);
            (mat3x4(0.6, 404.735, 1.1, -2310.3648, _GLF_IDENTITY(-6833.7640, max(-6833.7640, -6833.7640)), -8.8, 8.7, 34.03, 2.0, 4.4, 69.75, -41.40) * mat4x3(32.27, -91.02, -259.266, 1.4, 0.9, -765.871, _GLF_IDENTITY(-28.86, min(-28.86, _GLF_IDENTITY(-28.86, min(-28.86, -28.86)))), -3.8, -4.4, -65.25, -3.8, 6.0));
            bool _GLF_SWITCH_2_12v, _GLF_SWITCH_2_13v, _GLF_SWITCH_2_14v[63];
            for(            (uvec3(subgroup_size, uvec2(104362u, 63392u)) | uvec3(84844u, 46329u, 181903u));
 any(bvec2(true, false)); matrixCompMult(mat3x2(_GLF_IDENTITY(-86.73, (-86.73) / 1.0), 51.27, 33.00, 29.59, 3.6, -1.3), ((mat3x2(723.949, 6274.0043, 1.1, 4628.5470, -2.2, 2225.3334) + -894.161))))
             {
              mat2x3 _GLF_SWITCH_2_15v[86];
              cosh(381.762);
             }
           }
           default:
           1;
          }
         break;
         case 33:
         while(bool(-30182))
          {
           while((ivec2(-21886, -11073) != ivec2(46401, 28607)))
            {
             mat2 _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v;
             -92335;
             mat4(-949.647, -7.5, 9798.3803, 3.0, -9.6, -133.086, -79.79, -299.510, -6736.3207, -4.1, -8.6, 734.469, -6.7, 530.964, -375.586, 24.54);
             transpose(mat4(mat2x3(-7.0, 8.2, 148.206, -7841.7146, 2.6, 8.6)));
             bvec2 _GLF_SWITCH_3_2v[82];
             (ivec4(-76509, -44113, -19424, -22845) * ivec4(-94770, -76790, 569, -97826));
            }
           ivec3 _GLF_SWITCH_3_3v, _GLF_SWITCH_3_4v, _GLF_SWITCH_3_5v[30];
           (_GLF_SWITCH_3_4v[0] - ivec2(74270, -21892));
           if(true)
            {
             uvec4(38632u, 106937u, 138594u, 91496u);
             (- mat3x2(-86.36, -3.9, -90.99, 50.88, -83.43, -4801.9803));
             notEqual(vec4(36.32, 3386.0437, injectionSwitch), vec4(570.419, 6949.8109, 6.8, 194.185));
             _GLF_SWITCH_3_4v;
             vec2 _GLF_SWITCH_3_6v, _GLF_SWITCH_3_7v[47];
             vec3(uintBitsToFloat(uvec4(161768u, 181396u, 188303u, 14538u)));
             ;
             ivec2 _GLF_SWITCH_3_8v[6], _GLF_SWITCH_3_9v;
             vec2 _GLF_SWITCH_3_10v, _GLF_SWITCH_3_11v[79], _GLF_SWITCH_3_12v;
            }
           {
            ;
            (ivec3(-83008, 63759, -92811) == ivec3(56685, 13397, -39005));
            mat4x2(279.338, -10.43, 2.2, 7741.5471, 2555.3601, 6509.4658, 78.06, -4254.4835);
            refract(vec3(61.71, 370.106, -4481.7953), mod(vec3(6.3, 73.76, 9501.2113), 1.7), sign(refract(-4587.3953, -1018.4216, -68.62)));
            uvec4 _GLF_SWITCH_3_13v, _GLF_SWITCH_3_14v[26], _GLF_SWITCH_3_15v;
            int _GLF_SWITCH_3_16v[97], _GLF_SWITCH_3_17v;
            ;
            ivec2(-53403, -57420);
           }
          }
         case 6:
         vec4 _GLF_SWITCH_3_18v;
         default:
         1;
        }
      }
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
    }
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, true && (false)), (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     switch(_GLF_SWITCH((0 | 0)))
      {
       case 28:
       (176.192 , ivec4(-67771, -1751, -95530, -82064));
       case 0:
       case 63:
       case 93:
       if(_GLF_DEAD(false))
        barrier();
       case 99:
       case 89:
       case 3:
       case 46:
       if(_GLF_DEAD(false))
        return;
       break;
       default:
       1;
      }
    }
   else
    {
    }
  }
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = gl_NumWorkGroups.x;
 if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, ! (! (injectionSwitch.x > injectionSwitch.y)))), _GLF_IDENTITY(false || ((_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, (false ? _GLF_FUZZED(injectionSwitch) : _GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)))), vec2(mat2x4(_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, (false ? _GLF_FUZZED(injectionSwitch) : _GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)))), vec2(vec2(_GLF_IDENTITY(injectionSwitch, (false ? _GLF_FUZZED(injectionSwitch) : _GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch))))))), 1.0, 1.0, 0.0, exp(0.0), 1.0, log(1.0)))).x > injectionSwitch.y)), _GLF_IDENTITY(! (_GLF_IDENTITY(! (false || ((injectionSwitch.x > injectionSwitch.y))), bool(bool(! (false || ((injectionSwitch.x > injectionSwitch.y))))))), ! (! (_GLF_IDENTITY(! (_GLF_IDENTITY(! (false || ((injectionSwitch.x > injectionSwitch.y))), bool(bool(! (false || ((injectionSwitch.x > injectionSwitch.y))))))), (! (_GLF_IDENTITY(! (false || ((_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.x, clamp(injectionSwitch.x, injectionSwitch.x, _GLF_IDENTITY(injectionSwitch.x, clamp(injectionSwitch.x, _GLF_IDENTITY(injectionSwitch.x, 1.0 * (injectionSwitch.x)), injectionSwitch.x)))), float(vec4(_GLF_IDENTITY(injectionSwitch.x, float(mat4x3(injectionSwitch.x, _GLF_IDENTITY(0.0, max(_GLF_IDENTITY(0.0, min(0.0, 0.0)), 0.0)), 0.0, 1.0, _GLF_IDENTITY(0.0, max(0.0, _GLF_IDENTITY(0.0, min(0.0, 0.0)))), 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0))), 0.0, 1.0, 1.0))) > injectionSwitch.y))), _GLF_IDENTITY(bool(bool(! (false || ((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(mat2(1.0) * (injectionSwitch), mix(vec2((mat2(1.0) * (injectionSwitch))[0], _GLF_FUZZED(73.76)), vec2(_GLF_FUZZED(vec3(-4.2, 6.9, -41.83).t), (mat2(1.0) * (injectionSwitch))[1]), bvec2(false, true)))).y))))), bool(bool(bool(bool(! (false || ((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(mat2(1.0) * (injectionSwitch), mix(vec2((mat2(1.0) * (injectionSwitch))[0], _GLF_FUZZED(73.76)), vec2(_GLF_FUZZED(vec3(-4.2, 6.9, -41.83).t), (mat2(1.0) * (injectionSwitch))[1]), bvec2(false, true)))).y))))))))))) || false)))))))))
  {
   if(_GLF_DEAD(false))
    {
     do
      {
       switch(_GLF_SWITCH(0))
        {
         case 18:
         bool _GLF_SWITCH_2_0v[29], _GLF_SWITCH_2_1v[68];
         case 0:
         case 81:
         return;
         break;
         case 30:
         mat3x2(mat3x4(-7.7, 8057.1718, 3226.8387, -456.387, -6.5, -390.053, 0.7, 475.166, -3.8, -8.7, -8.3, 9.0));
         case 20:
         -546.540;
         default:
         1;
        }
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
   return;
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    barrier();
   return;
  }
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   switch(_GLF_SWITCH(int(_GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), clamp(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x))))))
    {
     case 86:
     if(bvec2(bvec4(false, true, false, true)).r)
      {
       vec2(8.1, -89.89);
       {
        ;
       }
       mat3x4 _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v[51], _GLF_SWITCH_2_2v;
       for(       mat4x2(-78.59, 69.62, -5737.5798, -3.2, -5.7, _GLF_IDENTITY(-4.1, float(float(-4.1))), -9327.3160, _GLF_IDENTITY(2.1, max(2.1, 2.1)));
 bvec4(false, true, false, true).g; mat3(mat2(-0.3, 7505.4902, -3407.7226, 381.442)))
        {
         ;
         for(mat2x4 _GLF_SWITCH_2_3v, _GLF_SWITCH_2_4v[14], _GLF_SWITCH_2_5v; false; ivec4(-98385, 38452, -718, 78837))
          {
           mat2x3 _GLF_SWITCH_2_6v[38];
          }
         mat4x3(-3.3, 8.1, -391.450, -259.157, -18.27, -64.93, 77.81, 6218.1566, -3.7, _GLF_IDENTITY(-1781.7279, float(_GLF_IDENTITY(mat2(-1781.7279, abs(1.0), 1.0, 0.0), (_GLF_IDENTITY(mat2(-1781.7279, abs(1.0), 1.0, 0.0), (true ? mat2(-1781.7279, abs(1.0), 1.0, 0.0) : _GLF_FUZZED(mat2(-155.418, -67.32, -600.252, -6.4))))) + mat2(0.0, 0.0, 0.0, 0.0)))), 9.0, -1.8);
         notEqual(sign((-45811 * _GLF_IDENTITY(ivec2(-23128, 27670), clamp(ivec2(-23128, 27670), _GLF_IDENTITY(ivec2(-23128, 27670), ivec2(ivec4(_GLF_IDENTITY(ivec2(-23128, 27670), ~ (~ (ivec2(-23128, 27670)))), 0, 0))), ivec2(-23128, 27670))))), (bitfieldExtract(-14329, 83373, 20004) - ivec2(-58100, -2956)));
         if(_GLF_IDENTITY((bvec3(false, true, _GLF_IDENTITY(true, true && (_GLF_IDENTITY(true, false || (_GLF_IDENTITY(true, false || (true))))))) == bvec3(true, false, true)), true && ((bvec3(false, true, _GLF_IDENTITY(true, true && (_GLF_IDENTITY(true, false || (_GLF_IDENTITY(true, false || (true))))))) == bvec3(true, false, true)))))
          {
          }
        }
       ;
       (_GLF_IDENTITY(clamp(uvec4(113626u, 89364u, 176436u, 102569u), uvec4(14278u, 23878u, 174004u, 122466u), uvec4(45351u, 95856u, 81991u, 193123u)) + uvec4(96850u, 88063u, 113989u, 126697u), (false ? _GLF_FUZZED(uvec4(198041u, 165179u, 65299u, 177433u)) : clamp(_GLF_IDENTITY(uvec4(113626u, 89364u, 176436u, 102569u), (uvec4(113626u, 89364u, 176436u, 102569u)) >> uvec4(0u, 0u, 0u, 0u)), uvec4(14278u, 23878u, 174004u, 122466u), uvec4(45351u, 95856u, 81991u, 193123u)) + uvec4(96850u, 88063u, 113989u, 126697u))));
      }
     case 94:
     ;
     case 0:
     if(_GLF_DEAD(false))
      return;
     case 61:
     case 37:
     case 76:
     case 92:
     barrier();
     case 68:
     case 36:
     case 75:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     break;
     default:
     1;
    }
  }
 uint workgroup_size = gl_WorkGroupSize.x;
 if(_GLF_DEAD(false))
  {
   switch(_GLF_SWITCH(0))
    {
     case 34:
     if(((92589 >= -59468)))
      {
       {
        do
         {
          int _GLF_SWITCH_2_0v;
          (5264.9140 / vec3(vec2(8.9, 6.4), 0.8));
          mat3x2(2465.6601, 456.370, 159.266, -599.535, 5591.8340, -8.9);
          int(-7.1);
          isinf(vec3(2861.6671, -3818.4722, -1.3));
          greaterThan((ivec3(-67583, -45603, -3160) % ivec3(-37686, 43852, -56116)), ivec3(-42886, 21122, 7461));
          bvec4(false, true, true, false);
         }
        while(false);
        vec3 _GLF_SWITCH_2_1v[78], _GLF_SWITCH_2_2v;
        ;
        ivec3 _GLF_SWITCH_2_3v;
        if((subgroup_local_id != num_workgroup))
         {
          bool _GLF_SWITCH_2_4v, _GLF_SWITCH_2_5v;
          smoothstep(vec2(-497.395, -3.5), vec2(-33.35, -2.6), injectionSwitch);
          mat3x2 _GLF_SWITCH_2_6v, _GLF_SWITCH_2_7v, _GLF_SWITCH_2_8v;
          ivec4 _GLF_SWITCH_2_9v[84];
          uint _GLF_SWITCH_2_10v[78], _GLF_SWITCH_2_11v;
         }
        else
         {
          (+ mat4x2(682.163, -955.400, 13.92, 9.5, -8211.7282, 2.6, 9.4, 2511.4023));
          bvec3 _GLF_SWITCH_2_12v, _GLF_SWITCH_2_13v[11], _GLF_SWITCH_2_14v;
         }
        (_GLF_SWITCH_2_3v % 18708);
        while((0.6 > 4.6))
         {
          switch(_GLF_SWITCH(0))
           {
            case 0:
            ivec2(-46439, -7375).ssss;
            mat4x2 _GLF_SWITCH_2_15v, _GLF_SWITCH_2_16v;
            max(-70895, -35450);
            case 33:
            uvec4(161399u, 24554u, 112238u, 48480u);
            injectionSwitch;
            bvec3 _GLF_SWITCH_2_17v, _GLF_SWITCH_2_18v;
            ivec4 _GLF_SWITCH_2_19v, _GLF_SWITCH_2_20v[90], _GLF_SWITCH_2_21v;
            break;
            case 66:
            bvec2 _GLF_SWITCH_3_0v;
            case 94:
            float _GLF_SWITCH_3_1v[21];
            default:
            1;
           }
         }
        mat2(1327.9837);
        mat2x4 _GLF_SWITCH_2_22v, _GLF_SWITCH_2_23v, _GLF_SWITCH_2_24v[85];
       }
       clamp((uvec2(83153u, 87143u) >> num_workgroup), (uvec2(135182u, 197729u) ^ uvec2(172685u, 36934u)), (uvec2(147565u, 7656u) % 93333u));
       98683;
       mat3 _GLF_SWITCH_2_25v[39], _GLF_SWITCH_2_26v;
      }
     case 0:
     case 42:
     case 86:
     case 51:
     case 76:
     do
      {
       if(_GLF_DEAD(false))
        return;
      }
     while(_GLF_WRAPPED_LOOP(false));
     case 43:
     case 74:
     case 63:
     case 11:
     return;
     break;
     case 22:
     if(false)
      {
       for(mat3 _GLF_SWITCH_2_27v; true; mat3x4(mat4x3(-6099.2756, 25.73, -5608.4111, -6.1, -980.517, 5.9, -39.85, -5144.7196, _GLF_IDENTITY(1.3, min(_GLF_IDENTITY(1.3, max(1.3, 1.3)), 1.3)), -9984.1999, -0.0, -865.744)))
        {
         if(_GLF_IDENTITY((_GLF_IDENTITY(-77528 >= 37207, _GLF_IDENTITY(bool(bvec4(_GLF_IDENTITY(-77528 >= 37207, true && (-77528 >= 37207)), false, true, false)), (bool(bvec4(_GLF_IDENTITY(-77528 >= 37207, true && (-77528 >= 37207)), false, true, false))) && true))), ! (_GLF_IDENTITY(! ((_GLF_IDENTITY(-77528 >= 37207, _GLF_IDENTITY(bool(bvec4(_GLF_IDENTITY(-77528 >= 37207, true && (-77528 >= 37207)), false, true, false)), (bool(bvec4(_GLF_IDENTITY(-77528 >= 37207, true && (-77528 >= 37207)), false, true, false))) && true)))), bool(bvec3(_GLF_IDENTITY(! ((_GLF_IDENTITY(-77528 >= 37207, _GLF_IDENTITY(bool(bvec4(_GLF_IDENTITY(-77528 >= 37207, true && (-77528 >= 37207)), false, true, false)), (bool(bvec4(_GLF_IDENTITY(-77528 >= 37207, true && (-77528 >= 37207)), false, true, false))) && true)))), ! (! (! ((_GLF_IDENTITY(-77528 >= 37207, _GLF_IDENTITY(bool(bvec4(_GLF_IDENTITY(-77528 >= 37207, true && (-77528 >= 37207)), false, true, false)), (bool(bvec4(_GLF_IDENTITY(-77528 >= 37207, true && (-77528 >= 37207)), false, true, false))) && true))))))), true, false))))))
          {
           switch(_GLF_SWITCH((0 | 0)))
            {
             case 31:
             mat4x3(-3.5, -9.0, -593.438, -8.6, -136.350, -705.896, -0.8, -9.1, 1022.5183, 8.6, 704.764, 1924.8475);
             case 71:
             uvec2 _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v;
             case 0:
             case 79:
             ;
             float _GLF_SWITCH_2_28v, _GLF_SWITCH_2_29v;
             mat2x3(245.324, -7.3, 6.7, 1.9, 3.0, 9.0);
             case 39:
             case 61:
             case 42:
             case 98:
             case 22:
             mat3x4 _GLF_SWITCH_2_30v[19];
             case 68:
             mat4x2(vec2(4396.0827, -6.1), injectionSwitch, vec2(-127.967, _GLF_IDENTITY(696.400, 1.0 * (696.400))), injectionSwitch);
             break;
             default:
             1;
            }
          }
         vec2 _GLF_SWITCH_2_31v, _GLF_SWITCH_2_32v;
         ;
         bvec4 _GLF_SWITCH_2_33v, _GLF_SWITCH_2_34v[58], _GLF_SWITCH_2_35v[16];
        }
       mat3x4(86.73, 0.6, -64.85, -83.73, 9.9, 5.4, 454.936, -8491.8261, 982.667, 8957.9436, -217.332, 7581.2431);
       uvec3 _GLF_SWITCH_2_36v, _GLF_SWITCH_2_37v, _GLF_SWITCH_2_38v;
       (ivec4(66813, -21854, -61585, -68453) + 86940);
      }
     else
      {
       vec4(-21.45, 1.7, 2.3, 2.0);
       for(       greaterThan(injectionSwitch, _GLF_IDENTITY(vec2(-192.594, 99.02), (vec2(-192.594, 99.02)) - vec2(0.0, 0.0)));
 (uvec2(12655u, 153788u) != uvec2(106863u, 167892u)); ivec4(17771, -73184, 68281, 84041))
        {
         {
          ;
          ivec3 _GLF_SWITCH_2_39v;
          tanh(vec2(-92.98, -96.69));
          bvec3 _GLF_SWITCH_2_40v;
          bvec3 _GLF_SWITCH_2_41v, _GLF_SWITCH_2_42v, _GLF_SWITCH_2_43v;
          uvec2(76611u, 136365u).s;
         }
         for(         mat4x2((7.4 + mat3(2127.0588, _GLF_IDENTITY(-581.388, float(mat2x3(_GLF_IDENTITY(-581.388, (true ? -581.388 : _GLF_FUZZED(-9.2))), sin(0.0), determinant(mat3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, determinant(mat2(0.0, 1.0, 0.0, 0.0)))), 1.0, 1.0, 1.0))), 2963.1772, -0.3, -7.1, 971.954, 71.20, 747.621, 5.0)));
 true; 692.249)
          {
          }
        }
       vec3 _GLF_SWITCH_2_44v;
       mat2x3(6.5, -3.6, 1486.7912, -1.4, 0.0, _GLF_IDENTITY(-6.9, clamp(-6.9, -6.9, _GLF_IDENTITY(-6.9, max(_GLF_IDENTITY(-6.9, max(-6.9, -6.9)), -6.9)))));
       bvec4 _GLF_SWITCH_2_45v;
       uvec2 _GLF_SWITCH_2_46v;
      }
     case 69:
     while((mat4(6394.0039, 8.0, -5.3, -5499.8334, -319.126, -32.94, -8.5, 3.8, 29.93, -8.6, _GLF_IDENTITY(-109.080, (true ? -109.080 : _GLF_FUZZED(21.83))), 7.9, -38.01, 7638.3209, -8.1, 9208.1152) != mat4(_GLF_IDENTITY(-9.6, max(-9.6, -9.6)), 895.843, -1273.0757, 2.4, -1.1, 7732.3612, 9778.2879, 708.865, -6911.7802, 1.8, 437.455, 2.0, -24.35, 428.264, -6591.7778, 0.9)))
      {
      }
     default:
     1;
    }
  }
 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec4(false, false, false, true)), true && (bool(bvec4(false, false, false, true)))))), (! (_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec4(false, false, false, true)), true && (bool(bvec4(false, false, false, true))))))) && true)))))
  return;
 uint workgroup_id = gl_WorkGroupID.x;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, (false ? _GLF_FUZZED(vec2(-657.772, -67.36)) : injectionSwitch)).y))))
  return;
 uint workgroup_base = workgroup_size * workgroup_id;
 if(_GLF_IDENTITY(_GLF_DEAD(false), false || (_GLF_DEAD(false))))
  {
   if(_GLF_DEAD(false))
    barrier();
   barrier();
  }
 uint virtual_gid = workgroup_base + subgroup_id * subgroup_size + subgroup_local_id;
 uint next_virtual_gid = workgroup_base + subgroup_id * subgroup_size + (_GLF_IDENTITY((subgroup_local_id + 1) % subgroup_size, (_GLF_IDENTITY((subgroup_local_id + 1) % subgroup_size, (false ? _GLF_FUZZED(atomicMin(num_workgroup, virtual_gid)) : (subgroup_local_id + 1) % subgroup_size))) ^ 0u));
 if(_GLF_DEAD(false))
  barrier();
 atomicStore(buf[next_virtual_gid], uint(1), _GLF_IDENTITY(4, 1 * (_GLF_IDENTITY(4, _GLF_IDENTITY((4), ((4)) | ((4))) << _GLF_IDENTITY(0, 0 | (0))))), 64, 4);
 if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec2(false, false)), ! (! (bool(bvec2(false, false))))))))
  return;
 uint read = atomicLoad(buf[virtual_gid], 4, 64, 0);
 if(_GLF_DEAD(false))
  barrier();
 if(subgroup_local_id + 1 < subgroup_size)
  {
   switch(_GLF_SWITCH(0))
    {
     case 71:
     for(     (vec3(-1.1, 6.3, _GLF_IDENTITY(2.4, (2.4) - 0.0)) + tan(-7999.4750));
 true; _GLF_IDENTITY(mat4(760.463, _GLF_IDENTITY(-7712.3959, mix(float(_GLF_IDENTITY(-7712.3959, _GLF_IDENTITY((false ? _GLF_FUZZED(-9.0) : -7712.3959), ((false ? _GLF_FUZZED(-9.0) : -7712.3959)) - 0.0))), float(_GLF_FUZZED((-634.275))), bool(false))), 240.886, _GLF_IDENTITY(-92.38, min(-92.38, -92.38)), -7455.8983, -34.73, _GLF_IDENTITY(7.2, (7.2) * 1.0), -1.5, 657.838, _GLF_IDENTITY(765.218, clamp(765.218, 765.218, 765.218)), 69.68, -8.6, -801.293, -11.17, -8015.2112, 5568.5573), (mat4(760.463, _GLF_IDENTITY(-7712.3959, mix(float(_GLF_IDENTITY(-7712.3959, (false ? _GLF_FUZZED(-9.0) : -7712.3959))), float(_GLF_FUZZED((-634.275))), bool(false))), 240.886, _GLF_IDENTITY(-92.38, min(-92.38, -92.38)), -7455.8983, -34.73, 7.2, -1.5, 657.838, _GLF_IDENTITY(765.218, clamp(765.218, 765.218, 765.218)), 69.68, -8.6, -801.293, -11.17, -8015.2112, 5568.5573)) / _GLF_IDENTITY(mat4(1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0), (mat4(1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0)) + mat4(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0))))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          continue;
         for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), (_GLF_IDENTITY(int(2), (int(2)) | 0)) * 1))) >> _GLF_IDENTITY(int(2), int(2))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
          {
           barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            break;
          }
        }
       if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
        {
         if(_GLF_DEAD(false))
          break;
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            break;
           barrier();
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, clamp(injectionSwitch.x, injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y))))
              barrier();
             return;
            }
           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
            barrier();
          }
        }
       else
        {
         if(_GLF_DEAD(false))
          barrier();
         _GLF_IDENTITY(_GLF_IDENTITY(-6.0, clamp(-6.0, _GLF_IDENTITY(-6.0, mix(float(_GLF_FUZZED(-48.49)), float(-6.0), bool(true))), _GLF_IDENTITY(-6.0, (-6.0) - 0.0))), _GLF_IDENTITY(float(vec3(-6.0, _GLF_ONE(_GLF_IDENTITY(1.0, sqrt(1.0) * (1.0)), injectionSwitch.y), 0.0)), (float(vec3(-6.0, _GLF_ONE(1.0, _GLF_IDENTITY(injectionSwitch, max(injectionSwitch, injectionSwitch)).y), 0.0))) / 1.0));
        }
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, float(_GLF_IDENTITY(float(_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) / 1.0), max(injectionSwitch.x, injectionSwitch.x))), max(float(_GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, injectionSwitch.x))), _GLF_IDENTITY(float(_GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, injectionSwitch.x))), (float(_GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, injectionSwitch.x)))) - _GLF_ZERO(0.0, injectionSwitch.x)))))) > injectionSwitch.y))))
        continue;
       float _GLF_SWITCH_0_0v;
       bool _GLF_SWITCH_0_1v[34];
       if(_GLF_IDENTITY((ivec3(-99798, -97927, 69687).tss == ivec3(23940, 7875, 24282)), ((ivec3(-99798, -97927, 69687).tss == ivec3(23940, 7875, 24282))) || false))
        {
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY(_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ! (_GLF_IDENTITY(! ((injectionSwitch.x > injectionSwitch.y)), bool(bvec3(! ((injectionSwitch.x > injectionSwitch.y)), true, false))))), _GLF_IDENTITY(bool(bvec2(_GLF_IDENTITY((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(1109.0300), (injectionSwitch)[1]), vec2((injectionSwitch)[0], _GLF_FUZZED(float(-6493))), bvec2(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), false))).y), ! (! ((injectionSwitch.x > injectionSwitch.y)))), true)), bool(bool(bool(bvec2(_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ! (! ((injectionSwitch.x > injectionSwitch.y)))), _GLF_IDENTITY(true, ! (! (_GLF_IDENTITY(true, ! (! (true)))))))))))))))
          continue;
         if(_GLF_DEAD(false))
          barrier();
         (bvec2(true, false));
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
            break;
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             barrier();
            }
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         if(_GLF_DEAD(false))
          {
           switch(_GLF_SWITCH(0))
            {
             case 21:
             ivec4 _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v;
             case 0:
             case 39:
             case 5:
             case 54:
             case 86:
             case 77:
             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y))))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               return;
              }
             case 44:
             case 91:
             case 84:
             case 12:
             continue;
             break;
             case 7:
             (vec3(-23.22, -0.2, 2.6) + _GLF_SWITCH_0_0v);
             case 68:
             (ivec3(-54610, _GLF_IDENTITY(-54007, 0 + (_GLF_IDENTITY(-54007, max(-54007, -54007)))), 6176) - -59085);
             default:
             1;
            }
          }
         20318;
        }
       else
        {
         ivec4 _GLF_SWITCH_0_2v, _GLF_SWITCH_0_3v, _GLF_SWITCH_0_4v;
         if(_GLF_DEAD(false))
          {
           do
            {
             return;
            }
           while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, (injectionSwitch) * mat2(1.0)).x > _GLF_IDENTITY(injectionSwitch.y, 1.0 * (_GLF_IDENTITY(injectionSwitch.y, max(_GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y)), injectionSwitch.y)))))), bool(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))));
          }
         if(_GLF_DEAD(false))
          barrier();
         (80992 | _GLF_SWITCH_0_4v);
         if(_GLF_DEAD(false))
          return;
        }
       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), _GLF_IDENTITY(bool(bvec2(! (false), false)), ! (! (bool(bvec2(! (false), false))))))))))
        continue;
       if(_GLF_DEAD(false))
        barrier();
       mat3x2(805.029, -50.13, -12.59, 3.0, -65.29, -4.9);
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false || (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
          {
          }
         else
          {
           barrier();
          }
        }
       do
        {
         switch(_GLF_SWITCH(_GLF_IDENTITY(0, ~ (_GLF_IDENTITY(~ (0), (false ? _GLF_FUZZED(-69472) : ~ (0)))))))
          {
           case 97:
           ;
           case 0:
           case 22:
           case 8:
           case 37:
           case 94:
           case 87:
           case 75:
           case 36:
           if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((_GLF_IDENTITY(injectionSwitch, min(_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])), injectionSwitch)).x > _GLF_IDENTITY(injectionSwitch, max(injectionSwitch, injectionSwitch)).y), ! (_GLF_IDENTITY(! ((_GLF_IDENTITY(injectionSwitch, min(_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])), injectionSwitch)).x > _GLF_IDENTITY(injectionSwitch, max(injectionSwitch, injectionSwitch)).y)), (! ((_GLF_IDENTITY(injectionSwitch, min(_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])), injectionSwitch)).x > _GLF_IDENTITY(injectionSwitch, max(injectionSwitch, injectionSwitch)).y))) && true))))))
            return;
           break;
           case 4:
           uvec3(73274u, 63098u, 176656u);
           default:
           1;
          }
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           switch(_GLF_SWITCH(0))
            {
             case 82:
             uvec3 _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v[78], _GLF_SWITCH_2_2v;
             case 0:
             case 43:
             case 61:
             case 10:
             if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))
              barrier();
             case 44:
             case 12:
             case 28:
             case 14:
             return;
             break;
             case 63:
             mat3x2(98.00, 6617.6994, -4591.1446, 1.5, -749.901, 5.7);
             case 37:
             float _GLF_SWITCH_2_3v;
             default:
             1;
            }
          }
         else
          {
          }
        }
       if(_GLF_DEAD(false))
        barrier();
       {
        mat2x4 _GLF_SWITCH_0_5v;
        if(_GLF_DEAD(false))
         barrier();
        for(bool _GLF_SWITCH_0_6v, _GLF_SWITCH_0_7v; _GLF_SWITCH_0_6v; mat2x4(8863.9827, 4.1, 0.6, _GLF_IDENTITY(96.07, min(96.07, _GLF_IDENTITY(96.07, max(_GLF_IDENTITY(96.07, max(96.07, 96.07)), 96.07)))), -163.393, -5.9, 7843.4232, 5675.8484))
         {
          switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
           {
            case 0:
            case 37:
            case 50:
            case 8:
            bvec2 _GLF_SWITCH_0_8v[42], _GLF_SWITCH_0_9v;
            break;
            case 86:
            bvec2 _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v, _GLF_SWITCH_2_2v[71];
            default:
            1;
           }
         }
        if(_GLF_DEAD(false))
         barrier();
        {
         if(_GLF_DEAD(false))
          return;
         if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))
          break;
         atomicMax(subgroup_size, atomicAnd(subgroup_id, num_workgroup));
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           continue;
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
          }
         else
          {
           switch(_GLF_SWITCH((0 >> _GLF_IDENTITY(int(7), _GLF_IDENTITY(int(7), (_GLF_IDENTITY(int(7), min(int(7), int(7)))) * _GLF_IDENTITY(1, 0 ^ (1)))))))
            {
             case 52:
             -99883;
             case 4:
             uint _GLF_SWITCH_2_0v[16];
             case 0:
             case 44:
             case 53:
             case 62:
             case 36:
             case 26:
             case 78:
             if(_GLF_DEAD(false))
              return;
             break;
             case 39:
             mat3x4(-6.4, 38.74, -8.4, -9.3, 902.669, 9.4, 642.741, 0.8, -782.824, 1431.0777, -4.1, -27.44);
             case 66:
             exp2(injectionSwitch);
             default:
             1;
            }
          }
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_DEAD(false))
          barrier();
         mat3 _GLF_SWITCH_0_10v, _GLF_SWITCH_0_11v, _GLF_SWITCH_0_12v;
         for(int _injected_loop_counter = (0 | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _GLF_IDENTITY(_injected_loop_counter ++, (_GLF_IDENTITY(_injected_loop_counter ++, (_injected_loop_counter ++) + 0)) - 0))
          {
           fma(_GLF_IDENTITY(vec4(5.1, 2.0, -7.6, -482.788), clamp(vec4(5.1, 2.0, -7.6, -482.788), vec4(5.1, 2.0, -7.6, -482.788), _GLF_IDENTITY(vec4(5.1, 2.0, -7.6, _GLF_IDENTITY(-482.788, max(-482.788, _GLF_IDENTITY(-482.788, max(-482.788, _GLF_IDENTITY(-482.788, max(-482.788, -482.788))))))), max(vec4(5.1, _GLF_IDENTITY(2.0, min(2.0, 2.0)), -7.6, -482.788), vec4(5.1, 2.0, -7.6, -482.788))))), vec4(-7.4, 5294.9426, _GLF_IDENTITY(-0.1, (-0.1) / 1.0), 4.6), vec4(9890.0510, 7.3, -223.214, 0.5));
          }
         if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(bvec2(false, true)))))
          {
          }
         else
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         isinf(injectionSwitch);
         do
          {
           do
            {
             do
              {
               switch(_GLF_SWITCH(int(_GLF_ZERO(_GLF_IDENTITY(0.0, cos(0.0) * (0.0)), injectionSwitch.x))))
                {
                 case 53:
                 if(_GLF_DEAD(false))
                  barrier();
                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                  {
                   if(_GLF_DEAD(false))
                    return;
                  }
                 if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(_GLF_IDENTITY(bvec3(false, true, false), _GLF_IDENTITY(bvec3(bvec4(_GLF_IDENTITY(bvec3(false, true, false), bvec3(bvec3(bvec3(false, true, false)))), true)), bvec3(bvec3(bvec3(bvec4(_GLF_IDENTITY(bvec3(false, true, false), bvec3(bvec3(bvec3(false, true, false)))), true))))))), ! (! (bool(_GLF_IDENTITY(bvec3(false, true, false), _GLF_IDENTITY(bvec3(bvec4(_GLF_IDENTITY(bvec3(false, true, false), bvec3(bvec3(bvec3(false, true, false)))), true)), bvec3(bvec3(bvec3(bvec4(_GLF_IDENTITY(bvec3(false, true, false), bvec3(bvec3(bvec3(false, true, false)))), true)))))))))))))
                  return;
                 mat2x3 _GLF_SWITCH_1_0v, _GLF_SWITCH_1_1v[53], _GLF_SWITCH_1_2v;
                 if(_GLF_DEAD(false))
                  break;
                 case 96:
                 if(_GLF_DEAD(false))
                  barrier();
                 ;
                 case 0:
                 case 67:
                 mat2x3(-7.7, -6.2, 52.89, 59.05, 4.3, 330.247);
                 if(_GLF_DEAD(false))
                  return;
                 break;
                 if(_GLF_DEAD(false))
                  return;
                 case 85:
                 int _GLF_SWITCH_1_3v;
                 default:
                 for(int _injected_loop_counter = ((int(_GLF_ONE(_GLF_IDENTITY(1.0, (1.0) / 1.0), _GLF_IDENTITY(injectionSwitch, clamp(injectionSwitch, injectionSwitch, injectionSwitch)).y)) << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(_GLF_IDENTITY(int(2), int(2)), _GLF_IDENTITY(int(int(_GLF_IDENTITY(int(2), int(2)))), (int(int(_GLF_IDENTITY(int(2), int(2))))) | 0))); _GLF_WRAPPED_LOOP(_injected_loop_counter != (_GLF_IDENTITY(0, (true ? _GLF_IDENTITY(0, ~ (~ (_GLF_IDENTITY(0, (0) >> 0)))) : _GLF_IDENTITY(_GLF_FUZZED(ivec4(-46553, -54879, 30796, 64380)[0]), ~ (~ (_GLF_FUZZED(ivec4(-46553, -54879, 30796, 64380)[0])))))) >> _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(ivec4(int(6), 0, 0, 0)), (int(ivec4(int(6), 0, 0, 0))) | (int(_GLF_IDENTITY(ivec4(_GLF_IDENTITY(int(6), (_GLF_IDENTITY(int(6), clamp(int(6), _GLF_IDENTITY(int(6), (int(6)) - 0), int(6)))) + 0), 0, 0, 0), max(ivec4(_GLF_IDENTITY(int(6), (_GLF_IDENTITY(int(6), clamp(int(6), _GLF_IDENTITY(int(6), (int(6)) - 0), int(6)))) + 0), 0, 0, 0), _GLF_IDENTITY(ivec4(_GLF_IDENTITY(int(6), (_GLF_IDENTITY(int(6), clamp(int(6), _GLF_IDENTITY(int(6), (int(6)) - 0), int(6)))) + 0), 0, 0, 0), (ivec4(_GLF_IDENTITY(int(6), (_GLF_IDENTITY(int(6), clamp(int(6), _GLF_IDENTITY(int(6), (int(6)) - 0), int(6)))) + 0), 0, 0, 0)) * ivec4(1, 1, 1, 1))))))))))); _injected_loop_counter --)
                  {
                   if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(_GLF_IDENTITY(bool(false), true && (bool(false)))), true && (bool(_GLF_IDENTITY(bool(false), true && (bool(false)))))))))
                    return;
                   1;
                  }
                }
               if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec2(false, false)), (bool(bvec2(false, false))) || false))))
                break;
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
         while(_GLF_WRAPPED_LOOP(false));
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
          return;
         (-- next_virtual_gid);
         if(_GLF_DEAD(false))
          barrier();
         581;
         do
          {
           (- mat3x2(-4714.2486, -8.3, _GLF_IDENTITY(3422.8947, (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) ? 3422.8947 : _GLF_FUZZED(distance(vec3(7.0, 5.7, 6320.9734), vec3(666.738, -2.2, 497.211))))), -41.36, 0.7, 7.7));
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y))));
        }
       }
       if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(_GLF_TRUE(true, (injectionSwitch.x < _GLF_IDENTITY(injectionSwitch.y, mix(float(_GLF_FUZZED(730.756)), float(injectionSwitch.y), bool(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))))), _GLF_IDENTITY(false || (_GLF_IDENTITY(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), true && (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))), ! (! (false || (_GLF_IDENTITY(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), _GLF_IDENTITY(true, true && (true)) && (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))))))))
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
         while(_GLF_IDENTITY(((workgroup_id / uvec2(470u, 187825u)) == uvec2(175534u, 54215u)), ! (! (((workgroup_id / uvec2(470u, 187825u)) == _GLF_IDENTITY(uvec2(175534u, 54215u), min(_GLF_IDENTITY(uvec2(175534u, 54215u), clamp(uvec2(175534u, 54215u), uvec2(175534u, 54215u), uvec2(175534u, 54215u))), uvec2(175534u, 54215u))))))))
          {
           switch(_GLF_SWITCH((0 ^ 0)))
            {
             case 71:
             outerProduct(vec4(-4.9, 93.71, -94.74, 99.88), vec3(-2.0, 5269.2383, -9.8));
             case 42:
             ;
             case 0:
             case 84:
             case 87:
             float _GLF_SWITCH_0_13v, _GLF_SWITCH_0_14v, _GLF_SWITCH_0_15v;
             case 72:
             case 89:
             case 83:
             matrixCompMult(mat3x2(-85.79, 8.0, 1.0, -225.603, -3.5, _GLF_IDENTITY(-55.29, max(_GLF_IDENTITY(-55.29, mix(float(-55.29), float(_GLF_FUZZED(315.691)), bool(false))), -55.29))), (_GLF_SWITCH_0_0v / mat3x2(_GLF_IDENTITY(_GLF_IDENTITY(48.13, mix(float(_GLF_FUZZED(2.0)), float(48.13), bool(true))), (_GLF_IDENTITY(48.13, mix(float(_GLF_FUZZED(2.0)), float(48.13), bool(true)))) * 1.0), -9899.4864, -16.80, -98.90, 39.28, -6425.9287)));
             case 13:
             if(_GLF_DEAD(false))
              continue;
             for(mat4 _GLF_SWITCH_0_16v[93], _GLF_SWITCH_0_17v, _GLF_SWITCH_0_18v; (ivec3(_GLF_IDENTITY(-60400, (-60400) << 0), 60395, 98074) == ivec3(46608, -9521, -64363)); subgroup_local_id)
              {
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).x < injectionSwitch.y))))
                {
                 switch(_GLF_IDENTITY(_GLF_SWITCH(0), (_GLF_SWITCH(0)) | (_GLF_SWITCH(0))))
                  {
                   case 97:
                   (27353u | workgroup_id);
                   if(_GLF_DEAD(false))
                    barrier();
                   case 43:
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     do
                      {
                       return;
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        barrier();
                      }
                     while(_GLF_WRAPPED_LOOP(false));
                    }
                   asinh(_GLF_SWITCH_0_14v);
                   if(_GLF_DEAD(false))
                    barrier();
                   case 0:
                   if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ! (! ((injectionSwitch.x > injectionSwitch.y)))))))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     continue;
                    }
                   case 24:
                   case 87:
                   do
                    {
                     if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && true))
                      {
                       switch(_GLF_SWITCH((0 & (-83847 / 16366))))
                        {
                         case 43:
                         bvec3(true, false, true);
                         case 0:
                         case 41:
                         case 17:
                         case 50:
                         case 6:
                         case 83:
                         case 45:
                         case 37:
                         case 33:
                         if(_GLF_WRAPPED_IF_FALSE(false))
                          {
                          }
                         else
                          {
                           return;
                          }
                         break;
                         default:
                         1;
                        }
                      }
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_IDENTITY(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec4(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), true)))) && true)), true && (_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, ! (! (_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).x > injectionSwitch.y)))) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (! (injectionSwitch.x > injectionSwitch.y)))), ! (! ((_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, ! (! (_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).x > injectionSwitch.y)))) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (! (injectionSwitch.x > injectionSwitch.y))))))))))))
                      break;
                     barrier();
                    }
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_DEAD(false))
                    {
                     do
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        {
                         if(_GLF_DEAD(false))
                          barrier();
                         return;
                        }
                      }
                     while(_GLF_WRAPPED_LOOP(false));
                     barrier();
                    }
                   case 42:
                   do
                    {
                     switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                      {
                       case 18:
                       bvec4(false, false, false, false);
                       case 35:
                       (uvec4(198571u, 171046u, _GLF_IDENTITY(147543u, (147543u) * 1u), 64686u) % uvec4(77515u, 103467u, 126788u, 195584u));
                       case 0:
                       case 51:
                       case 96:
                       case 50:
                       case 91:
                       case 17:
                       case 42:
                       mod(vec4(-9.4, -1041.0417, _GLF_IDENTITY(-8.7, max(-8.7, -8.7)), -70.15), cosh(_GLF_SWITCH_0_0v));
                       break;
                       case 48:
                       ((_GLF_SWITCH_0_14v - mat4x3(-39.33, 91.16, -44.55, -91.24, -431.412, 2.1, -3764.1998, _GLF_IDENTITY(-2.2, (_GLF_IDENTITY(-2.2, _GLF_IDENTITY(float(vec3(-2.2, 0.0, 0.0)), clamp(float(vec3(-2.2, 0.0, 0.0)), float(vec3(-2.2, 0.0, 0.0)), float(vec3(-2.2, 0.0, 0.0)))))) - 0.0), -969.602, -381.976, -66.14, 83.28)));
                       case 71:
                       uvec2(146010u, 43904u);
                       default:
                       1;
                      }
                    }
                   while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) || false)));
                   break;
                   default:
                   1;
                  }
                }
               else
                {
                }
               if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))
                barrier();
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))))
                  continue;
                 continue;
                }
              }
             break;
             case 45:
             (_GLF_SWITCH_0_15v > _GLF_SWITCH_0_13v);
             default:
             1;
            }
          }
        }
       else
        {
         if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, bool(bvec4(false, false, false, false)))) && true), _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), bool(bvec4((injectionSwitch.x > injectionSwitch.y), false, true, false))))))
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(false))
              break;
             do
              {
               switch(_GLF_SWITCH((0 | 0)))
                {
                 case 94:
                 (mat3x2(-46.23, -5619.2685, -7041.4324, -9553.4430, -95.81, -76.98) / _GLF_SWITCH_0_0v);
                 case 21:
                 _GLF_SWITCH_0_0v;
                 case 0:
                 case 79:
                 case 47:
                 case 65:
                 case 34:
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 break;
                 case 14:
                 asin(injectionSwitch);
                 case 76:
                 (uvec4(126808u, 171486u, 146342u, 143019u) & uvec4(129762u, 193339u, 110435u, 155579u));
                 default:
                 1;
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_DEAD(false))
              continue;
            }
           else
            {
             if(_GLF_DEAD(false))
              return;
             switch(_GLF_SWITCH(_GLF_IDENTITY(0, (false ? _GLF_FUZZED(71528) : 0))))
              {
               case 0:
               case 1:
               case 69:
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(false))
                return;
               case 80:
               if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, clamp(injectionSwitch.x, injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y))))
                break;
               case 86:
               if(_GLF_DEAD(false))
                continue;
               case 91:
               do
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                }
               while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (_GLF_IDENTITY(! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), true && (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))), bool(bool(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (_GLF_IDENTITY(! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), true && (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))))))));
               barrier();
               break;
               default:
               for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > _GLF_IDENTITY(0, int(ivec4(0, 0, _GLF_IDENTITY(1, ~ (~ (_GLF_IDENTITY(1, (false ? _GLF_FUZZED(_injected_loop_counter) : 1))))), 0)))); _injected_loop_counter --)
                {
                 switch(_GLF_SWITCH((0 ^ int(_GLF_ZERO(0.0, injectionSwitch.x)))))
                  {
                   case 21:
                   (mat4x2(mat2x3(-7.4, -8.3, -3.7, -9113.9842, 7.7, -836.204)) * mat2x4(-54.07, -609.954, 8565.1923, -734.550, 99.77, -2191.0233, 1104.6224, 6.3));
                   case 92:
                   bvec3(true, true, false);
                   case 0:
                   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      break;
                     if(_GLF_DEAD(false))
                      continue;
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, float(_GLF_IDENTITY(mat2x4(_GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, injectionSwitch.y, injectionSwitch.y)), determinant(mat2(0.0, 0.0, 1.0, 0.0)), 0.0, 0.0, 0.0, 1.0, 0.0, 1.0), mat4(1.0) * (mat2x4(_GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, injectionSwitch.y, injectionSwitch.y)), determinant(mat2(0.0, 0.0, 1.0, 0.0)), 0.0, 0.0, 0.0, 1.0, 0.0, 1.0)))))))))
                      barrier();
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                   break;
                   default:
                   1;
                  }
                }
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 1;
                }
               else
                {
                }
              }
             if(_GLF_DEAD(false))
              break;
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).y), (_GLF_IDENTITY((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).y), (_GLF_IDENTITY((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).y), bool(bvec2((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).y), true)))) || false)) || _GLF_IDENTITY(false, (false) || false)))))
          break;
         if(_GLF_DEAD(false))
          barrier();
        }
      }
     case 35:
     do
      {
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        barrier();
      }
     while(_GLF_WRAPPED_LOOP(false));
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        return;
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
        {
         barrier();
        }
      }
     mat2x4 _GLF_SWITCH_0_19v, _GLF_SWITCH_0_20v[37];
     case 0:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        {
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
          {
           barrier();
          }
        }
      }
     if(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), false || (_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), false || (_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
      {
      }
     else
      {
       if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, vec2(_GLF_IDENTITY(mat4x3(injectionSwitch, 1.0, 1.0, round(length(normalize(1.0))), 1.0, abs(1.0), 0.0, 1.0, 1.0, 1.0, tan(0.0)), transpose(transpose(mat4x3(injectionSwitch, 1.0, 1.0, round(length(normalize(1.0))), 1.0, abs(1.0), 0.0, 1.0, 1.0, 1.0, tan(0.0))))))).y), ! (! (_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), bool(_GLF_IDENTITY(bool((injectionSwitch.x > injectionSwitch.y)), (bool((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, (true ? injectionSwitch : _GLF_FUZZED(vec2(6.3, 3.2)))).y))) && true)))))))))
        {
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
           barrier();
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          return;
         if(_GLF_IDENTITY(_GLF_DEAD(false), false || (_GLF_DEAD(false))))
          barrier();
        }
      }
     if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, (false) && true)))
      {
       if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, ! (! (true)))))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            return;
           barrier();
          }
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
          return;
        }
       else
        {
         if(_GLF_DEAD(false))
          barrier();
        }
      }
     else
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, (false) || false))))))
        {
         do
          {
           if(_GLF_DEAD(false))
            return;
          }
         while(_GLF_WRAPPED_LOOP(false));
         barrier();
         if(_GLF_DEAD(false))
          barrier();
        }
      }
     case 65:
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        {
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
          {
           if(_GLF_DEAD(false))
            continue;
           barrier();
          }
        }
      }
     if(_GLF_DEAD(false))
      {
       switch(_GLF_SWITCH(0))
        {
         case 0:
         case 79:
         if(_GLF_DEAD(false))
          return;
         return;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         break;
         default:
         1;
        }
      }
     case 34:
     case 43:
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       barrier();
      }
     case 28:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      return;
     int i = 0;
     case 62:
     if(_GLF_DEAD(false))
      return;
     case 18:
     case 96:
     if(_GLF_DEAD(false))
      return;
     atomicStore(checker[virtual_gid], read, _GLF_IDENTITY(4, ~ (_GLF_IDENTITY(~ (4), int(ivec2(~ (4), 0))))), 64, 4);
     break;
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        return;
       barrier();
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       barrier();
      }
     default:
     for(int _injected_loop_counter = _GLF_IDENTITY(0, min(_GLF_IDENTITY(0, (_GLF_IDENTITY(0, (0) | (0))) | 0), 0)); _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(_GLF_IDENTITY(int(4), (int(4)) | (int(4))), int(4))) >> _GLF_IDENTITY(int(4), int(4)))); _injected_loop_counter ++)
      {
       switch(_GLF_SWITCH(0))
        {
         case 0:
         case 51:
         if(_GLF_DEAD(false))
          barrier();
         case 31:
         case 65:
         case 70:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         case 1:
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           1;
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, ! (! (false))), (injectionSwitch.x > injectionSwitch.y))))
            return;
          }
         case 83:
         case 42:
         if(_GLF_DEAD(false))
          return;
         break;
         case 34:
         ;
         case 80:
         min(uvec3(140325u, 2215u, 63686u), next_virtual_gid);
         default:
         1;
        }
      }
    }
   if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, ! (! (false))))))) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))) || false))
    return;
   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, bool(bvec2(_GLF_IDENTITY(false, (false) && true), false))), bool(bool(_GLF_IDENTITY(false, bool(bvec2(_GLF_IDENTITY(false, (false) && true), false))))))))
    barrier();
  }
 else
  {
   if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec2(false, true)), ! (! (bool(bvec2(false, true))))))))
    {
     if(_GLF_DEAD(false))
      barrier();
    }
   else
    {
     if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, (false) && true), (injectionSwitch.x > injectionSwitch.y))))
      return;
     if(_GLF_DEAD(false))
      return;
     switch(_GLF_SWITCH(0))
      {
       case 0:
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, (true) || false)))
          {
           if(_GLF_DEAD(false))
            return;
           barrier();
          }
         else
          {
          }
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(vec2(mat4x3(_GLF_IDENTITY(injectionSwitch, (injectionSwitch) - vec2(0.0, 0.0)), 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, abs(1.0), 0.0, 1.0, 1.0)), _GLF_IDENTITY((vec2(mat4x3(_GLF_IDENTITY(injectionSwitch, (injectionSwitch) - vec2(0.0, 0.0)), 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, abs(1.0), 0.0, 1.0, 1.0))) * mat2(1.0), mix(vec2(((vec2(mat4x3(_GLF_IDENTITY(injectionSwitch, (injectionSwitch) - vec2(0.0, 0.0)), 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, abs(1.0), 0.0, 1.0, 1.0))) * mat2(1.0))[0], _GLF_FUZZED(-93.87)), vec2(_GLF_FUZZED(-6.3), ((vec2(mat4x3(_GLF_IDENTITY(injectionSwitch, (injectionSwitch) - vec2(0.0, 0.0)), 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, abs(1.0), 0.0, 1.0, 1.0))) * mat2(1.0))[1]), bvec2(false, true))))).x > injectionSwitch.y))))
        return;
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > _GLF_IDENTITY(0, 1 * (0))); _injected_loop_counter --)
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_DEAD(false))
          {
           do
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             return;
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
        }
       case 2:
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        return;
       do
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         atomicStore(checker[virtual_gid], read, 4, 64, 4);
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(false))
        return;
       break;
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           barrier();
          }
         else
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
            barrier();
          }
        }
       if(_GLF_DEAD(false))
        return;
       case 71:
       if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_IDENTITY(bool(_GLF_IDENTITY(bool(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), (bool(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))) && true)), true && (bool(_GLF_IDENTITY(bool(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), (bool(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))) && true)))))))
        {
        }
       else
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           ;
          }
         else
          {
          }
        }
       if(_GLF_DEAD(false))
        {
         switch(_GLF_SWITCH(0))
          {
           case 53:
           uint _GLF_SWITCH_2_0v[13];
           case 13:
           vec4 _GLF_SWITCH_2_1v;
           case 0:
           case 76:
           case 60:
           if(_GLF_DEAD(false))
            barrier();
           case 45:
           case 51:
           case 46:
           case 48:
           case 52:
           return;
           break;
           case 56:
           uvec3(168689u, 45515u, 26641u);
           case 28:
           ivec2 _GLF_SWITCH_2_2v, _GLF_SWITCH_2_3v;
           default:
           1;
          }
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       case 47:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
         for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(0), int(0))); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), false || (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))))
            {
             if(_GLF_IDENTITY(_GLF_WRAPPED_IF_TRUE(true), _GLF_TRUE(_GLF_IDENTITY(true, ! (! (_GLF_IDENTITY(true, ! (! (true)))))), (injectionSwitch.x < injectionSwitch.y)) && (_GLF_IDENTITY(_GLF_WRAPPED_IF_TRUE(true), ! (! (_GLF_WRAPPED_IF_TRUE(true)))))))
              {
               barrier();
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
             else
              {
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(false))
                return;
              }
            }
          }
        }
       else
        {
         vec3(-280.479, -36.91, -27.83);
        }
       if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(_GLF_IDENTITY(true, false || (true)), ! (! (true)))))
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       else
        {
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       default:
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          {
           if(_GLF_IDENTITY(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))), ! (_GLF_IDENTITY(! (_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))), (! (_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
            {
             switch(_GLF_SWITCH(0))
              {
               case 30:
               (uvec4(45629u, 51700u, 54284u, 108537u) >> uvec4(59108u, 169971u, 44896u, 62842u));
               case 0:
               barrier();
               case 79:
               case 25:
               case 54:
               case 58:
               case 86:
               if(_GLF_DEAD(false))
                barrier();
               break;
               case 60:
               ivec4(-45706, -19729, 53992, -75622);
               default:
               1;
              }
            }
           else
            {
            }
           if(_GLF_DEAD(false))
            return;
          }
        }
       else
        {
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       do
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, vec2(_GLF_IDENTITY(injectionSwitch, vec2(_GLF_IDENTITY(mat4x2(_GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED((2091.2716 / 1.3)), _GLF_FUZZED(-1.3)), bvec2(false, false))), 1.0, 1.0, 1.0, cos(length(0.0)), 1.0, 0.0), mat4x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) + (_GLF_IDENTITY(mat4x2(_GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED((2091.2716 / 1.3)), _GLF_FUZZED(-1.3)), bvec2(false, false))), 1.0, 1.0, 1.0, cos(length(0.0)), 1.0, 0.0), mat4x2(mat4(mat4x2(_GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED((2091.2716 / 1.3)), _GLF_FUZZED(-1.3)), bvec2(false, false))), 1.0, 1.0, 1.0, cos(length(0.0)), 1.0, 0.0))))))))[0], injectionSwitch[1])).x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            barrier();
           do
            {
             return;
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
          }
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(false))
        return;
       1;
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         barrier();
        }
       if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec2(false, false)), bool(bvec3(bool(bvec2(false, false)), _GLF_IDENTITY(false, ! (! (false))), true))))))
        return;
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_IDENTITY(_GLF_DEAD(false), bool(bool(_GLF_DEAD(false)))))
        {
         if(_GLF_DEAD(false))
          return;
         do
          {
           switch(_GLF_SWITCH((-7434 & 0)))
            {
             case 34:
             int _GLF_SWITCH_2_0v[80], _GLF_SWITCH_2_1v, _GLF_SWITCH_2_2v[38];
             case 11:
             transpose((mat3(-16.97, -9159.7955, 1.9, -4514.3882, 1.8, 492.543, -4807.1325, 726.437, -9384.4315) / mat3(94.82, -3.1, 9.5, -420.283, -45.11, -3755.4041, -8289.0549, 2.7, 62.92)));
             case 0:
             if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, (_GLF_IDENTITY(_GLF_IDENTITY(false, ! (! (false))), (_GLF_IDENTITY(false, ! (! (false)))) || _GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y)))))) && true)))
              {
              }
             else
              {
               switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                {
                 case 45:
                 if(false)
                  {
                   mat3 _GLF_SWITCH_1_0v[78];
                   if(_GLF_DEAD(false))
                    barrier();
                   uint _GLF_SWITCH_1_1v;
                   ivec2 _GLF_SWITCH_1_2v, _GLF_SWITCH_1_3v;
                   ivec4(36866, _GLF_IDENTITY(41588, clamp(_GLF_IDENTITY(41588, min(41588, 41588)), 41588, 41588)), -35883, -31953);
                   bvec2 _GLF_SWITCH_1_4v;
                   3.8;
                   greaterThan(vec3(-800.031, 1.3, 635.576), vec3(-6770.2697, 59.10, -5.5));
                  }
                 else
                  {
                   switch(_GLF_SWITCH(0))
                    {
                     case 97:
                     -182.773;
                     case 0:
                     if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(_GLF_TRUE(true, _GLF_IDENTITY((injectionSwitch.x < injectionSwitch.y), bool(_GLF_IDENTITY(bool((injectionSwitch.x < injectionSwitch.y)), true && (bool((injectionSwitch.x < injectionSwitch.y))))))), true && (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))))
                      {
                       (mat2(-1.5, -577.936, 3.4, 1.4) / mat2(_GLF_IDENTITY(8.3, float(float(8.3))), 8176.0440, -4.7, 4.1));
                      }
                     else
                      {
                      }
                     if(_GLF_DEAD(false))
                      barrier();
                     if(_GLF_DEAD(false))
                      return;
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                     if(_GLF_DEAD(false))
                      return;
                     case 96:
                     case 1:
                     ;
                     case 50:
                     if(_GLF_DEAD(false))
                      barrier();
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED(3341.9836), _GLF_FUZZED(340.444)), bvec2(false, false))).y))))
                      return;
                     bvec3(false, true, true);
                     mat4x2(mat2x4(8637.8799, 7.3, -9.1, 293.895, 9.3, 5.5, 753.128, -3.7));
                     case 53:
                     case 15:
                     bvec2 _GLF_SWITCH_1_5v, _GLF_SWITCH_1_6v, _GLF_SWITCH_1_7v;
                     ivec4 _GLF_SWITCH_1_8v, _GLF_SWITCH_1_9v, _GLF_SWITCH_1_10v[24];
                     case 55:
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      return;
                     if(_GLF_DEAD(false))
                      barrier();
                     break;
                     case 30:
                     uvec3(129840u, 58841u, 102255u);
                     case 6:
                     mat2x4 _GLF_SWITCH_3_0v;
                     default:
                     1;
                    }
                  }
                 case 0:
                 if(_GLF_DEAD(false))
                  barrier();
                 case 20:
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      return;
                     return;
                    }
                  }
                 case 60:
                 case 55:
                 case 82:
                 case 70:
                 if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, ! (! (true)))))
                  {
                   if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                    return;
                  }
                 else
                  {
                  }
                 return;
                 break;
                 if(_GLF_DEAD(false))
                  return;
                 case 29:
                 {
                  switch(_GLF_SWITCH((0 << _GLF_IDENTITY(int(8), int(8)))))
                   {
                    case 0:
                    case 42:
                    case 2:
                    if(_GLF_DEAD(false))
                     {
                      if(_GLF_DEAD(false))
                       barrier();
                      for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                       {
                        return;
                       }
                     }
                    case 81:
                    case 39:
                    if(_GLF_DEAD(false))
                     return;
                    case 51:
                    for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                     {
                      uvec4(66925u, 150698u, _GLF_IDENTITY(46890u, uint(uint(_GLF_IDENTITY(46890u, clamp(46890u, _GLF_IDENTITY(46890u, max(46890u, 46890u)), 46890u))))), 13699u);
                     }
                    case 11:
                    case 9:
                    case 40:
                    injectionSwitch;
                    break;
                    case 69:
                    vec4(74.00, -9.7, 1216.3564, -3.7);
                    default:
                    1;
                   }
                 }
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    return;
                   return;
                  }
                 default:
                 1;
                }
              }
             if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
              barrier();
             break;
             case 53:
             ;
             default:
             1;
            }
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
       if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
        return;
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec4(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, false, false)))))
          return;
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, max(_GLF_IDENTITY(injectionSwitch.y, (injectionSwitch.y) * 1.0), injectionSwitch.y)))), false || (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
          barrier();
         barrier();
        }
      }
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     if(_GLF_DEAD(false))
      barrier();
     return;
     if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) || false))
      barrier();
    }
  }
}

END

BUFFER tester DATA_TYPE uint32 SIZE 8388096 FILL 0
BUFFER expected DATA_TYPE uint32 SIZE 8388096 FILL 2
BUFFER injection DATA_TYPE vec2<float> DATA
 0.0 1.0
END
BUFFER checker DATA_TYPE uint32 SIZE 8388096 FILL 0
BUFFER expected_checker DATA_TYPE uint32 SIZE 8388096 FILL 1

PIPELINE compute test_pipe
  ATTACH test
  BIND BUFFER tester AS storage DESCRIPTOR_SET 0 BINDING 0 
  BIND BUFFER injection AS uniform DESCRIPTOR_SET 0 BINDING 1 
  BIND BUFFER checker AS storage DESCRIPTOR_SET 0 BINDING 2 

  SUBGROUP test
	  VARYING_SIZE on
  END
END

RUN test_pipe 65532 1 1
EXPECT checker EQ_BUFFER expected_checker
