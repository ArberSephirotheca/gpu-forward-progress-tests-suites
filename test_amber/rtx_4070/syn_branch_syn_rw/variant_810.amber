#!amber

DEVICE_FEATURE SubgroupSizeControl.subgroupSizeControl

SET ENGINE_DATA fence_timeout_ms 10000

SHADER compute test GLSL
#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_maximal_reconvergence : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer Checker {
 uint checker[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(_GLF_IDENTITY(bvec3(false, false, false), bvec3(bvec4(bvec3(false, false, false), false)))), ! (_GLF_IDENTITY(_GLF_IDENTITY(! (bool(_GLF_IDENTITY(bvec3(false, false, false), bvec3(bvec4(bvec3(false, false, false), false))))), true && (! (bool(_GLF_IDENTITY(bvec3(false, false, false), bvec3(bvec4(bvec3(false, false, false), false))))))), ! (! (_GLF_IDENTITY(! _GLF_IDENTITY((bool(_GLF_IDENTITY(bvec3(false, false, false), bvec3(bvec4(bvec3(false, false, false), false))))), bool(bvec2((bool(_GLF_IDENTITY(bvec3(false, false, false), bvec3(bvec4(bvec3(false, false, false), false))))), true))), true && (! (bool(_GLF_IDENTITY(bvec3(false, false, false), bvec3(bvec4(bvec3(false, false, false), false)))))))))))))))
  {
   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
    {
     barrier();
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
  }
 if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || _GLF_FALSE(_GLF_IDENTITY(_GLF_IDENTITY(false, ! (! (false))), ! (! (_GLF_IDENTITY(false, ! (! (false)))))), (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (injectionSwitch.x > injectionSwitch.y) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))))))
  barrier();
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
    barrier();
  }
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = gl_NumWorkGroups.x;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, _GLF_IDENTITY(true, false || (true)))))))
    barrier();
   barrier();
  }
 do
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, (true) && true)))
      {
       if(_GLF_DEAD(false))
        barrier();
       do
        {
         barrier();
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
     else
      {
      }
    }
  }
 while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) || false)));
 uint workgroup_size = gl_WorkGroupSize.x;
 do
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).y))))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, max(_GLF_IDENTITY(injectionSwitch.x, (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) ? injectionSwitch.x : _GLF_FUZZED(96.30))), _GLF_IDENTITY(injectionSwitch.x, (false ? _GLF_FUZZED(109.480) : injectionSwitch.x)))) > injectionSwitch.y))))
        barrier();
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
            {
             do
              {
               barrier();
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
          }
         else
          {
          }
        }
       else
        {
        }
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           barrier();
          }
        }
      }
    }
  }
 while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (_GLF_IDENTITY(false, ! (! (false)))), true && (! (_GLF_IDENTITY(false, ! (! (false))))))))));
 if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, (false) && _GLF_TRUE(true, _GLF_IDENTITY(_GLF_IDENTITY((injectionSwitch.x < injectionSwitch.y), true && (_GLF_IDENTITY((injectionSwitch.x < injectionSwitch.y), (_GLF_IDENTITY((injectionSwitch.x < injectionSwitch.y), false || ((injectionSwitch.x < injectionSwitch.y)))) || false))), ! (! ((injectionSwitch.x < injectionSwitch.y)))))), bool(bvec2(false, false)))))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, tan(vec2(0.0, 0.0)) + (_GLF_IDENTITY(injectionSwitch, (true ? injectionSwitch : _GLF_FUZZED(injectionSwitch))))).x > injectionSwitch.y))))
      {
      }
     else
      {
       barrier();
      }
    }
   for(int _injected_loop_counter = (int(_GLF_ONE(1.0, injectionSwitch.y)) & 1); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
    {
     do
      {
       barrier();
      }
     while(_GLF_WRAPPED_LOOP(false));
     if(_GLF_DEAD(false))
      barrier();
    }
   if(_GLF_DEAD(_GLF_IDENTITY(false, false || (_GLF_IDENTITY(false, (false) && true)))))
    barrier();
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   barrier();
  }
 if(_GLF_DEAD(false))
  barrier();
 uint workgroup_id = gl_WorkGroupID.x;
 uint workgroup_base = workgroup_size * _GLF_IDENTITY(workgroup_id, (0u << _GLF_IDENTITY(uint(2u), uint(2u))) | (workgroup_id));
 uint subgroup_base = subgroup_id * _GLF_IDENTITY(subgroup_size, ~ (~ (subgroup_size)));
 uint virtual_gid = _GLF_IDENTITY(_GLF_IDENTITY(workgroup_base, (0u ^ 1u) * (workgroup_base)) + subgroup_base, (_GLF_IDENTITY(workgroup_base, (0u ^ 1u) * (workgroup_base)) + subgroup_base) - (0u >> _GLF_IDENTITY(uint(2u), uint(2u)))) + subgroup_local_id;
 if(_GLF_DEAD(false))
  barrier();
 uint next_virtual_gid = _GLF_IDENTITY(workgroup_base + subgroup_base, 0u | (_GLF_IDENTITY(_GLF_IDENTITY(workgroup_base, (workgroup_base) ^ 0u) + subgroup_base, max(_GLF_IDENTITY(workgroup_base, (workgroup_base) ^ 0u) + subgroup_base, _GLF_IDENTITY(_GLF_IDENTITY(workgroup_base, (workgroup_base) ^ 0u) + subgroup_base, (_GLF_IDENTITY(workgroup_base, (workgroup_base) ^ 0u) + subgroup_base) << 0u))))) + ((subgroup_local_id + _GLF_IDENTITY(1, clamp(1, 1, 1))) % subgroup_size);
 uint read = atomicLoad(buf[virtual_gid], _GLF_IDENTITY(_GLF_IDENTITY(_GLF_IDENTITY(4, int(ivec2(4, 0))), clamp(_GLF_IDENTITY(_GLF_IDENTITY(4, int(ivec2(4, 0))), _GLF_IDENTITY(min(_GLF_IDENTITY(4, int(ivec2(4, 0))), _GLF_IDENTITY(4, int(ivec2(4, 0)))), (min(_GLF_IDENTITY(4, int(ivec2(4, 0))), _GLF_IDENTITY(4, int(ivec2(4, 0))))) >> 0)), _GLF_IDENTITY(4, int(ivec2(4, 0))), _GLF_IDENTITY(_GLF_IDENTITY(4, int(ivec2(4, 0))), (_GLF_IDENTITY(_GLF_IDENTITY(4, int(ivec2(4, 0))), int(ivec2(_GLF_IDENTITY(4, int(ivec2(4, 0))), 0)))) >> 0))), min(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_IDENTITY(4, int(ivec2(4, 0))), 0 | (_GLF_IDENTITY(4, int(ivec2(4, 0))))), clamp(_GLF_IDENTITY(_GLF_IDENTITY(4, int(ivec2(4, 0))), _GLF_IDENTITY(min(_GLF_IDENTITY(4, int(ivec2(4, 0))), _GLF_IDENTITY(4, int(ivec2(4, 0)))), (_GLF_IDENTITY(min(_GLF_IDENTITY(4, int(ivec2(4, 0))), _GLF_IDENTITY(4, int(ivec2(4, 0)))), max(_GLF_IDENTITY(min(_GLF_IDENTITY(4, int(ivec2(4, 0))), _GLF_IDENTITY(4, int(ivec2(4, 0)))), ~ (~ (min(_GLF_IDENTITY(4, int(ivec2(4, 0))), _GLF_IDENTITY(4, int(ivec2(4, 0))))))), min(_GLF_IDENTITY(4, int(ivec2(4, 0))), _GLF_IDENTITY(4, int(ivec2(4, 0))))))) >> 0)), _GLF_IDENTITY(_GLF_IDENTITY(4, (false ? _GLF_FUZZED(25682) : _GLF_IDENTITY(4, max(4, 4)))), int(ivec2(4, 0))), _GLF_IDENTITY(_GLF_IDENTITY(4, int(ivec2(4, 0))), (_GLF_IDENTITY(_GLF_IDENTITY(4, int(ivec2(4, 0))), int(ivec2(_GLF_IDENTITY(4, int(ivec2(4, 0))), 0)))) >> 0))), _GLF_IDENTITY(_GLF_IDENTITY(4, int(ivec2(4, 0))), clamp(_GLF_IDENTITY(_GLF_IDENTITY(4, int(ivec2(4, 0))), _GLF_IDENTITY(min(_GLF_IDENTITY(4, int(ivec2(4, 0))), _GLF_IDENTITY(4, int(ivec2(4, 0)))), (min(_GLF_IDENTITY(4, int(ivec2(_GLF_IDENTITY(4, (4) | 0), 0))), _GLF_IDENTITY(4, int(ivec2(4, 0))))) >> 0)), _GLF_IDENTITY(4, int(ivec2(4, 0))), _GLF_IDENTITY(_GLF_IDENTITY(4, int(ivec2(4, 0))), (_GLF_IDENTITY(_GLF_IDENTITY(4, int(ivec2(4, 0))), int(ivec2(_GLF_IDENTITY(4, int(ivec2(4, 0))), 0)))) >> 0))))), _GLF_IDENTITY(64, max(_GLF_IDENTITY(64, (64) | 0), 64)), 2);
 do
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
      }
     else
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
    }
   else
    {
    }
   if(_GLF_IDENTITY((subgroup_local_id % 2) == 0, false || (_GLF_IDENTITY((_GLF_IDENTITY(_GLF_IDENTITY(subgroup_local_id, (_GLF_IDENTITY(subgroup_local_id, clamp(subgroup_local_id, subgroup_local_id, subgroup_local_id))) | (subgroup_local_id)) % 2, clamp(_GLF_IDENTITY(subgroup_local_id % 2, (subgroup_local_id % 2) | 0u), subgroup_local_id % 2, _GLF_IDENTITY(subgroup_local_id % 2, min(subgroup_local_id % 2, _GLF_IDENTITY(subgroup_local_id % 2, (subgroup_local_id % 2) / 1u)))))) == _GLF_IDENTITY(0, clamp(0, 0, _GLF_IDENTITY(0, _GLF_IDENTITY(clamp(0, 0, 0), max(_GLF_IDENTITY(clamp(0, 0, 0), ~ (_GLF_IDENTITY(~ (clamp(0, 0, 0)), 1 * (~ (clamp(0, 0, 0)))))), clamp(0, 0, 0)))))), (_GLF_IDENTITY((subgroup_local_id % 2), _GLF_IDENTITY(clamp((subgroup_local_id % 2), (subgroup_local_id % 2), (subgroup_local_id % 2)), (clamp((subgroup_local_id % 2), (subgroup_local_id % _GLF_IDENTITY(2, (2) | (0 >> _GLF_IDENTITY(int(6), int(6))))), (subgroup_local_id % 2))) | (0u ^ 0u))) == 0) && true))))
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, true && (true))))
      {
       if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (true))))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         switch(_GLF_IDENTITY(_GLF_SWITCH(0), _GLF_IDENTITY(_GLF_IDENTITY(0, (_GLF_IDENTITY(0, (true ? 0 : _GLF_FUZZED(99756)))) - 0), (_GLF_IDENTITY(0, (_GLF_IDENTITY(0, (true ? 0 : _GLF_FUZZED(99756)))) - 0)) / 1) | _GLF_IDENTITY((_GLF_SWITCH(0)), min(_GLF_IDENTITY((_GLF_SWITCH(0)), ~ (~ (_GLF_IDENTITY((_GLF_SWITCH(0)), min((_GLF_SWITCH(0)), (_GLF_SWITCH(0))))))), _GLF_IDENTITY((_GLF_SWITCH(0)), min((_GLF_SWITCH(0)), (_GLF_SWITCH(0))))))))
          {
           case 34:
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             do
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   barrier();
                  }
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
           else
            {
            }
           bvec2 _GLF_SWITCH_0_0v;
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < ((int(_GLF_ONE(1.0, injectionSwitch.y)) | 1) & 1)); _injected_loop_counter ++)
              {
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   for(int _injected_loop_counter = (0 ^ 1); _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                    {
                     barrier();
                     if(_GLF_WRAPPED_IF_FALSE(false))
                      {
                      }
                     else
                      {
                       if(_GLF_DEAD(false))
                        barrier();
                      }
                    }
                  }
                 if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                  {
                   do
                    {
                     barrier();
                     if(_GLF_DEAD(false))
                      barrier();
                     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                      {
                       for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), int(4))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                        {
                         if(_GLF_DEAD(false))
                          barrier();
                        }
                      }
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_WRAPPED_IF_TRUE(true))
                      {
                       barrier();
                      }
                     else
                      {
                      }
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                  }
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_TRUE(_GLF_IDENTITY(true, ! (! (true))), (injectionSwitch.x < injectionSwitch.y)), ! (_GLF_IDENTITY(! (_GLF_TRUE(true, _GLF_IDENTITY((injectionSwitch.x < injectionSwitch.y), ((injectionSwitch.x < injectionSwitch.y)) || false))), _GLF_IDENTITY(bool(bvec4(_GLF_IDENTITY(! (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))), bool(bvec3(! (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))), true, true))), _GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec2(false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))), bool(bvec3(bool(bvec2(false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), true)))), false, false)), bool(bool(bool(bvec4(_GLF_IDENTITY(! (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))), bool(bvec3(! (_GLF_TRUE(true, (_GLF_IDENTITY(injectionSwitch.x < injectionSwitch.y, ! (! (injectionSwitch.x < injectionSwitch.y)))))), true, true))), false, false, _GLF_IDENTITY(false, (false) && true))))))))), (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))) && true)))
                    {
                     barrier();
                    }
                   else
                    {
                    }
                   if(_GLF_DEAD(false))
                    barrier();
                  }
                }
               else
                {
                }
              }
            }
           case 88:
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             do
              {
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 for(int _injected_loop_counter = 0; _GLF_IDENTITY(_GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_IDENTITY(_GLF_ONE(1.0, injectionSwitch.y), min(_GLF_ONE(1.0, injectionSwitch.y), _GLF_ONE(1.0, injectionSwitch.y))))), bool(_GLF_IDENTITY(bvec2(_GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))), false), bvec2(bvec3(bvec2(_GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))), false), true))))); _injected_loop_counter ++)
                  {
                   if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                    barrier();
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                    }
                   else
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                     if(_GLF_DEAD(false))
                      barrier();
                     if(_GLF_WRAPPED_IF_TRUE(true))
                      {
                       if(_GLF_DEAD(false))
                        barrier();
                       for(int _injected_loop_counter = _GLF_IDENTITY(int(_GLF_ZERO(0.0, injectionSwitch.x)), 0 ^ (_GLF_IDENTITY(int(_GLF_ZERO(0.0, injectionSwitch.x)), 1 * (int(_GLF_ZERO(0.0, injectionSwitch.x)))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                        {
                         if(_GLF_WRAPPED_IF_FALSE(false))
                          {
                          }
                         else
                          {
                           if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (! (_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
                            {
                             if(_GLF_DEAD(false))
                              barrier();
                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              barrier();
                             if(_GLF_DEAD(false))
                              {
                               if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ((injectionSwitch.x > injectionSwitch.y)) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
                                barrier();
                               if(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bool(bool(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
                                {
                                }
                               else
                                {
                                 if(_GLF_DEAD(false))
                                  barrier();
                                }
                               if(_GLF_WRAPPED_IF_TRUE(true))
                                {
                                 do
                                  {
                                   do
                                    {
                                     barrier();
                                    }
                                   while(_GLF_WRAPPED_LOOP(false));
                                  }
                                 while(_GLF_WRAPPED_LOOP(false));
                                }
                               else
                                {
                                 if(_GLF_DEAD(false))
                                  barrier();
                                }
                              }
                             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter, (true ? _injected_loop_counter : _GLF_FUZZED(_injected_loop_counter))) < _GLF_IDENTITY(((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), (34762 & 0) | (int(0))))), _GLF_IDENTITY(int(_GLF_IDENTITY(ivec2(((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), (34762 & 0) | (int(0))))), 1), min(_GLF_IDENTITY(ivec2(((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(_GLF_IDENTITY(0, min(0, 0))), _GLF_IDENTITY(int(0), (34762 & 0) | (int(0))))), 1), (ivec2(((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(_GLF_IDENTITY(int(0), max(int(0), int(0))), int(0))) >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), (34762 & 0) | (int(0))))), 1)) - ivec2(0, 0)), ivec2(((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), (34762 & 0) | (int(0))))), 1)))), (int(_GLF_IDENTITY(ivec2(((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(0), int(_GLF_IDENTITY(0, (_GLF_IDENTITY(0, max(0, 0))) | (0))))) >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), (34762 & 0) | (int(0))))), 1), min(_GLF_IDENTITY(ivec2(((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), (34762 & 0) | (int(0))))), 1), (ivec2(((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), (34762 & 0) | (int(0))))), 1)) - ivec2(0, 0)), ivec2(((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), (34762 & 0) | (int(0))))), 1))))) >> 0))); _injected_loop_counter ++)
                              {
                               do
                                {
                                 if(_GLF_DEAD(false))
                                  {
                                   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                    {
                                     if(_GLF_DEAD(false))
                                      barrier();
                                    }
                                   else
                                    {
                                     barrier();
                                    }
                                  }
                                }
                               while(_GLF_WRAPPED_LOOP(false));
                               barrier();
                              }
                             if(_GLF_DEAD(false))
                              barrier();
                            }
                          }
                         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                          {
                           for(int _GLF_SWITCH_0_1v, _GLF_SWITCH_0_2v; true; mat4x2((false ? mat4(-4.8, -2.1, 501.268, -6718.5038, -58.26, 283.634, 3.2, 134.980, -56.84, -5304.7248, -43.52, -775.479, 6407.8967, -13.27, -0.9, _GLF_IDENTITY(1.6, float(mat2x3(1.6, determinant(mat4(0.0, 0.0, length(vec2(0.0, 0.0)), 0.0, _GLF_IDENTITY(0.0, float(mat2x3(0.0, 0.0, 0.0, 0.0, 1.0, 0.0))), 0.0, 0.0, 0.0, _GLF_IDENTITY(1.0, clamp(1.0, 1.0, 1.0)), 0.0, 0.0, 0.0, 1.0, sin(0.0), 1.0, 0.0)), 0.0, 1.0, _GLF_IDENTITY(0.0, mix(float(_GLF_FUZZED(-6.7)), float(0.0), _GLF_IDENTITY(bool(true), _GLF_IDENTITY(bool(_GLF_IDENTITY(bvec3(bool(true), true, true), bvec3(bvec4(bvec3(bool(true), true, true), true)))), ! (! (bool(_GLF_IDENTITY(bvec3(bool(true), true, true), bvec3(bvec4(bvec3(bool(true), true, true), true)))))))))), 1.0)))) : _GLF_IDENTITY(mat4(-1.1, -45.23, -6314.0500, -3568.1648, -65.57, 554.238, 8845.0557, -0.9, 9907.1812, -3142.9139, 6.9, 970.590, 79.01, 6.1, _GLF_IDENTITY(-1.9, float(mat3(_GLF_IDENTITY(-1.9, (false ? _GLF_FUZZED(-8.1) : -1.9)), 0.0, 1.0, sqrt(1.0), sqrt(1.0), _GLF_IDENTITY(1.0, (1.0) / 1.0), _GLF_IDENTITY(1.0, max(1.0, 1.0)), 0.0, sin(0.0)))), -73.71), transpose(_GLF_IDENTITY(transpose(mat4(-1.1, -45.23, -6314.0500, -3568.1648, -65.57, 554.238, 8845.0557, -0.9, _GLF_IDENTITY(9907.1812, (9907.1812) / sqrt(1.0)), -3142.9139, 6.9, 970.590, 79.01, 6.1, _GLF_IDENTITY(-1.9, float(mat3(_GLF_IDENTITY(_GLF_IDENTITY(-1.9, (false ? _GLF_FUZZED(-8.1) : -1.9)), clamp(_GLF_IDENTITY(-1.9, (false ? _GLF_FUZZED(-8.1) : -1.9)), _GLF_IDENTITY(_GLF_IDENTITY(-1.9, (false ? _GLF_FUZZED(-8.1) : -1.9)), clamp(_GLF_IDENTITY(-1.9, (false ? _GLF_FUZZED(-8.1) : -1.9)), _GLF_IDENTITY(-1.9, (false ? _GLF_FUZZED(-8.1) : -1.9)), _GLF_IDENTITY(_GLF_IDENTITY(-1.9, (false ? _GLF_FUZZED(-8.1) : -1.9)), clamp(_GLF_IDENTITY(-1.9, (false ? _GLF_FUZZED(-8.1) : -1.9)), _GLF_IDENTITY(-1.9, (_GLF_IDENTITY(false ? _GLF_FUZZED(-8.1) : -1.9, clamp(false ? _GLF_FUZZED(-8.1) : -1.9, false ? _GLF_FUZZED(-8.1) : -1.9, _GLF_IDENTITY(false ? _GLF_FUZZED(-8.1) : -1.9, mix(float(_GLF_FUZZED(-6204.9991)), float(false ? _GLF_FUZZED(-8.1) : -1.9), bool(true))))))), _GLF_IDENTITY(_GLF_IDENTITY(-1.9, (false ? _GLF_FUZZED(-8.1) : -1.9)), (_GLF_IDENTITY(_GLF_IDENTITY(-1.9, (false ? _GLF_FUZZED(-8.1) : -1.9)), mix(float(_GLF_IDENTITY(-1.9, (false ? _GLF_FUZZED(-8.1) : -1.9))), float(_GLF_FUZZED(5464.2679)), bool(false)))) * 1.0))))), _GLF_IDENTITY(-1.9, (false ? _GLF_FUZZED(-8.1) : -1.9)))), 0.0, 1.0, sqrt(1.0), sqrt(1.0), _GLF_IDENTITY(1.0, _GLF_IDENTITY(_GLF_IDENTITY((1.0), mix(float(_GLF_FUZZED(26.24)), float((1.0)), bool(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))), min(_GLF_IDENTITY(_GLF_IDENTITY((1.0), mix(float(_GLF_FUZZED(26.24)), float((1.0)), bool(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))), max(_GLF_IDENTITY((1.0), mix(float(_GLF_FUZZED(26.24)), float((1.0)), bool(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))), _GLF_IDENTITY((1.0), mix(float(_GLF_FUZZED(26.24)), float((1.0)), bool(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))))), _GLF_IDENTITY(_GLF_IDENTITY((1.0), mix(float(_GLF_FUZZED(26.24)), float((1.0)), bool(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))), float(_GLF_IDENTITY(mat2(_GLF_IDENTITY((1.0), mix(float(_GLF_FUZZED(26.24)), float((1.0)), bool(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))), 0.0, 1.0, 1.0), mat2(mat2(mat2(_GLF_IDENTITY((1.0), mix(float(_GLF_FUZZED(26.24)), float((1.0)), bool(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))), 0.0, 1.0, 1.0)))))))) / 1.0), _GLF_IDENTITY(1.0, max(1.0, 1.0)), _GLF_IDENTITY(0.0, (0.0) / round(length(normalize(vec2(1.0, 1.0))))), sin(_GLF_IDENTITY(0.0, (0.0) / 1.0))))), -73.71)), transpose(_GLF_IDENTITY(transpose(transpose(mat4(-1.1, -45.23, -6314.0500, -3568.1648, _GLF_IDENTITY(-65.57, mix(float(_GLF_FUZZED(-2656.4570)), float(-65.57), bool(true))), 554.238, 8845.0557, _GLF_IDENTITY(-0.9, 1.0 * (_GLF_IDENTITY(_GLF_IDENTITY(-0.9, max(-0.9, _GLF_IDENTITY(-0.9, clamp(-0.9, _GLF_IDENTITY(-0.9, clamp(-0.9, -0.9, -0.9)), -0.9)))), (-0.9) / determinant(mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, _GLF_IDENTITY(1.0, 1.0 * (1.0)), 0.0, 1.0, 0.0, 0.0, 1.0))))), 9907.1812, -3142.9139, 6.9, 970.590, 79.01, 6.1, _GLF_IDENTITY(-1.9, float(mat3(_GLF_IDENTITY(-1.9, (false ? _GLF_FUZZED(-8.1) : -1.9)), 0.0, 1.0, sqrt(1.0), sqrt(1.0), _GLF_IDENTITY(1.0, (1.0) / 1.0), _GLF_IDENTITY(1.0, max(_GLF_IDENTITY(1.0, (_GLF_IDENTITY(false, bool(bvec3(false, true, false))) ? _GLF_FUZZED(48.97) : 1.0)), 1.0)), 0.0, sin(0.0)))), -73.71))), transpose(transpose(transpose(transpose(mat4(-1.1, -45.23, -6314.0500, -3568.1648, -65.57, 554.238, 8845.0557, -0.9, 9907.1812, _GLF_IDENTITY(-3142.9139, (-3142.9139) * 1.0), _GLF_IDENTITY(6.9, min(6.9, 6.9)), 970.590, 79.01, 6.1, _GLF_IDENTITY(-1.9, float(mat3(_GLF_IDENTITY(-1.9, (false ? _GLF_FUZZED(-8.1) : -1.9)), 0.0, _GLF_IDENTITY(1.0, (1.0) * 1.0), sqrt(1.0), sqrt(1.0), _GLF_IDENTITY(1.0, (1.0) / 1.0), _GLF_IDENTITY(1.0, max(1.0, 1.0)), 0.0, sin(0.0)))), -73.71)))))))))))))
                            {
                             do
                              {
                               if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, bool(bvec2(true, false)))))
                                {
                                 if(_GLF_DEAD(false))
                                  {
                                   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                                    {
                                     barrier();
                                     if(_GLF_DEAD(false))
                                      barrier();
                                     if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, false || (_GLF_IDENTITY(true, false || (true))))))
                                      {
                                       if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ! (_GLF_IDENTITY(! (_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), true && ((injectionSwitch.x > injectionSwitch.y)))), false || (! (_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), true && ((injectionSwitch.x > injectionSwitch.y)))))))))))
                                        barrier();
                                      }
                                     else
                                      {
                                      }
                                    }
                                   else
                                    {
                                    }
                                  }
                                 if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) && (injectionSwitch.x > injectionSwitch.y))))))
                                  {
                                   do
                                    {
                                     if(_GLF_WRAPPED_IF_TRUE(true))
                                      {
                                       barrier();
                                      }
                                     else
                                      {
                                      }
                                    }
                                   while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, ! (! (false)))));
                                  }
                                }
                               else
                                {
                                }
                               if(_GLF_WRAPPED_IF_FALSE(false))
                                {
                                 do
                                  {
                                   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                                    {
                                     do
                                      {
                                       if(_GLF_WRAPPED_IF_TRUE(true))
                                        {
                                         if(_GLF_DEAD(false))
                                          {
                                           if(_GLF_WRAPPED_IF_TRUE(true))
                                            {
                                             if(_GLF_DEAD(false))
                                              barrier();
                                             if(_GLF_DEAD(false))
                                              {
                                               do
                                                {
                                                 barrier();
                                                }
                                               while(_GLF_WRAPPED_LOOP(false));
                                              }
                                             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                              {
                                              }
                                             else
                                              {
                                               if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(false, true, false, false)))))
                                                barrier();
                                              }
                                            }
                                           else
                                            {
                                            }
                                           for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                                            {
                                             barrier();
                                            }
                                           if(_GLF_DEAD(false))
                                            barrier();
                                          }
                                        }
                                       else
                                        {
                                        }
                                      }
                                     while(_GLF_WRAPPED_LOOP(false));
                                    }
                                  }
                                 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                                }
                               else
                                {
                                 if(_GLF_WRAPPED_IF_TRUE(true))
                                  {
                                   do
                                    {
                                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                      {
                                       do
                                        {
                                         if(_GLF_DEAD(false))
                                          barrier();
                                         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], _GLF_FUZZED(-71.07)), vec2(_GLF_FUZZED(6.2), (injectionSwitch)[1]), bvec2(false, true))).x > injectionSwitch.y))))
                                          barrier();
                                        }
                                       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                                       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (_GLF_IDENTITY(0, (0) / 1) | 0)); _injected_loop_counter --)
                                        {
                                         barrier();
                                         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                                          {
                                           if(_GLF_DEAD(false))
                                            barrier();
                                          }
                                        }
                                      }
                                    }
                                   while(_GLF_WRAPPED_LOOP(false));
                                  }
                                 else
                                  {
                                  }
                                }
                              }
                             while(_GLF_WRAPPED_LOOP(false));
                             do
                              {
                               if(_GLF_WRAPPED_IF_FALSE(false))
                                {
                                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                  barrier();
                                }
                               else
                                {
                                 _GLF_IDENTITY(uvec4(191243u, 111214u, 165717u, 160147u), uvec4(0u, 0u, 0u, 0u) | (uvec4(191243u, 111214u, 165717u, 160147u)));
                                 if(_GLF_DEAD(false))
                                  barrier();
                                }
                              }
                             while(_GLF_WRAPPED_LOOP(false));
                             _GLF_IDENTITY(bitfieldInsert(uvec4(150223u, 171795u, 29020u, 179877u), uvec4(_GLF_IDENTITY(119210u, (_GLF_IDENTITY(119210u, (119210u) - 0u)) | 0u), 150778u, 76869u, 75269u), _GLF_IDENTITY(atomicCompSwap(_GLF_SWITCH_0_2v, _GLF_SWITCH_0_1v, -75855), ~ (~ (atomicCompSwap(_GLF_SWITCH_0_2v, _GLF_SWITCH_0_1v, -75855)))), int(subgroup_base)), (bitfieldInsert(uvec4(150223u, 171795u, 29020u, 179877u), uvec4(_GLF_IDENTITY(119210u, (_GLF_IDENTITY(119210u, (119210u) - 0u)) | 0u), 150778u, 76869u, 75269u), _GLF_IDENTITY(atomicCompSwap(_GLF_SWITCH_0_2v, _GLF_SWITCH_0_1v, -75855), ~ (~ (atomicCompSwap(_GLF_SWITCH_0_2v, _GLF_SWITCH_0_1v, -75855)))), int(subgroup_base))) | uvec4(0u, 0u, 0u, 0u));
                             if(_GLF_WRAPPED_IF_FALSE(false))
                              {
                              }
                             else
                              {
                               if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) || false))
                                barrier();
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                barrier();
                              }
                             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              {
                              }
                             else
                              {
                               if(_GLF_WRAPPED_IF_TRUE(true))
                                {
                                 if(_GLF_DEAD(false))
                                  barrier();
                                 if(_GLF_DEAD(false))
                                  barrier();
                                 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                                  {
                                   if(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), _GLF_IDENTITY(bool(bool(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (! (_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))), false || (bool(bool(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (! (_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))))))))
                                    {
                                    }
                                   else
                                    {
                                     for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                                      {
                                       for(int _injected_loop_counter = 1; _GLF_IDENTITY(_GLF_WRAPPED_LOOP(_injected_loop_counter != 0), ! (_GLF_IDENTITY(! (_GLF_WRAPPED_LOOP(_injected_loop_counter != 0)), ! (! (_GLF_IDENTITY(! (_GLF_WRAPPED_LOOP(_injected_loop_counter != 0)), false || (! (_GLF_WRAPPED_LOOP(_injected_loop_counter != 0))))))))); _injected_loop_counter --)
                                        {
                                         if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bool(bool(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (_GLF_IDENTITY(! (_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))), false || (! _GLF_IDENTITY((_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))), true && ((_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))))))))))
                                          barrier();
                                         if(_GLF_WRAPPED_IF_FALSE(false))
                                          {
                                          }
                                         else
                                          {
                                           do
                                            {
                                             if(_GLF_DEAD(false))
                                              {
                                               if(_GLF_DEAD(false))
                                                barrier();
                                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                                {
                                                 for(int _injected_loop_counter = _GLF_IDENTITY(int(_GLF_ZERO(0.0, injectionSwitch.x)), (int(_GLF_ZERO(0.0, injectionSwitch.x))) ^ 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                                                  {
                                                   barrier();
                                                  }
                                                }
                                               if(_GLF_WRAPPED_IF_FALSE(false))
                                                {
                                                }
                                               else
                                                {
                                                 barrier();
                                                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                                  barrier();
                                                }
                                              }
                                            }
                                           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                                          }
                                         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                                          {
                                           if(_GLF_WRAPPED_IF_FALSE(false))
                                            {
                                            }
                                           else
                                            {
                                             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, mix(float(injectionSwitch.x), float(_GLF_FUZZED(-88.57)), bool(false))) > injectionSwitch.y))))
                                              {
                                               if(_GLF_WRAPPED_IF_TRUE(true))
                                                {
                                                 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                                  {
                                                  }
                                                 else
                                                  {
                                                   barrier();
                                                  }
                                                }
                                               else
                                                {
                                                }
                                              }
                                            }
                                           if(_GLF_DEAD(false))
                                            {
                                             if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, bool(bool(false))), (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y))))))
                                              barrier();
                                             barrier();
                                             if(_GLF_DEAD(false))
                                              barrier();
                                            }
                                          }
                                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                          barrier();
                                         if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, (false) && true)))
                                          {
                                          }
                                         else
                                          {
                                           if(_GLF_WRAPPED_IF_TRUE(true))
                                            {
                                             do
                                              {
                                               for(int _injected_loop_counter = (_GLF_IDENTITY(0, (0) + 0) >> _GLF_IDENTITY(int(0), int(0))); _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 | 1)); _injected_loop_counter ++)
                                                {
                                                 for(int _injected_loop_counter = (0 | 0); _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter != ((_GLF_IDENTITY(1, min(1, 1)) << _GLF_IDENTITY(int(3), int(3))) >> _GLF_IDENTITY(_GLF_IDENTITY(int(3), int(3)), (_GLF_IDENTITY(int(3), int(3))) ^ 0)), (_injected_loop_counter != ((_GLF_IDENTITY(1, min(1, 1)) << _GLF_IDENTITY(int(3), int(3))) >> _GLF_IDENTITY(_GLF_IDENTITY(int(3), int(3)), (_GLF_IDENTITY(int(3), int(3))) ^ 0))) && true)); _injected_loop_counter ++)
                                                  {
                                                   if(_GLF_DEAD(false))
                                                    barrier();
                                                   if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                                                    barrier();
                                                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                                    barrier();
                                                   _GLF_IDENTITY((mat2(mat4x2(47.45, -0.9, 7196.1542, -0.4, -9259.1927, -54.45, 1.1, _GLF_IDENTITY(25.08, _GLF_IDENTITY(float(vec4(25.08, 1.0, 1.0, 1.0)), (float(vec4(25.08, 1.0, 1.0, 1.0))) - 0.0)))) / _GLF_IDENTITY(_GLF_IDENTITY(-6.5, (_GLF_IDENTITY(true ? -6.5 : _GLF_FUZZED(normalize(-3.1)), float(mat4(true ? -6.5 : _GLF_FUZZED(_GLF_IDENTITY(normalize(-3.1), (_GLF_IDENTITY(normalize(-3.1), (_GLF_IDENTITY(normalize(-3.1), 1.0 * (normalize(-3.1)))) / 1.0)) / 1.0)), 0.0, sqrt(1.0), 0.0, 0.0, determinant(mat2(1.0, 0.0, _GLF_IDENTITY(dot(vec4(0.0, 0.0, 0.0, 1.0), vec4(0.0, 0.0, 0.0, 1.0)), dot(vec4(0.0, 0.0, 0.0, 1.0), vec4(0.0, 0.0, 0.0, 1.0))), 1.0)), 1.0, sqrt(_GLF_IDENTITY(0.0, clamp(0.0, 0.0, 0.0))), 0.0, 0.0, 0.0, _GLF_IDENTITY(1.0, (false ? _GLF_FUZZED(-3929.1762) : 1.0)), 1.0, round(length(normalize(vec2(_GLF_IDENTITY(1.0, (1.0) / 1.0), 1.0)))), 1.0, abs(1.0)))))), (_GLF_IDENTITY(-6.5, (_GLF_IDENTITY(-6.5, mix(float(_GLF_FUZZED(3231.3060)), float(_GLF_IDENTITY(-6.5, max(-6.5, -6.5))), bool(true)))) - 0.0)) / 1.0)), (true ? (mat2(mat4x2(47.45, -0.9, 7196.1542, -0.4, -9259.1927, -54.45, 1.1, 25.08)) / _GLF_IDENTITY(_GLF_IDENTITY(-6.5, min(-6.5, -6.5)), _GLF_IDENTITY((_GLF_IDENTITY(-6.5, (_GLF_IDENTITY(-6.5, mix(float(_GLF_FUZZED(_GLF_IDENTITY(3231.3060, clamp(3231.3060, 3231.3060, 3231.3060)))), float(-6.5), bool(true)))) - 0.0)) / 1.0, ((_GLF_IDENTITY(-6.5, (_GLF_IDENTITY(-6.5, mix(float(_GLF_FUZZED(_GLF_IDENTITY(3231.3060, clamp(3231.3060, 3231.3060, 3231.3060)))), float(-6.5), bool(true)))) - 0.0)) / 1.0) / 1.0))) : _GLF_FUZZED(mat2(-9.9, 161.942, -169.851, -7.0))));
                                                  }
                                                }
                                              }
                                             while(_GLF_IDENTITY(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec4(false, false, true, true)), (bool(bvec4(false, false, true, true))) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), bool(bool(_GLF_IDENTITY(_GLF_WRAPPED_LOOP(false), (_GLF_WRAPPED_LOOP(false)) || false)))));
                                             if(_GLF_DEAD(false))
                                              barrier();
                                            }
                                           else
                                            {
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                               else
                                {
                                 for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                                  {
                                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                    {
                                     if(_GLF_WRAPPED_IF_TRUE(true))
                                      {
                                       barrier();
                                      }
                                     else
                                      {
                                      }
                                    }
                                  }
                                }
                              }
                             if(_GLF_WRAPPED_IF_FALSE(false))
                              {
                              }
                             else
                              {
                               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (injectionSwitch.x > injectionSwitch.y) && true)))))
                                {
                                 if(_GLF_DEAD(false))
                                  barrier();
                                }
                               else
                                {
                                 bvec2(true, false);
                                }
                              }
                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, max(injectionSwitch.y, injectionSwitch.y))))))
                              {
                               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 | 1)); _GLF_IDENTITY(_injected_loop_counter ++, int(_GLF_ZERO(0.0, injectionSwitch.x)) + (_GLF_IDENTITY(_injected_loop_counter ++, 0 | (_GLF_IDENTITY(_injected_loop_counter ++, 0 ^ (_injected_loop_counter ++)))))))
                                {
                                 barrier();
                                }
                               if(_GLF_DEAD(false))
                                barrier();
                              }
                             for(int _injected_loop_counter = _GLF_IDENTITY(_GLF_IDENTITY((0 | 0), ~ (~ ((0 | 0)))), 0 | (_GLF_IDENTITY((0 | 0), ~ (~ ((0 | 0)))))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _GLF_IDENTITY(_injected_loop_counter ++, (_injected_loop_counter ++) - 0))
                              {
                               if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
                                {
                                 if(_GLF_DEAD(false))
                                  {
                                   do
                                    {
                                     barrier();
                                    }
                                   while(_GLF_WRAPPED_LOOP(false));
                                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                    barrier();
                                  }
                                 if(_GLF_WRAPPED_IF_FALSE(false))
                                  {
                                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                    barrier();
                                  }
                                 else
                                  {
                                   if(_GLF_DEAD(false))
                                    barrier();
                                   barrier();
                                  }
                                }
                               ivec2(_GLF_IDENTITY(45524, (45524) - 0), -25049);
                               if(_GLF_DEAD(false))
                                {
                                 if(_GLF_DEAD(false))
                                  barrier();
                                 if(_GLF_DEAD(false))
                                  barrier();
                                 barrier();
                                }
                              }
                             for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                              {
                               vec3(0.5, -433.593, -3.3);
                               if(_GLF_DEAD(false))
                                barrier();
                              }
                             if(_GLF_WRAPPED_IF_FALSE(false))
                              {
                               if(_GLF_DEAD(false))
                                barrier();
                              }
                             else
                              {
                               if(_GLF_WRAPPED_IF_TRUE(true))
                                {
                                 if(_GLF_DEAD(false))
                                  barrier();
                                 if(_GLF_DEAD(false))
                                  barrier();
                                }
                               else
                                {
                                }
                              }
                             if(_GLF_DEAD(false))
                              barrier();
                             do
                              {
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, clamp(injectionSwitch, injectionSwitch, injectionSwitch)).y))))
                                barrier();
                              }
                             while(_GLF_WRAPPED_LOOP(false));
                             do
                              {
                               if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, true && _GLF_IDENTITY((false), ((false)) && true))))
                                {
                                 if(_GLF_WRAPPED_IF_FALSE(false))
                                  {
                                   if(_GLF_DEAD(false))
                                    barrier();
                                  }
                                 else
                                  {
                                   if(_GLF_DEAD(false))
                                    barrier();
                                  }
                                }
                               else
                                {
                                 do
                                  {
                                   if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_IDENTITY(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), _GLF_IDENTITY(! (_GLF_IDENTITY(! (_GLF_IDENTITY(! (false), bool(bvec4(! (false), true, false, false)))), bool(bvec4(! (_GLF_IDENTITY(! (false), bool(bvec4(! (false), true, false, false)))), true, false, false)))), false || (! (_GLF_IDENTITY(! (_GLF_IDENTITY(! (false), bool(bvec4(! (false), true, false, false)))), bool(bvec4(! (_GLF_IDENTITY(! (false), bool(bvec4(! (false), true, false, false)))), true, false, false)))))))))), _GLF_IDENTITY(bool(bvec2(_GLF_DEAD(false), true)), true && (_GLF_IDENTITY(bool(bvec2(_GLF_DEAD(false), true)), ! (! (bool(bvec2(_GLF_DEAD(false), true))))))))) || false))
                                    {
                                     if(_GLF_DEAD(false))
                                      barrier();
                                     barrier();
                                    }
                                  }
                                 while(_GLF_WRAPPED_LOOP(false));
                                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                  barrier();
                                 do
                                  {
                                   do
                                    {
                                     do
                                      {
                                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                        barrier();
                                      }
                                     while(_GLF_WRAPPED_LOOP(false));
                                    }
                                   while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                                  }
                                 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                                 if(_GLF_DEAD(false))
                                  barrier();
                                }
                              }
                             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                             if(_GLF_DEAD(false))
                              barrier();
                            }
                          }
                         else
                          {
                          }
                         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) + 0.0) > injectionSwitch.y))))
                          barrier();
                        }
                      }
                     else
                      {
                      }
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                  }
                }
               else
                {
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
              {
               if(_GLF_DEAD(false))
                barrier();
               barrier();
              }
            }
           case 0:
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 barrier();
                }
               else
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
              }
             else
              {
              }
            }
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 | 0)); _GLF_IDENTITY(_injected_loop_counter --, (_injected_loop_counter --) * ((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), int(1)))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_IDENTITY((injectionSwitch)[0], ((injectionSwitch)[0]) / 1.0), (injectionSwitch)[1]), vec2(_GLF_FUZZED(4187.4535), _GLF_FUZZED(6.0)), bvec2(false, false))).x > injectionSwitch.y))))
              barrier();
            }
           case 98:
           case 4:
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
              {
               if(_GLF_DEAD(false))
                barrier();
               barrier();
              }
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                }
               else
                {
                 barrier();
                }
              }
            }
           if(_GLF_DEAD(false))
            barrier();
           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
            {
             do
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_WRAPPED_IF_TRUE(true))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                   else
                    {
                    }
                   if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), _GLF_IDENTITY(bool(bvec2(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), true)), bool(bool(bool(bvec2(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), true)))))))
                    {
                     if(_GLF_DEAD(_GLF_IDENTITY(false, true && (_GLF_IDENTITY(false, bool(bool(false)))))))
                      barrier();
                     barrier();
                    }
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                    }
                   else
                    {
                     do
                      {
                       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 << _GLF_IDENTITY(int(0), int(0)))); _injected_loop_counter --)
                        {
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            barrier();
                           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 & _GLF_IDENTITY(1, max(_GLF_IDENTITY(1, ~ (~ (1))), 1)))); _injected_loop_counter ++)
                            {
                             barrier();
                            }
                          }
                        }
                      }
                     while(_GLF_WRAPPED_LOOP(false));
                    }
                   barrier();
                  }
                }
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
            }
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
              {
               barrier();
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           case 65:
           case 93:
           atomicStore(buf[next_virtual_gid], uint(1), 4, 64, 4);
           case 24:
           case 42:
           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), int(0)))); _injected_loop_counter ++)
            {
             if(_GLF_DEAD(false))
              {
               do
                {
                 do
                  {
                   if(_GLF_DEAD(false))
                    {
                     for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(3), _GLF_IDENTITY(int(3), min(int(3), int(3))))) >> _GLF_IDENTITY(int(3), int(3))); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                      {
                       if(_GLF_DEAD(false))
                        barrier();
                       barrier();
                      }
                    }
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                }
               while(_GLF_WRAPPED_LOOP(false));
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 barrier();
                }
               else
                {
                }
              }
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             barrier();
            }
           case 70:
           if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
            barrier();
           case 38:
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           else
            {
            }
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(_GLF_IDENTITY(true, true && (_GLF_IDENTITY(true, bool(bvec2(_GLF_IDENTITY(true, true && (true)), true))))), (injectionSwitch.x < injectionSwitch.y))))
            {
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
            }
           else
            {
            }
           if(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(false), _GLF_IDENTITY(bool(bvec4(_GLF_WRAPPED_IF_FALSE(false), false, false, true)), (bool(bvec4(_GLF_WRAPPED_IF_FALSE(false), false, false, true))) && true)))
            {
            }
           else
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, float(mat2(_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.y, (injectionSwitch.y) - 0.0), float(_GLF_IDENTITY(mat4x3(_GLF_IDENTITY(injectionSwitch.y, (injectionSwitch.y) - 0.0), 0.0, sin(0.0), _GLF_IDENTITY(tan(0.0), _GLF_IDENTITY(float(mat4x2(tan(0.0), 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, round(length(normalize(vec3(1.0, 1.0, 1.0)))))), clamp(float(mat4x2(tan(0.0), 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, round(length(normalize(vec3(1.0, 1.0, 1.0)))))), float(mat4x2(tan(0.0), 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, round(length(normalize(vec3(1.0, 1.0, 1.0)))))), float(mat4x2(tan(0.0), 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, round(length(normalize(vec3(1.0, 1.0, 1.0))))))))), round(length(normalize(vec3(1.0, 1.0, 1.0)))), 1.0, 0.0, 0.0, 1.0, 1.0, round(length(normalize(vec4(1.0, 1.0, 1.0, 1.0)))), 0.0), (mat4x3(_GLF_IDENTITY(injectionSwitch.y, (injectionSwitch.y) - 0.0), 0.0, sin(0.0), tan(0.0), round(length(normalize(vec3(1.0, 1.0, 1.0)))), 1.0, 0.0, 0.0, 1.0, 1.0, round(length(normalize(vec4(1.0, 1.0, 1.0, 1.0)))), 0.0)) - mat4x3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)))), 0.0, 1.0, 0.0)))))))
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_WRAPPED_IF_TRUE(true))
                      {
                       barrier();
                      }
                     else
                      {
                      }
                    }
                  }
                }
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(bool(false)))))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                      {
                       barrier();
                      }
                     else
                      {
                      }
                    }
                  }
                }
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                  {
                   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                    {
                     do
                      {
                       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        {
                         if(_GLF_WRAPPED_IF_FALSE(false))
                          {
                          }
                         else
                          {
                           if(_GLF_DEAD(false))
                            barrier();
                          }
                        }
                       else
                        {
                         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                          {
                           barrier();
                          }
                        }
                       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                        {
                         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true)))
                          {
                           if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(bvec3(false, true, false)))))
                            {
                            }
                           else
                            {
                             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              {
                              }
                             else
                              {
                               barrier();
                              }
                            }
                          }
                        }
                      }
                     while(_GLF_WRAPPED_LOOP(false));
                    }
                  }
                }
               else
                {
                }
              }
            }
           break;
           case 37:
           bvec3 _GLF_SWITCH_0_3v, _GLF_SWITCH_0_4v[15];
           case 51:
           if(_GLF_DEAD(false))
            barrier();
           do
            {
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) && (injectionSwitch.x > injectionSwitch.y))))))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              {
               do
                {
                 barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, _GLF_IDENTITY(float(mat3x4(_GLF_IDENTITY(injectionSwitch.y, (true ? injectionSwitch.y : _GLF_FUZZED(-9818.0325))), 1.0, 0.0, _GLF_IDENTITY(dot(vec4(_GLF_IDENTITY(0.0, mix(float(_GLF_FUZZED(-6295.5371)), float(_GLF_IDENTITY(0.0, float(mat3x2(0.0, length(vec4(0.0, 0.0, 0.0, 0.0)), 1.0, 1.0, 0.0, 1.0)))), bool(true))), 0.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x)), vec4(1.0, 1.0, 0.0, 1.0)), dot(vec4(0.0, 0.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x)), vec4(1.0, 1.0, 0.0, 1.0))), 1.0, 1.0, 0.0, 1.0, 0.0, length(_GLF_IDENTITY(vec4(0.0, 0.0, _GLF_IDENTITY(0.0, mix(float(_GLF_FUZZED(((_GLF_IDENTITY(7197.3741 + -3.3, (7197.3741 + -3.3) / 1.0))))), float(0.0), bool(true))), 0.0), max(vec4(0.0, 0.0, _GLF_IDENTITY(0.0, mix(float(_GLF_FUZZED(((7197.3741 + -3.3)))), float(0.0), bool(true))), 0.0), vec4(_GLF_IDENTITY(0.0, (true ? 0.0 : _GLF_FUZZED(6.7))), 0.0, _GLF_IDENTITY(0.0, mix(_GLF_IDENTITY(float(_GLF_FUZZED(((7197.3741 + -3.3)))), (float(_GLF_FUZZED(((7197.3741 + -3.3))))) / 1.0), float(0.0), bool(true))), 0.0)))), log(1.0), 1.0)), float(mat2x3(float(mat3x4(_GLF_IDENTITY(injectionSwitch.y, (true ? injectionSwitch.y : _GLF_FUZZED(-9818.0325))), 1.0, 0.0, _GLF_IDENTITY(dot(vec4(0.0, 0.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x)), vec4(1.0, 1.0, 0.0, 1.0)), dot(vec4(0.0, 0.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x)), vec4(1.0, _GLF_IDENTITY(1.0, clamp(_GLF_IDENTITY(1.0, (false ? _GLF_FUZZED(-25.81) : 1.0)), _GLF_IDENTITY(1.0, max(1.0, 1.0)), _GLF_IDENTITY(1.0, (true ? _GLF_IDENTITY(1.0, (1.0) * 1.0) : _GLF_FUZZED(28.80))))), 0.0, 1.0))), 1.0, 1.0, 0.0, 1.0, 0.0, length(vec4(0.0, 0.0, 0.0, 0.0)), log(1.0), 1.0)), 0.0, 1.0, 0.0, 1.0, 0.0))))))))
                  barrier();
                }
               else
                {
                }
              }
            }
           if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ((injectionSwitch.x > injectionSwitch.y)) || false))))
            barrier();
           default:
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               barrier();
              }
            }
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter != 0, (_GLF_IDENTITY(_injected_loop_counter != 0, bool(bool(_injected_loop_counter != 0)))) || false)); _injected_loop_counter --)
              {
               1;
              }
             if(_GLF_DEAD(false))
              barrier();
            }
           else
            {
            }
          }
        }
       else
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     else
      {
      }
     if(_GLF_IDENTITY(_GLF_DEAD(false), bool(bool(_GLF_DEAD(false)))))
      barrier();
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), (_GLF_IDENTITY(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), bool(bvec3(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), true, true)))) || false)))
        {
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
              }
             else
              {
               if(_GLF_DEAD(false))
                barrier();
              }
            }
           else
            {
            }
          }
        }
       else
        {
        }
       if(_GLF_DEAD(false))
        barrier();
      }
    }
   else
    {
     do
      {
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
        {
         if(_GLF_DEAD(false))
          barrier();
        }
      }
     while(_GLF_WRAPPED_LOOP(false));
     do
      {
       atomicStore(buf[next_virtual_gid], uint(_GLF_IDENTITY(1, min(1, 1))), _GLF_IDENTITY(4, _GLF_IDENTITY(max(4, 4), (_GLF_IDENTITY(max(4, 4), min(max(4, 4), max(4, _GLF_IDENTITY(4, max(4, 4)))))) | (max(4, 4)))), 64, _GLF_IDENTITY(4, _GLF_IDENTITY(int(_GLF_IDENTITY(ivec2(_GLF_IDENTITY(4, (_GLF_IDENTITY(4, ~ (~ (4)))) - _GLF_IDENTITY(0, ~ (~ (0)))), 1), (_GLF_IDENTITY(ivec2(_GLF_IDENTITY(4, (_GLF_IDENTITY(4, ~ (~ (4)))) - 0), 1), (ivec2(_GLF_IDENTITY(4, (_GLF_IDENTITY(4, ~ (~ (4)))) - 0), 1)) - ivec2(0, 0))) << ivec2(0, 0))), (int(ivec2(_GLF_IDENTITY(4, (_GLF_IDENTITY(_GLF_IDENTITY(4, int(int(_GLF_IDENTITY(4, max(_GLF_IDENTITY(4, max(4, 4)), 4))))), ~ (~ _GLF_IDENTITY((4), _GLF_IDENTITY(int(ivec3((4), 0, 0)), min(int(ivec3((4), 0, 0)), int(ivec3((4), 0, 0)))))))) - 0), 1))) * 1)));
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
    {
     do
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(_GLF_IDENTITY((injectionSwitch), (false ? _GLF_FUZZED(injectionSwitch) : (injectionSwitch))) + _GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), max(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), _GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), mix(vec2((vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0)))[0], _GLF_FUZZED(-742.231)), vec2(_GLF_FUZZED(5406.9022), (vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, clamp((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0))) / abs(1.0)))))[1]), bvec2(false, true))))), clamp(_GLF_IDENTITY((injectionSwitch), (false ? _GLF_FUZZED(injectionSwitch) : (injectionSwitch))) + _GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), max(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), _GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), mix(vec2((vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0)))[0], _GLF_FUZZED(-742.231)), vec2(_GLF_FUZZED(5406.9022), (vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, clamp((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0))) / abs(1.0)))))[1]), bvec2(false, true))))), _GLF_IDENTITY((injectionSwitch), (false ? _GLF_FUZZED(injectionSwitch) : (injectionSwitch))) + _GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), max(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), _GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), mix(vec2((vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0)))[0], _GLF_FUZZED(-742.231)), vec2(_GLF_FUZZED(5406.9022), (vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, clamp((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0))) / abs(1.0)))))[1]), bvec2(false, true))))), _GLF_IDENTITY((injectionSwitch), (false ? _GLF_FUZZED(injectionSwitch) : (injectionSwitch))) + _GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), max(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), _GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), mix(vec2((vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0)))[0], _GLF_FUZZED(-742.231)), vec2(_GLF_FUZZED(5406.9022), (vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, clamp((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0))) / abs(1.0)))))[1]), bvec2(false, true)))))))).x > injectionSwitch.y), _GLF_IDENTITY(bool(bool(_GLF_IDENTITY((_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY((injectionSwitch), (false ? _GLF_FUZZED(injectionSwitch) : (injectionSwitch))) + _GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), max(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), mix(float(_GLF_ZERO(0.0, injectionSwitch.x)), float(_GLF_FUZZED(9.0)), bool(false)))), _GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), mix(vec2((_GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0)), (vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0))) * mat2(1.0)))[0], _GLF_FUZZED(-742.231)), vec2(_GLF_FUZZED(5406.9022), (vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, clamp((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0))) / abs(1.0)))))[1]), bvec2(false, true)))))).x > injectionSwitch.y), ! (! ((_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY((injectionSwitch), (false ? _GLF_FUZZED(injectionSwitch) : (injectionSwitch))) + _GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), max(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, _GLF_IDENTITY(injectionSwitch, (true ? _GLF_IDENTITY(injectionSwitch, (injectionSwitch) + vec2(0.0, 0.0)) : _GLF_FUZZED(injectionSwitch))).x)), _GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), mix(vec2((vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), (_GLF_ZERO(_GLF_IDENTITY(0.0, float(mat3(0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, tan(0.0)))), injectionSwitch.x)) / 1.0)))[0], _GLF_FUZZED(-742.231)), vec2(_GLF_FUZZED(5406.9022), (vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, _GLF_IDENTITY((_GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, clamp((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0))), ((_GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, clamp((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0)))) + 0.0) / abs(1.0)))))[1]), bvec2(false, true)))))).x > injectionSwitch.y)))))), (bool(bool(_GLF_IDENTITY((_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY((injectionSwitch), (false ? _GLF_FUZZED(injectionSwitch) : (injectionSwitch))) + _GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), max(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(_GLF_IDENTITY(0.0, (_GLF_IDENTITY(0.0, float(vec4(0.0, 1.0, 0.0, 1.0)))) + 0.0), injectionSwitch.x)), _GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), mix(vec2((vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), (_GLF_ZERO(0.0, _GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, _GLF_IDENTITY(injectionSwitch.x, float(mat3(_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) / 1.0), 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0))))))) / 1.0)))[0], _GLF_FUZZED(_GLF_IDENTITY(-742.231, float(_GLF_IDENTITY(mat3x2(_GLF_IDENTITY(-742.231, min(-742.231, -742.231)), 1.0, 1.0, tan(0.0), 0.0, 1.0), (mat3x2(_GLF_IDENTITY(-742.231, min(-742.231, -742.231)), 1.0, 1.0, tan(0.0), 0.0, 1.0)) - mat3x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)))))), vec2(_GLF_FUZZED(5406.9022), (_GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(_GLF_IDENTITY(0.0, mix(float(_GLF_FUZZED((true ? -46.89 : 1.6))), float(_GLF_IDENTITY(0.0, mix(float(_GLF_FUZZED(9574.9051)), float(0.0), bool(true)))), bool(true))), injectionSwitch.x), _GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, clamp((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0))) / abs(1.0)))), mix(vec2((vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(_GLF_IDENTITY(0.0, mix(float(_GLF_FUZZED((true ? -46.89 : 1.6))), float(_GLF_IDENTITY(0.0, mix(float(_GLF_FUZZED(9574.9051)), float(0.0), bool(true)))), bool(true))), injectionSwitch.x), _GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, clamp((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0))) / abs(1.0)))))[0], _GLF_FUZZED(-8433.8351)), vec2(_GLF_FUZZED(-7.4), (vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(_GLF_IDENTITY(0.0, mix(float(_GLF_FUZZED((true ? -46.89 : 1.6))), float(_GLF_IDENTITY(0.0, mix(float(_GLF_FUZZED(9574.9051)), float(0.0), bool(true)))), bool(true))), injectionSwitch.x), _GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, clamp((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0))) / abs(1.0)))))[1]), bvec2(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true))))[1]), bvec2(false, true)))))).x > injectionSwitch.y), ! (! ((_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY((injectionSwitch), (false ? _GLF_FUZZED(injectionSwitch) : (injectionSwitch))) + _GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), max(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), _GLF_IDENTITY(vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), clamp(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)))), mix(vec2((vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0)))[0], _GLF_FUZZED(-742.231)), vec2(_GLF_FUZZED(5406.9022), (vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_IDENTITY((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, clamp((_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0, (_GLF_ZERO(0.0, injectionSwitch.x)) / 1.0))) / abs(1.0)))))[1]), bvec2(false, true)))))).x > injectionSwitch.y))))))) && true)))))
        barrier();
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
   else
    {
    }
  }
 while(_GLF_IDENTITY(_GLF_WRAPPED_LOOP(_GLF_FALSE(_GLF_IDENTITY(false, _GLF_IDENTITY((_GLF_IDENTITY(false, false || (false))) && true, ((_GLF_IDENTITY(false, false || (false))) && true) || false)), (_GLF_IDENTITY(injectionSwitch, max(_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(_GLF_IDENTITY(8.4, float(_GLF_IDENTITY(float(8.4), mix(float(_GLF_FUZZED(0.3)), float(float(8.4)), _GLF_IDENTITY(bool(true), ! (! (bool(true))))))))), _GLF_FUZZED(8245.7268)), vec2(_GLF_IDENTITY(_GLF_IDENTITY((injectionSwitch), max(_GLF_IDENTITY((injectionSwitch), _GLF_IDENTITY(vec2(mat3x2((injectionSwitch), 0.0, 1.0, 0.0, 1.0)), (vec2(mat3x2((injectionSwitch), 0.0, _GLF_IDENTITY(_GLF_IDENTITY(1.0, clamp(1.0, 1.0, _GLF_IDENTITY(1.0, (1.0) / 1.0))), min(_GLF_IDENTITY(1.0, clamp(1.0, 1.0, _GLF_IDENTITY(1.0, (1.0) / 1.0))), _GLF_IDENTITY(1.0, clamp(1.0, 1.0, _GLF_IDENTITY(1.0, (1.0) / 1.0))))), 0.0, _GLF_IDENTITY(1.0, float(mat2x3(1.0, 0.0, 0.0, 0.0, 0.0, 1.0)))))) + _GLF_IDENTITY(vec2(0.0, 0.0), vec2(_GLF_IDENTITY(mat3x4(vec2(0.0, 0.0), 1.0, _GLF_IDENTITY(0.0, max(_GLF_IDENTITY(0.0, _GLF_IDENTITY((true ? 0.0 : _GLF_FUZZED(4403.0968)), float(vec2((true ? 0.0 : _GLF_FUZZED(4403.0968)), 0.0)))), 0.0)), 1.0, 0.0, 1.0, 1.0, sqrt(abs(0.0)), 1.0, 0.0, sqrt(0.0)), transpose(transpose(mat3x4(vec2(0.0, 0.0), _GLF_IDENTITY(1.0, (true ? 1.0 : _GLF_FUZZED(vec4(6989.2129, -4.3, -154.970, -7.1).g))), 0.0, 1.0, 0.0, 1.0, _GLF_IDENTITY(1.0, float(mat2x3(1.0, 0.0, 1.0, determinant(mat2(0.0, 1.0, 0.0, 0.0)), 1.0, 0.0))), sqrt(abs(0.0)), 1.0, 0.0, sqrt(0.0))))))))), (injectionSwitch)))[0], mix(float(_GLF_IDENTITY((injectionSwitch), max(_GLF_IDENTITY((injectionSwitch), _GLF_IDENTITY(vec2(mat3x2((injectionSwitch), 0.0, 1.0, 0.0, 1.0)), (vec2(mat3x2(_GLF_IDENTITY((injectionSwitch), max((injectionSwitch), _GLF_IDENTITY((injectionSwitch), clamp((injectionSwitch), (injectionSwitch), _GLF_IDENTITY((injectionSwitch), (false ? _GLF_FUZZED(vec2(3886.8867, -5238.9948)) : (injectionSwitch))))))), 0.0, 1.0, 0.0, 1.0))) + vec2(0.0, 0.0))), (injectionSwitch)))[0]), float(_GLF_FUZZED(4.1)), bool(_GLF_IDENTITY(false, ! (! (false)))))), _GLF_IDENTITY(_GLF_IDENTITY((injectionSwitch)[1], ((injectionSwitch)[1]) + 0.0), (_GLF_IDENTITY((injectionSwitch), _GLF_IDENTITY(vec2(_GLF_IDENTITY(mat4x2(_GLF_IDENTITY((injectionSwitch), vec2(vec4((injectionSwitch), 1.0, 1.0))), 0.0, abs(sin(0.0)), _GLF_IDENTITY(dot(vec4(0.0, 0.0, 1.0, 0.0), vec4(1.0, 1.0, log(1.0), 1.0)), dot(vec4(0.0, 0.0, 1.0, 0.0), vec4(1.0, 1.0, log(1.0), 1.0))), 0.0, 1.0, 0.0), mat2(1.0) * (mat4x2(_GLF_IDENTITY((injectionSwitch), vec2(vec4((injectionSwitch), 1.0, 1.0))), 0.0, abs(sin(0.0)), _GLF_IDENTITY(dot(vec4(0.0, 0.0, 1.0, 0.0), vec4(1.0, 1.0, log(1.0), 1.0)), dot(vec4(0.0, 0.0, 1.0, 0.0), vec4(1.0, 1.0, log(1.0), 1.0))), 0.0, 1.0, 0.0)))), (vec2(_GLF_IDENTITY(mat4x2(_GLF_IDENTITY((injectionSwitch), vec2(vec4((injectionSwitch), 1.0, 1.0))), 0.0, abs(sin(0.0)), _GLF_IDENTITY(dot(vec4(0.0, 0.0, 1.0, 0.0), vec4(1.0, 1.0, log(1.0), 1.0)), dot(vec4(0.0, 0.0, 1.0, 0.0), vec4(1.0, 1.0, log(1.0), 1.0))), 0.0, 1.0, 0.0), mat2(1.0) * (mat4x2(_GLF_IDENTITY((injectionSwitch), vec2(vec4((injectionSwitch), 1.0, 1.0))), 0.0, abs(sin(0.0)), _GLF_IDENTITY(dot(vec4(0.0, 0.0, 1.0, 0.0), vec4(1.0, 1.0, log(1.0), 1.0)), dot(vec4(0.0, 0.0, 1.0, 0.0), vec4(1.0, 1.0, log(1.0), 1.0))), 0.0, 1.0, 0.0))))) / vec2(1.0, 1.0)))[1]) + 0.0)), bvec2(true, true))), injectionSwitch)).x > _GLF_IDENTITY(injectionSwitch, log(vec2(1.0, 1.0)) + (injectionSwitch)).y))), bool(bvec4(_GLF_WRAPPED_LOOP(_GLF_FALSE(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, false || (false))) && true), (_GLF_IDENTITY(injectionSwitch, max(_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(_GLF_IDENTITY(8.4, float(float(8.4)))), _GLF_FUZZED(8245.7268)), vec2(_GLF_IDENTITY(_GLF_IDENTITY((injectionSwitch), max(_GLF_IDENTITY((injectionSwitch), _GLF_IDENTITY(vec2(mat3x2((injectionSwitch), 0.0, _GLF_IDENTITY(1.0, min(1.0, 1.0)), 0.0, 1.0)), (vec2(mat3x2((injectionSwitch), 0.0, _GLF_IDENTITY(_GLF_IDENTITY(1.0, clamp(1.0, 1.0, _GLF_IDENTITY(_GLF_IDENTITY(1.0, (1.0) / 1.0), 0.0 + (_GLF_IDENTITY(1.0, (1.0) / 1.0))))), min(_GLF_IDENTITY(1.0, clamp(1.0, 1.0, _GLF_IDENTITY(1.0, (1.0) / _GLF_IDENTITY(1.0, max(1.0, 1.0))))), _GLF_IDENTITY(1.0, clamp(1.0, 1.0, _GLF_IDENTITY(1.0, (1.0) / 1.0))))), 0.0, _GLF_IDENTITY(1.0, float(mat2x3(1.0, 0.0, 0.0, 0.0, 0.0, 1.0)))))) + _GLF_IDENTITY(vec2(0.0, 0.0), vec2(_GLF_IDENTITY(mat3x4(vec2(0.0, 0.0), 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, sqrt(abs(0.0)), 1.0, 0.0, sqrt(0.0)), transpose(transpose(mat3x4(vec2(0.0, 0.0), 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, sqrt(abs(0.0)), 1.0, 0.0, sqrt(0.0))))))))), (injectionSwitch)))[0], mix(float(_GLF_IDENTITY((injectionSwitch), max(_GLF_IDENTITY((injectionSwitch), _GLF_IDENTITY(vec2(mat3x2((injectionSwitch), 0.0, 1.0, 0.0, 1.0)), (vec2(mat3x2((injectionSwitch), 0.0, 1.0, 0.0, 1.0))) + vec2(0.0, 0.0))), (injectionSwitch)))[0]), float(_GLF_FUZZED(4.1)), bool(_GLF_IDENTITY(false, false || (false))))), _GLF_IDENTITY(_GLF_IDENTITY((injectionSwitch), ((injectionSwitch)) / vec2(1.0, 1.0))[1], ((injectionSwitch)[1]) + 0.0)), bvec2(_GLF_IDENTITY(true, ! (! (true))), true))), injectionSwitch)).x > injectionSwitch.y))), true, false, true))));
 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
  {
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
    {
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        {
         for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(3), _GLF_IDENTITY(int(3), ~ (~ (int(3)))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
          {
           barrier();
           if(_GLF_DEAD(false))
            barrier();
          }
        }
      }
     else
      {
      }
    }
   if(_GLF_DEAD(false))
    barrier();
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (_GLF_IDENTITY((0 << _GLF_IDENTITY(int(8), int(8))), (_GLF_IDENTITY((0 << _GLF_IDENTITY(int(8), int(8))), (_GLF_IDENTITY((0 << _GLF_IDENTITY(int(8), int(8))), max((0 << _GLF_IDENTITY(int(8), int(8))), (0 << _GLF_IDENTITY(int(8), int(8)))))) / 1)) >> 0) << _GLF_IDENTITY(int(7), int(7)))); _injected_loop_counter --)
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     do
      {
       subgroupBarrier();
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).x, min(_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).x, _GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).x)) > _GLF_IDENTITY(injectionSwitch.y, float(_GLF_IDENTITY(mat4x3(_GLF_IDENTITY(injectionSwitch.y, 0.0 + (injectionSwitch.y)), 1.0, length(vec3(0.0, 0.0, 0.0)), 1.0, determinant(mat2(sqrt(0.0), 0.0, 1.0, 0.0)), sqrt(1.0), 0.0, _GLF_ONE(1.0, injectionSwitch.y), 1.0, 1.0, 0.0, 1.0), (false ? _GLF_FUZZED(mat4x3(1339.8749, -6.2, 908.346, -804.700, -7204.0135, 4.9, 6.8, 0.3, -617.265, 4.8, 488.456, 0.6)) : mat4x3(_GLF_IDENTITY(injectionSwitch.y, 0.0 + (injectionSwitch.y)), 1.0, length(vec3(0.0, 0.0, 0.0)), 1.0, determinant(mat2(sqrt(0.0), 0.0, 1.0, 0.0)), sqrt(1.0), 0.0, _GLF_ONE(1.0, injectionSwitch.y), 1.0, 1.0, 0.0, 1.0)))))))))
    barrier();
  }
 else
  {
  }
 atomicStore(checker[virtual_gid], read, 4, 64, _GLF_IDENTITY(4, (_GLF_IDENTITY(4, (false ? _GLF_FUZZED(89548) : 4))) << (0 & -37264)));
}

END

BUFFER tester DATA_TYPE uint32 SIZE 8388096 FILL 0
BUFFER expected DATA_TYPE uint32 SIZE 8388096 FILL 2
BUFFER injection DATA_TYPE vec2<float> DATA
 0.0 1.0
END
BUFFER checker DATA_TYPE uint32 SIZE 8388096 FILL 0
BUFFER expected_checker DATA_TYPE uint32 SIZE 8388096 FILL 0

PIPELINE compute test_pipe
  ATTACH test
  BIND BUFFER tester AS storage DESCRIPTOR_SET 0 BINDING 0 
  BIND BUFFER injection AS uniform DESCRIPTOR_SET 0 BINDING 1 
  BIND BUFFER checker AS storage DESCRIPTOR_SET 0 BINDING 2 

  SUBGROUP test
	  VARYING_SIZE on
  END
END

RUN test_pipe 65532 1 1
EXPECT checker EQ_BUFFER expected_checker
