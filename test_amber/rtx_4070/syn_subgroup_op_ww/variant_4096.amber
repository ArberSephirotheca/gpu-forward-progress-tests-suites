#!amber

DEVICE_FEATURE SubgroupSizeControl.subgroupSizeControl

SET ENGINE_DATA fence_timeout_ms 10000

SHADER compute test GLSL
#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 uint subgroup_id = gl_SubgroupID;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     barrier();
    }
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     do
      {
       if(_GLF_DEAD(false))
        return;
      }
     while(_GLF_WRAPPED_LOOP(false));
     return;
    }
   return;
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     return;
    }
  }
 do
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(false))
      return;
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       barrier();
      }
    }
  }
 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_DEAD(false))
    return;
  }
 uint subgroup_size = gl_SubgroupSize;
 if(_GLF_DEAD(false))
  {
   switch(_GLF_SWITCH(0))
    {
     case 94:
     uint _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v[38];
     case 0:
     case 4:
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        return;
       return;
      }
     case 26:
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       do
        {
         return;
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
     break;
     case 18:
     ivec3(-23834, 58811, 86080);
     default:
     1;
    }
  }
 if(_GLF_DEAD(false))
  barrier();
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = gl_NumWorkGroups.x;
 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
  {
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    continue;
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    break;
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        continue;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       continue;
      }
     return;
    }
  }
 uint workgroup_size = gl_WorkGroupSize.x;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  {
   do
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        return;
       return;
      }
    }
   while(_GLF_WRAPPED_LOOP(false));
   if(_GLF_DEAD(false))
    return;
   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      break;
     barrier();
    }
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         return;
        }
      }
    }
  }
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 if(_GLF_DEAD(false))
  {
   for(int _injected_loop_counter = (1 ^ 0); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
       if(_GLF_DEAD(false))
        barrier();
      }
     else
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         barrier();
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     barrier();
    }
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     barrier();
    }
   if(_GLF_DEAD(false))
    return;
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 uint workgroup_id = gl_WorkGroupID.x;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 do
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(false))
        {
         do
          {
           return;
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
      }
     else
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       return;
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
          }
         else
          {
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              return;
             barrier();
            }
           else
            {
            }
          }
        }
       if(_GLF_DEAD(false))
        return;
      }
     if(_GLF_DEAD(false))
      {
       do
        {
         if(_GLF_DEAD(false))
          return;
        }
       while(_GLF_WRAPPED_LOOP(false));
       barrier();
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), (! (false)) && true)))))
        barrier();
       barrier();
      }
    }
  }
 while(_GLF_WRAPPED_LOOP(false));
 do
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
      {
       do
        {
         switch(_GLF_SWITCH(0))
          {
           case 37:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
           while(false)
            {
             if((mat2x4(3861.9868, -1.4, 6900.2039, -2.0, -990.588, 1.5, 2.9, 5554.6062) != mat2x4(931.398, 9.0, -1591.0566, -0.7, 2.2, -42.59, 55.40, -4221.9427)))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 for(                 bvec2(true, false);
 true; sin(7.1))
                  {
                   bvec3 _GLF_SWITCH_2_0v;
                   if(_GLF_DEAD(false))
                    barrier();
                  }
                }
               else
                {
                }
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                   return;
                  }
                 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                  }
                 else
                  {
                   return;
                  }
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
              }
             else
              {
               if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
                continue;
               mat2x4(-5.8, -1.3, 2131.8389, 5.5, 1867.9708, -1.4, 63.87, 59.55);
               vec2 _GLF_SWITCH_2_1v;
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  break;
                 if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
                  continue;
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, bool(bvec2(true, true)))))
                  {
                   barrier();
                  }
                 else
                  {
                  }
                }
               if(_GLF_DEAD(false))
                continue;
               {
                do
                 {
                  if(_GLF_WRAPPED_IF_FALSE(false))
                   {
                    if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, true)))))
                     barrier();
                   }
                  else
                   {
                    mat4x2(-45.29, -6.3, 460.916, -45.85, 386.613, 4093.5314, -5.4, 7.8);
                   }
                 }
                while(_GLF_WRAPPED_LOOP(false));
                if(_GLF_DEAD(false))
                 {
                  switch(_GLF_SWITCH(0))
                   {
                    case 78:
                    asin(vec4(-7328.7991, -981.971, -93.48, -235.773));
                    case 0:
                    if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     barrier();
                    continue;
                    break;
                    case 25:
                    ivec4 _GLF_SWITCH_3_0v[39];
                    case 14:
                    ivec4(-68438, -45297, 94670, -39642);
                    default:
                    1;
                   }
                 }
                outerProduct(vec4(66.61, -74.52, -0.2, 2924.9460), vec3(7.2, 6.4, -288.333));
                mat2x3(9140.8548, -16.57, -5.0, 3793.9733, 9360.8560, 9607.0550);
                if(_GLF_DEAD(false))
                 return;
                for(int _injected_loop_counter = (0 & 58695); _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), int(1)))); _injected_loop_counter ++)
                 {
                  equal(uvec2(109861u, 58542u), uvec2(166676u, 95188u));
                 }
                mat4(-7.1, -9.5, -7043.1009, 4.3, 0.5, -8367.5402, -743.875, 13.11, -619.584, -362.140, -9533.8620, 65.19, 4.7, 2.7, 33.73, -0.9);
                mat2x4 _GLF_SWITCH_2_2v[59];
                false;
               }
               if(_GLF_DEAD(false))
                barrier();
               ivec4(16726, -88440, -60302, -38943);
               ;
               if(_GLF_DEAD(false))
                break;
               (bvec4(true, true, false, false));
               uvec3 _GLF_SWITCH_2_3v;
               if(_GLF_DEAD(false))
                continue;
               {
                bvec3 _GLF_SWITCH_2_4v[13];
                _GLF_SWITCH_2_3v;
                lessThan((ivec3(17113, 7943, -19446) - max(ivec3(-28264, 57956, -50731), ivec3(-30781, 79585, -96507))), (ivec3(-38303, 82246, 33509) % ivec3(-60908, -81029, 71235)));
                for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                 {
                  switch(_GLF_SWITCH((0 >> _GLF_IDENTITY(int(8), int(8)))))
                   {
                    case 16:
                    mat4x2 _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v[96], _GLF_SWITCH_3_2v;
                    case 32:
                    (_GLF_SWITCH_3_0v - _GLF_SWITCH_3_2v);
                    case 0:
                    if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                     barrier();
                    case 24:
                    case 99:
                    mat3x4(2.2, -0.7, -77.65, -9.3, 1.4, 5.1, -0.9, -463.102, 340.303, 31.02, -415.643, 410.992);
                    break;
                    case 33:
                    mat4x3(9992.4428, -6162.5621, 16.32, -6.1, 5.0, -540.415, -5.1, 72.99, 2.1, 8.3, 98.56, -9.8);
                    default:
                    1;
                   }
                 }
                if(_GLF_DEAD(false))
                 continue;
               }
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             {
              (- mat4x2(-3.6, -9.8, -7075.3471, -9.2, 94.02, -1.6, 5.9, 1.8));
              if(_GLF_DEAD(false))
               break;
             }
             do
              {
               vec2(vec3(293.807, 705.430, -84.69));
              }
             while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, true && (false))));
            }
           case 0:
           case 5:
           case 97:
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            return;
           case 32:
           do
            {
             return;
            }
           while(_GLF_WRAPPED_LOOP(false));
           case 53:
           case 74:
           if(_GLF_DEAD(false))
            return;
           case 60:
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              {
               do
                {
                 if(_GLF_DEAD(false))
                  break;
                 return;
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             if(_GLF_DEAD(false))
              barrier();
             barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           case 42:
           case 99:
           if(_GLF_DEAD(false))
            return;
           break;
           case 31:
           while(true)
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(false))
                barrier();
               continue;
              }
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             {
              mat4x2(mat3(-16.73, -6.3, 23.46, 1953.3565, -64.61, -616.807, 848.472, -772.287, -391.615));
              if(_GLF_WRAPPED_IF_FALSE(false))
               {
               }
              else
               {
                uvec3(98636u, 136620u, 130454u);
               }
              if(_GLF_DEAD(false))
               return;
              for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 ^ 0)); _injected_loop_counter --)
               {
                if(_GLF_DEAD(false))
                 barrier();
                while(equal(ivec4(19125, -71118, 67610, -43529), ivec4(-1206, -97626, 41174, -10156))[2])
                 {
                  if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                   {
                    mat4x2(11.33, -1.1, -11.10, -9.2, 8.6, 997.706, 9.6, 6.0);
                   }
                  else
                   {
                   }
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   break;
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   break;
                  (vec2(8200.2384, 1760.6573) - min(acosh(injectionSwitch), -1903.5726));
                 }
               }
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
                switch(_GLF_SWITCH((0 >> _GLF_IDENTITY(int(8), _GLF_IDENTITY(int(8), (int(8)) >> 0)))))
                 {
                  case 45:
                  ivec2(77909, 72629);
                  case 0:
                  case 26:
                  case 84:
                  if(_GLF_DEAD(false))
                   continue;
                  case 99:
                  case 1:
                  continue;
                  break;
                  case 62:
                  ivec2(28533, 76915);
                  default:
                  1;
                 }
               }
              if(_GLF_DEAD(false))
               barrier();
              mat4(8.1, -9.9, -618.426, -9.7, -5.8, 6.7, -857.702, 598.259, 7837.8392, 26.52, -1.3, -330.567, -378.708, -2.0, 7.5, 92.88);
              if(_GLF_DEAD(false))
               barrier();
              for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
               {
                if(_GLF_DEAD(false))
                 {
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   break;
                  return;
                 }
               }
              mat2x3 _GLF_SWITCH_2_5v, _GLF_SWITCH_2_6v[59], _GLF_SWITCH_2_7v[73];
              do
               {
                ((num_workgroup ^ (uvec4(84977u, 170224u, 45847u, 120137u) % subgroup_id)) , false);
               }
              while(_GLF_WRAPPED_LOOP(false));
             }
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              return;
             float _GLF_SWITCH_2_8v[94], _GLF_SWITCH_2_9v, _GLF_SWITCH_2_10v;
             mat4x3 _GLF_SWITCH_2_11v;
             if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
              continue;
             if(_GLF_DEAD(false))
              barrier();
             ;
             if(_GLF_DEAD(false))
              return;
             if(true)
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
               for(               cosh(max(vec3(-8.1, 4926.2918, -6943.5613), vec3(921.219, -388.311, 4944.5570)));
 true; (ivec2(32659, 27659) & ivec2(-65716, 79760)))
                {
                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                  {
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                    }
                   else
                    {
                     switch(_GLF_SWITCH(((0 >> _GLF_IDENTITY(int(3), int(3))) | 0)))
                      {
                       case 0:
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        return;
                       for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(3), int(3))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                        {
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          return;
                        }
                       break;
                       case 4:
                       (_GLF_SWITCH_2_10v - mat3(754.979, -68.46, 4554.1418, 5.2, -3.7, -1242.8588, 381.132, 97.71, 5.6));
                       default:
                       1;
                      }
                    }
                  }
                 uvec4 _GLF_SWITCH_2_12v[31];
                 if(_GLF_DEAD(false))
                  continue;
                 ivec2 _GLF_SWITCH_2_13v, _GLF_SWITCH_2_14v, _GLF_SWITCH_2_15v;
                 bvec4 _GLF_SWITCH_2_16v, _GLF_SWITCH_2_17v, _GLF_SWITCH_2_18v;
                 if(_GLF_DEAD(false))
                  {
                   do
                    {
                     barrier();
                    }
                   while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                  }
                 do
                  {
                   mat2x4(-7.1, -8.9, -4.2, 73.39, 8.4, -33.35, 1671.1651, -56.65);
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                 bvec4 _GLF_SWITCH_2_19v, _GLF_SWITCH_2_20v;
                 if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec2(false, true), bvec2(bvec2(bvec2(false, true))))))))
                  barrier();
                 mat2(178.447, -759.219, -0.7, -3788.3250);
                }
               if((vec2(-4.6, 6413.3106) != vec2(-1720.5922, 953.507)))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                 ivec3 _GLF_SWITCH_2_21v, _GLF_SWITCH_2_22v[82];
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bool(false)), (bool(bool(false))) || false))))
                    barrier();
                   break;
                  }
                 mat2 _GLF_SWITCH_2_23v, _GLF_SWITCH_2_24v;
                 lessThan(uvec2(25570u, 98526u), uvec2(188857u, 195093u));
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                 vec4 _GLF_SWITCH_2_25v;
                 uvec4(170314u, 51686u, 14676u, 84208u);
                 if(_GLF_DEAD(false))
                  continue;
                 uint _GLF_SWITCH_2_26v[16], _GLF_SWITCH_2_27v;
                 mat2 _GLF_SWITCH_2_28v;
                }
               _GLF_SWITCH_2_11v;
               mat2x4(-8.8, 563.846, 48.41, -44.96, 4.0, -8.3, 10.02, -3201.1391);
               if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                  {
                   barrier();
                  }
                 else
                  {
                  }
                }
               mat4 _GLF_SWITCH_2_29v;
              }
             uint _GLF_SWITCH_2_30v, _GLF_SWITCH_2_31v, _GLF_SWITCH_2_32v;
             mat3 _GLF_SWITCH_2_33v, _GLF_SWITCH_2_34v;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               continue;
              }
             _GLF_SWITCH_2_11v;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             for(int _injected_loop_counter = (((((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), int(1))) | (0 & 54561)) << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), int(4))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
              {
               uvec4(12514u, 26611u, 7010u, 86518u);
              }
             if(_GLF_DEAD(false))
              break;
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           case 93:
           while((workgroup_id > workgroup_size))
            {
             for(int _injected_loop_counter = (int(_GLF_ONE(1.0, injectionSwitch.y)) ^ (0 | 0)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
             vec4(-376.901, -2.8, -1.2, 0.5);
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             if((-64144 >= 13901))
              {
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 {
                  if(_GLF_DEAD(false))
                   {
                    if(_GLF_WRAPPED_IF_FALSE(false))
                     {
                     }
                    else
                     {
                      return;
                     }
                   }
                  barrier();
                 }
                subgroup_size;
                do
                 {
                  transpose(mat4x3(-975.175, 7.0, 711.613, -3.1, 85.94, -79.99, -9.9, -98.88, -698.350, -2.9, 3.5, 25.10));
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   barrier();
                 }
                while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, ! (! (false)))));
                if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                 continue;
                ivec2 _GLF_SWITCH_2_35v, _GLF_SWITCH_2_36v;
                if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 {
                  if(_GLF_DEAD(false))
                   barrier();
                 }
                else
                 {
                  bvec3(false, bvec2(true, true));
                 }
                (true ? uvec3(129333u, 170242u, 128786u) : bitfieldReverse(uvec3(2415u, 153714u, 70877u)));
                bvec4(false, true, false, false);
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 barrier();
               }
               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                }
               else
                {
                }
              }
             else
              {
               uvec4 _GLF_SWITCH_2_37v[84], _GLF_SWITCH_2_38v, _GLF_SWITCH_2_39v[41];
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                break;
               {
                if(_GLF_DEAD(false))
                 barrier();
                do
                 {
                  if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
                   continue;
                  if(_GLF_DEAD(false))
                   barrier();
                  vec4(-18.46);
                  if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, false, false)))))
                   barrier();
                 }
                while(_GLF_WRAPPED_LOOP(false));
                if(_GLF_WRAPPED_IF_TRUE(true))
                 {
                  if(_GLF_DEAD(false))
                   {
                    if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     return;
                    barrier();
                   }
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   {
                    if(_GLF_DEAD(false))
                     barrier();
                    break;
                   }
                 }
                else
                 {
                 }
                mat2x3(7.2, -5161.1097, 5678.0088, -9339.1671, 691.436, -99.83);
                mat2x3(46.54, -13.90, 2831.6843, 8.8, 1939.7620, 5299.2788);
                if(_GLF_DEAD(false))
                 {
                  if(_GLF_DEAD(false))
                   barrier();
                  if(_GLF_DEAD(false))
                   return;
                  break;
                 }
                if(_GLF_DEAD(false))
                 break;
                do
                 {
                  mat2x3(21.87, -1886.4242, 5955.0048, -1634.6761, -84.79, -177.052);
                 }
                while(_GLF_WRAPPED_LOOP(false));
                mat2x3 _GLF_SWITCH_2_40v;
               }
               bvec3(false, false, true);
               mat3(-850.810, -5743.7588, 4.1, 7671.6932, -7.8, 14.75, 6555.8719, 1.8, -6.1);
               for(               (5449 * ivec4(36238, 98296, -15266, 52925));
 bvec3(true, true, false).t; mix((uvec2(159408u, 102649u) | uvec2(37111u, 108309u)), clamp((uvec2(139020u, 57977u) & uvec2(179919u, 85516u)), bitfieldExtract(uvec2(114868u, 34502u), -8271, 53974), uvec2(164063u, 111412u)), equal(bvec2(true, true), bvec2(false, false))))
                {
                 vec2 _GLF_SWITCH_2_41v;
                 ;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                 if(_GLF_DEAD(false))
                  continue;
                 vec2 _GLF_SWITCH_2_42v, _GLF_SWITCH_2_43v, _GLF_SWITCH_2_44v[63];
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(false))
                  break;
                 mat3x2 _GLF_SWITCH_2_45v, _GLF_SWITCH_2_46v;
                 ivec2(35313, 93422);
                 if(_GLF_DEAD(false))
                  return;
                 do
                  {
                   15727;
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(false))
                  break;
                 continue;
                }
               ;
               (mat4(2.7, 929.471, -0.2, -2.9, 5.3, -2843.5451, -9155.8073, -0.7, -9.6, 86.81, 418.769, 6.2, -79.60, -5.9, -54.61, -2115.8460));
               if(false)
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec4(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, false, false)))))
                  break;
                }
               else
                {
                 if(_GLF_DEAD(false))
                  break;
                 findLSB(ivec4(-49098, -18184, -47694, -78935));
                 if(_GLF_DEAD(false))
                  barrier();
                 (-79748 / -92791);
                 ;
                 if(_GLF_DEAD(false))
                  return;
                 if(_GLF_DEAD(false))
                  break;
                 mat3x4(-6081.9573, 5653.8499, 68.96, 3.4, -9.8, -59.50, 3590.2021, -5.7, -14.80, 40.79, -0.1, 334.248);
                 mat2(mat2x3(mat4(-0.6, 32.87, -9245.8003, -3.7, -5.2, -769.785, -5829.5099, 7.4, 78.89, 312.643, -24.67, 2.0, 9.3, -8.4, 354.231, -782.674)));
                 mat2(-619.485, 9.4, -3872.2828, -6.5);
                }
               if(_GLF_DEAD(false))
                continue;
              }
            }
           default:
           1;
          }
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
     else
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          barrier();
         return;
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
    }
   if(_GLF_DEAD(false))
    barrier();
  }
 while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, true && (false))));
 uint workgroup_base = workgroup_size * workgroup_id;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     return;
    }
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     return;
    }
   else
    {
     if(_GLF_DEAD(false))
      barrier();
    }
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    return;
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       switch(_GLF_SWITCH((1 ^ 1)))
        {
         case 4:
         while(true)
          {
           mat4 _GLF_SWITCH_3_0v[30], _GLF_SWITCH_3_1v, _GLF_SWITCH_3_2v[20];
          }
         case 51:
         int _GLF_SWITCH_3_3v;
         case 0:
         case 52:
         case 30:
         case 56:
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
          return;
         case 20:
         case 54:
         case 93:
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           do
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               do
                {
                 return;
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
              }
             if(_GLF_DEAD(false))
              barrier();
            }
           while(_GLF_WRAPPED_LOOP(false));
           barrier();
           if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
            return;
          }
         else
          {
          }
         break;
         case 64:
         do
          {
           while((subgroup_local_id > uint(false)))
            {
             uvec2 _GLF_SWITCH_3_4v, _GLF_SWITCH_3_5v;
             mat3x4(-4.7, -9.3, 429.864, -7.3, -1844.3020, -7685.0766, 31.78, 7.2, 4938.8567, 6.7, -82.67, -5292.5348);
             ivec4(-3131, -59607, -63229, 89707);
             mat2x4 _GLF_SWITCH_3_6v[79], _GLF_SWITCH_3_7v;
             mat4x3 _GLF_SWITCH_3_8v, _GLF_SWITCH_3_9v;
             bool _GLF_SWITCH_3_10v, _GLF_SWITCH_3_11v[31], _GLF_SWITCH_3_12v[47];
            }
           mat4 _GLF_SWITCH_3_13v, _GLF_SWITCH_3_14v;
           ;
           ivec3(-57355, -43213, -73182);
           for(           vec3(-693.725, 1577.4338, 59.50);
 false; lessThan(vec3(-9.3, 1.5, 0.7), vec3(9.6, 85.96, 68.82)))
            {
             ivec3 _GLF_SWITCH_3_15v;
             mat4(-2.1, 7.1, 73.29, 4.0, -765.485, -26.24, -9.9, -0.7, 9.4, 25.13, -966.682, -506.659, -823.798, -7624.8623, 590.923, -9.6);
             ivec3 _GLF_SWITCH_3_16v[71];
             uint _GLF_SWITCH_3_17v;
             ivec4 _GLF_SWITCH_3_18v[91], _GLF_SWITCH_3_19v[25], _GLF_SWITCH_3_20v;
             ;
             vec4 _GLF_SWITCH_3_21v, _GLF_SWITCH_3_22v, _GLF_SWITCH_3_23v;
             (uvec2(161961u, 189524u) | num_workgroup);
             mat3 _GLF_SWITCH_3_24v, _GLF_SWITCH_3_25v;
            }
           vec4(47.57, 93.58, 7.8, -3441.3371);
           {
            vec4 _GLF_SWITCH_3_26v, _GLF_SWITCH_3_27v;
           }
           while(true)
            {
             mat3(-2863.3630, 4.8, 628.121, 9131.6181, 98.32, 54.23, 3.6, 29.85, 664.527);
             _GLF_SWITCH_3_3v;
             (mat2x3(973.165, -660.457, 0.6, -1202.4448, -1.2, -507.819) * mat4x2(-1.7, 15.27, -37.84, -3.7, -8.9, 6098.6747, 440.124, -8.6));
             (mat3(81.87, -7078.2243, 1346.3537, 8.3, 67.17, 9.8, -164.541, 3.4, 193.352) / mat3(-9.3, -411.774, -10.89, 490.907, -228.385, -5.1, -41.95, -66.46, -3.4));
             ;
             ;
             mat4x2 _GLF_SWITCH_3_28v;
             mat4x3(4.9, -5.4, -66.01, 6.2, 3.5, 1.7, -5.8, -59.26, -27.34, -8184.9539, 6.3, 6.3);
            }
           ;
          }
         while(false);
         case 2:
         mat4x2 _GLF_SWITCH_3_29v[71], _GLF_SWITCH_3_30v;
         default:
         1;
        }
      }
    }
   else
    {
    }
   do
    {
     return;
    }
   while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       return;
      }
    }
  }
 uint virtual_gid = workgroup_base + subgroup_id * subgroup_size + subgroup_local_id;
 if(_GLF_DEAD(false))
  return;
 uint next_virtual_gid = workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size);
 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
  }
 else
  {
   switch(_GLF_SWITCH((((mat2x4(8.6, -4.4, -54.40, -4662.3850, 771.471, 2595.5656, -93.80, -2.8) != mat2x4(3801.0111, 395.373, -5.6, -2824.7865, -7785.2701, 9.9, 6.3, 2593.5440)) ? -37196 : -59995) & (0 << _GLF_IDENTITY(int(2), int(2))))))
    {
     case 72:
     if((mat4x3(-0.0, -2723.2876, 4.3, -6629.0257, -6770.9499, 28.83, -9.3, 6.7, 1.6, -6603.5201, -5.7, 39.57) == mat4x3(3.9, -679.405, -1.1, -3.2, -3.0, -1187.5670, -4.8, 700.404, -2787.0348, -17.66, 762.986, 469.455)))
      {
       greaterThanEqual(uvec2(86383u, 60240u), (workgroup_size - uvec2(5452u, 66110u)));
       {
        vec3 _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v, _GLF_SWITCH_3_2v;
        for(        (mat2x3(542.031, -0.7, -1.0, 917.972, -8968.4069, 1.7) / (mat4x3(-437.005, -299.034, -8122.7237, -3493.1848, 63.88, -2913.0573, 5.4, 9917.3604, -426.668, -1.6, -71.06, 407.629) * mat2x4(48.91, 8382.5135, 45.97, 7.7, 9303.8083, -4.3, 71.47, 1.7)));
 (uvec2(36067u, 64637u) == uvec2(189821u, 71412u)); mat2x4(46.97, 8.4, 5143.6572, -8.4, 4.1, 6.1, 4.0, 8.0))
         {
          bvec4(true, true, true, false);
          uvec3(2249u, 117341u, 119448u).tp;
          ivec4(-23899, -88572, -86080, 49217);
          uvec4(128730u, 81022u, 78851u, 162723u);
          ;
          atomicOr(workgroup_id, subgroup_local_id);
         }
        vec4(-83.80, -3.9, -1.8, 0.3);
        lessThan(vec4(-4.7, 3.4, 45.02, 9.1), vec4(-612.496, 7.7, 6.0, -7684.8860)).zw;
        ivec2 _GLF_SWITCH_3_3v[67], _GLF_SWITCH_3_4v;
        if((false ? (vec4(-9.2, -819.997, -2304.4719, -68.35)[2] == 8374.4818) : false))
         {
          uvec3(47542u, 43001u, 67702u);
          (_GLF_SWITCH_3_0v + vec3(817.667, 24.54, -891.102));
         }
        else
         {
          float _GLF_SWITCH_3_5v[10];
          mat2x3 _GLF_SWITCH_3_6v, _GLF_SWITCH_3_7v[32], _GLF_SWITCH_3_8v;
          ivec3 _GLF_SWITCH_3_9v;
         }
        if(false)
         {
          (mat4x3(-78.20, 9204.0647, -3498.0467, 6696.2231, -1702.0282, 50.38, -7.5, 6775.7557, 8.0, -9.7, 839.654, -312.180) * mat3x4(-1348.4234, -217.655, -244.300, -6792.1295, -9.3, 545.825, 741.547, 49.78, -582.789, -1.7, -5.0, -5.8));
          ivec2 _GLF_SWITCH_3_10v[87], _GLF_SWITCH_3_11v[41], _GLF_SWITCH_3_12v;
          true;
          mat2x3(73.09, -1.6, 2.0, 5479.8920, 7.4, -7.2);
          uvec3(195782u, 112379u, 54364u);
          3.5;
          (+ mat2x3(43.30, -64.95, 1366.2762, -61.14, -8689.2614, 5148.3971));
          bvec2(true, false);
          uvec4(146288u, 118143u, 1475u, 60871u);
         }
        else
         {
          uvec3(uvec4(112618u, 41860u, 102272u, 123395u));
          (mat3x4(-8111.7648, 14.55, 2.3, -1729.3883, 482.102, 8.2, -4.6, -345.471, -3.3, -1643.2486, 4.3, -1048.1045) + mat3x4(33.48, 124.100, -94.14, 83.20, -9931.7327, -2.1, 3329.9322, 4046.2612, -78.96, 5.9, 6.2, -6141.4181));
          ;
          workgroup_id;
         }
        mat3x2 _GLF_SWITCH_3_13v[4], _GLF_SWITCH_3_14v, _GLF_SWITCH_3_15v[91];
       }
       mat2x3 _GLF_SWITCH_3_16v;
       mat4x3(-6.2, -0.5, -5696.1580, -81.67, 49.33, 6.8, 7.4, 6.7, -8.8, -44.33, 7.9, -0.4);
       findLSB(ivec2(-1834, -36035));
       vec2 _GLF_SWITCH_3_17v[74], _GLF_SWITCH_3_18v;
       bvec2(true, false);
       mat2x4(2.4, -0.9, 9.2, -977.913, 356.405, 5.8, 9.6, -3.5);
      }
     case 0:
     case 89:
     case 37:
     case 86:
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
      {
       atomicStore(buf[virtual_gid], uint(1), 4, 64, 4);
      }
     break;
     case 63:
     mat2x3(-2159.2865, -15.21, -5.3, 6.1, -450.579, 138.576);
     case 70:
     {
      {
       {
        mat3x2(-6.4, -5.1, -9.4, -601.861, -110.874, -9.1);
        70764;
        vec4(8228.6137, -7.7, -41.13, 341.496);
        mat3 _GLF_SWITCH_3_19v[57];
        uvec2(uvec4(85729u, 54544u, 150592u, 166601u));
        mat3x4 _GLF_SWITCH_3_20v, _GLF_SWITCH_3_21v, _GLF_SWITCH_3_22v;
        ;
        (packSnorm4x8(vec4(-5.3, 4.7, -9651.0392, 404.127)) < subgroup_size);
       }
       for(       mat4(-60.65, 9.0, -603.949, 4723.4688, 52.87, -0.2, -783.046, 8.8, -32.41, -4130.0614, -40.39, 8258.2835, 7.3, -1.2, -963.669, 4.6);
 (uvec4(41991u, 34714u, 4090u, 2605u) == uvec4(104018u, 95562u, 25796u, 114712u)); ((9.0 + mat3x4(-142.388, 1.8, -90.71, -2.1, -800.705, -4.3, -8932.1055, 501.217, 8335.0138, 9.3, 325.283, 3537.8677))))
        {
         float _GLF_SWITCH_3_23v;
         bvec2(false, false);
         bvec4 _GLF_SWITCH_3_24v, _GLF_SWITCH_3_25v;
         mat4(length(vec3(93.90, -0.9, 6.4)));
         (mat4x3(-57.03, 1.9, -8.0, -484.251, 61.23, -646.763, 1.8, 0.8, 3935.0503, 7268.3670, 205.614, 6875.7008) * mat3x4(315.820, -2.0, -721.400, 7.6, -1.5, 30.77, -3.1, 14.09, -7.7, -0.5, -1053.2133, -7.0));
         mat4x3(-2.6, -2.8, 7.3, -25.41, 9246.9002, -28.63, 8.9, -2.6, 8534.6772, 39.52, 5953.6737, 805.922);
        }
       ;
       if((bvec2(false, false) == bvec2(false, false)))
        {
         bvec3(false, false, false);
         bvec3(false, true, true);
        }
       else
        {
         (9.7 + (mat4(20.45, -56.13, 8235.7789, -56.30, 126.606, 934.284, 8.2, -986.834, 2.1, -9.4, -752.350, 0.0, 7.8, -1.7, 3.9, 7.1) + mat4(3889.3545, 7607.8806, 34.98, 822.698, -1.0, -2.1, 3490.7179, -53.80, -407.295, 222.306, -614.529, -6903.1922, 16.81, 3.4, 90.68, -1.6)));
        }
       int _GLF_SWITCH_3_26v, _GLF_SWITCH_3_27v, _GLF_SWITCH_3_28v;
       do
        {
         ivec2(-88039, 52281);
         bvec4(isinf(tanh(injectionSwitch)), (ivec2(48761, -10070) == ivec2(83347, 5728)), true);
         bvec3(false, false, false);
         mat2x4(374.646, 351.965, -4.1, 53.15, -11.69, -5511.8416, 38.09, 4.7);
        }
       while(false);
       clamp(((uvec4(80496u, 5377u, 42497u, 142886u) % uvec4(63745u, 91302u, 126231u, 148850u)) % uvec4(100531u, 114904u, 97474u, 73482u)), uvec4(166647u, 193280u, 77u, 89754u), uvec4(109275u, 14325u, 72068u, 60605u));
       if(true)
        {
         mat2x3 _GLF_SWITCH_3_29v;
         -38363;
         mat4 _GLF_SWITCH_3_30v, _GLF_SWITCH_3_31v;
         vec2 _GLF_SWITCH_3_32v[40], _GLF_SWITCH_3_33v, _GLF_SWITCH_3_34v;
        }
      }
      if(false)
       {
        ivec3 _GLF_SWITCH_3_35v, _GLF_SWITCH_3_36v, _GLF_SWITCH_3_37v;
        while(true)
         {
          7.0;
          bvec2 _GLF_SWITCH_3_38v;
          mat3x2 _GLF_SWITCH_3_39v[55];
          (mat4x2(-2247.7955, -45.61, -134.654, -3200.6673, 0.1, 8.9, 42.21, -3.7) , (uvec3(108266u, 136568u, 196474u) == uvec3(51219u, 157800u, 132346u)));
          mat4(5.4, 9.5, -3.3, -5.2, 98.94, 97.91, 4.5, 65.10, -578.171, 3882.0463, -2300.9375, -40.60, -9.1, -90.66, -60.73, -3.9);
          698.866;
          ivec2(11364, -84339);
         }
        for(mat4x2 _GLF_SWITCH_3_40v[31]; true; ivec2(11662, 67129))
         {
          (ivec3(38596, -10917, 97017) % -21893);
          -3229.9299;
          mat2x4 _GLF_SWITCH_3_41v, _GLF_SWITCH_3_42v[81];
          mat4 _GLF_SWITCH_3_43v, _GLF_SWITCH_3_44v[60], _GLF_SWITCH_3_45v;
          vec3(99.90, 793.258, -45.49);
          floatBitsToUint(vec4(-6.0, 359.363, -8.0, -6197.5441));
          injectionSwitch;
          findMSB(uvec2(93310u, 123587u));
         }
        while(true)
         {
          bool _GLF_SWITCH_3_46v, _GLF_SWITCH_3_47v[52], _GLF_SWITCH_3_48v;
          (ivec2(-72303, 76954) << ivec2(1672, 80536));
         }
        if(true)
         {
          uvec4(171704u, 171159u, 82625u, 188863u);
         }
        else
         {
         }
        while(true)
         {
          uvec3(51048u, 14999u, 5816u);
          virtual_gid;
          ;
          lessThanEqual(injectionSwitch, injectionSwitch);
          bvec2(true, true);
          mat3x2(73.58, -849.329, 50.60, -3907.3013, -884.563, -49.35);
         }
        mat4x3 _GLF_SWITCH_3_49v, _GLF_SWITCH_3_50v[96], _GLF_SWITCH_3_51v;
        (workgroup_size % uvec4(105897u, 130122u, 80415u, 57339u));
        int _GLF_SWITCH_3_52v[57], _GLF_SWITCH_3_53v;
       }
      for(      bvec3(false, true, false);
 false; bvec2(false, true))
       {
        if(false)
         {
          14724;
          ivec3(-83822, 26037, 92679);
          notEqual(bvec4(false, false, false, false), bvec4(true, true, false, true));
          ivec3 _GLF_SWITCH_3_54v;
          ;
          mat2x3 _GLF_SWITCH_3_55v;
          mat3 _GLF_SWITCH_3_56v;
          ivec2(-17963, -17855).r;
          ;
         }
        else
         {
          vec2 _GLF_SWITCH_3_57v[35], _GLF_SWITCH_3_58v;
          mat3x4 _GLF_SWITCH_3_59v[22], _GLF_SWITCH_3_60v;
          ;
          min(ivec2(-93755, -65923), -90425);
          ;
         }
        mat2(36.02, -2.9, -4.7, -739.838);
        ((-7.8 + mat2x3(-9.8, 7203.2516, -86.63, 20.73, -8.7, 9.8)) - 260.387);
        ;
        if(true)
         {
          false;
          ;
          ivec4 _GLF_SWITCH_3_61v;
          ((bvec2(false, false) == bvec2(false, true)) ? uvec3(143488u, 174308u, 147308u) : (uvec3(155378u, 28400u, 17825u) - workgroup_size));
          bvec2(true, true);
          mat2x3(-3441.5141, 6.6, -978.045, -0.9, -5.8, 34.83);
          ivec3(-46594, 8595, -21968);
          5.3;
          (transpose(mat3x2(-3669.7913, -5.9, 0.8, 766.550, 3.7, 3533.1094)) - mat2x3(-838.925, -2705.1426, 5940.2929, 737.944, 784.157, 110.243));
         }
        ;
        mat4x2 _GLF_SWITCH_3_62v[45], _GLF_SWITCH_3_63v, _GLF_SWITCH_3_64v[21];
        mat3x4 _GLF_SWITCH_3_65v[83];
       }
     }
     default:
     1;
    }
  }
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       else
        {
         return;
        }
      }
    }
  }
 else
  {
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
    {
     barrier();
    }
  }
 do
  {
   for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), int(2))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       break;
      }
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        break;
       if(subgroup_local_id + 1 < subgroup_size)
        {
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
         else
          {
           atomicStore(buf[next_virtual_gid], uint(2), 4, 64, 4);
          }
         subgroupAll(false);
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            barrier();
           return;
          }
        }
       else
        {
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           break;
          }
         switch(_GLF_SWITCH(0))
          {
           case 34:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
           if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                barrier();
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 continue;
                }
               return;
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             barrier();
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               break;
              }
            }
           bvec3(false, false, false);
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              continue;
             continue;
            }
           case 0:
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             switch(_GLF_SWITCH(0))
              {
               case 59:
               ((injectionSwitch - 256.781) == injectionSwitch);
               case 0:
               case 47:
               case 23:
               case 60:
               case 97:
               case 20:
               if(_GLF_DEAD(false))
                continue;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               if(_GLF_DEAD(false))
                return;
               case 38:
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                barrier();
               if(_GLF_DEAD(false))
                return;
               break;
               default:
               1;
               if(_GLF_DEAD(false))
                break;
              }
            }
           else
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(false))
                barrier();
               continue;
              }
            }
           else
            {
             atomicStore(buf[next_virtual_gid], uint(2), 4, 64, 4);
            }
           case 42:
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
              return;
             continue;
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               break;
              }
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_DEAD(false))
                barrier();
               return;
              }
             else
              {
              }
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
             barrier();
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, true && (false)))))))
              continue;
            }
           if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, ! (! (false)))))
            {
             do
              {
               if(_GLF_DEAD(false))
                continue;
               if(_GLF_DEAD(false))
                barrier();
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
             if(_GLF_DEAD(false))
              break;
            }
           else
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               continue;
              }
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                 if(_GLF_DEAD(false))
                  return;
                }
               else
                {
                 switch(_GLF_SWITCH((0 << _GLF_IDENTITY(int(2), int(2)))))
                  {
                   case 0:
                   case 81:
                   case 12:
                   case 76:
                   case 67:
                   case 28:
                   case 68:
                   case 58:
                   case 99:
                   case 57:
                   barrier();
                   break;
                   case 94:
                   bvec2 _GLF_SWITCH_3_0v;
                   default:
                   1;
                  }
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
              }
             if(_GLF_DEAD(false))
              {
               switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                {
                 case 44:
                 subgroup_local_id;
                 case 37:
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   outerProduct(vec3(22.15, 5.6, -883.548), vec3(4550.5965, 1161.7956, -6.3));
                  }
                 if(_GLF_DEAD(false))
                  barrier();
                 case 0:
                 case 94:
                 if(_GLF_DEAD(false))
                  return;
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    break;
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_DEAD(false))
                      continue;
                     break;
                    }
                   break;
                  }
                 case 29:
                 if(_GLF_DEAD(false))
                  return;
                 case 18:
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                     barrier();
                    }
                  }
                 else
                  {
                  }
                 if(_GLF_DEAD(false))
                  return;
                 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                  barrier();
                 case 75:
                 case 27:
                 if(_GLF_DEAD(false))
                  return;
                 case 53:
                 if(_GLF_DEAD(false))
                  return;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 case 8:
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(false))
                    return;
                   break;
                  }
                 switch(_GLF_SWITCH((0 << _GLF_IDENTITY(int(3), int(3)))))
                  {
                   case 33:
                   mat3x4 _GLF_SWITCH_0_0v[31], _GLF_SWITCH_0_1v;
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                   if(_GLF_DEAD(false))
                    return;
                   if(_GLF_DEAD(false))
                    barrier();
                   case 91:
                   if(_GLF_WRAPPED_IF_TRUE(true))
                    {
                     mat4x2(-8.5, -236.255, 788.945, 9.0, -7554.6265, -7.6, 9264.9281, 11.15);
                    }
                   else
                    {
                    }
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_WRAPPED_IF_FALSE(false))
                      {
                      }
                     else
                      {
                       if(_GLF_DEAD(false))
                        break;
                       return;
                      }
                     if(_GLF_DEAD(false))
                      barrier();
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_DEAD(false))
                        barrier();
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        break;
                       continue;
                      }
                    }
                   case 0:
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     return;
                    }
                   if(_GLF_DEAD(false))
                    return;
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_DEAD(false))
                    continue;
                   case 30:
                   case 39:
                   for(int _injected_loop_counter = _GLF_IDENTITY((1 ^ 1), ~ (~ ((1 ^ 1)))); _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(3), int(3))) >> _GLF_IDENTITY(int(3), _GLF_IDENTITY(int(3), clamp(int(3), int(3), _GLF_IDENTITY(int(3), 1 * (int(3)))))))); _injected_loop_counter ++)
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                    }
                   if(_GLF_DEAD(false))
                    break;
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      {
                       if(_GLF_DEAD(false))
                        barrier();
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        {
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          barrier();
                         continue;
                        }
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          barrier();
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_DEAD(false))
                            continue;
                           if(_GLF_WRAPPED_IF_TRUE(true))
                            {
                             if(_GLF_WRAPPED_IF_TRUE(true))
                              {
                               barrier();
                              }
                             else
                              {
                              }
                            }
                           else
                            {
                            }
                          }
                         break;
                        }
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          {
                           if(_GLF_DEAD(false))
                            {
                             if(_GLF_DEAD(false))
                              barrier();
                             return;
                            }
                           break;
                          }
                         barrier();
                        }
                       return;
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(false))
                          barrier();
                         do
                          {
                           return;
                          }
                         while(_GLF_WRAPPED_LOOP(false));
                        }
                      }
                     if(_GLF_WRAPPED_IF_TRUE(true))
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        return;
                      }
                     else
                      {
                      }
                     if(_GLF_WRAPPED_IF_FALSE(false))
                      {
                      }
                     else
                      {
                       return;
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        barrier();
                      }
                     if(_GLF_DEAD(false))
                      break;
                     if(_GLF_DEAD(false))
                      {
                       switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                        {
                         case 0:
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_DEAD(false))
                            {
                             if(_GLF_DEAD(false))
                              return;
                             continue;
                            }
                           barrier();
                          }
                         case 88:
                         case 33:
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          {
                           do
                            {
                             return;
                            }
                           while(_GLF_WRAPPED_LOOP(false));
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            continue;
                           if(_GLF_DEAD(false))
                            barrier();
                          }
                         case 60:
                         case 95:
                         if(_GLF_DEAD(false))
                          break;
                         case 34:
                         if(_GLF_DEAD(false))
                          return;
                         case 53:
                         case 2:
                         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                          {
                           if(_GLF_DEAD(false))
                            return;
                           barrier();
                           if(_GLF_DEAD(false))
                            continue;
                          }
                         do
                          {
                           if(_GLF_WRAPPED_IF_FALSE(false))
                            {
                            }
                           else
                            {
                             return;
                            }
                          }
                         while(_GLF_WRAPPED_LOOP(false));
                         if(_GLF_DEAD(false))
                          barrier();
                         break;
                         if(_GLF_DEAD(false))
                          continue;
                         if(_GLF_DEAD(false))
                          continue;
                         default:
                         if(_GLF_DEAD(false))
                          barrier();
                         if(_GLF_DEAD(false))
                          barrier();
                         if(_GLF_DEAD(false))
                          return;
                         if(_GLF_DEAD(false))
                          return;
                         if(_GLF_DEAD(false))
                          barrier();
                         if(_GLF_DEAD(false))
                          break;
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          barrier();
                         1;
                         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                          {
                           if(_GLF_DEAD(false))
                            barrier();
                          }
                         if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                          barrier();
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          return;
                        }
                      }
                    }
                   case 94:
                   if(_GLF_DEAD(false))
                    continue;
                   case 19:
                   if(_GLF_DEAD(false))
                    return;
                   if(_GLF_DEAD(false))
                    {
                     switch(_GLF_SWITCH(0))
                      {
                       case 10:
                       if(_GLF_DEAD(false))
                        continue;
                       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                        {
                         (mat2(586.410, -631.831, -392.683, 298.944) , mat3(-8.9, -6.0, 9.8, 1.6, -6083.9344, 2416.2470, 7.1, -3.8, -3.2));
                        }
                       else
                        {
                        }
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        barrier();
                       case 0:
                       case 6:
                       if(_GLF_DEAD(false))
                        {
                         switch(_GLF_SWITCH(0))
                          {
                           case 39:
                           _GLF_SWITCH_0_1v;
                           case 0:
                           case 95:
                           case 13:
                           case 14:
                           case 81:
                           if(_GLF_DEAD(false))
                            continue;
                           case 46:
                           case 76:
                           case 98:
                           case 34:
                           barrier();
                           break;
                           default:
                           1;
                          }
                        }
                       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                        {
                         if(_GLF_DEAD(false))
                          barrier();
                         switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                          {
                           case 47:
                           if(_GLF_DEAD(false))
                            barrier();
                           bvec2 _GLF_SWITCH_1_0v, _GLF_SWITCH_1_1v;
                           if(_GLF_DEAD(false))
                            barrier();
                           case 0:
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            continue;
                           do
                            {
                             if(_GLF_DEAD(false))
                              {
                               if(_GLF_DEAD(false))
                                return;
                               barrier();
                               if(_GLF_DEAD(false))
                                barrier();
                              }
                            }
                           while(_GLF_WRAPPED_LOOP(false));
                           return;
                           break;
                           default:
                           if(_GLF_DEAD(false))
                            {
                             if(_GLF_DEAD(false))
                              break;
                             if(_GLF_DEAD(false))
                              return;
                             barrier();
                            }
                           1;
                          }
                        }
                       else
                        {
                        }
                       break;
                       case 60:
                       if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                        barrier();
                       if(_GLF_DEAD(false))
                        break;
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          barrier();
                         do
                          {
                           return;
                           if(_GLF_DEAD(false))
                            barrier();
                          }
                         while(_GLF_WRAPPED_LOOP(false));
                        }
                       false;
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        return;
                       default:
                       1;
                      }
                    }
                   case 58:
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_DEAD(false))
                        barrier();
                       barrier();
                      }
                     if(_GLF_DEAD(false))
                      continue;
                     return;
                    }
                   barrier();
                   if(_GLF_DEAD(false))
                    barrier();
                   break;
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                      break;
                     barrier();
                    }
                   do
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      return;
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                   if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                    return;
                   case 59:
                   mat4 _GLF_SWITCH_0_2v, _GLF_SWITCH_0_3v[83], _GLF_SWITCH_0_4v[35];
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(false))
                          barrier();
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            barrier();
                           continue;
                          }
                         barrier();
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          barrier();
                         if(_GLF_DEAD(false))
                          continue;
                        }
                       if(_GLF_DEAD(false))
                        break;
                       return;
                      }
                     return;
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                    }
                   case 4:
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     barrier();
                    }
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     continue;
                    }
                   if(_GLF_DEAD(false))
                    barrier();
                   bvec4((ivec3(45968, 41902, 34821) == ivec3(73627, -30850, -49142)), greaterThan((uvec2(11278u, 164441u) - uvec2(60584u, 22932u)), uvec2(146462u, 57383u)), false);
                   default:
                   if(_GLF_DEAD(false))
                    break;
                   1;
                   if(_GLF_DEAD(false))
                    continue;
                  }
                 break;
                 case 62:
                 for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   -3.3;
                  }
                 case 67:
                 for(int _injected_loop_counter = (0 | 1); _GLF_WRAPPED_LOOP(_injected_loop_counter > ((int(_GLF_ZERO(0.0, injectionSwitch.x)) & -36127) & (false ? 14749 : 98313))); _injected_loop_counter --)
                  {
                   (injectionSwitch - -8.4);
                  }
                 for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(7), int(7))); _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 | 1)); _injected_loop_counter ++)
                  {
                   do
                    {
                     if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, true)))))
                      barrier();
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                  }
                 default:
                 1;
                }
              }
            }
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            break;
           subgroupAll(true);
           break;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              return;
             barrier();
            }
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 >> _GLF_IDENTITY(int(4), int(4)))); _injected_loop_counter --)
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(false))
                  break;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 break;
                }
               return;
              }
             if(_GLF_DEAD(false))
              break;
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              break;
             for(int _injected_loop_counter = (1 & 1); _GLF_WRAPPED_LOOP(_injected_loop_counter > (-79103 & 0)); _injected_loop_counter --)
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 barrier();
                }
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                 barrier();
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                  }
                 else
                  {
                  }
                }
               else
                {
                 if(_GLF_DEAD(false))
                  continue;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(false))
                    continue;
                   return;
                  }
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                  }
                 else
                  {
                  }
                 if(_GLF_DEAD(false))
                  barrier();
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  continue;
                 if(_GLF_DEAD(false))
                  barrier();
                 return;
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
               barrier();
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                return;
              }
             if(_GLF_DEAD(false))
              break;
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
              continue;
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
               return;
              }
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   barrier();
                  }
                 else
                  {
                  }
                }
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(false))
                barrier();
               return;
              }
             barrier();
            }
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             do
              {
               if(_GLF_DEAD(false))
                continue;
               if(_GLF_DEAD(false))
                return;
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
              {
               if(_GLF_DEAD(false))
                return;
               return;
               if(_GLF_DEAD(false))
                barrier();
              }
             return;
            }
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   break;
                  }
                 barrier();
                }
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             return;
            }
           if(_GLF_DEAD(false))
            break;
           default:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))))
              break;
             barrier();
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             continue;
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             if(_GLF_DEAD(false))
              barrier();
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
              {
               if(_GLF_DEAD(false))
                continue;
               return;
              }
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
              break;
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(false))
            continue;
           1;
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             switch(_GLF_SWITCH(0))
              {
               case 0:
               case 14:
               if(_GLF_DEAD(false))
                return;
               case 18:
               case 94:
               case 43:
               case 91:
               barrier();
               break;
               case 87:
               mat4((3.4 - mat2x4(-743.496, 209.877, -17.12, 62.24, -1.4, -601.542, 9832.9496, 8.2)));
               default:
               1;
              }
            }
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               return;
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(false))
                  continue;
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   if(_GLF_DEAD(false))
                    continue;
                   return;
                  }
                 else
                  {
                  }
                 if(_GLF_DEAD(false))
                  continue;
                }
               barrier();
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                continue;
               for(int _injected_loop_counter = (1 | (0 >> _GLF_IDENTITY(int(5), int(5)))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(false))
                    {
                     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                      {
                       if(_GLF_DEAD(false))
                        return;
                      }
                     barrier();
                    }
                   barrier();
                  }
                }
               for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), int(ivec4(int(0), 0, 0, int(_GLF_ONE(1.0, injectionSwitch.y))))))) >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), (int(0)) | 0))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   return;
                  }
                }
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < ((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), (true ? int(2) : _GLF_FUZZED(77539))))) >> _GLF_IDENTITY(int(2), int(2)))); _injected_loop_counter ++)
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                    }
                   else
                    {
                     return;
                    }
                  }
                 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                   barrier();
                  }
                }
               switch(_GLF_SWITCH(0))
                {
                 case 0:
                 case 87:
                 case 1:
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                 if(_GLF_DEAD(false))
                  barrier();
                 case 68:
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                 case 13:
                 if(_GLF_DEAD(false))
                  barrier();
                 case 24:
                 case 48:
                 if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                  continue;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 break;
                 if(_GLF_DEAD(false))
                  continue;
                 case 46:
                 if(_GLF_DEAD(false))
                  continue;
                 (ivec3(-86380, -50061, 31205) == ivec3(56785, -2420, -51262));
                 if(_GLF_DEAD(false))
                  break;
                 default:
                 if(_GLF_DEAD(false))
                  continue;
                 1;
                }
               do
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
              }
             do
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    return;
                  }
                 return;
                }
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
             if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
              continue;
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
            }
           else
            {
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(false))
              break;
             do
              {
               if(_GLF_DEAD(false))
                continue;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   switch(_GLF_SWITCH(0))
                    {
                     case 61:
                     round(vec2(-2.8, 2836.7552));
                     case 5:
                     ivec3(-30778, -69524, -26066);
                     case 0:
                     case 32:
                     case 47:
                     case 11:
                     case 71:
                     case 66:
                     case 78:
                     barrier();
                     break;
                     case 50:
                     mix(exp(vec3(-70.75, 6.9, -318.390)), vec3(-3.5, 4.4, 0.6), acos(mat2x3(5.4, -7.6, -7934.8428, -4.1, -72.47, -732.393)[0]));
                     case 38:
                     ivec2 _GLF_SWITCH_3_0v;
                     default:
                     1;
                    }
                  }
                 else
                  {
                  }
                 if(_GLF_DEAD(false))
                  barrier();
                }
               for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    break;
                   barrier();
                  }
                }
               if(_GLF_DEAD(false))
                break;
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              break;
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), int(1))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                {
                 if(_GLF_DEAD(false))
                  {
                   switch(_GLF_SWITCH(0))
                    {
                     case 0:
                     if(_GLF_DEAD(false))
                      return;
                     case 66:
                     case 64:
                     continue;
                     break;
                     default:
                     1;
                    }
                  }
                 if(_GLF_DEAD(false))
                  break;
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(false))
                  break;
                 return;
                 if(_GLF_DEAD(false))
                  barrier();
                }
              }
             else
              {
              }
            }
           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
            return;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
             return;
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            barrier();
           continue;
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           barrier();
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
             barrier();
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             continue;
            }
           return;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
              continue;
             break;
            }
          }
        }
       if(_GLF_DEAD(false))
        continue;
       if(_GLF_DEAD(false))
        {
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 ^ 0)); _injected_loop_counter ++)
          {
           barrier();
          }
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           continue;
          }
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           barrier();
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
              {
               case 38:
               (- ivec3(90468, -92028, -56723));
               case 16:
               ivec2(17056, 66680);
               case 0:
               case 15:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               continue;
               break;
               case 42:
               float _GLF_SWITCH_3_0v[96], _GLF_SWITCH_3_1v;
               case 22:
               int _GLF_SWITCH_3_2v, _GLF_SWITCH_3_3v, _GLF_SWITCH_3_4v[17];
               default:
               1;
              }
            }
          }
         if(_GLF_DEAD(false))
          break;
        }
      }
    }
  }
 while(_GLF_WRAPPED_LOOP(false));
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   if(_GLF_DEAD(false))
    {
     do
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       return;
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
  }
 else
  {
  }
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          return;
         return;
        }
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            return;
           return;
          }
         barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
        }
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           return;
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
        }
       return;
      }
    }
   else
    {
    }
   do
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
    }
   while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, (false) || false)) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))));
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     do
      {
       barrier();
      }
     while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (false))));
     if(_GLF_DEAD(false))
      barrier();
    }
   barrier();
  }
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   do
    {
     if(_GLF_DEAD(false))
      return;
    }
   while(_GLF_WRAPPED_LOOP(false));
   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       barrier();
      }
    }
   else
    {
    }
   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
    }
   else
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           return;
          }
         barrier();
         if(_GLF_DEAD(false))
          barrier();
        }
       else
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            barrier();
           return;
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
        }
      }
    }
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    return;
   return;
  }
}

END

BUFFER tester DATA_TYPE uint32 SIZE 8388096 FILL 0
BUFFER expected DATA_TYPE uint32 SIZE 8388096 FILL 2
BUFFER injection DATA_TYPE vec2<float> DATA
 0.0 1.0
END

PIPELINE compute test_pipe
  ATTACH test
  BIND BUFFER tester AS storage DESCRIPTOR_SET 0 BINDING 0 
  BIND BUFFER injection AS uniform DESCRIPTOR_SET 0 BINDING 1 

  SUBGROUP test
	  VARYING_SIZE on
  END
END

RUN test_pipe 65532 1 1
EXPECT tester EQ_BUFFER expected
