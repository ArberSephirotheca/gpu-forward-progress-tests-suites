#!amber

DEVICE_FEATURE SubgroupSizeControl.subgroupSizeControl

SET ENGINE_DATA fence_timeout_ms 10000

SHADER compute test GLSL
#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer Checker {
 uint checker[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = gl_NumWorkGroups.x;
 uint workgroup_size = gl_WorkGroupSize.x;
 uint workgroup_id = gl_WorkGroupID.x;
 uint workgroup_base = workgroup_size * workgroup_id;
 uint virtual_gid = workgroup_base + subgroup_id * subgroup_size + subgroup_local_id;
 uint next_virtual_gid = workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size);
 uint read = atomicLoad(buf[virtual_gid], 4, 64, 0);
 atomicStore(buf[next_virtual_gid], uint(1), 4, 64, 4);
 if(subgroup_local_id + 1 < subgroup_size)
  {
   switch(_GLF_SWITCH(0))
    {
     case 39:
     while(bvec2(false, true)[1])
      {
       while((bvec3(false, true, false) != bvec3(true, true, false)))
        {
         {
          bool _GLF_SWITCH_0_0v;
          ivec3(-64488, -25768, 87520);
          findMSB(12186u);
          ;
          subgroup_size;
          bvec4 _GLF_SWITCH_0_1v, _GLF_SWITCH_0_2v;
         }
         if(bool(-14120))
          {
          }
        }
       if((mix(bvec2(false, false), bvec2(true, true), bvec2(true, true)) == bvec4(false, false, true, true).ra))
        {
         while(false)
          {
           sign(vec3(-5.9, 72.41, 3.1));
           (mat3(-3.5, -6.0, -8.0, 420.799, -342.981, -9.1, 1313.2342, 97.91, -525.911));
           ;
           mix(ivec4(63027, 50425, -40465, 28796), ivec4(68898, 57972, 58926, -35970), bvec4(true, true, true, true));
          }
        }
       (uvec4(144697u, 70317u, 192219u, 2126u) + uvec4(125518u, 84755u, 93092u, 171788u));
       ;
       if((workgroup_base > packSnorm2x16(injectionSwitch)))
        {
         mat3x2(4.4, 8.5, 484.787, -0.0, 2.1, 44.44);
         bvec4(bvec2(false, false), not(bvec2(true, false)));
         ivec4 _GLF_SWITCH_0_3v;
         mat4(763.840, 53.47, -44.20, -0.3, 6.4, 4.2, 0.8, 834.832, -1206.3419, 3.4, -0.5, 36.50, 49.89, 8.4, -694.440, 4.9);
         bvec3 _GLF_SWITCH_0_4v;
         while((bvec4(true, false, true, true) == bvec4(false, true, true, false)))
          {
          }
         if(true)
          {
           mat2x3 _GLF_SWITCH_0_5v, _GLF_SWITCH_0_6v, _GLF_SWITCH_0_7v;
           mat4x2(mat4(251.805, 43.79, -4.4, 3204.2041, 651.885, 652.947, 6.5, -2259.6122, -6.1, 5326.6895, 6.3, 63.47, -8.8, -9.4, -3896.7803, -4.8));
           ivec2 _GLF_SWITCH_0_8v, _GLF_SWITCH_0_9v[42];
           ;
           uvec2(49478u, 35078u);
           bitfieldInsert(21537, 9142, (62752 << -67409), int(464.986));
          }
         mat3x4 _GLF_SWITCH_0_10v, _GLF_SWITCH_0_11v;
        }
       else
        {
         ivec2(41301, 44248);
         if(false)
          {
           refract(vec4(-1524.4383, 216.663, -3.1, 896.314), tan(radians(vec4(-5.1, -628.130, 434.780, -96.33))), dot(1576.5726, -9.8));
           mat2x4(-2896.3439, -46.45, 29.97, -6.9, 1.6, 6.6, 1.0, 166.102);
          }
         else
          {
          }
         -66897;
         for(         uvec4(84985u, 87436u, 134351u, 120044u);
 true; (mat3x2(8.5, 4.3, -7647.1446, 2.6, 3.3, -0.3) * mat3(0.8, -976.463, 1.6, 9691.7488, 4.1, -9.2, -5532.1067, 14.50, -58.18)))
          {
           int _GLF_SWITCH_0_12v, _GLF_SWITCH_0_13v;
           vec2(8.7, -4.6);
           uvec4 _GLF_SWITCH_0_14v, _GLF_SWITCH_0_15v, _GLF_SWITCH_0_16v;
           bvec2(true, true);
           mat3 _GLF_SWITCH_0_17v, _GLF_SWITCH_0_18v, _GLF_SWITCH_0_19v;
           uvec2 _GLF_SWITCH_0_20v[22], _GLF_SWITCH_0_21v, _GLF_SWITCH_0_22v[76];
           mat3 _GLF_SWITCH_0_23v;
           mat4x3(mat2x3(-4.6, -423.163, 9675.7964, -2.6, 1.9, 654.688));
          }
         ivec2(-51730, -66497);
         ivec2(-21987, 18412);
         floor(vec4(7.1, -4.2, -12.20, -2.8));
         mat3x4 _GLF_SWITCH_0_24v;
        }
       if(false)
        {
         for(         ivec2(17244, 58437);
 true; false)
          {
          }
         {
          mat2x4(-2.3, 0.2, 335.043, 1.5, -742.985, 85.93, -891.731, 1796.7938);
          mat3x2 _GLF_SWITCH_0_25v[34];
          ivec4(54856, -16040, -95731, 89602);
          ;
          uint _GLF_SWITCH_0_26v, _GLF_SWITCH_0_27v, _GLF_SWITCH_0_28v;
          bool _GLF_SWITCH_0_29v, _GLF_SWITCH_0_30v, _GLF_SWITCH_0_31v;
          ;
         }
         mat3x2 _GLF_SWITCH_0_32v, _GLF_SWITCH_0_33v;
         bool _GLF_SWITCH_0_34v;
         ;
         vec2 _GLF_SWITCH_0_35v[87], _GLF_SWITCH_0_36v[53], _GLF_SWITCH_0_37v[50];
         (_GLF_SWITCH_0_33v --);
        }
       mat4(-381.424, 5.9, -3.0, 590.064, -9.4, -50.52, -457.504, -6.6, 123.250, 7.7, -8.7, 560.559, -25.11, 4.1, 4.1, -43.97);
       mat2x3 _GLF_SWITCH_0_38v[32], _GLF_SWITCH_0_39v[62];
      }
     case 0:
     case 88:
     case 56:
     case 80:
     int i = 0;
     case 99:
     case 85:
     case 69:
     case 53:
     case 29:
     atomicStore(checker[virtual_gid], read, 4, 64, 4);
     break;
     case 27:
     while(true)
      {
       mat4x3(6.8, 48.45, -6357.1775, 6282.6971, -2551.3336, 7340.7346, -1350.6023, -1054.4070, -0.8, -1945.6250, 8.1, -46.31);
       uvec3 _GLF_SWITCH_0_40v[45], _GLF_SWITCH_0_41v;
       44981;
       (mat2x4(3.7, -3787.4133, 415.412, 1229.9348, -209.790, 967.228, 21.34, 860.310) / mat2x4(916.082, -9.5, 6.9, 879.540, -2983.7427, 1.3, 105.902, 628.456));
       mat3x4 _GLF_SWITCH_0_42v, _GLF_SWITCH_0_43v;
      }
     case 7:
     bvec3(true, true, true);
     default:
     1;
    }
  }
 else
  {
   atomicStore(checker[virtual_gid], read, 4, 64, 4);
  }
}

END

BUFFER tester DATA_TYPE uint32 SIZE 8388096 FILL 0
BUFFER expected DATA_TYPE uint32 SIZE 8388096 FILL 2
BUFFER injection DATA_TYPE vec2<float> DATA
 0.0 1.0
END
BUFFER checker DATA_TYPE uint32 SIZE 8388096 FILL 0
BUFFER expected_checker DATA_TYPE uint32 SIZE 8388096 FILL 0

PIPELINE compute test_pipe
  ATTACH test
  BIND BUFFER tester AS storage DESCRIPTOR_SET 0 BINDING 0 
  BIND BUFFER injection AS uniform DESCRIPTOR_SET 0 BINDING 1 
  BIND BUFFER checker AS storage DESCRIPTOR_SET 0 BINDING 2 

  SUBGROUP test
	  VARYING_SIZE on
  END
END

RUN test_pipe 65532 1 1
EXPECT checker EQ_BUFFER expected_checker
