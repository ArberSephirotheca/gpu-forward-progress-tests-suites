#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


struct _GLF_struct_38 {
 uvec2 _f0;
 bvec2 _f1;
 mat4x3 _f2;
 bvec3 _f3;
 ivec3 _f4;
 uvec4 _f5;
} ;

struct _GLF_struct_37 {
 mat2x4 _f0;
 mat4x3 _f1;
 int _f2;
 uvec2 _f3;
 uvec2 _f4;
} ;

struct _GLF_struct_39 {
 mat4 _f0;
 int _f1;
 float _f2;
 mat2 _f3;
 _GLF_struct_37 _f4;
 _GLF_struct_38 _f5;
} ;

struct _GLF_struct_35 {
 uint num_workgroup;
 mat3x2 _f0;
 mat3x2 _f1;
 vec2 _f2;
 mat3 _f3;
} ;

struct _GLF_struct_36 {
 _GLF_struct_35 _f0;
 mat4x2 _f1;
 mat3 _f2;
} ;

struct _GLF_struct_40 {
 bool _f0;
 _GLF_struct_36 _f1;
 mat3x4 _f2;
 _GLF_struct_39 _f3;
} ;

struct _GLF_struct_32 {
 mat3 _f0;
 bvec4 _f1;
} ;

struct _GLF_struct_31 {
 mat4 _f0;
 vec2 _f1;
 float _f2;
 vec3 _f3;
 mat4x2 _f4;
 bvec3 _f5;
} ;

struct _GLF_struct_30 {
 mat4x2 _f0;
 float _f1;
 bool _f2;
} ;

struct _GLF_struct_33 {
 bvec2 _f0;
 uvec4 _f1;
 _GLF_struct_30 _f2;
 bvec3 _f3;
 _GLF_struct_31 _f4;
 _GLF_struct_32 _f5;
} ;

struct _GLF_struct_29 {
 mat3x2 _f0;
 vec3 _f1;
 uvec3 _f2;
} ;

struct _GLF_struct_27 {
 mat2 _f0;
 ivec2 _f1;
 mat3x2 _f2;
 mat2x3 _f3;
 uint _f4;
 mat3 _f5;
} ;

struct _GLF_struct_28 {
 uvec3 _f0;
 bvec3 _f1;
 _GLF_struct_27 _f2;
} ;

struct _GLF_struct_25 {
 mat3 _f0;
 vec2 _f1;
 uvec3 _f2;
 mat4x2 _f3;
} ;

struct _GLF_struct_24 {
 uint _f0;
 bvec2 _f1;
} ;

struct _GLF_struct_23 {
 mat3x4 _f0;
 uvec4 _f1;
 ivec4 _f2;
 bvec4 _f3;
 uvec3 _f4;
 mat2x3 _f5;
 mat2x4 _f6;
} ;

struct _GLF_struct_26 {
 _GLF_struct_23 _f0;
 _GLF_struct_24 _f1;
 _GLF_struct_25 _f2;
} ;

struct _GLF_struct_34 {
 float _GLF_SWITCH_0_17v;
 _GLF_struct_26 _f0;
 _GLF_struct_28 _f1;
 _GLF_struct_29 _f2;
 mat4x2 _f3;
 _GLF_struct_33 _f4;
} ;

struct _GLF_struct_22 {
 mat2x3 _f0;
 uint workgroup_size;
} ;

struct _GLF_struct_19 {
 bvec3 _f0;
 mat4 _f1;
 uint _f2;
} ;

struct _GLF_struct_18 {
 vec4 _f0;
 float _f1;
} ;

struct _GLF_struct_17 {
 vec3 _f0;
 bvec2 _f1;
 mat2 _f2;
 uvec2 _f3;
} ;

struct _GLF_struct_20 {
 _GLF_struct_17 _f0;
 _GLF_struct_18 _f1;
 _GLF_struct_19 _f2;
 bool _f3;
 vec2 _f4;
 bool _f5;
 mat3x2 _f6;
} ;

struct _GLF_struct_21 {
 _GLF_struct_20 _f0;
 int _injected_loop_counter;
} ;

struct _GLF_struct_14 {
 ivec2 _f0;
 ivec2 _f1;
 mat4x2 _f2;
 mat2x3 _f3;
 mat3x4 _f4;
 bvec3 _f5;
 bool _f6;
} ;

struct _GLF_struct_13 {
 float _f0;
} ;

struct _GLF_struct_15 {
 _GLF_struct_13 _f0;
 _GLF_struct_14 _f1;
 bvec3 _f2;
 vec4 _f3;
 int _f4;
 float _f5;
} ;

struct _GLF_struct_16 {
 _GLF_struct_15 _f0;
 uint next_virtual_gid;
 bvec4 _f1;
} ;

struct _GLF_struct_10 {
 ivec2 _f0;
 uvec4 _f1;
 bvec2 _f2;
 int _f3;
} ;

struct _GLF_struct_9 {
 mat4x2 _f0;
} ;

struct _GLF_struct_8 {
 ivec4 _f0;
 int _f1;
 uint _f2;
 bvec4 _f3;
} ;

struct _GLF_struct_11 {
 _GLF_struct_8 _f0;
 _GLF_struct_9 _f1;
 _GLF_struct_10 _f2;
} ;

struct _GLF_struct_6 {
 mat2x3 _f0;
 mat4x2 _f1;
 uvec3 _f2;
} ;

struct _GLF_struct_5 {
 float _f0;
 bool _f1;
} ;

struct _GLF_struct_4 {
 uint _f0;
 ivec4 _f1;
 mat4 _f2;
 mat4x2 _f3;
 bvec3 _f4;
 mat4x2 _f5;
 mat2 _f6;
} ;

struct _GLF_struct_3 {
 int _f0;
 ivec2 _f1;
 bvec3 _f2;
 mat4x2 _f3;
 vec3 _f4;
 mat4x3 _f5;
} ;

struct _GLF_struct_2 {
 uvec3 _f0;
 mat2x3 _f1;
 mat3x4 _f2;
 mat2x4 _f3;
} ;

struct _GLF_struct_7 {
 _GLF_struct_2 _f0;
 _GLF_struct_3 _f1;
 _GLF_struct_4 _f2;
 _GLF_struct_5 _f3;
 _GLF_struct_6 _f4;
} ;

struct _GLF_struct_0 {
 mat2x4 _f0;
 mat2 _f1;
 mat2 _f2;
} ;

struct _GLF_struct_1 {
 _GLF_struct_0 _f0;
} ;

struct _GLF_struct_12 {
 _GLF_struct_1 _f0;
 ivec4 _f1;
 uint subgroup_id;
 _GLF_struct_7 _f2;
 _GLF_struct_11 _f3;
 mat3 _f4;
} ;

layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer Checker {
 uint checker[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
    {
     barrier();
    }
   else
    {
    }
  }
 if(_GLF_DEAD(false))
  {
   do
    {
     switch(_GLF_SWITCH(0))
      {
       case 0:
       case 4:
       case 54:
       case 62:
       case 5:
       case 3:
       case 92:
       if(_GLF_DEAD(false))
        continue;
       case 65:
       case 25:
       case 43:
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          break;
         barrier();
        }
       if(_GLF_DEAD(false))
        break;
       break;
       case 66:
       if(_GLF_DEAD(false))
        continue;
       if((bvec2(true, true) == bvec2(true, true)))
        {
         uvec2 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v, _GLF_SWITCH_4_2v[72];
        }
       default:
       1;
      }
    }
   while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, false || (false))));
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     barrier();
    }
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
     if(_GLF_DEAD(false))
      barrier();
    }
   else
    {
     return;
     if(_GLF_DEAD(false))
      return;
    }
  }
 _GLF_struct_12 _GLF_struct_replacement_12 = _GLF_struct_12(_GLF_struct_1(_GLF_struct_0(mat2x4(1.0), mat2(1.0), mat2(1.0))), ivec4(1), gl_SubgroupID, _GLF_struct_7(_GLF_struct_2(uvec3(1u), mat2x3(1.0), mat3x4(1.0), mat2x4(1.0)), _GLF_struct_3(1, ivec2(1), bvec3(true), mat4x2(1.0), vec3(1.0), mat4x3(1.0)), _GLF_struct_4(1u, ivec4(1), mat4(1.0), mat4x2(1.0), bvec3(true), mat4x2(1.0), mat2(1.0)), _GLF_struct_5(1.0, true), _GLF_struct_6(mat2x3(1.0), mat4x2(1.0), uvec3(1u))), _GLF_struct_11(_GLF_struct_8(ivec4(1), 1, 1u, bvec4(true)), _GLF_struct_9(mat4x2(1.0)), _GLF_struct_10(ivec2(1), uvec4(1u), bvec2(true), 1)), mat3(1.0));
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
    {
     return;
    }
  }
 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
      return;
     do
      {
       if(_GLF_DEAD(false))
        break;
       if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec4(false, false, false, true)), false || (bool(bvec4(false, false, false, true)))))))
        barrier();
       if(_GLF_DEAD(false))
        {
         switch(_GLF_SWITCH(0))
          {
           case 17:
           if(false)
            {
             float _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v;
             vec4(-1412.7237, -9996.0249, -62.49, -2.0);
             if(_GLF_DEAD(false))
              break;
             6.5;
             bvec2 _GLF_SWITCH_4_2v, _GLF_SWITCH_4_3v, _GLF_SWITCH_4_4v;
             uvec2 _GLF_SWITCH_4_5v, _GLF_SWITCH_4_6v, _GLF_SWITCH_4_7v;
             mat4x2 _GLF_SWITCH_4_8v, _GLF_SWITCH_4_9v;
             bvec4 _GLF_SWITCH_4_10v[9], _GLF_SWITCH_4_11v, _GLF_SWITCH_4_12v;
             mat2 _GLF_SWITCH_4_13v[27], _GLF_SWITCH_4_14v, _GLF_SWITCH_4_15v;
            }
           case 93:
           while(false)
            {
             vec3 _GLF_SWITCH_4_16v, _GLF_SWITCH_4_17v[56];
             mat2x3(-2838.7683, 834.532, -198.055, -69.90, 2.4, 3.4);
             (2.5);
             mat2 _GLF_SWITCH_4_18v, _GLF_SWITCH_4_19v, _GLF_SWITCH_4_20v;
             int _GLF_SWITCH_4_21v, _GLF_SWITCH_4_22v, _GLF_SWITCH_4_23v;
             if(_GLF_DEAD(false))
              continue;
            }
           case 0:
           case 32:
           case 25:
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 | 0)); _injected_loop_counter --)
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 ^ (0 << _GLF_IDENTITY(int(7), int(7))))); _injected_loop_counter ++)
                {
                 barrier();
                }
              }
             if(_GLF_DEAD(false))
              barrier();
             barrier();
            }
           case 27:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               if(_GLF_DEAD(false))
                break;
               barrier();
              }
             return;
            }
           break;
           case 84:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           while(true)
            {
             (+ mat4(-1.3, 5.4, 9.1, 7153.4917, 97.99, -1.8, 9447.2370, -6119.6248, 241.538, 7.4, -392.224, 5236.9351, -3.2, -884.266, 531.171, -99.19));
             ;
             ;
             mat3x4 _GLF_SWITCH_4_24v, _GLF_SWITCH_4_25v, _GLF_SWITCH_4_26v;
             ivec2 _GLF_SWITCH_4_27v, _GLF_SWITCH_4_28v[77];
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             ;
            }
           if(_GLF_DEAD(false))
            continue;
           default:
           1;
          }
         if(_GLF_DEAD(false))
          return;
        }
      }
     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, false || (false))) || false)))
      {
       for(int _injected_loop_counter = (int(_GLF_ZERO(0.0, injectionSwitch.x)) << _GLF_IDENTITY(int(3), int(3))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
        {
         return;
        }
      }
    }
   else
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        {
         do
          {
           return;
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
        }
       barrier();
      }
    }
  }
 if(_GLF_DEAD(false))
  return;
 uint subgroup_size = gl_SubgroupSize;
 if(_GLF_DEAD(false))
  {
   do
    {
     if(_GLF_DEAD(false))
      barrier();
    }
   while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_DEAD(false))
      barrier();
    }
   else
    {
    }
   if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, true)))))
    {
     do
      {
       if(_GLF_DEAD(false))
        return;
      }
     while(_GLF_WRAPPED_LOOP(false));
     return;
    }
   return;
  }
 do
  {
   for(int _injected_loop_counter = ((0 >> _GLF_IDENTITY(int(1), int(1))) | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 ^ 0)); _injected_loop_counter ++)
    {
     if(_GLF_DEAD(false))
      barrier();
    }
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        continue;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        continue;
       if(_GLF_DEAD(false))
        barrier();
      }
     else
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
        barrier();
       if(_GLF_DEAD(false))
        {
         do
          {
           barrier();
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     switch(_GLF_SWITCH(0))
      {
       case 65:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(false)
        {
         switch(_GLF_SWITCH((1 ^ 1)))
          {
           case 2:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           do
            {
             ivec2(96236, 52472);
            }
           while(_GLF_WRAPPED_LOOP(false));
           case 0:
           case 28:
           do
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             mat3 _GLF_SWITCH_0_0v[88], _GLF_SWITCH_0_1v, _GLF_SWITCH_0_2v;
             if(true)
              {
               if(_GLF_DEAD(false))
                continue;
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 barrier();
                 if(_GLF_DEAD(false))
                  barrier();
                }
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    return;
                  }
                 barrier();
                }
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   switch(_GLF_SWITCH(0))
                    {
                     case 73:
                     vec3 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v[11];
                     case 0:
                     case 91:
                     case 29:
                     case 34:
                     case 84:
                     do
                      {
                       barrier();
                      }
                     while(_GLF_WRAPPED_LOOP(false));
                     break;
                     case 83:
                     for(int _injected_loop_counter = (1 | 1); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                      {
                       mat3x4(-80.66, -10.67, 6.4, 683.220, -718.425, 3428.9610, 8.9, 45.51, 6.6, 7214.7027, -9361.6206, -8717.4596);
                      }
                     case 6:
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      break;
                     mat3x4 _GLF_SWITCH_4_2v;
                     default:
                     if(_GLF_DEAD(false))
                      break;
                     1;
                    }
                  }
                }
               do
                {
                 do
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    break;
                   if(_GLF_DEAD(false))
                    barrier();
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
               if(_GLF_DEAD(false))
                continue;
               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                {
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   if(_GLF_DEAD(false))
                    {
                     do
                      {
                       for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(5), int(5))) >> _GLF_IDENTITY(int(5), int(5))); _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 << _GLF_IDENTITY(int(8), int(8)))); _injected_loop_counter --)
                        {
                         if(_GLF_DEAD(false))
                          break;
                         if(_GLF_DEAD(false))
                          barrier();
                         return;
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          break;
                         if(_GLF_DEAD(false))
                          barrier();
                         if(_GLF_DEAD(false))
                          continue;
                         if(_GLF_DEAD(false))
                          continue;
                         if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(false, false, false, false)))))
                          barrier();
                         if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
                          break;
                        }
                      }
                     while(_GLF_WRAPPED_LOOP(false));
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                    }
                  }
                 else
                  {
                  }
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
               if(_GLF_DEAD(false))
                break;
               ivec4 _GLF_SWITCH_0_3v, _GLF_SWITCH_0_4v;
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                  }
                 else
                  {
                   return;
                  }
                }
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, (false) && true))))))
                  return;
                }
               else
                {
                }
               if(_GLF_DEAD(false))
                {
                 switch(_GLF_SWITCH((0 << _GLF_IDENTITY(int(7), int(7)))))
                  {
                   case 0:
                   case 39:
                   case 9:
                   if(_GLF_DEAD(false))
                    barrier();
                   case 81:
                   case 42:
                   case 79:
                   barrier();
                   break;
                   case 89:
                   do
                    {
                     mat2x4(37.17, 16.95, 32.85, 61.00, 8.2, -1.1, 5.9, 395.114);
                    }
                   while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                   default:
                   1;
                   if(_GLF_DEAD(false))
                    return;
                  }
                }
               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(false))
                  continue;
                }
               else
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    break;
                   do
                    {
                     barrier();
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                  }
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                 do
                  {
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     barrier();
                     if(_GLF_DEAD(false))
                      return;
                    }
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                 ;
                }
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 switch(_GLF_SWITCH(0))
                  {
                   case 0:
                   if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (_GLF_IDENTITY(false, bool(bvec4(false, true, true, false)))))))
                    {
                     if(_GLF_WRAPPED_IF_FALSE(false))
                      {
                      }
                     else
                      {
                       barrier();
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        barrier();
                      }
                     if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
                      continue;
                     if(_GLF_DEAD(false))
                      barrier();
                     if(_GLF_DEAD(false))
                      {
                       for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), int(2))); _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 << _GLF_IDENTITY(int(3), int(3)))); _injected_loop_counter --)
                        {
                         barrier();
                        }
                      }
                    }
                   if(_GLF_DEAD(false))
                    return;
                   break;
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(false, false, false, false)))))
                      barrier();
                     barrier();
                    }
                   case 61:
                   if(_GLF_DEAD(false))
                    continue;
                   ivec2 _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v, _GLF_SWITCH_2_2v;
                   default:
                   1;
                  }
                }
               else
                {
                }
               if(_GLF_DEAD(false))
                {
                 for(int _injected_loop_counter = (1 & int(_GLF_ONE(1.0, injectionSwitch.y))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                  {
                   barrier();
                  }
                }
               ivec3(85012, 31183, 92430);
               if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || false)))
                break;
               do
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                    {
                     barrier();
                    }
                   else
                    {
                    }
                  }
                }
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 mat2x3(-797.130, 8.5, 9286.6082, -6.1, -374.626, 255.901);
                }
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_DEAD(false))
                    {
                     switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                      {
                       case 49:
                       vec3 _GLF_SWITCH_4_0v;
                       case 0:
                       case 59:
                       if(_GLF_DEAD(false))
                        barrier();
                       case 67:
                       case 52:
                       case 57:
                       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        {
                        }
                       else
                        {
                         if(_GLF_DEAD(false))
                          barrier();
                         do
                          {
                           return;
                          }
                         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                        }
                       break;
                       case 76:
                       uvec2 _GLF_SWITCH_4_1v;
                       case 14:
                       vec3 _GLF_SWITCH_4_2v, _GLF_SWITCH_4_3v;
                       default:
                       1;
                      }
                    }
                   barrier();
                   if(_GLF_DEAD(false))
                    barrier();
                  }
                }
               else
                {
                }
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   barrier();
                  }
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    return;
                   barrier();
                  }
                }
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                  barrier();
                 barrier();
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                }
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                 if(_GLF_DEAD(false))
                  barrier();
                 do
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                 break;
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    break;
                   continue;
                  }
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      {
                      }
                     else
                      {
                       barrier();
                      }
                    }
                   if(_GLF_DEAD(false))
                    break;
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     barrier();
                    }
                   if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec3(false, true, false), bvec3(bvec3(bvec3(false, true, false))))))))
                    return;
                   do
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     barrier();
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                  }
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    break;
                   barrier();
                  }
                 if(_GLF_DEAD(false))
                  break;
                 barrier();
                 if(_GLF_DEAD(false))
                  break;
                 if(_GLF_DEAD(false))
                  return;
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
                  break;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                    barrier();
                   barrier();
                  }
                 do
                  {
                   if(_GLF_DEAD(false))
                    break;
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                      break;
                     barrier();
                    }
                   if(_GLF_DEAD(false))
                    break;
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 do
                  {
                   if(_GLF_DEAD(false))
                    {
                     do
                      {
                       return;
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(false))
                          continue;
                         barrier();
                        }
                      }
                     while(_GLF_WRAPPED_LOOP(false));
                    }
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) || false)));
                }
               if(_GLF_DEAD(false))
                barrier();
               do
                {
                 (mat4x3(mat2x3(-7.4, -8.1, 5.3, -5.1, 4088.1111, -4295.8224)) + mat4x3(75.86, 15.87, 612.577, -2.9, 1.6, -2.5, 3.8, -5148.0047, 56.97, -8808.2990, 4232.7062, -52.76));
                }
               while(_GLF_WRAPPED_LOOP(false));
               if(_GLF_DEAD(false))
                break;
              }
             else
              {
               switch(_GLF_SWITCH(0))
                {
                 case 96:
                 if(_GLF_DEAD(false))
                  break;
                 do
                  {
                   vec2(-0.8, 4.5);
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                 case 97:
                 lessThan(ivec3(55381, 82593, 19337), ivec3(-18582, 26837, 16343));
                 case 0:
                 case 90:
                 if(_GLF_DEAD(false))
                  {
                   do
                    {
                     return;
                    }
                   while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                  }
                 case 31:
                 case 98:
                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                  {
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                    }
                   else
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      {
                       if(_GLF_DEAD(false))
                        barrier();
                       barrier();
                      }
                    }
                  }
                 case 17:
                 switch(_GLF_SWITCH(_GLF_IDENTITY(0, 0 + (0))))
                  {
                   case 36:
                   if(_GLF_DEAD(false))
                    break;
                   if(_GLF_DEAD(false))
                    continue;
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_DEAD(false))
                    continue;
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        barrier();
                       barrier();
                      }
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      {
                       if(_GLF_DEAD(false))
                        continue;
                       break;
                      }
                     barrier();
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      {
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          continue;
                         barrier();
                        }
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        break;
                       break;
                      }
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                   vec2 _GLF_SWITCH_1_0v, _GLF_SWITCH_1_1v[41], _GLF_SWITCH_1_2v;
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      continue;
                     barrier();
                    }
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     do
                      {
                       barrier();
                      }
                     while(_GLF_WRAPPED_LOOP(false));
                    }
                   case 26:
                   if(_GLF_DEAD(false))
                    break;
                   vec4 _GLF_SWITCH_1_3v, _GLF_SWITCH_1_4v, _GLF_SWITCH_1_5v[21];
                   case 0:
                   if(_GLF_DEAD(false))
                    return;
                   case 14:
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     if(_GLF_DEAD(false))
                      barrier();
                     if(_GLF_DEAD(false))
                      break;
                     if(_GLF_DEAD(false))
                      barrier();
                     switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                      {
                       case 7:
                       if(_GLF_DEAD(false))
                        barrier();
                       ;
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                          {
                           barrier();
                          }
                         else
                          {
                          }
                        }
                       if(_GLF_DEAD(false))
                        barrier();
                       case 67:
                       if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec2(false, true)), bool(bvec4(bool(bvec2(false, true)), false, false, true))))))
                        continue;
                       if(_GLF_DEAD(false))
                        barrier();
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        break;
                       false;
                       case 0:
                       case 21:
                       case 47:
                       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                        {
                         barrier();
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_DEAD(false))
                            continue;
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            {
                             if(_GLF_DEAD(false))
                              barrier();
                             if(_GLF_DEAD(false))
                              break;
                             if(_GLF_DEAD(false))
                              return;
                             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                              barrier();
                             barrier();
                            }
                           continue;
                           if(_GLF_DEAD(false))
                            break;
                           if(_GLF_DEAD(false))
                            {
                             if(_GLF_DEAD(false))
                              barrier();
                             barrier();
                            }
                          }
                         if(_GLF_DEAD(false))
                          barrier();
                        }
                       else
                        {
                        }
                       if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                        continue;
                       if(_GLF_DEAD(false))
                        barrier();
                       do
                        {
                         if(_GLF_DEAD(false))
                          barrier();
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          {
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            continue;
                           barrier();
                          }
                        }
                       while(_GLF_WRAPPED_LOOP(false));
                       break;
                       case 40:
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(false))
                          barrier();
                         barrier();
                        }
                       uvec2 _GLF_SWITCH_3_0v[94];
                       case 42:
                       ivec2 _GLF_SWITCH_3_1v;
                       default:
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        return;
                       if(_GLF_DEAD(false))
                        barrier();
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        return;
                       1;
                      }
                    }
                   if(_GLF_DEAD(false))
                    continue;
                   if(_GLF_DEAD(false))
                    break;
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_WRAPPED_IF_TRUE(true))
                        {
                         return;
                        }
                       else
                        {
                        }
                      }
                     continue;
                    }
                   subgroup_size;
                   case 63:
                   case 38:
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      continue;
                     barrier();
                    }
                   uvec3 _GLF_SWITCH_0_5v;
                   if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                    barrier();
                   bool _GLF_SWITCH_0_6v, _GLF_SWITCH_0_7v[81], _GLF_SWITCH_0_8v;
                   if(_GLF_DEAD(false))
                    break;
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    continue;
                   if(_GLF_DEAD(false))
                    barrier();
                   case 71:
                   case 82:
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    return;
                   uvec3 _GLF_SWITCH_0_9v[54], _GLF_SWITCH_0_10v[81], _GLF_SWITCH_0_11v;
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      break;
                     barrier();
                    }
                   if(_GLF_DEAD(false))
                    return;
                   break;
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                     if(_GLF_DEAD(false))
                      return;
                    }
                   else
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        break;
                       barrier();
                      }
                     if(_GLF_DEAD(false))
                      {
                       switch(_GLF_SWITCH((-9042 & 0)))
                        {
                         case 0:
                         if(_GLF_DEAD(false))
                          barrier();
                         case 34:
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          barrier();
                         return;
                         break;
                         case 18:
                         uint _GLF_SWITCH_4_0v;
                         default:
                         1;
                        }
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        return;
                      }
                     if(_GLF_WRAPPED_IF_FALSE(false))
                      {
                      }
                     else
                      {
                       if(_GLF_DEAD(false))
                        barrier();
                      }
                     if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
                      {
                       if(_GLF_DEAD(false))
                        barrier();
                       barrier();
                      }
                    }
                   if(_GLF_DEAD(false))
                    return;
                   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, ! (! (false))), (_GLF_IDENTITY(false, ! (! (false)))) && true)))
                    break;
                   if(_GLF_DEAD(false))
                    return;
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(bool(false)))))
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        barrier();
                      }
                     else
                      {
                       barrier();
                      }
                    }
                   case 80:
                   (mat4x2(200.817, -4173.5138, -8.6, -86.86, -747.774, 9.8, -75.80, 64.00));
                   if(_GLF_DEAD(false))
                    return;
                   case 19:
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_DEAD(false))
                    break;
                   (mat2(-7.0, 4.6, -7.6, -77.93) / mat2(mat2x4(0.9, -3898.8709, -163.849, 5.4, 11.19, -995.816, 37.55, 459.180)));
                   default:
                   1;
                  }
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_DEAD(false))
                    barrier();
                   barrier();
                  }
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 break;
                 case 5:
                 mat4 _GLF_SWITCH_4_0v[82], _GLF_SWITCH_4_1v[48], _GLF_SWITCH_4_2v;
                 case 57:
                 do
                  {
                   uvec2(175869u, 123370u);
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, bool(bvec2(false, true)))));
                 default:
                 do
                  {
                   1;
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                }
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             if(_GLF_DEAD(false))
              barrier();
             ivec3 _GLF_SWITCH_0_12v, _GLF_SWITCH_0_13v;
             uint _GLF_SWITCH_0_14v, _GLF_SWITCH_0_15v[96], _GLF_SWITCH_0_16v;
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 {
                  if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                   {
                    return;
                   }
                  else
                   {
                    if(_GLF_DEAD(false))
                     barrier();
                    if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     return;
                   }
                  if(_GLF_DEAD(false))
                   barrier();
                 }
                if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                 {
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   {
                    do
                     {
                      barrier();
                     }
                    while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                   }
                 }
                else
                 {
                 }
                if(_GLF_DEAD(false))
                 barrier();
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 break;
                barrier();
               }
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_DEAD(false))
               continue;
              ;
              if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
               barrier();
              mat2x4(2.5, -36.27, 1.2, -2731.0858, -0.9, -559.253, -329.275, 585.734);
              if(_GLF_DEAD(false))
               barrier();
              _GLF_struct_34 _GLF_struct_replacement_34;
              ;
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_WRAPPED_IF_FALSE(false))
               {
               }
              else
               {
                do
                 {
                  mat4(9.6, -5088.4611, 521.580, 1.6, -94.75, -206.403, -2594.0677, 88.22, -192.596, 7.2, -250.552, -457.881, -826.109, 68.35, -4.6, 2.5);
                 }
                while(_GLF_WRAPPED_LOOP(false));
                if(_GLF_DEAD(false))
                 barrier();
               }
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 continue;
                return;
               }
              if(_GLF_DEAD(false))
               continue;
              47293;
             }
             {
              for(int _injected_loop_counter = (int(_GLF_ZERO(0.0, injectionSwitch.x)) ^ 0); _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY(1, min(1, 1))); _injected_loop_counter ++)
               {
                ;
               }
              if(_GLF_DEAD(false))
               return;
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
                for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                 {
                  barrier();
                 }
               }
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               barrier();
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               return;
             }
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    continue;
                   if(_GLF_WRAPPED_IF_TRUE(true))
                    {
                     barrier();
                    }
                   else
                    {
                    }
                  }
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
             {
              mat4(-8.3, 2842.1753, 39.80, 738.250, -6.6, 762.626, 512.288, -954.864, 2.3, -9.0, 6.8, 7.1, -8.5, -18.41, -9758.3032, -6.3);
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               barrier();
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 {
                  if(_GLF_DEAD(false))
                   break;
                  barrier();
                 }
                break;
               }
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 return;
                if(_GLF_DEAD(false))
                 barrier();
                barrier();
               }
              ivec3 _GLF_SWITCH_0_18v, _GLF_SWITCH_0_19v;
              if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec2(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true)))))
               barrier();
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 {
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   barrier();
                  barrier();
                 }
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 {
                  do
                   {
                    barrier();
                   }
                  while(_GLF_WRAPPED_LOOP(false));
                 }
                return;
               }
              if(_GLF_DEAD(false))
               break;
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 barrier();
                barrier();
               }
              if(_GLF_WRAPPED_IF_TRUE(true))
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 {
                  if(_GLF_WRAPPED_IF_TRUE(true))
                   {
                    barrier();
                   }
                  else
                   {
                   }
                 }
               }
              else
               {
               }
              mat4x2(mat3x4(6.5, -29.42, 8.4, 68.40, -7746.0431, 9382.7390, 46.33, 6684.1740, 1.5, -2.1, -8120.6463, -91.17));
              ivec3 _GLF_SWITCH_0_20v[82];
             }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               do
                {
                 barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             -17731;
             if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) && (false))))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 barrier();
                }
               else
                {
                }
              }
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               barrier();
              }
             if(_GLF_DEAD(false))
              barrier();
             if(true)
              {
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(false))
                barrier();
              }
            }
           while(true);
           case 93:
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              return;
            }
           else
            {
            }
           case 58:
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
            continue;
           for(_GLF_struct_21 _GLF_struct_replacement_21 = _GLF_struct_21(_GLF_struct_20(_GLF_struct_17(vec3(1.0), bvec2(true), mat2(1.0), uvec2(1u)), _GLF_struct_18(vec4(1.0), 1.0), _GLF_struct_19(bvec3(true), mat4(1.0), 1u), true, vec2(1.0), true, mat3x2(1.0)), int(_GLF_ONE(1.0, injectionSwitch.y))); _GLF_WRAPPED_LOOP(_GLF_struct_replacement_21._injected_loop_counter > 0); _GLF_struct_replacement_21._injected_loop_counter --)
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, (true) && true)))
              {
               do
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
               for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(7), int(7))) >> _GLF_IDENTITY(int(7), int(7))); _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 << _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(6), clamp(int(6), int(6), _GLF_IDENTITY(int(6), max(int(6), int(6)))))))); _injected_loop_counter --)
                {
                 if(_GLF_DEAD(false))
                  {
                   do
                    {
                     barrier();
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                  }
                }
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                 if(_GLF_DEAD(false))
                  return;
                }
               else
                {
                 for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(3), int(3))) >> _GLF_IDENTITY(int(3), int(3))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                  {
                   bvec2(false, true);
                  }
                }
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
              }
             else
              {
              }
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != (int(_GLF_ZERO(0.0, injectionSwitch.x)) ^ (1 ^ 0))); _injected_loop_counter ++)
              {
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   return;
                  }
                }
              }
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               break;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
              }
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                {
                 case 46:
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   ;
                  }
                 else
                  {
                  }
                 case 0:
                 case 50:
                 case 93:
                 case 26:
                 case 34:
                 case 86:
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   barrier();
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    continue;
                  }
                 break;
                 case 83:
                 if(_GLF_DEAD(false))
                  continue;
                 float _GLF_SWITCH_4_0v[31];
                 case 75:
                 mat2x4 _GLF_SWITCH_4_1v[25], _GLF_SWITCH_4_2v;
                 default:
                 1;
                }
              }
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    return;
                  }
                 else
                  {
                   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                    }
                   else
                    {
                    }
                  }
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                   continue;
                  }
                 break;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 if(_GLF_DEAD(false))
                  barrier();
                }
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
               barrier();
               if(_GLF_DEAD(false))
                continue;
              }
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
              return;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(false))
                return;
               return;
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           else
            {
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              return;
             continue;
            }
           case 25:
           do
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               break;
              }
             do
              {
               if(_GLF_DEAD(false))
                return;
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               119437u;
               if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
                continue;
              }
             else
              {
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           case 55:
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              continue;
             barrier();
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(false))
              barrier();
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                }
               do
                {
                 return;
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             return;
            }
           case 89:
           if(_GLF_DEAD(false))
            barrier();
           case 16:
           8.8;
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               barrier();
              }
             else
              {
              }
            }
           break;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           default:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           1;
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           if(_GLF_DEAD(false))
            return;
           break;
          }
         do
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         barrier();
        }
       case 0:
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              return;
             switch(_GLF_SWITCH(0))
              {
               case 53:
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 {
                  for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                   {
                    return;
                   }
                 }
                if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 {
                 }
                else
                 {
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   {
                    if(_GLF_WRAPPED_IF_TRUE(true))
                     {
                      barrier();
                     }
                    else
                     {
                     }
                   }
                 }
                if(_GLF_DEAD(false))
                 continue;
                mat4 _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v;
                bvec2 _GLF_SWITCH_2_2v;
                ;
                ivec3 _GLF_SWITCH_2_3v, _GLF_SWITCH_2_4v;
                (vec3(4.5, 1.1, 506.883) - vec3(70.42, -629.436, -3277.2725));
                ;
                for(int _injected_loop_counter = (0 ^ 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(6), int(6))) >> _GLF_IDENTITY(int(6), int(6)))); _injected_loop_counter ++)
                 {
                  uvec2(45933u, 180925u);
                 }
                mat3x4 _GLF_SWITCH_2_5v, _GLF_SWITCH_2_6v;
               }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
               if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, true && (true))))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
               else
                {
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
               case 85:
               if(_GLF_DEAD(false))
                barrier();
               uint _GLF_SWITCH_2_7v;
               case 0:
               case 60:
               case 15:
               case 8:
               do
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                    barrier();
                   barrier();
                  }
                 if(_GLF_DEAD(false))
                  break;
                 if(_GLF_DEAD(false))
                  break;
                }
               while(_GLF_WRAPPED_LOOP(false));
               if(_GLF_DEAD(false))
                continue;
               break;
               case 36:
               ivec3(-64940, 81240, -22053);
               default:
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 break;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                }
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                    }
                   else
                    {
                     barrier();
                    }
                  }
                }
               else
                {
                }
               1;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 return;
                }
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
              }
            }
           if(_GLF_DEAD(false))
            barrier();
           do
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                break;
               switch(_GLF_SWITCH(0))
                {
                 case 87:
                 vec4 _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v[28];
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                 case 44:
                 if(_GLF_DEAD(false))
                  {
                   for(int _injected_loop_counter = (0 & -33732); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                    {
                     barrier();
                    }
                  }
                 (mat2x4(mat3x4(2.8, -3.6, -7.8, -261.846, -63.26, 8961.2364, -2.2, 319.289, 1.7, -7543.1187, -7.5, 8253.4805)) * injectionSwitch);
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 case 0:
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                    {
                     barrier();
                    }
                   else
                    {
                    }
                  }
                 case 59:
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_WRAPPED_IF_TRUE(true))
                    {
                     barrier();
                    }
                   else
                    {
                    }
                  }
                 if(_GLF_DEAD(false))
                  continue;
                 case 41:
                 case 95:
                 if(_GLF_DEAD(false))
                  barrier();
                 case 7:
                 case 53:
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    return;
                   return;
                  }
                 if(_GLF_DEAD(false))
                  barrier();
                 case 35:
                 if(_GLF_DEAD(false))
                  break;
                 if(_GLF_DEAD(false))
                  barrier();
                 case 57:
                 return;
                 break;
                 case 88:
                 if(_GLF_DEAD(false))
                  barrier();
                 vec4 _GLF_SWITCH_3_2v;
                 if(_GLF_DEAD(false))
                  break;
                 case 27:
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(false))
                  break;
                 for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                  {
                   mat4(-2.1, 26.31, 147.317, -75.98, 100.996, 6.9, 24.67, 87.41, -10.10, 5.3, -8.8, 7933.2295, -0.2, 24.17, -3585.6215, -2.9);
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      return;
                     barrier();
                    }
                  }
                 if(_GLF_DEAD(false))
                  {
                   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 | 1)); _injected_loop_counter ++)
                    {
                     barrier();
                    }
                  }
                 default:
                 1;
                }
              }
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 if(_GLF_DEAD(false))
                  continue;
                }
               return;
              }
             return;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
            }
           while(_GLF_WRAPPED_LOOP(false));
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                continue;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                 barrier();
                }
               break;
               if(_GLF_DEAD(false))
                barrier();
              }
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(false))
                barrier();
              }
             barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           else
            {
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           switch(_GLF_SWITCH(0))
            {
             case 0:
             case 83:
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             case 82:
             case 16:
             case 57:
             case 34:
             continue;
             break;
             default:
             1;
            }
          }
         barrier();
         if(_GLF_DEAD(false))
          break;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           for(int _injected_loop_counter = _GLF_IDENTITY((0 ^ 0), min(_GLF_IDENTITY((0 ^ 0), ((0 ^ 0)) | 0), (0 ^ 0))); _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(7), _GLF_IDENTITY(int(7), max(int(7), int(7))))) >> _GLF_IDENTITY(int(7), int(7)))); _injected_loop_counter ++)
            {
             barrier();
            }
          }
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              continue;
             break;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(false, false, true, true)))))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 if(_GLF_DEAD(false))
                  return;
                }
               else
                {
                }
               do
                {
                 barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             return;
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 barrier();
                }
              }
             barrier();
            }
          }
         else
          {
           do
            {
             barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           if(_GLF_DEAD(false))
            barrier();
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY(0, 0 ^ (0))); _injected_loop_counter --)
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                }
               else
                {
                 barrier();
                }
              }
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
         if(_GLF_DEAD(false))
          barrier();
        }
       case 35:
       case 43:
       case 7:
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         barrier();
        }
       if(_GLF_DEAD(false))
        barrier();
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (((1 | 1) << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), 0 ^ (int(4)))))); _injected_loop_counter ++)
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
             barrier();
            }
           if(_GLF_DEAD(false))
            return;
           return;
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          {
           switch(_GLF_SWITCH((-66559 & 0)))
            {
             case 21:
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               barrier();
              }
             ;
             case 0:
             case 80:
             case 75:
             case 25:
             if(_GLF_DEAD(false))
              barrier();
             case 95:
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 return;
                }
              }
             case 30:
             case 72:
             case 2:
             return;
             break;
             case 3:
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             mat2 _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v[35], _GLF_SWITCH_3_2v;
             case 67:
             if(_GLF_DEAD(false))
              barrier();
             ;
             default:
             if(_GLF_DEAD(false))
              barrier();
             1;
            }
           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
            continue;
          }
         if(_GLF_DEAD(false))
          barrier();
        }
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 & 1)); _injected_loop_counter ++)
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           barrier();
          }
        }
       if(_GLF_DEAD(false))
        barrier();
       case 89:
       case 78:
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          continue;
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              {
               do
                {
                 barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             barrier();
            }
           return;
           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
        }
       case 83:
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        {
         do
          {
           return;
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
       if(_GLF_DEAD(false))
        barrier();
       case 13:
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       do
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              continue;
             break;
            }
           if(_GLF_DEAD(false))
            break;
           continue;
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(false))
          return;
         barrier();
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (_GLF_IDENTITY(0, (0) | 0) >> _GLF_IDENTITY(int(4), int(4)))); _injected_loop_counter --)
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  return;
                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 << _GLF_IDENTITY(int(1), int(1)))); _injected_loop_counter --)
                  {
                   barrier();
                  }
                }
               barrier();
              }
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           continue;
          }
        }
       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
       if(_GLF_DEAD(false))
        continue;
       break;
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          break;
         barrier();
        }
       case 44:
       do
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             barrier();
             if(_GLF_DEAD(false))
              break;
            }
           barrier();
          }
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = (1 & ((1 << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), int(4)))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
            {
             barrier();
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
        }
       while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))));
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          break;
         if(_GLF_DEAD(false))
          break;
         break;
        }
       mat4 _GLF_SWITCH_0_21v[66], _GLF_SWITCH_0_22v;
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          break;
         barrier();
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             return;
            }
           else
            {
            }
          }
         barrier();
        }
       if(_GLF_DEAD(false))
        continue;
       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bool(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
          barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           switch(_GLF_SWITCH(0))
            {
             case 0:
             case 20:
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 barrier();
                }
               else
                {
                }
              }
             else
              {
              }
             break;
             case 38:
             if(_GLF_DEAD(false))
              return;
             for(int _injected_loop_counter = ((-38443) & 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < (0 | (1 & 1))); _injected_loop_counter ++)
              {
               lessThan(vec4(-98.37, -6.5, 9.1, 4.1), vec4(0.1, 59.94, 663.057, 871.303));
              }
             case 54:
             bvec4 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v, _GLF_SWITCH_4_2v;
             default:
             1;
            }
          }
         return;
        }
       default:
       for(int _injected_loop_counter = (((1 | 0) << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), (false ? _GLF_FUZZED(16373) : int(2))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               barrier();
              }
             else
              {
              }
            }
           for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(3), int(3))) >> _GLF_IDENTITY(int(3), _GLF_IDENTITY(int(3), (int(3)) * 1))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
            {
             return;
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               barrier();
              }
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           1;
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            {
             do
              {
               barrier();
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
           barrier();
          }
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
            {
             barrier();
            }
          }
        }
       else
        {
        }
      }
     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        return;
      }
     else
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         continue;
        }
       if(_GLF_DEAD(false))
        break;
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           barrier();
           if(_GLF_DEAD(false))
            barrier();
          }
        }
       else
        {
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
    }
  }
 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec3(_GLF_IDENTITY(false, ! (! (false))), false, true), bvec3(bvec4(bvec3(_GLF_IDENTITY(false, ! (! (false))), false, true), false)))))))
  return;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(7), int(7))) >> _GLF_IDENTITY(int(7), _GLF_IDENTITY(int(7), 0 + (int(7))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
          }
         return;
        }
      }
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          return;
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           barrier();
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          return;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          return;
         do
          {
           return;
          }
         while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, bool(bvec4(false, false, true, false)))));
        }
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        {
         do
          {
           barrier();
          }
         while(_GLF_WRAPPED_LOOP(false));
         if(_GLF_DEAD(false))
          barrier();
        }
       barrier();
      }
     else
      {
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, ! (! (true)))))
        {
         if(_GLF_DEAD(false))
          barrier();
         return;
        }
       else
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
        }
      }
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
      }
    }
  }
 do
  {
   if(_GLF_DEAD(false))
    return;
  }
 while(_GLF_WRAPPED_LOOP(false));
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
    }
   else
    {
     if(_GLF_DEAD(false))
      barrier();
    }
   barrier();
  }
 if(_GLF_DEAD(false))
  return;
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       do
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(false))
      barrier();
     barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       switch(_GLF_SWITCH((0 | 0)))
        {
         case 0:
         case 15:
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 | int(_GLF_ZERO(0.0, injectionSwitch.x)))); _injected_loop_counter --)
          {
           return;
          }
         break;
         case 37:
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
          }
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
          {
           for(           mat2x4(6.0, -17.45, 5590.6246, 8.0, -9.7, -9.7, -1.9, -2.9);
 (vec3(3.9, -9392.9757, 5.4) == vec3(-210.198, -2.9, -0.7)); bvec2(true, true))
            {
             while(false)
              {
               normalize(4.8);
               for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                {
                 for(uint _GLF_SWITCH_4_0v; (5737 < -11988); ivec4(-27385, -52258, 21158, 60157))
                  {
                  }
                }
               ivec2(14919, -81113);
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
               bvec3(false, true, true);
               do
                {
                 mat2(-16.01, 4.0, -16.69, -4.2);
                 mat3(20.15, -4.8, -6.2, -0.8, 1503.4482, 870.262, 96.12, -9824.1190, -9.4);
                }
               while(true);
               mat3x2(35.20, 978.608, -795.872, 9.5, -705.179, -40.42);
               vec2 _GLF_SWITCH_4_1v, _GLF_SWITCH_4_2v;
               ivec4 _GLF_SWITCH_4_3v, _GLF_SWITCH_4_4v, _GLF_SWITCH_4_5v;
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             if((65176 != -83993))
              {
               (vec4(-1918.1081, 4.5, -6.4, -6467.5171) == (vec4(8.9, 52.55, 3674.5533, -2.0) / -9507.5559));
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
              }
             {
              for(ivec2 _GLF_SWITCH_4_6v, _GLF_SWITCH_4_7v; false; mat3(-2.0, 1369.5963, -1.5, 348.309, 4107.9076, -57.38, 39.30, -668.312, -15.08))
               {
                uvec4(10392u, 46765u, 193096u, 132661u);
                ivec3 _GLF_SWITCH_4_8v;
                uint _GLF_SWITCH_4_9v[98], _GLF_SWITCH_4_10v, _GLF_SWITCH_4_11v;
                uvec4(125936u, 183129u, 57516u, 6663u);
                mat4(4.1, -25.30, 79.09, -83.02, -57.96, -0.8, -5.5, 84.49, -28.02, -255.419, 26.10, -8.9, -9.1, -502.806, -120.901, 4.7);
                uvec4 _GLF_SWITCH_4_12v, _GLF_SWITCH_4_13v;
                ivec3 _GLF_SWITCH_4_14v[39];
                ;
               }
              {
               (uvec3(99704u, 126606u, 162733u) & (187669u | uvec3(31943u, 177805u, 172140u)));
               (mat3x2(-9.8, 715.759, 2.8, 88.63, 3564.2670, -37.03) != mat3x2(9281.9258, -0.6, -3881.2334, -0.2, -54.24, 2.3));
              }
              if((mat4x3(68.23, 952.826, -2.7, -4.9, 8.5, 802.276, 5197.2558, 1007.5712, 3615.5280, -215.189, -7535.0895, -0.7) != mat4x3(23.30, 38.49, 3880.4045, 9815.9404, 8997.5414, -0.0, 7.1, 0.4, -5.5, -5.0, -3.0, -763.171)))
               {
                matrixCompMult(mat3x2(-2.7, -23.26, -87.85, 369.806, roundEven(-9.5), -0.2), matrixCompMult(mat3x2(6256.3593, 7.2, -44.46, 804.427, 971.848, 85.49), (mat3x2(5.9, 385.749, 6.1, 0.2, -175.491, -5.7) + -9.5)));
                mat3x2 _GLF_SWITCH_4_15v, _GLF_SWITCH_4_16v[90], _GLF_SWITCH_4_17v[40];
                ivec4(-98780, -39048, -36622, 86555);
                if(_GLF_DEAD(false))
                 break;
                97141;
                (mat2x4(-90.70, -3401.7016, 38.90, -7957.8535, -667.126, -573.241, 4619.5925, -1889.1522) != mat2x4(mat4x3(1473.1503, -63.54, 8.3, -1.6, -3.6, 119.190, -1.1, 47.19, -9.7, -3.9, -6421.5540, -659.519)));
                uvec3(183744u, 132142u, 138719u);
                int(1.4);
                uint _GLF_SWITCH_4_18v, _GLF_SWITCH_4_19v;
                mat2x4 _GLF_SWITCH_4_20v;
               }
             }
             {
              mat3x4(1.0, 3.1, 3.1, -5729.4429, 504.006, 687.792, 332.837, 2863.3055, -6171.7789, -9537.7825, -65.28, -4160.5676);
              do
               {
                ldexp(vec3(-76.97, 728.576, -0.9), ivec3(52670, -69152, 19094));
               }
              while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
              ;
              if(_GLF_DEAD(false))
               break;
              if((clamp(subgroup_size, 27927u, subgroup_size) == subgroup_size))
               {
                for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 | 0)); _injected_loop_counter --)
                 {
                  (- mat2(-52.03, -7.0, 58.61, 2.5));
                 }
               }
              bool _GLF_SWITCH_4_21v;
              ;
             }
             bvec2(true, true);
             if((mat4(7.2, -984.805, 7600.4684, 54.77, -2.6, -868.986, 4.1, 39.99, 4.2, 94.65, -78.99, 6161.3457, -6.0, -161.696, 67.07, 1.5) == mat4(467.397, -6.9, 8.2, -2.6, 431.753, 4944.6653, -29.65, -955.038, 2320.2686, -6.7, 1690.4982, 6.8, 4.8, 0.2, -7.7, -2134.2216)))
              {
               for(ivec2 _GLF_SWITCH_4_22v, _GLF_SWITCH_4_23v[26], _GLF_SWITCH_4_24v[46]; (128058u < 96750u); mat3x2(-37.63, -8396.5933, 425.032, -9.5, -44.35, -662.035))
                {
                }
               mat3(-258.988, 29.29, -95.27, -3.5, 1145.7954, -2.1, -9.6, 5.6, 6.6);
               mat3 _GLF_SWITCH_4_25v;
               for(bvec2 _GLF_SWITCH_4_26v[56], _GLF_SWITCH_4_27v; true; uvec2(uvec3(186869u, 104025u, 146771u)))
                {
                 (_GLF_SWITCH_4_25v * mat3(4651.3698, 3.4, -511.894, -4.0, -41.50, -45.16, -6089.5650, 96.08, 0.5));
                 vec4(352.620, 4767.7997, -6.8, 5.8);
                 8430.1141;
                 mat3x4(99.70, -233.389, -7.9, -762.510, 1.0, -7068.6388, 3500.3709, -4.3, -5.3, -3166.2379, 9.8, -1.7);
                 equal((ivec2(90101, 52651) & -67629), ivec2(-70478, -73714));
                 float _GLF_SWITCH_4_28v[69];
                 mat3x4 _GLF_SWITCH_4_29v;
                }
               mat2x4(-6.6);
               ivec4 _GLF_SWITCH_4_30v, _GLF_SWITCH_4_31v, _GLF_SWITCH_4_32v;
               if(false)
                {
                 mat2x4(7976.7492, -7959.3626, -41.94, 647.156, -9.5, 5156.5266, 6.1, 35.92);
                 uvec3(146034u, 104608u, 6685u);
                 mat2x4 _GLF_SWITCH_4_33v, _GLF_SWITCH_4_34v;
                 if(_GLF_DEAD(false))
                  return;
                 bvec4(true, true, true, true);
                 ivec4 _GLF_SWITCH_4_35v, _GLF_SWITCH_4_36v[2], _GLF_SWITCH_4_37v;
                 uvec2(23407u, 75956u);
                 if(_GLF_DEAD(false))
                  continue;
                 vec2 _GLF_SWITCH_4_38v, _GLF_SWITCH_4_39v, _GLF_SWITCH_4_40v[48];
                 uvec4(138463u, 158742u, 195415u, 45809u);
                 injectionSwitch;
                }
               else
                {
                 mat3x4 _GLF_SWITCH_4_41v, _GLF_SWITCH_4_42v[15];
                 do
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    return;
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                 do
                  {
                   ivec2(11360, 96855);
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                 (vec3(-8.8, 7247.3582, 7446.7807) / normalize(-7140.0424));
                 int _GLF_SWITCH_4_43v;
                 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                  {
                   mat2x4(mat2x3(-1.0, 95.46, -840.044, -29.60, -1.3, -5405.2840));
                  }
                 else
                  {
                  }
                 round(501.575);
                 if(_GLF_DEAD(false))
                  break;
                }
               bvec2(true, true);
               (ivec4(95898, 84201, 37083, -69222) | ivec4(-46304, 57933, 34731, 84820));
              }
             else
              {
               if(_GLF_DEAD(false))
                return;
               vec4(-442.226, -4.3, 795.996, -1.9);
               if((mat2(6.2, -8.1, -214.706, 479.083) == mat2(-139.360, -0.4, 7.1, -5541.1968)))
                {
                 mat3x4(6.4, 1440.0845, 7650.0711, 90.24, -33.26, 9168.2090, -756.129, -8.3, -6.1, -4.5, -4.0, -432.532);
                 if(_GLF_DEAD(false))
                  continue;
                 bvec4 _GLF_SWITCH_4_44v;
                 uvec4 _GLF_SWITCH_4_45v[69], _GLF_SWITCH_4_46v[10];
                 ;
                }
               else
                {
                 bvec4(bvec3(true, false, false), (bvec2(true, true) != lessThan(uvec2(129704u, 46815u), uvec2(58288u, 67323u))));
                 (-38347 | bitCount(ivec2(-15906, -85478)));
                 if(_GLF_DEAD(false))
                  return;
                 ((mat4x2(3.9, 3558.3233, 722.069, -473.916, 470.026, 3.1, -3234.0793, 5.4) * mat3x4(-8.7, 6.8, -0.3, -59.48, -7.0, 9.6, 0.1, -1.2, 97.22, -2.8, 34.01, -469.583)) * mat4x3(-1.4, 26.14, -75.61, 1.3, -8147.0360, 8.8, 3.8, 5.6, -51.70, -38.25, -81.62, 9437.4099));
                 uvec2 _GLF_SWITCH_4_47v, _GLF_SWITCH_4_48v;
                 ivec3(-96175, -30739, 501);
                 (mat4x3(15.74, 8.4, -7307.7404, -4.0, 519.835, -2.1, 2.3, -0.5, -7.1, -15.20, -5.9, -3291.1025) + -9.7);
                 if(_GLF_DEAD(false))
                  continue;
                 mat2(-9675.4641, 1.9, -692.505, -1.1);
                }
               ;
               if((ivec2(-40325, 85836) != ivec2(-38031, -59244)))
                {
                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                  {
                   bvec2(true, true);
                  }
                 bvec3 _GLF_SWITCH_4_49v, _GLF_SWITCH_4_50v;
                 bvec4(false, false, false, false);
                 (-1923.2612 == dot(injectionSwitch, vec2(584.727, 3.7)));
                 mat3x4(-5.7, 7.3, -305.352, -54.63, -0.4, -1336.0916, -650.472, -38.32, 7.3, 2.9, 7.9, 6672.4741);
                 ;
                 uvec3(67984u, 24884u, 113542u);
                 mat4(-44.78, 69.69, -168.165, -1.0, 1.6, -9073.7227, 3.7, -9495.1067, 1943.1081, -522.077, -2248.0557, -0.3, 311.788, -89.44, 5.5, -7147.5815);
                 mat4x2(-28.71, 4.0, 26.20, 50.70, -1.6, 63.77, 3353.8414, 3309.4243);
                }
               if((uvec2(62606u, 31660u) != uvec2(23204u, 168331u)))
                {
                 bvec4 _GLF_SWITCH_4_51v[36];
                 bvec3 _GLF_SWITCH_4_52v, _GLF_SWITCH_4_53v;
                }
               else
                {
                 inverse(mat4(-2.0, -8047.6738, -101.520, 863.147, -52.37, 316.258, -970.750, -8.6, -7.7, -0.8, 4.1, -8913.6781, 3539.7058, 29.00, 996.133, 4120.9804));
                 mat3x2((mat3x4(3.5, -9276.0495, 7.0, 6605.0768, 3.2, -75.02, 6620.3825, -0.4, 6.9, -4503.3767, -7523.4149, 9.6) - -9.3));
                }
               clamp((false ? uvec3(84576u, 125480u, 113095u) : uvec3(166601u, 162361u, 177813u)), uvec3(69282u, 96186u, 90569u), uvec3(138807u, 137710u, 41199u));
              }
             mat3x2(-1254.9106, -4371.3342, 1.0, 44.77, -3.4, 95.38);
             for(float _GLF_SWITCH_4_54v, _GLF_SWITCH_4_55v[72], _GLF_SWITCH_4_56v[36]; true; mat2x4(-416.496, -337.804, 93.21, -16.77, -0.8, 8.2, 1.2, 823.838))
              {
               if(true)
                {
                 true;
                 mat2x3 _GLF_SWITCH_4_57v, _GLF_SWITCH_4_58v, _GLF_SWITCH_4_59v[34];
                 matrixCompMult(mat3x4(-2.3, -0.9, -54.14, -18.48, 5.8, -0.4, 2657.4570, 6.9, -0.2, 673.918, -41.75, 8.2), mat3x4(13.40, -584.981, 930.008, 4299.0525, -31.17, -7566.6686, 5.9, 292.751, -4.4, -82.22, 17.47, 6.1));
                 do
                  {
                   false;
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                 int _GLF_SWITCH_4_60v, _GLF_SWITCH_4_61v;
                 mat4x3 _GLF_SWITCH_4_62v[89], _GLF_SWITCH_4_63v[31], _GLF_SWITCH_4_64v;
                 _GLF_SWITCH_4_60v;
                 int _GLF_SWITCH_4_65v[78], _GLF_SWITCH_4_66v;
                 matrixCompMult(_GLF_SWITCH_4_57v, (+ mat2x3(4.1, 16.25, -44.15, -4461.1495, -68.86, 2.7)));
                }
               else
                {
                }
               mat4 _GLF_SWITCH_4_67v, _GLF_SWITCH_4_68v, _GLF_SWITCH_4_69v;
               for(               mat2(690.045, -4.8, 1053.8322, 2.5);
 (mat3x2(709.821, 16.21, -878.452, 6375.8375, 90.24, 3.1) != mat3x2(-7333.3388, 2.8, 60.13, -3248.0683, -503.247, 6854.0574)); -28407)
                {
                 ivec2 _GLF_SWITCH_4_70v;
                }
               while((reflect(vec2(623.221, -80.98), injectionSwitch) != vec2(-988.024, -7.2)))
                {
                 _GLF_SWITCH_4_54v;
                 bvec4 _GLF_SWITCH_4_71v[78];
                 bvec3(true, true, false);
                }
               if(true)
                {
                 mat2 _GLF_SWITCH_4_72v, _GLF_SWITCH_4_73v, _GLF_SWITCH_4_74v;
                 mat4x3 _GLF_SWITCH_4_75v, _GLF_SWITCH_4_76v[32];
                 mat4(mat4x2(7249.1036, -33.39, 702.726, -5.0, 9230.3362, -1.8, -9011.0557, 5.6));
                 bvec2(false, false);
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   mat4((mat4x2(-929.015, -4.3, -6114.4657, 3100.4562, 5.6, -95.61, 3.4, -6.6) * mat4(670.681, -3.2, 0.2, -55.46, -5790.7366, -42.65, 296.746, 1942.7123, 6120.5390, 4366.1924, 645.627, -17.71, -5013.0038, -136.621, -14.83, 6662.0664)));
                  }
                 else
                  {
                  }
                 (mat3x4(-6.9, 2.6, 5.3, -1702.1240, -179.999, -1.3, 54.50, 304.008, -1.0, 9072.6660, -4814.6634, 185.728) + mat3x4(-3.5, -9.5, 5.9, 41.76, -1114.0239, -6484.9206, -4.4, -97.01, 6.0, 7.1, 2.1, -6169.9310));
                 bvec3 _GLF_SWITCH_4_77v[52];
                 uint(-53.64);
                 bvec2 _GLF_SWITCH_4_78v;
                 if(_GLF_DEAD(false))
                  break;
                }
              }
            }
          }
         case 76:
         for(         uvec2(66164u, 69977u);
 (mat3(-7.8, 339.407, -3.3, 6053.0437, 6167.0415, -247.877, 880.779, -9095.0205, 0.6) == mat3(-3.2, 5.9, 814.087, 53.72, 869.665, -7826.7849, -8.9, 3.2, 31.98)); 43478u)
          {
           floatBitsToInt(mod(vec3(56.95, -9.1, -62.54), -981.227));
           564.260;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           for(           ivec3(-75918, 40860, 16794);
 true; mat2x3(mat3x4(-92.19, 6225.2136, 391.321, -1714.8676, -7977.7183, 4061.5928, -9.2, 75.52, -53.78, 7.9, -8.5, 92.42)))
            {
             (findLSB(subgroup_local_id) & ivec3(36244, -83632, 55429));
             ;
             vec3(3.2, -30.71, -6546.1195);
             for(             bitCount(bitfieldReverse(uvec2(122193u, 84076u))[0]);
 true; (length(vec3(4.4, -0.0, -958.879)) / mat3(7666.0267, -448.763, 69.25, -3910.9818, -260.564, 7.2, 147.451, 9.9, 1983.3808)))
              {
               if(_GLF_DEAD(false))
                return;
               mat3x4 _GLF_SWITCH_4_79v[68], _GLF_SWITCH_4_80v;
               int _GLF_SWITCH_4_81v[85], _GLF_SWITCH_4_82v, _GLF_SWITCH_4_83v[77];
               vec4(4.6, 386.535, -925.079, -1.8);
               vec4 _GLF_SWITCH_4_84v[62];
               atomicCompSwap(_GLF_SWITCH_4_82v, _GLF_SWITCH_4_82v, (-73954 & _GLF_SWITCH_4_82v));
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
               mat3x4 _GLF_SWITCH_4_85v;
               if(_GLF_DEAD(false))
                break;
               for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                {
                 ;
                }
               mat3 _GLF_SWITCH_4_86v[30];
               mat3(mat2x4(-55.22, 830.120, -338.564, 68.41, 0.2, 9.1, 2.6, 2.2));
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
             while(true)
              {
               mat4 _GLF_SWITCH_4_87v[11], _GLF_SWITCH_4_88v;
               ((314.587 + mat2x3(-3.2, 99.74, 893.024, 2.4, 8394.8553, -1746.9379)) + -9613.8269);
               mat2 _GLF_SWITCH_4_89v, _GLF_SWITCH_4_90v[29];
              }
             mat4 _GLF_SWITCH_4_91v[75];
             (bvec4(true, false, true, false) , mat4x3(-51.85, 3730.5798, 903.121, -7399.6031, 6.0, -477.392, -37.64, 87.26, -712.486, -41.24, 61.82, -30.02));
             while(bool(90.69))
              {
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 mat2x3(mat3x4(-460.851));
                }
               else
                {
                }
               if(_GLF_DEAD(false))
                return;
               bvec4(false, true, true, true);
              }
             subgroup_size;
            }
          }
         default:
         1;
        }
       if(_GLF_DEAD(false))
        return;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       do
        {
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
          }
         else
          {
           barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(false))
        return;
      }
    }
  }
 else
  {
  }
 if(_GLF_DEAD(false))
  return;
 _GLF_struct_40 _GLF_struct_replacement_40 = _GLF_struct_40(true, _GLF_struct_36(_GLF_struct_35(gl_NumWorkGroups.x, mat3x2(1.0), mat3x2(1.0), vec2(1.0), mat3(1.0)), mat4x2(1.0), mat3(1.0)), mat3x4(1.0), _GLF_struct_39(mat4(1.0), 1, 1.0, mat2(1.0), _GLF_struct_37(mat2x4(1.0), mat4x3(1.0), 1, uvec2(1u), uvec2(1u)), _GLF_struct_38(uvec2(1u), bvec2(true), mat4x3(1.0), bvec3(true), ivec3(1), uvec4(1u))));
 _GLF_struct_22 _GLF_struct_replacement_22 = _GLF_struct_22(mat2x3(1.0), gl_WorkGroupSize.x);
 do
  {
   if(_GLF_DEAD(false))
    barrier();
  }
 while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) && true)));
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
    }
   else
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         return;
        }
       else
        {
        }
      }
    }
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     barrier();
    }
   else
    {
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   barrier();
   if(_GLF_DEAD(false))
    barrier();
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
    {
     return;
    }
  }
 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
  {
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(false))
    return;
  }
 else
  {
   if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
    {
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         return;
         if(_GLF_DEAD(false))
          return;
        }
      }
     else
      {
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         barrier();
        }
      }
    }
  }
 do
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      return;
     return;
    }
  }
 while(_GLF_WRAPPED_LOOP(false));
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, false, false)))))
    barrier();
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       barrier();
      }
    }
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
     if(_GLF_DEAD(false))
      barrier();
    }
   else
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        return;
      }
     if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
      {
       if(_GLF_DEAD(false))
        barrier();
       barrier();
      }
     do
      {
       return;
      }
     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
     do
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
   if(_GLF_DEAD(false))
    barrier();
  }
 uint workgroup_id = gl_WorkGroupID.x;
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
   if(_GLF_DEAD(false))
    barrier();
  }
 else
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         return;
        }
      }
     else
      {
      }
     do
      {
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       else
        {
        }
       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(false, true, false, true)))))
        break;
      }
     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 << _GLF_IDENTITY(int(6), int(6)))); _injected_loop_counter --)
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
             if(_GLF_DEAD(false))
              break;
            }
           else
            {
             barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           if(_GLF_DEAD(false))
            break;
          }
         if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, false, true)))))
          barrier();
        }
       return;
      }
     else
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     do
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), ! (! (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))))
            {
             barrier();
            }
           else
            {
            }
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         barrier();
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             do
              {
               barrier();
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
          }
        }
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
     if(_GLF_DEAD(false))
      return;
    }
   else
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || false)))
        return;
       if(_GLF_DEAD(false))
        return;
       return;
       if(_GLF_DEAD(false))
        barrier();
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 >> _GLF_IDENTITY(int(8), _GLF_IDENTITY(int(8), (int(8)) / 1)))); _injected_loop_counter --)
        {
         return;
        }
      }
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     barrier();
     if(_GLF_DEAD(false))
      barrier();
    }
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, (false) || false)))
            {
            }
           else
            {
             return;
            }
          }
         barrier();
        }
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        {
         do
          {
           return;
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
        }
       barrier();
      }
     return;
    }
   if(_GLF_DEAD(false))
    barrier();
   barrier();
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     barrier();
    }
  }
 do
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
        }
       else
        {
         barrier();
        }
      }
     return;
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    break;
   if(_GLF_DEAD(false))
    continue;
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        break;
       barrier();
       do
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
  }
 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
 if(_GLF_DEAD(false))
  return;
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     if(_GLF_DEAD(false))
      barrier();
     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > _GLF_IDENTITY(0, (0) | (0))); _injected_loop_counter --)
      {
       if(_GLF_DEAD(false))
        continue;
       return;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        continue;
       if(_GLF_DEAD(false))
        {
         for(int _injected_loop_counter = (((1 << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), int(2))) ^ int(_GLF_ZERO(0.0, injectionSwitch.x))); _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
          {
           barrier();
          }
        }
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, ! (! (false)))))
          {
          }
         else
          {
           barrier();
          }
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (false))))
        return;
       barrier();
      }
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        barrier();
      }
    }
  }
 uint workgroup_base = _GLF_struct_replacement_22.workgroup_size * workgroup_id;
 uint virtual_gid = workgroup_base + _GLF_struct_replacement_12.subgroup_id * subgroup_size + subgroup_local_id;
 do
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, (false) || false)))
      {
      }
     else
      {
       barrier();
      }
    }
  }
 while(_GLF_WRAPPED_LOOP(false));
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(false))
    return;
   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
    }
   else
    {
     return;
    }
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  barrier();
 _GLF_struct_16 _GLF_struct_replacement_16 = _GLF_struct_16(_GLF_struct_15(_GLF_struct_13(1.0), _GLF_struct_14(ivec2(1), ivec2(1), mat4x2(1.0), mat2x3(1.0), mat3x4(1.0), bvec3(true), true), bvec3(true), vec4(1.0), 1, 1.0), workgroup_base + _GLF_struct_replacement_12.subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size), bvec4(true));
 uint read = atomicLoad(buf[virtual_gid], 4, 64, 0);
 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     barrier();
    }
  }
 else
  {
  }
 if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(_GLF_IDENTITY(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, true), bvec3(bvec4(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, true), true)))))))
  barrier();
 for(int _injected_loop_counter = ((17566 >> (93408 << 64769)) & ((0 << _GLF_IDENTITY(int(6), int(6))) << _GLF_IDENTITY(int(8), int(8)))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
  {
   if(_GLF_DEAD(false))
    return;
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(false))
    barrier();
   return;
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     return;
    }
   else
    {
    }
   if(_GLF_DEAD(false))
    {
     do
      {
       return;
      }
     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
    }
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 atomicStore(buf[_GLF_struct_replacement_16.next_virtual_gid], uint(1), 4, 64, 4);
 atomicStore(checker[virtual_gid], read, 4, 64, 4);
}
