#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer Checker {
 uint checker[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   switch(_GLF_SWITCH(0))
    {
     case 87:
     ivec2 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v;
     case 13:
     while((bvec4(false, true, false, false) == bvec4(true, true, false, false)))
      {
      }
     case 0:
     case 90:
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     else
      {
      }
     case 65:
     if(_GLF_DEAD(false))
      return;
     case 40:
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       barrier();
      }
     case 30:
     barrier();
     break;
     case 43:
     for(     any(bvec2(false, false));
 isnan(0.4); bitfieldExtract(uvec2(51622u, 33448u), 94249, 35094))
      {
       mat3x4(15.87, -6.1, 2.7, -1.1, -9.7, 5.7, 0.6, -1760.9940, 9.3, -3271.6116, 69.44, 9956.7004);
       while(true)
        {
         ((mat4x2(-1.7, -8605.5138, -8.6, -918.455, -8676.9428, 6.3, -4901.4829, -9.7) == mat4x2(-70.80, -2.7, -3.6, 7.2, -101.243, 5848.1381, 6.9, -1044.5176)) ? bvec3(false, true, true) : bvec3(false, true, true));
         if(_GLF_DEAD(false))
          return;
         ivec2(-13400, 33479);
         if(_GLF_DEAD(false))
          continue;
         if(true)
          {
           bvec4 _GLF_SWITCH_5_2v[61], _GLF_SWITCH_5_3v, _GLF_SWITCH_5_4v;
           vec2(5.9, 263.258);
           ivec4 _GLF_SWITCH_5_5v[34];
           (uvec2(78018u, 119150u) >> uvec2(86895u, 149637u));
           mat3x4(45.73, 93.06, -3775.8604, 4.0, 4868.1164, 7.6, -18.46, -4.1, 9.6, 38.05, 5.7, -3.5);
           float _GLF_SWITCH_5_6v, _GLF_SWITCH_5_7v, _GLF_SWITCH_5_8v[40];
          }
         else
          {
           mat3x2(6306.6955, -952.395, -5.7, -2310.2242, -2.9, -366.587);
           vec2 _GLF_SWITCH_5_9v, _GLF_SWITCH_5_10v, _GLF_SWITCH_5_11v;
           uvec3 _GLF_SWITCH_5_12v, _GLF_SWITCH_5_13v, _GLF_SWITCH_5_14v;
           mat2x3((8235.0680 * 5.4), 7.0, -5.5, 976.009, 7.6, 4030.3029);
          }
         if(_GLF_DEAD(false))
          continue;
         for(         vec4(6.3, -2.7, -764.926, 26.08);
 false; mat4x3(28.03, 5.3, -8.8, 64.25, 4.2, 2.7, 0.2, -1.4, -883.789, -0.8, 645.535, -2912.1958))
          {
           1.9;
          }
         ;
         (true ? mat4(-506.155, -16.59, -2.4, 7.6, -7.9, -915.384, -959.459, 3.9, 9541.3531, -986.625, -85.88, -53.84, -66.56, -835.412, 434.108, -5623.1151) : mat4(-4.6, -68.73, 5.3, 1.6, 8101.9003, -930.206, -40.86, -9.3, -360.583, -5.0, 494.718, 794.124, -642.611, 916.186, -43.47, 1.6));
         do
          {
          }
         while(true);
         mat4x2(1.6, -0.0, 2.3, 3.2, -3451.3877, 2.8, -17.87, 37.98);
         mat3x4(-6423.8321, 39.78, 3.8, -68.26, -88.47, -2606.5175, 0.3, -3.4, 37.74, -942.820, 7.4, -0.6);
        }
       ivec4 _GLF_SWITCH_5_15v[83], _GLF_SWITCH_5_16v[23], _GLF_SWITCH_5_17v;
       (mat2x4(4.7, 5.7, -11.39, 67.69, 9008.0136, -0.9, 6.5, -58.79) * vec2(_GLF_IDENTITY(-8.3, clamp(-8.3, -8.3, _GLF_IDENTITY(-8.3, (true ? -8.3 : _GLF_FUZZED(9.9))))), 8.1));
       ;
       {
        if(false)
         {
          ivec2 _GLF_SWITCH_5_18v;
          (mat3(620.564, -662.620, -7.7, 9669.8229, 5.2, -8121.2102, 52.28, 5.8, 1701.1575) / mat3(-9.6, 422.223, 5244.7075, -1.5, -973.279, 9.8, -159.847, 775.568, 4.2));
          isnan(degrees(vec3(-2069.5175, 4110.0662, 7.1)));
          ivec4(-46337, -20944, -75903, -25032);
          mat2 _GLF_SWITCH_5_19v;
          bvec3 _GLF_SWITCH_5_20v;
          uvec4 _GLF_SWITCH_5_21v[43], _GLF_SWITCH_5_22v[74], _GLF_SWITCH_5_23v;
          mat4x2 _GLF_SWITCH_5_24v[34];
         }
        else
         {
          mat2x4(-902.973, 892.718, -8.3, -43.14, -4.1, -7475.7325, -8553.1713, 9.5);
          ivec3(-37313, 66614, -8087);
          vec4 _GLF_SWITCH_5_25v, _GLF_SWITCH_5_26v, _GLF_SWITCH_5_27v;
          (_GLF_SWITCH_5_1v.tst * 35831);
          if(_GLF_DEAD(false))
           return;
          transpose((true ? mat2(-4.9, 283.688, -0.8, 253.421) : (mat2(-0.7, -0.9, -2938.9599, 9684.2431) + 5057.4569)));
          mat3x2(-8.0, -1.3, 96.72, 9.4, -29.08, -647.314);
          mat4 _GLF_SWITCH_5_28v, _GLF_SWITCH_5_29v;
          mat4x2(1686.9372, 7.0, -6.7, 86.76, -5.9, 898.378, 1.8, -695.548);
         }
        mat3x4 _GLF_SWITCH_5_30v;
        bvec2(false, false);
        ;
        vec3(-7.7, 9889.0085, -3.7);
        if(_GLF_DEAD(false))
         continue;
        while((bvec4(true, true, false, false) != bvec4(true, true, true, true)))
         {
          bvec2(_GLF_IDENTITY(true, true && (_GLF_IDENTITY(true, (_GLF_IDENTITY(true, ! (! (true)))) || false))), true);
          vec4(-69.30, -40.75, -389.512, 3.7);
          uint _GLF_SWITCH_5_31v[78], _GLF_SWITCH_5_32v, _GLF_SWITCH_5_33v[85];
          uvec3(uvec2(128537u, 20497u), _GLF_SWITCH_5_32v);
         }
       }
       {
        60709u;
        mat2x3(53.35, 9311.7484, -9177.7615, 5.7, 98.52, -5.4);
        ;
       }
       mat4x3 _GLF_SWITCH_5_34v, _GLF_SWITCH_5_35v, _GLF_SWITCH_5_36v;
       bvec3(true, true, true).rgr;
      }
     default:
     1;
    }
   if(_GLF_DEAD(false))
    return;
  }
 if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      return;
     barrier();
    }
   return;
  }
 if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, ! (! (false)))) && true)))
  barrier();
 uint subgroup_id = gl_SubgroupID;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    {
     switch(_GLF_SWITCH((0 & 27245)))
      {
       case 0:
       case 27:
       case 40:
       case 44:
       case 62:
       if(_GLF_DEAD(false))
        barrier();
       case 10:
       if(_GLF_DEAD(false))
        return;
       case 35:
       barrier();
       break;
       case 77:
       while((mat3(8.4, 79.33, -8.6, -9609.4676, 511.813, -6058.3001, 9577.6317, -13.92, 9.5) != mat3(78.72, 6.4, -175.251, -7.4, -375.439, 2.0, -1.3, 761.295, 2.7)))
        {
         ivec3(19442, 68889, -289);
         if(false)
          {
           mat4x2 _GLF_SWITCH_5_0v;
          }
         else
          {
          }
         mat2x4 _GLF_SWITCH_5_1v[83], _GLF_SWITCH_5_2v, _GLF_SWITCH_5_3v;
         {
          {
           _GLF_SWITCH_5_3v;
           uvec3(67669u, 191191u, 40852u);
           ((ivec4(-23104, -35937, -8790, -75452) + -21286) - ivec4(-97351, -96468, -68930, 15395));
           if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bool(false), ! (! (bool(false))))))))
            continue;
           ivec3 _GLF_SWITCH_5_4v;
           bool _GLF_SWITCH_5_5v[50], _GLF_SWITCH_5_6v;
           (51363 * min(ivec4(-90670, 84003, 49504, 49206).tsps, ivec4(65230, 47968, 72755, 77344)));
          }
          while(false)
           {
            mat4x2(5.4, -6241.5391, -1.3, 186.904, 26.01, -9.9, -37.97, -72.77);
            ;
            greaterThan(uvec2(77344u, 188984u), uvec2(149732u, 103298u));
            ivec3(-62781, 3132, 99680);
            ;
            ;
            uvec3(53095u, 119338u, 40584u);
            bvec3(true, false, false);
           }
          mat3x2 _GLF_SWITCH_5_7v[64], _GLF_SWITCH_5_8v;
          {
          }
          {
           uvec3(151856u, 64871u, 112432u);
           subgroup_id;
           (injectionSwitch + -230.681);
           vec3(81.70, -9.6, -4.3);
           uvec4(125942u, 142308u, 154564u, 65667u);
           mat3 _GLF_SWITCH_5_9v, _GLF_SWITCH_5_10v, _GLF_SWITCH_5_11v[57];
           mat4x3 _GLF_SWITCH_5_12v, _GLF_SWITCH_5_13v, _GLF_SWITCH_5_14v[48];
           ;
          }
          (98929u < (+ 76677u));
          mat4(2.6, 98.77, -7.8, -86.68, -6.8, 4.0, -0.7, -401.395, 0.7, -7.3, -5.1, 1.5, 0.5, 7.1, 549.056, -4.1);
          bool _GLF_SWITCH_5_15v;
         }
         {
         }
         do
          {
           if(_GLF_DEAD(false))
            return;
           bvec2(false, false);
           for(int _GLF_SWITCH_5_16v, _GLF_SWITCH_5_17v; (true ^^ false); bitfieldReverse((uvec4(38139u, 194787u, 71609u, 96840u) * uvec4(_GLF_IDENTITY(82687u, min(82687u, 82687u)), 8307u, 165330u, 88840u))))
            {
             vec4 _GLF_SWITCH_5_18v, _GLF_SWITCH_5_19v[99];
             ivec2 _GLF_SWITCH_5_20v[67];
            }
           while(false)
            {
             mat3(6.9, 4.6, -92.45, -3.9, -68.41, 19.30, 7.9, _GLF_IDENTITY(-81.55, float(_GLF_IDENTITY(mat4x2(-81.55, cos(0.0), abs(1.0), 1.0, 1.0, 1.0, 1.0, determinant(mat2(0.0, 0.0, sin(0.0), 0.0))), (_GLF_IDENTITY(mat4x2(-81.55, cos(0.0), abs(1.0), 1.0, 1.0, 1.0, 1.0, determinant(mat2(0.0, 0.0, sin(0.0), 0.0))), transpose(transpose(mat4x2(-81.55, cos(0.0), abs(1.0), 1.0, 1.0, 1.0, 1.0, determinant(mat2(0.0, 0.0, sin(0.0), 0.0))))))) - mat4x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)))), 8.1);
             mat4x2(-2.9, 84.30, 4.0, -2072.4247, -9.0, -751.471, 5.6, -5.5);
            }
           {
            lessThanEqual(ivec3(-43267, -36108, -29591), ivec3(15920, 62880, -37451));
           }
           if(true)
            {
             bvec2 _GLF_SWITCH_5_21v, _GLF_SWITCH_5_22v;
             uint _GLF_SWITCH_5_23v, _GLF_SWITCH_5_24v;
             mat4 _GLF_SWITCH_5_25v, _GLF_SWITCH_5_26v, _GLF_SWITCH_5_27v;
            }
           if(true)
            {
             mat2x3(9.7, 8905.0071, _GLF_IDENTITY(1.6, (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) ? _GLF_FUZZED(atan(99.12)) : 1.6)), -2726.0821, -63.95, -958.636);
             bvec4(false, false, false, false);
             (mat2x4(-1.0, 0.9, 6.4, 6.4, -22.39, -4.9, 3.7, 1050.9058) / mat2x4(63.89, 892.390, 36.89, 80.94, -94.11, 5.1, -521.951, -26.92));
            }
          }
         while((mat2x3(-2.8, 31.92, 8.1, -350.782, -4.5, 60.82) != mat2x3(-412.970, 4.1, 0.2, 9.9, -23.02, -8.0)));
        }
       default:
       1;
      }
    }
   barrier();
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 uint subgroup_size = gl_SubgroupSize;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     barrier();
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))), bool(_GLF_IDENTITY(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, true), bvec3(bvec3(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, true))))))))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        barrier();
       barrier();
      }
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     barrier();
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     barrier();
    }
   barrier();
   if(_GLF_DEAD(false))
    barrier();
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 uint subgroup_local_id = gl_SubgroupInvocationID;
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   barrier();
  }
 if(_GLF_DEAD(false))
  {
   switch(_GLF_SWITCH(0))
    {
     case 38:
     mat3(-36.57, -21.41, -835.749, -8.2, -52.45, 4.7, 3.4, -5768.5264, -1525.3463);
     case 0:
     if(_GLF_DEAD(false))
      return;
     case 55:
     case 24:
     case 95:
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          return;
         barrier();
        }
       return;
      }
     case 20:
     case 21:
     case 97:
     case 13:
     case 18:
     case 66:
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY((1 ^ 0), int(_GLF_IDENTITY(ivec2(_GLF_IDENTITY((1 ^ 0), int(ivec2((1 ^ 0), 1))), 0), ivec2(ivec3(ivec2(_GLF_IDENTITY((1 ^ 0), int(ivec2((1 ^ _GLF_IDENTITY(0, (_GLF_IDENTITY(0, min(0, 0))) >> 0)), 1))), 0), 1)))))); _GLF_IDENTITY(_injected_loop_counter ++, (_injected_loop_counter ++) | 0))
      {
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > _GLF_IDENTITY(0, 0 ^ (0))); _injected_loop_counter --)
        {
         return;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
        }
       if(_GLF_DEAD(false))
        barrier();
      }
     break;
     if(_GLF_DEAD(false))
      return;
     case 87:
     mat3x4(3813.0135, -2.3, 0.9, -1942.5110, -551.525, -6.1, -6.0, -260.041, -3.1, -186.911, 270.051, -7.9);
     case 11:
     mat2x3(-85.33, -64.95, -754.056, -4.6, 3.3, 8557.1233);
     default:
     1;
    }
  }
 if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ! (! (_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), true && ((injectionSwitch.x > injectionSwitch.y)))))))), bool(bool(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), (! (false)) || false)))))
      return;
     barrier();
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     barrier();
    }
   barrier();
  }
 uint num_workgroup = gl_NumWorkGroups.x;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
  {
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(false))
    barrier();
   do
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          break;
         if(_GLF_DEAD(false))
          break;
         continue;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, (_GLF_IDENTITY(injectionSwitch.y, (injectionSwitch.y) / 1.0)) + 0.0)))))
        barrier();
       barrier();
      }
     if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, (_GLF_IDENTITY(false, bool(bvec4(false, false, false, true)))) || false)))))))))
      {
       if(_GLF_DEAD(false))
        continue;
       barrier();
      }
    }
   while(_GLF_WRAPPED_LOOP(false));
  }
 else
  {
   if(_GLF_DEAD(false))
    return;
  }
 if(_GLF_DEAD(false))
  barrier();
 uint workgroup_size = _GLF_IDENTITY(gl_WorkGroupSize, (_GLF_IDENTITY(gl_WorkGroupSize, max(gl_WorkGroupSize, gl_WorkGroupSize))) / uvec3(1u, 1u, 1u)).x;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, (injectionSwitch) - vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x))).x, max(_GLF_IDENTITY(injectionSwitch, (injectionSwitch) - vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x))).x, _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, (injectionSwitch) - vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x))).x, max(_GLF_IDENTITY(injectionSwitch, (injectionSwitch) - vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x))).x, _GLF_IDENTITY(injectionSwitch, (injectionSwitch) - vec2(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x))).x)))) > injectionSwitch.y))))
  barrier();
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   do
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
    }
   while(_GLF_WRAPPED_LOOP(false));
   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(_GLF_IDENTITY(int(2), (int(2)) >> 0), int(2))) >> _GLF_IDENTITY(int(2), int(2)))); _injected_loop_counter ++)
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      continue;
     barrier();
     if(_GLF_DEAD(false))
      continue;
    }
   if(_GLF_DEAD(false))
    barrier();
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   barrier();
  }
 uint workgroup_id = gl_WorkGroupID.x;
 uint workgroup_base = workgroup_size * workgroup_id;
 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      break;
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          continue;
         return;
        }
       barrier();
      }
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != ((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(_GLF_IDENTITY(int(7), int(7)), 0 ^ (_GLF_IDENTITY(_GLF_IDENTITY(_GLF_IDENTITY(int(7), int(7)), (_GLF_IDENTITY(int(7), int(7))) | (_GLF_IDENTITY(_GLF_IDENTITY(int(7), int(7)), ~ (~ (_GLF_IDENTITY(int(7), int(7))))))), 0 + (_GLF_IDENTITY(_GLF_IDENTITY(int(7), int(7)), (_GLF_IDENTITY(int(7), int(7))) | (_GLF_IDENTITY(_GLF_IDENTITY(int(7), int(7)), ~ (~ (_GLF_IDENTITY(int(7), int(7)))))))))))) >> _GLF_IDENTITY(int(7), _GLF_IDENTITY(int(_GLF_IDENTITY(7, (_GLF_IDENTITY(7, int(ivec2(_GLF_IDENTITY(7, clamp(7, 7, 7)), 1)))) >> 0)), clamp(_GLF_IDENTITY(int(7), min(int(7), int(7))), int(7), int(7)))))); _injected_loop_counter ++)
      {
       if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), bool(bvec3(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), true, true)))))
        {
         switch(_GLF_SWITCH(0))
          {
           case 92:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           for(int _injected_loop_counter = (1 ^ 1); _GLF_WRAPPED_LOOP(_injected_loop_counter < _GLF_IDENTITY(1, min(1, 1))); _injected_loop_counter ++)
            {
             switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
              {
               case 57:
               ivec4 _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v;
               case 0:
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  continue;
                 return;
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               case 95:
               if(false)
                {
                 if(_GLF_DEAD(false))
                  {
                   switch(_GLF_SWITCH((-18914 & 0)))
                    {
                     case 0:
                     case 49:
                     case 91:
                     case 17:
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      return;
                     case 97:
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        barrier();
                       barrier();
                      }
                     case 47:
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      continue;
                     case 63:
                     case 22:
                     case 95:
                     case 15:
                     return;
                     break;
                     if(_GLF_DEAD(false))
                      barrier();
                     case 27:
                     uvec2(103649u, 179446u);
                     case 41:
                     (_GLF_IDENTITY(_injected_loop_counter + _injected_loop_counter, (_injected_loop_counter + _injected_loop_counter) | 0));
                     default:
                     1;
                    }
                  }
                 for(                 bvec4(true, false, true, true);
 (_GLF_IDENTITY(_GLF_IDENTITY(ivec2(2045, -64795), (ivec2(0, 0) | ivec2(0, 0)) | (ivec2(2045, -64795))), min(_GLF_IDENTITY(ivec2(2045, -64795), (ivec2(0, 0) | ivec2(0, 0)) | (ivec2(2045, -64795))), _GLF_IDENTITY(ivec2(2045, -64795), (ivec2(0, 0) | ivec2(0, 0)) | (ivec2(2045, -64795))))) == max(ivec2(-637, -92785), 97919)); -73660)
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    break;
                   do
                    {
                     ivec4 _GLF_SWITCH_2_0v;
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      break;
                     ;
                     ivec3(-61819, 15309, 24835);
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      return;
                     if(_GLF_DEAD(false))
                      barrier();
                     uvec3 _GLF_SWITCH_2_1v, _GLF_SWITCH_2_2v;
                    }
                   while(true);
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                   while(_GLF_IDENTITY(((_GLF_IDENTITY(-378.004 - vec2(305.290, 2.2), (true ? -378.004 - vec2(_GLF_IDENTITY(305.290, mix(float(_GLF_IDENTITY(305.290, mix(float(_GLF_FUZZED(-8.8)), float(305.290), bool(true)))), float(_GLF_FUZZED(7.3)), bool(false))), 2.2) : _GLF_FUZZED(injectionSwitch)))) == injectionSwitch), bool(bvec3(((-378.004 - vec2(305.290, 2.2)) == injectionSwitch), false, false))))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                   else
                    {
                     mat2(mat3x2(1.0, 6.1, 4.7, -7401.8710, 381.078, 6.7));
                    }
                   mat4x2(-0.6, 9.3, -0.8, -129.404, -3.8, 4.7, -4.0, 768.750);
                   if(_GLF_DEAD(false))
                    break;
                  }
                 if(_GLF_DEAD(false))
                  continue;
                 {
                  bvec4 _GLF_SWITCH_2_3v, _GLF_SWITCH_2_4v[77], _GLF_SWITCH_2_5v;
                  smoothstep((7.6 + vec4(1547.8118, -2.3, 615.948, 34.58)), vec4(-6160.2687, -1.2, 20.45, 1.7), vec4(_GLF_IDENTITY(9387.6844, mix(float(9387.6844), float(_GLF_FUZZED((-7948.6473 * (-509.627 / 7609.0208)))), bool(false))), 0.2, -51.28, 8183.1195));
                  for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                   {
                    switch(_GLF_SWITCH(0))
                     {
                      case 40:
                      if(_GLF_DEAD(false))
                       return;
                      float _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v, _GLF_SWITCH_3_2v;
                      case 0:
                      case 91:
                      case 74:
                      case 45:
                      case 34:
                      if(_GLF_DEAD(false))
                       {
                        if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), false || ((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, mix(float(injectionSwitch.y), float(_GLF_FUZZED(-5535.6686)), bool(false)))))))))
                         barrier();
                        barrier();
                        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                         break;
                       }
                      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                       continue;
                      if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (! (_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(3.4), _GLF_IDENTITY(_GLF_FUZZED(vec4(86.66, 4.3, 756.993, 4.4).s), min(_GLF_FUZZED(vec4(86.66, 4.3, 756.993, 4.4).s), _GLF_FUZZED(vec4(86.66, 4.3, 756.993, 4.4).s)))), vec2((injectionSwitch)[0], (injectionSwitch)[1]), _GLF_IDENTITY(bvec2(true, true), _GLF_IDENTITY(bvec2(bvec3(bvec2(true, true), false)), bvec2(bvec3(bvec2(bvec3(bvec2(true, true), false)), false)))))).y)))))))
                       barrier();
                      case 7:
                      case 30:
                      case 46:
                      case 33:
                      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                       continue;
                      case 85:
                      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                       continue;
                      (mix(ivec3(39118, 77271, -97918), ivec3(87168, 13970, 25332), bvec3(false, false, true)) == ivec3(-61737, 30515, -65168));
                      break;
                      case 66:
                      ivec4 _GLF_SWITCH_3_3v, _GLF_SWITCH_3_4v[67];
                      default:
                      1;
                     }
                    if(_GLF_DEAD(false))
                     continue;
                   }
                  mat2x4 _GLF_SWITCH_2_6v, _GLF_SWITCH_2_7v;
                  _GLF_IDENTITY((mat2x4(8.4, -9.7, -7.9, 6.9, -7043.3997, 456.010, -4.1, 6.3) != mat2x4(-3.2, -448.550, 6578.5062, 2.2, -71.68, -524.830, -7383.2597, -641.002)), _GLF_IDENTITY(bool(bvec2((mat2x4(8.4, -9.7, -7.9, 6.9, -7043.3997, 456.010, -4.1, 6.3) != mat2x4(-3.2, -448.550, 6578.5062, 2.2, -71.68, -524.830, -7383.2597, -641.002)), false)), bool(bvec2(bool(bvec2((mat2x4(8.4, -9.7, -7.9, 6.9, -7043.3997, 456.010, -4.1, 6.3) != mat2x4(-3.2, -448.550, 6578.5062, 2.2, -71.68, -524.830, -7383.2597, -641.002)), false)), false))));
                  bvec4 _GLF_SWITCH_2_8v[62], _GLF_SWITCH_2_9v[21];
                 }
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
               break;
               case 35:
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
               mat3x4(986.829, -6.4, _GLF_IDENTITY(-0.8, min(_GLF_IDENTITY(-0.8, max(-0.8, -0.8)), -0.8)), -6871.0256, -1578.7528, -280.468, -5.1, 879.938, 3995.8615, -72.79, 75.76, -214.145);
               case 19:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               (mat3x2(-1.4, -0.5, 236.065, 9.5, 0.4, 6.4));
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
                continue;
               if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                barrier();
               default:
               1;
              }
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(false))
              barrier();
             barrier();
            }
           case 32:
           if(_GLF_DEAD(false))
            return;
           {
            switch(_GLF_SWITCH(_GLF_IDENTITY(int(_GLF_ZERO(0.0, injectionSwitch.x)), max(int(_GLF_ZERO(0.0, injectionSwitch.x)), int(_GLF_ZERO(0.0, injectionSwitch.x))))))
             {
              case 83:
              bvec3 _GLF_SWITCH_5_0v;
              case 61:
              _injected_loop_counter;
              case 0:
              mat4x3 _GLF_SWITCH_2_10v, _GLF_SWITCH_2_11v[9], _GLF_SWITCH_2_12v;
              for(              mat4x2(1.1, -63.79, 4.2, 39.64, 149.702, 57.88, -1326.9329, 5.7);
 true; mat4(7034.6252, -127.238, -6283.3998, -947.225, -66.07, -5.8, 761.997, 6501.6113, 0.9, 3237.8057, 3.8, 10.30, 5.0, 27.67, 7259.1123, 9.1))
               {
                {
                 if(_GLF_DEAD(false))
                  return;
                 (_GLF_IDENTITY(uvec2(183657u, 68888u) == uvec2(78689u, 159950u), (uvec2(183657u, 68888u) == uvec2(78689u, 159950u)) || false));
                 _GLF_IDENTITY(ivec4(-70190, 84959, -4146, 20522), ivec4(0, 0, 0, 0) ^ (ivec4(-70190, 84959, -4146, 20522)));
                 ;
                 if(_GLF_IDENTITY(_GLF_DEAD(false), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (_GLF_DEAD(false))))
                  barrier();
                 mat2 _GLF_SWITCH_2_13v, _GLF_SWITCH_2_14v, _GLF_SWITCH_2_15v;
                 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, ! (! (false))))))))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   barrier();
                  }
                 ivec2(35665, 6078);
                 if(_GLF_DEAD(false))
                  barrier();
                 mat4 _GLF_SWITCH_2_16v[3], _GLF_SWITCH_2_17v[84];
                 if(_GLF_DEAD(false))
                  return;
                 _GLF_IDENTITY(_GLF_SWITCH_2_14v, transpose(transpose(_GLF_SWITCH_2_14v)));
                 if(_GLF_DEAD(false))
                  break;
                 if(_GLF_DEAD(false))
                  barrier();
                 uint _GLF_SWITCH_2_18v, _GLF_SWITCH_2_19v[27];
                 if(_GLF_DEAD(false))
                  barrier();
                }
               }
              case 22:
              for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
               {
                if(_GLF_DEAD(false))
                 barrier();
                do
                 {
                  if(_GLF_DEAD(false))
                   barrier();
                  if(_GLF_DEAD(false))
                   barrier();
                 }
                while(_GLF_WRAPPED_LOOP(false));
                if(_GLF_DEAD(false))
                 return;
                if(_GLF_DEAD(false))
                 {
                  for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                   {
                    switch(_GLF_SWITCH(0))
                     {
                      case 35:
                      mat2(2.4, -647.108, 9.4, 64.28);
                      case 47:
                      float _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v, _GLF_SWITCH_4_2v;
                      case 0:
                      case 80:
                      case 96:
                      case 27:
                      case 55:
                      return;
                      break;
                      case 13:
                      uvec3 _GLF_SWITCH_4_3v;
                      case 50:
                      vec2(87.30, -8.0);
                      if(_GLF_DEAD(false))
                       break;
                      default:
                      1;
                     }
                    if(_GLF_DEAD(false))
                     continue;
                   }
                 }
               }
              for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 return;
                while(false)
                 {
                  ;
                  if(_GLF_DEAD(false))
                   barrier();
                  if(_GLF_DEAD(false))
                   barrier();
                  mat3x2 _GLF_SWITCH_2_20v;
                  if(_GLF_DEAD(false))
                   barrier();
                 }
               }
              (+ mat4x2(-2798.6464, -8.6, 4178.0995, 3503.8818, 4511.0954, 8469.0436, 8961.0812, -50.01));
              case 18:
              case 66:
              if((mat3(34.08, -93.71, -8.5, 76.28, -89.72, 5117.2974, 58.64, 26.91, -57.07) != mat3(-0.3, -44.46, -8125.4819, 3.3, 8.5, 3.0, 69.16, -9.8, 7.2)))
               {
               }
              case 16:
              mat4x2 _GLF_SWITCH_2_21v, _GLF_SWITCH_2_22v;
              mat4x2 _GLF_SWITCH_2_23v[88], _GLF_SWITCH_2_24v[59];
              break;
              case 6:
              uvec2 _GLF_SWITCH_5_1v[30], _GLF_SWITCH_5_2v[60], _GLF_SWITCH_5_3v[64];
              case 37:
              int _GLF_SWITCH_5_4v[92], _GLF_SWITCH_5_5v, _GLF_SWITCH_5_6v;
              default:
              1;
             }
           }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           case 0:
           case 20:
           case 69:
           case 24:
           if(_GLF_DEAD(false))
            barrier();
           case 42:
           case 53:
           barrier();
           break;
           default:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           1;
           if(_GLF_DEAD(false))
            barrier();
          }
        }
       else
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_DEAD(false))
        barrier();
      }
     if(_GLF_DEAD(false))
      barrier();
    }
  }
 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
  barrier();
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 if(_GLF_DEAD(false))
  {
   switch(_GLF_SWITCH(0))
    {
     case 91:
     bvec3(true, false, false);
     case 93:
     int _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v;
     case 0:
     case 43:
     case 53:
     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
      }
     else
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        return;
      }
     do
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        break;
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, (false ? _GLF_FUZZED(vec2(5.6, 8.9)) : injectionSwitch)).x > injectionSwitch.y))))
          {
           if(_GLF_IDENTITY(_GLF_DEAD(false), ! (_GLF_IDENTITY(! (_GLF_DEAD(false)), bool(bool(_GLF_IDENTITY(! (_GLF_DEAD(false)), (! (_GLF_DEAD(false))) && true)))))))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(false))
              barrier();
             barrier();
             if(_GLF_DEAD(false))
              return;
            }
           return;
          }
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         barrier();
        }
       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec3(_GLF_IDENTITY(false, bool(bvec2(false, false))), false, false), bvec3(bvec3(bvec3(_GLF_IDENTITY(false, bool(bvec2(false, false))), false, false))))))))
        barrier();
      }
     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
     case 44:
     barrier();
     if(_GLF_DEAD(false))
      {
       for(int _injected_loop_counter = (_GLF_IDENTITY(0, 0 ^ (0)) | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (int(4)) >> 0)))); _injected_loop_counter ++)
        {
         barrier();
        }
      }
     break;
     if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), (_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))) || false))
      barrier();
     case 35:
     uvec3(149114u, 36442u, 53400u);
     default:
     1;
    }
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
    barrier();
   barrier();
  }
 uint virtual_gid = workgroup_base + subgroup_id * _GLF_IDENTITY(subgroup_size, (subgroup_size) | (subgroup_size)) + subgroup_local_id;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  {
   for(int _injected_loop_counter = (1 | 1); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
    {
     barrier();
    }
  }
 if(_GLF_DEAD(false))
  barrier();
 do
  {
   switch(_GLF_SWITCH(0))
    {
     case 0:
     if(_GLF_DEAD(false))
      continue;
     case 75:
     if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || _GLF_IDENTITY(false, ! (! (false))))))
      {
       switch(_GLF_SWITCH((1 ^ 1)))
        {
         case 0:
         case 63:
         case 4:
         if(_GLF_DEAD(false))
          {
           switch(_GLF_SWITCH((0 << _GLF_IDENTITY(int(7), int(7)))))
            {
             case 86:
             true;
             case 38:
             clamp((61222 / ivec4(58518, 98873, -49669, 45768)), ivec4(21736, -53891, -48930, _GLF_IDENTITY(78600, (78600) | 0)), ivec4(67052, 81385, -29832, 47737));
             case 0:
             if(_GLF_DEAD(false))
              barrier();
             barrier();
             break;
             default:
             1;
            }
          }
         barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         break;
         case 38:
         mat3 _GLF_SWITCH_3_0v[79], _GLF_SWITCH_3_1v[37], _GLF_SWITCH_3_2v;
         case 22:
         if(false)
          {
           mat3x2(4.7, 51.28, -2.7, -567.418, 2.2, 6.9);
           mat4(1.4, -205.749, -3557.9771, 1.7, 38.45, -3202.1657, -82.48, 0.9, -6731.6248, -50.52, 3.5, -411.154, 9869.9538, 18.59, -2.1, -60.14);
           if(false)
            {
             if(_GLF_DEAD(false))
              break;
             ((5.7 / mat2x4(5.0, 73.13, -3.3, 682.636, -573.596, -43.45, -2.4, -724.734)));
             mat3x2 _GLF_SWITCH_3_3v[89], _GLF_SWITCH_3_4v[43], _GLF_SWITCH_3_5v;
             uvec2 _GLF_SWITCH_3_6v, _GLF_SWITCH_3_7v[19];
             if(_GLF_DEAD(false))
              continue;
             mat2x3(5.2, -1.2, 6.8, -7.1, 33.46, -84.09);
             mat3x4 _GLF_SWITCH_3_8v;
             ((true ? ivec3(-78908, 75175, _GLF_IDENTITY(84266, (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) ? _GLF_FUZZED(40639) : 84266))) : ivec3(99465, -84173, 23986)) / ivec3(79332, 82742, 29244));
            }
           if(_GLF_DEAD(false))
            barrier();
           {
            false;
            bvec2(false, true);
            (mat4x3(-623.517, -80.47, 6.4, _GLF_IDENTITY(32.16, clamp(32.16, 32.16, 32.16)), -8.4, 5920.1769, 1.9, 4.0, -8.9, -1399.5730, 4.7, 662.270) / 8.5);
            uvec3(41810u, 101175u, 96682u);
            mat2x4 _GLF_SWITCH_3_9v[13], _GLF_SWITCH_3_10v;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            vec3 _GLF_SWITCH_3_11v;
            if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
             barrier();
            max(ivec4(-23748, -48944, -94489, -45392), ivec4(23647, 34299, -30819, 28024));
           }
           do
            {
             if(_GLF_DEAD(false))
              barrier();
             vec3(514.428, -29.92, 6285.2883);
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             ((+ ivec2(78985, 3955)) | 21300);
             if(_GLF_DEAD(false))
              barrier();
             mat2 _GLF_SWITCH_3_12v[67];
             ;
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
             uvec4(uvec2(199806u, 113321u), (uvec2(89355u, 57654u)));
             if(_GLF_DEAD(false))
              barrier();
             (ivec3(84836, 17578, 67801) != (-38115 | ivec3(-40478, 78811, 5891)));
             uvec3(84725u, 3446u, 123172u);
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
              barrier();
             uvec2 _GLF_SWITCH_3_13v, _GLF_SWITCH_3_14v;
             (ivec3(-70272, _GLF_IDENTITY(88918, 1 * (_GLF_IDENTITY(88918, int(_GLF_ONE(1.0, injectionSwitch.y)) * (_GLF_IDENTITY(88918, max(88918, 88918)))))), -19658) * ivec3(52361, -90748, -26601));
            }
           while(true);
           if((! true))
            {
             (virtual_gid % uvec2(46024u, 90751u));
            }
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             sqrt(-9.8);
            }
          }
         default:
         1;
         if(_GLF_DEAD(false))
          return;
        }
      }
     break;
     case 73:
     if(_GLF_DEAD(false))
      return;
     mat4x3(2.9, 106.896, -463.103, -758.381, 0.6, -168.209, -5846.6204, -635.482, -5.1, -714.900, 2.6, 83.47);
     default:
     if(_GLF_DEAD(false))
      return;
     1;
    }
  }
 while(_GLF_WRAPPED_LOOP(false));
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  return;
 uint next_virtual_gid = workgroup_base + _GLF_IDENTITY(subgroup_id * subgroup_size, (subgroup_id * subgroup_size) | (subgroup_id * subgroup_size)) + ((subgroup_local_id + 1) % subgroup_size);
 uint read = atomicLoad(buf[virtual_gid], 4, 64, 0);
 do
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   switch(_GLF_SWITCH(0))
    {
     case 61:
     mat3 _GLF_SWITCH_1_0v;
     case 26:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, injectionSwitch.y, injectionSwitch.y))))))
      barrier();
     for(int _injected_loop_counter = _GLF_IDENTITY(1, clamp(1, 1, 1)); _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY(0, clamp(0, 0, 0))); _injected_loop_counter --)
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         barrier();
        }
       if(_GLF_DEAD(false))
        barrier();
      }
     ;
     if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(false))
      break;
     if(_GLF_DEAD(false))
      barrier();
     case 0:
     case 53:
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       barrier();
      }
     case 34:
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       break;
       if(_GLF_DEAD(false))
        return;
      }
     if(_GLF_DEAD(false))
      barrier();
     case 42:
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      {
       switch(_GLF_SWITCH(0))
        {
         case 34:
         ;
         case 0:
         case 69:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         case 29:
         if(_GLF_DEAD(false))
          continue;
         case 60:
         case 66:
         case 99:
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
          }
         else
          {
           barrier();
          }
         break;
         case 18:
         bool _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v, _GLF_SWITCH_4_2v;
         case 54:
         mat3x2 _GLF_SWITCH_4_3v[63], _GLF_SWITCH_4_4v;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         default:
         1;
        }
      }
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      continue;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     switch(_GLF_IDENTITY(_GLF_SWITCH(0), ~ (_GLF_IDENTITY(~ (_GLF_SWITCH(0)), _GLF_IDENTITY(max(~ (_GLF_SWITCH(0)), ~ (_GLF_SWITCH(0))), (max(~ (_GLF_SWITCH(0)), ~ (_GLF_SWITCH(0)))) - 0)))))
      {
       case 89:
       if((step(normalize(-287.688), injectionSwitch) != vec2(4.2, 6.6)))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         bvec2 _GLF_SWITCH_0_0v[4], _GLF_SWITCH_0_1v, _GLF_SWITCH_0_2v;
         mat3x4 _GLF_SWITCH_0_3v, _GLF_SWITCH_0_4v[71];
         if(_GLF_DEAD(false))
          barrier();
         uvec2 _GLF_SWITCH_0_5v[98], _GLF_SWITCH_0_6v;
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_IDENTITY(_GLF_DEAD(false), _GLF_IDENTITY(true, ! (! (_GLF_IDENTITY(true, (true) || false)))) && (_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))))
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             switch(_GLF_SWITCH(0))
              {
               case 64:
               -845.596;
               case 0:
               case 97:
               case 36:
               case 1:
               case 9:
               case 68:
               switch(_GLF_IDENTITY(_GLF_SWITCH(_GLF_IDENTITY(int(_GLF_ZERO(_GLF_IDENTITY(0.0, (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) ? 0.0 : _GLF_FUZZED(7.4))), injectionSwitch.x)), (int(_GLF_ZERO(_GLF_IDENTITY(0.0, (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) ? 0.0 : _GLF_FUZZED(7.4))), injectionSwitch.x))) >> 0)), ~ (~ (_GLF_IDENTITY(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))), ~ (~ (_GLF_IDENTITY(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))), int(ivec4(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))), 1, 0, 1))))))))))
                {
                 case 17:
                 mat4x3 _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v[2];
                 case 0:
                 case 77:
                 case 62:
                 if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, (_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1]))) - vec2(0.0, 0.0)).x > _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.y, max(injectionSwitch.y, _GLF_IDENTITY(injectionSwitch.y, (_GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, injectionSwitch.y, injectionSwitch.y))) / 1.0))), max(_GLF_IDENTITY(injectionSwitch.y, max(injectionSwitch.y, _GLF_IDENTITY(injectionSwitch.y, (_GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, injectionSwitch.y, injectionSwitch.y))) / 1.0))), _GLF_IDENTITY(injectionSwitch.y, max(injectionSwitch.y, _GLF_IDENTITY(injectionSwitch.y, (_GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, injectionSwitch.y, injectionSwitch.y))) / 1.0)))))))))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 & -4225)); _injected_loop_counter --)
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                    }
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      return;
                     barrier();
                    }
                   continue;
                  }
                 case 93:
                 barrier();
                 break;
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                 case 7:
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      break;
                     break;
                    }
                   barrier();
                  }
                 ;
                 if(_GLF_DEAD(false))
                  barrier();
                 default:
                 if(_GLF_DEAD(false))
                  break;
                 1;
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(false))
                  barrier();
                }
               break;
               case 16:
               (uvec2(128708u, 156820u) / uvec2(40878u, 85983u));
               default:
               1;
              }
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, (false) && true)))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              barrier();
             do
              {
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, true)))))
                return;
               return;
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bool(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
            break;
           barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         ivec4 _GLF_SWITCH_0_7v, _GLF_SWITCH_0_8v;
         if(_GLF_IDENTITY(_GLF_DEAD(false), false || (_GLF_DEAD(false))))
          barrier();
         {
          if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && true))
           barrier();
          if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, false || (false))) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))
           break;
          if(_GLF_WRAPPED_IF_TRUE(true))
           {
            _GLF_SWITCH_0_6v;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
           }
          else
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             continue;
           }
          if(_GLF_DEAD(false))
           barrier();
          if(_GLF_DEAD(false))
           continue;
          ivec2 _GLF_SWITCH_0_9v, _GLF_SWITCH_0_10v;
          uvec4(48551u, 14010u, 23618u, 143672u);
          uvec4(196781u, 153476u, 31893u, 8440u);
          if(_GLF_DEAD(false))
           {
            switch(_GLF_SWITCH(0))
             {
              case 9:
              mat3 _GLF_SWITCH_3_0v[72], _GLF_SWITCH_3_1v, _GLF_SWITCH_3_2v[40];
              case 71:
              (-4934.7621 / mat4(-1.3, -19.55, 4.0, -3273.8928, -526.537, -92.34, -9958.1620, 7.8, -10.48, _GLF_IDENTITY(-6.5, (false ? _GLF_FUZZED(-55.50) : -6.5)), -26.00, -728.798, 3.6, -452.778, -2.3, -3.8));
              case 0:
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 continue;
                barrier();
               }
              if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
               {
                switch(_GLF_SWITCH((0 << _GLF_IDENTITY(int(6), int(6)))))
                 {
                  case 94:
                  uvec4(workgroup_base, (uvec2(59372u, 161092u) / uvec2(24311u, 24455u)), (vec2(-4.2, -69.76) , next_virtual_gid));
                  case 0:
                  case 81:
                  barrier();
                  if(_GLF_DEAD(false))
                   barrier();
                  break;
                  case 52:
                  mat3(vec3(-1.9, 3937.6062, 2.9), (vec3(9.0, -4.2, 7.6)), vec3(810.025, -9150.4796, -164.141));
                  if(_GLF_DEAD(false))
                   return;
                  default:
                  1;
                 }
               }
              else
               {
                if(_GLF_DEAD(false))
                 break;
               }
              break;
              case 90:
              ivec3 _GLF_SWITCH_3_3v, _GLF_SWITCH_3_4v;
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               barrier();
              default:
              1;
              if(_GLF_DEAD(false))
               continue;
              if(_GLF_DEAD(false))
               barrier();
             }
            if(_GLF_DEAD(false))
             break;
           }
          if(_GLF_DEAD(false))
           barrier();
          if(_GLF_DEAD(false))
           return;
          mat2x3 _GLF_SWITCH_0_11v;
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             break;
            break;
           }
         }
         float _GLF_SWITCH_0_12v, _GLF_SWITCH_0_13v[91], _GLF_SWITCH_0_14v;
         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, bool(bool(_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, true && (injectionSwitch.x > injectionSwitch.y)))))))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             barrier();
            }
           if(_GLF_DEAD(false))
            barrier();
           barrier();
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_DEAD(false))
          {
           switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
            {
             case 35:
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             (-56240 | ivec2(-85084, 71839));
             case 0:
             if(_GLF_DEAD(false))
              return;
             continue;
             break;
             case 24:
             uint _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v[52];
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             default:
             1;
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
         ((_GLF_IDENTITY((ivec2(_GLF_IDENTITY(43989, max(43989, 43989)), 21958) % -32708) - -73277, max(_GLF_IDENTITY((ivec2(_GLF_IDENTITY(43989, max(43989, 43989)), 21958) % -32708) - -73277, max((ivec2(_GLF_IDENTITY(43989, max(43989, 43989)), 21958) % -32708) - -73277, (ivec2(_GLF_IDENTITY(43989, max(43989, 43989)), 21958) % -32708) - -73277)), (ivec2(_GLF_IDENTITY(43989, max(43989, 43989)), 21958) % -32708) - -73277))) , _GLF_SWITCH_0_3v);
         mat2x3 _GLF_SWITCH_0_15v, _GLF_SWITCH_0_16v[11], _GLF_SWITCH_0_17v;
         {
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
              if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))
               continue;
              barrier();
             }
            if(_GLF_WRAPPED_IF_TRUE(true))
             {
              if(_GLF_DEAD(false))
               barrier();
              barrier();
             }
            else
             {
              if(_GLF_DEAD(false))
               return;
             }
           }
          if(_GLF_IDENTITY((ivec3(_GLF_IDENTITY(-93184, (-93184) >> 0), _GLF_IDENTITY(-80420, (-80420) << _GLF_IDENTITY(0, ~ (~ (0)))), -93051) != ivec3(ivec4(58480, -63708, -27466, -43083))), false || ((ivec3(-93184, -80420, -93051) != ivec3(ivec4(58480, -63708, -27466, -43083))))))
           {
            switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
             {
              case 39:
              uvec3 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v;
              case 9:
              mat2x4 _GLF_SWITCH_5_2v;
              case 0:
              case 97:
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, false || (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (injectionSwitch.x > injectionSwitch.y) && true)))))))
               {
                if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(_GLF_IDENTITY(false, true && (_GLF_IDENTITY(false, (false) || false))), false, true)))))
                 barrier();
                barrier();
               }
              case 6:
              mat3x2 _GLF_SWITCH_0_18v, _GLF_SWITCH_0_19v;
              case 82:
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 barrier();
                barrier();
               }
              case 57:
              case 96:
              case 38:
              float _GLF_SWITCH_0_20v[73], _GLF_SWITCH_0_21v;
              case 10:
              case 61:
              for(int _injected_loop_counter = _GLF_IDENTITY(0, (0) | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _GLF_IDENTITY(_injected_loop_counter ++, (_injected_loop_counter ++) >> 0))
               {
                if(_GLF_DEAD(false))
                 continue;
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 barrier();
                if(_GLF_DEAD(false))
                 {
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, mix(float(_GLF_FUZZED(vec3(250.715, 286.020, 712.204).b)), float(injectionSwitch.y), bool(true)))))))
                   barrier();
                  barrier();
                  if(_GLF_DEAD(false))
                   barrier();
                 }
               }
              break;
              case 93:
              int _GLF_SWITCH_5_3v[5], _GLF_SWITCH_5_4v, _GLF_SWITCH_5_5v[60];
              default:
              if(_GLF_DEAD(false))
               continue;
              1;
             }
           }
          {
           do
            {
             switch(_GLF_SWITCH(0))
              {
               case 11:
               (_GLF_SWITCH_0_12v - mat2(mat3x4(-5.1, -4.8, -92.59, 3.6, 8.2, 3.1, 868.401, -83.98, 96.85, 770.600, 5116.1586, 7.5)));
               case 0:
               case 4:
               case 36:
               if(_GLF_DEAD(false))
                continue;
               case 42:
               case 53:
               case 80:
               case 54:
               case 16:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
               case 60:
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                break;
               break;
               case 88:
               ;
               case 64:
               uvec4 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v;
               default:
               1;
               if(_GLF_DEAD(false))
                continue;
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(_GLF_IDENTITY(bool(false), false || (bool(false)))), false || (bool(_GLF_IDENTITY(bool(false), false || (bool(false))))))), true && (_GLF_IDENTITY(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(_GLF_IDENTITY(bool(false), false || (bool(false)))), false || (bool(_GLF_IDENTITY(bool(false), false || (bool(false))))))), ! (! (_GLF_IDENTITY(false, _GLF_IDENTITY(bool(_GLF_IDENTITY(bool(false), false || (bool(false)))), false || (bool(_GLF_IDENTITY(bool(false), false || (bool(false))))))))))))));
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               barrier();
              }
             else
              {
              }
            }
           if(_GLF_DEAD(false))
            continue;
           (_GLF_SWITCH_0_3v == (mat3x4(_GLF_SWITCH_0_14v) / mat3x4(-8576.1457, 9918.5239, _GLF_IDENTITY(_GLF_IDENTITY(-8800.6510, (_GLF_IDENTITY(-8800.6510, clamp(-8800.6510, -8800.6510, -8800.6510))) / 1.0), (_GLF_IDENTITY(_GLF_IDENTITY(-8800.6510, (_GLF_IDENTITY(-8800.6510, clamp(-8800.6510, -8800.6510, -8800.6510))) / 1.0), (_GLF_IDENTITY(-8800.6510, _GLF_IDENTITY((_GLF_IDENTITY(-8800.6510, clamp(-8800.6510, -8800.6510, -8800.6510))) / 1.0, max((_GLF_IDENTITY(-8800.6510, clamp(-8800.6510, -8800.6510, -8800.6510))) / 1.0, _GLF_IDENTITY((_GLF_IDENTITY(-8800.6510, clamp(-8800.6510, -8800.6510, -8800.6510))) / 1.0, min(_GLF_IDENTITY((_GLF_IDENTITY(-8800.6510, clamp(-8800.6510, -8800.6510, -8800.6510))) / 1.0, (false ? _GLF_FUZZED(_GLF_SWITCH_0_12v) : (_GLF_IDENTITY(-8800.6510, clamp(-8800.6510, -8800.6510, -8800.6510))) / 1.0)), (_GLF_IDENTITY(-8800.6510, clamp(-8800.6510, -8800.6510, -8800.6510))) / 1.0)))))) + 0.0)) - sin(0.0)), -1.0, 8.1, 3.7, 5.6, 5.6, -43.56, 5.4, 8.4, -8.6)));
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
            {
             ;
            }
           ;
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
            return;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               barrier();
              }
             else
              {
              }
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(false))
              barrier();
            }
           mat3x2 _GLF_SWITCH_0_22v, _GLF_SWITCH_0_23v, _GLF_SWITCH_0_24v;
           _GLF_SWITCH_0_3v;
          }
          if(_GLF_DEAD(false))
           barrier();
          if(_GLF_DEAD(false))
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            break;
           }
          if(_GLF_DEAD(false))
           barrier();
          _GLF_SWITCH_0_1v;
          if(_GLF_DEAD(false))
           barrier();
          if(_GLF_DEAD(false))
           barrier();
          if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
           barrier();
          for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < _GLF_IDENTITY(1, (1) | (1))); _injected_loop_counter ++)
           {
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(false))
               return;
              barrier();
             }
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
                if(_GLF_DEAD(false))
                 continue;
                barrier();
               }
              if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
               return;
              return;
             }
           }
          if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(87.05), (injectionSwitch)[1]), vec2((injectionSwitch)[0], _GLF_FUZZED(-1.7)), bvec2(true, false))).x > injectionSwitch.y))))
           continue;
          if(_GLF_DEAD(false))
           barrier();
          if(_GLF_WRAPPED_IF_TRUE(true))
           {
            injectionSwitch;
           }
          else
           {
           }
          if(_GLF_DEAD(false))
           break;
          if(_GLF_DEAD(false))
           barrier();
          while(false)
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            isnan(vec2(-49.30, 2.1)).stt;
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(false))
               break;
              return;
             }
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             continue;
            min(_GLF_SWITCH_0_6v, _GLF_SWITCH_0_6v);
            if(_GLF_DEAD(false))
             barrier();
            if(_GLF_DEAD(false))
             continue;
           }
          if(_GLF_DEAD(false))
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
              switch(_GLF_SWITCH(0))
               {
                case 56:
                mat4x2 _GLF_SWITCH_5_0v[73], _GLF_SWITCH_5_1v[7], _GLF_SWITCH_5_2v[73];
                case 76:
                uvec3 _GLF_SWITCH_5_3v;
                if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                 return;
                case 0:
                case 50:
                case 78:
                case 38:
                case 33:
                if(_GLF_DEAD(false))
                 barrier();
                case 57:
                continue;
                break;
                case 44:
                ivec2 _GLF_SWITCH_5_4v, _GLF_SWITCH_5_5v;
                default:
                1;
               }
             }
            barrier();
            if(_GLF_DEAD(false))
             barrier();
           }
          if(_GLF_DEAD(false))
           return;
          for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > _GLF_IDENTITY(int(_GLF_ZERO(0.0, injectionSwitch.x)), (int(_GLF_ZERO(0.0, injectionSwitch.x))) | 0)); _injected_loop_counter --)
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 break;
                if(_GLF_DEAD(false))
                 barrier();
                break;
               }
              if(_GLF_DEAD(false))
               continue;
              barrier();
              if(_GLF_DEAD(false))
               barrier();
             }
            if(_GLF_DEAD(false))
             barrier();
            if(_GLF_DEAD(false))
             barrier();
           }
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           {
            do
             {
              barrier();
             }
            while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, (injectionSwitch) - vec2(0.0, 0.0)).x > injectionSwitch.y))));
           }
          while((mat4(-6.5, -2116.3381, -85.41, -687.788, -0.2, -65.23, 5.8, _GLF_IDENTITY(-1.1, float(mat2x4(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_IDENTITY(-1.1, _GLF_IDENTITY(dot(vec2(0.0, cos(0.0)), vec2(1.0, 0.0)), _GLF_IDENTITY(dot(vec2(0.0, cos(0.0)), vec2(1.0, 0.0)), min(dot(vec2(0.0, cos(0.0)), vec2(1.0, 0.0)), dot(vec2(0.0, cos(0.0)), vec2(1.0, 0.0))))) + (-1.1)), (_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).x > injectionSwitch.y)) ? _GLF_FUZZED(2.4) : -1.1)), max(-1.1, -1.1)), _GLF_IDENTITY(1.0, (1.0) - 0.0), _GLF_IDENTITY(1.0, float(float(_GLF_IDENTITY(1.0, max(1.0, 1.0))))), 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 0.0, 1.0, 1.0))), _GLF_IDENTITY(-3.1, float(float(-3.1))), 35.83, 39.53, 5.6, 24.78, -48.06, 776.476, 7.3) == mat4(599.722, -520.472, 832.380, 6.2, -27.02, -6488.3518, -7980.2725, -5.2, -86.14, -5.7, 2.8, _GLF_IDENTITY(_GLF_IDENTITY(99.64, max(_GLF_IDENTITY(99.64, (false ? _GLF_FUZZED(8.0) : 99.64)), 99.64)), _GLF_IDENTITY(float(mat4x3(_GLF_IDENTITY(99.64, max(_GLF_IDENTITY(99.64, (false ? _GLF_FUZZED(8.0) : 99.64)), 99.64)), 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, determinant(mat3(1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, log(1.0), 1.0)), 0.0, 1.0, 0.0, 0.0)), mix(float(float(mat4x3(_GLF_IDENTITY(99.64, max(_GLF_IDENTITY(99.64, (false ? _GLF_FUZZED(8.0) : 99.64)), 99.64)), 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, determinant(mat3(1.0, _GLF_IDENTITY(0.0, _GLF_IDENTITY(float(mat3x4(0.0, 0.0, 0.0, 0.0, sin(0.0), 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0)), float(mat4x3(float(mat3x4(0.0, 0.0, 0.0, 0.0, sin(0.0), 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0)), 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0)))), 1.0, 0.0, 1.0, 0.0, 0.0, log(1.0), 1.0)), 0.0, 1.0, 0.0, 0.0))), float(_GLF_FUZZED((-739.898 - -18.22))), bool(false)))), -6.1, 780.606, -5965.8042, -886.224)))
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            if(_GLF_DEAD(false))
             break;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             break;
            switch(_GLF_SWITCH(0))
             {
              case 67:
              if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (_GLF_IDENTITY(! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))) && true)))))
               barrier();
              ;
              case 0:
              if(_GLF_WRAPPED_IF_TRUE(true))
               {
                if(_GLF_DEAD(false))
                 barrier();
                if(_GLF_DEAD(false))
                 return;
                if(_GLF_WRAPPED_IF_FALSE(false))
                 {
                 }
                else
                 {
                  ;
                  if(_GLF_DEAD(false))
                   {
                    if(_GLF_DEAD(false))
                     return;
                    continue;
                   }
                 }
               }
              else
               {
               }
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
                switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                 {
                  case 12:
                  uvec3(1931u, 108139u, 32254u);
                  case 63:
                  uvec3 _GLF_SWITCH_5_0v[60], _GLF_SWITCH_5_1v, _GLF_SWITCH_5_2v;
                  case 0:
                  case 74:
                  if(_GLF_DEAD(false))
                   break;
                  case 25:
                  case 67:
                  if(_GLF_DEAD(false))
                   break;
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   return;
                  case 82:
                  case 69:
                  barrier();
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   continue;
                  break;
                  default:
                  1;
                 }
               }
              case 32:
              if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
               {
                for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                 {
                  if(_GLF_DEAD(false))
                   barrier();
                 }
               }
              else
               {
               }
              break;
              case 65:
              if(_GLF_DEAD(false))
               break;
              workgroup_base;
              default:
              do
               {
                1;
                if(_GLF_DEAD(false))
                 return;
               }
              while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
              if(_GLF_DEAD(false))
               break;
             }
           }
          if(_GLF_DEAD(false))
           {
            if(_GLF_DEAD(false))
             barrier();
            if(_GLF_DEAD(false))
             barrier();
            if(_GLF_DEAD(false))
             continue;
            break;
            if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
           }
          vec4 _GLF_SWITCH_0_25v, _GLF_SWITCH_0_26v;
          if(_GLF_DEAD(false))
           barrier();
          uvec4((_GLF_IDENTITY(subgroup_local_id * workgroup_base, 1u * (_GLF_IDENTITY(subgroup_local_id * workgroup_base, (subgroup_local_id * workgroup_base) | (subgroup_local_id * workgroup_base))))), virtual_gid, _GLF_SWITCH_0_6v);
         }
         if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && true))
          {
           if(_GLF_DEAD(false))
            barrier();
           continue;
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
          return;
        }
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
        }
       else
        {
         if(_GLF_DEAD(false))
          break;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       case 0:
       case 87:
       if(_GLF_DEAD(false))
        {
         if(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(false), _GLF_IDENTITY(false, ! (! (false))) || (_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(false), (_GLF_WRAPPED_IF_FALSE(false)) && true))))
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
           barrier();
          }
        }
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        {
         for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
          {
           if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, (_GLF_IDENTITY(true, (_GLF_IDENTITY(true, bool(bool(true)))) && true)) && true)))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             barrier();
            }
           else
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), (! (false)) || false))), _GLF_IDENTITY((_GLF_IDENTITY(injectionSwitch, (injectionSwitch) * mat2(1.0)).x > injectionSwitch.y), bool(bvec3((_GLF_IDENTITY(injectionSwitch, (injectionSwitch) * mat2(1.0)).x > injectionSwitch.y), _GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, sqrt(1.0) * (injectionSwitch.x)) > injectionSwitch.y)), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 barrier();
                 if(_GLF_DEAD(false))
                  return;
                }
              }
            }
          }
        }
       case 67:
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
          }
         else
          {
           barrier();
          }
        }
       case 52:
       case 27:
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            barrier();
           barrier();
           if(_GLF_DEAD(false))
            break;
          }
         barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          break;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       case 65:
       case 56:
       if(_GLF_DEAD(false))
        barrier();
       case 98:
       atomicStore(buf[next_virtual_gid], uint(1), 4, 64, 4);
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          break;
         barrier();
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, (false) && true), (injectionSwitch.x > injectionSwitch.y))))
          barrier();
        }
       break;
       case 49:
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       else
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              return;
             barrier();
            }
           break;
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             barrier();
            }
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         uvec3(189812u, 48264u, 88527u);
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
        }
       default:
       1;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         do
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
            break;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, (false) && true))))))
              break;
             barrier();
            }
           barrier();
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
      }
     if(_GLF_DEAD(false))
      barrier();
     break;
     if(_GLF_DEAD(false))
      continue;
     default:
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        break;
       barrier();
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     1;
     if(_GLF_DEAD(false))
      barrier();
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    break;
  }
 while(_GLF_IDENTITY(_GLF_WRAPPED_LOOP(false), bool(_GLF_IDENTITY(bvec2(_GLF_IDENTITY(_GLF_WRAPPED_LOOP(false), bool(bvec4(_GLF_WRAPPED_LOOP(false), true, true, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), _GLF_TRUE(true, (injectionSwitch.x < _GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)).y))), bvec2(bvec3(bvec2(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_WRAPPED_LOOP(false), bool(bvec4(_GLF_WRAPPED_LOOP(false), _GLF_IDENTITY(true, ! (! (true))), true, _GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, (false ? _GLF_FUZZED(max(injectionSwitch, injectionSwitch)) : injectionSwitch)).y, (_GLF_IDENTITY(injectionSwitch, (false ? _GLF_FUZZED(max(injectionSwitch, injectionSwitch)) : injectionSwitch)).y) / 1.0)))))), _GLF_IDENTITY(bool(bvec4(_GLF_IDENTITY(_GLF_WRAPPED_LOOP(false), bool(bvec4(_GLF_WRAPPED_LOOP(false), true, true, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), true, false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))), ! (! (bool(bvec4(_GLF_IDENTITY(_GLF_WRAPPED_LOOP(false), bool(bvec4(_GLF_WRAPPED_LOOP(false), true, _GLF_IDENTITY(true, (true) || false), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), true, false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))), true))))));
 if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY((false) && true, (_GLF_IDENTITY((false) && true, true && ((false) && true))) || false))))
  barrier();
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      return;
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       return;
       if(_GLF_DEAD(false))
        barrier();
      }
     else
      {
      }
    }
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y))))))
    barrier();
   do
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(false), ! (! (_GLF_WRAPPED_IF_FALSE(false)))))
        {
         switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
          {
           case 0:
           case 74:
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           case 72:
           case 96:
           if(_GLF_DEAD(false))
            {
             switch(_GLF_SWITCH(_GLF_IDENTITY(0, (0) | (0))))
              {
               case 0:
               if(_GLF_IDENTITY(_GLF_DEAD(false), bool(_GLF_IDENTITY(bvec2(_GLF_DEAD(false), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bvec2(bvec2(_GLF_IDENTITY(bvec2(_GLF_DEAD(false), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bvec2(bvec3(bvec2(_GLF_DEAD(false), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), false)))))))))
                {
                 do
                  {
                   return;
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                }
               if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                barrier();
               if(_GLF_DEAD(false))
                barrier();
               barrier();
               break;
               case 44:
               mat4 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v[58];
               default:
               if(_GLF_DEAD(false))
                continue;
               1;
              }
            }
           break;
           default:
           1;
          }
        }
       else
        {
         return;
        }
      }
    }
   while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
   for(int _injected_loop_counter = _GLF_IDENTITY(int(_GLF_ONE(1.0, injectionSwitch.y)), int(ivec2(int(_GLF_ONE(1.0, injectionSwitch.y)), 1))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        return;
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))
          barrier();
         barrier();
        }
      }
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      break;
    }
  }
 else
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(false))
    barrier();
  }
 if(_GLF_DEAD(false))
  barrier();
 atomicStore(checker[virtual_gid], read, 4, 64, 4);
 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
  {
   if(_GLF_DEAD(false))
    {
     do
      {
       if(_GLF_DEAD(false))
        barrier();
       for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
        {
         if(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) ? _GLF_FUZZED(476.987) : injectionSwitch.x)) > injectionSwitch.y))), bool(bvec2(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), false))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             barrier();
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
              continue;
             barrier();
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(false))
                barrier();
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
               return;
              }
            }
          }
        }
      }
     while(_GLF_WRAPPED_LOOP(false));
     do
      {
       if(_GLF_DEAD(false))
        return;
      }
     while(_GLF_WRAPPED_LOOP(false));
     for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), int(2)))); _injected_loop_counter ++)
      {
       return;
      }
     if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
      barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      continue;
     if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
      barrier();
     if(_GLF_DEAD(false))
      return;
    }
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_DEAD(false))
      barrier();
    }
   else
    {
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    break;
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    continue;
  }
}
