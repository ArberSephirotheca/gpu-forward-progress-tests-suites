#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer Checker {
 uint checker[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  {
   for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(3), int(3))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
    {
     if(_GLF_DEAD(false))
      return;
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     switch(_GLF_SWITCH(((0 << _GLF_IDENTITY(int(0), int(0))) << _GLF_IDENTITY(int(5), int(5)))))
      {
       case 94:
       for(       ivec4(18680, 52952, -8113, 45654);
 (ivec2(10336, 14121) != ivec2(-4853, 4656)); findMSB(uvec4(168295u, 190426u, 104766u, 86986u)))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if((mat2(648.795, 8998.6555, -0.5, 0.1) == mat2(1054.8392, 8.1, 7.2, 127.868)))
            {
             float _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v, _GLF_SWITCH_3_2v;
             mat3x4(3.6, -8905.6515, 6.5, -6168.2609, -139.939, 812.994, 6450.6515, 775.178, -2446.7127, 6.1, 696.553, 7.1);
             {
              (dot(vec3(-86.76, 285.564, -568.092), vec3(1746.7188, -84.37, -25.49)) - exp2(injectionSwitch));
              mat3 _GLF_SWITCH_3_3v;
              if(_GLF_DEAD(false))
               {
                if(_GLF_WRAPPED_IF_TRUE(true))
                 {
                  return;
                 }
                else
                 {
                 }
               }
              if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
               }
              else
               {
                vec3(79.15, -37.08, 0.7);
               }
              bvec2 _GLF_SWITCH_3_4v, _GLF_SWITCH_3_5v, _GLF_SWITCH_3_6v;
             }
             for(mat2x4 _GLF_SWITCH_3_7v, _GLF_SWITCH_3_8v; false; (ivec2(-59390, 47533) % sign(23359)))
              {
               mat3x4(-7.7, 56.92, 7.3, 6141.3077, 2.5, 8.3, -23.90, 386.000, 3416.9491, 979.324, 5335.0187, 7.9);
               if(_GLF_DEAD(false))
                continue;
               mat3x4(5.7, -9.4, 0.3, 8.3, 6.1, -7.0, 36.45, 88.60, -42.84, 6905.5404, 226.974, -1.2);
               float _GLF_SWITCH_3_9v, _GLF_SWITCH_3_10v[80];
               if(_GLF_DEAD(false))
                return;
               mat3x4 _GLF_SWITCH_3_11v[63];
              }
             if((_GLF_SWITCH_3_1v < 8.2))
              {
               mat2x4(5.6, 0.1, -6995.4362, -315.286, -92.72, 353.567, -6.5, 2.7);
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 41321u;
                }
               else
                {
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               mat3x2(29.57, 7197.8233, -9.3, 6.3, 8.2, -0.2);
               (ivec3(-16938, 39449, 37481) * ivec3(-55968, -96318, -89681));
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               vec4 _GLF_SWITCH_3_12v[33], _GLF_SWITCH_3_13v[15];
               do
                {
                 bvec4(false, true, false, true);
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
              }
             else
              {
               (intBitsToFloat(17746) + (mat4x2(276.519, 6.1, 505.702, 502.751, -54.44, -9657.2019, -68.72, -6.4) / mat4x2(6.3, 79.90, -1.4, -93.75, 447.361, -1.6, 3551.5451, -2532.9878)));
               float _GLF_SWITCH_3_14v[29], _GLF_SWITCH_3_15v[56], _GLF_SWITCH_3_16v;
               asin(vec4(6853.0128, 1029.6137, 99.42, 0.9));
               if(_GLF_DEAD(false))
                return;
               mat3x2(_GLF_SWITCH_3_0v);
               mat2x4 _GLF_SWITCH_3_17v, _GLF_SWITCH_3_18v, _GLF_SWITCH_3_19v;
               ivec2(-30616, -97995);
              }
            }
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          return;
         if((bvec3(true, false, true) != bvec3(true, true, true)))
          {
           true;
           do
            {
             ;
            }
           while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, false || (false))));
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             uvec3(51494u, 61668u, 185566u);
            }
          }
         else
          {
           mat4 _GLF_SWITCH_3_20v, _GLF_SWITCH_3_21v;
           _GLF_SWITCH_3_21v;
           for(           mat2x4(mat3x4(-836.575, -8879.9324, 59.96, -3276.0461, 3.0, 2641.1717, 0.4, 883.647, -35.78, 848.622, -0.8, 82.28));
 (vec4(7702.5884, -6550.6508, 390.226, 96.71) != vec4(3.9, 4089.6729, 758.410, 1.2)); mat3x4(7.3, -4950.8833, -52.65, 910.282, 9.0, 679.078, 22.59, 148.843, 3718.9433, -9.9, 1267.2476, 98.57))
            {
             mat3x4 _GLF_SWITCH_3_22v, _GLF_SWITCH_3_23v;
             mat2x3 _GLF_SWITCH_3_24v[93], _GLF_SWITCH_3_25v;
            }
           bvec3 _GLF_SWITCH_3_26v[58];
           mat4 _GLF_SWITCH_3_27v[58], _GLF_SWITCH_3_28v;
          }
         mat4 _GLF_SWITCH_3_29v[51], _GLF_SWITCH_3_30v[9], _GLF_SWITCH_3_31v[47];
         if(true)
          {
           transpose(mat4x2(-65.26, 830.498, 1.8, 766.380, 25.92, 8651.1424, -170.288, -2425.4111));
          }
         else
          {
           for(mat4x2 _GLF_SWITCH_3_32v, _GLF_SWITCH_3_33v; (bvec4(false, false, false, true) == bvec4(false, false, true, false)); mat2x3(39.16, -9.3, 8.4, -4.4, 21.57, 5.5))
            {
             uvec3 _GLF_SWITCH_3_34v[79], _GLF_SWITCH_3_35v[98], _GLF_SWITCH_3_36v;
             false;
             uint _GLF_SWITCH_3_37v, _GLF_SWITCH_3_38v[43], _GLF_SWITCH_3_39v;
             ivec3(-54546, 33028, 77704);
            }
           mat4 _GLF_SWITCH_3_40v, _GLF_SWITCH_3_41v, _GLF_SWITCH_3_42v[29];
           if((-28021 < 60534))
            {
             mat4x2((mat2(-5029.2267, -8.1, 1291.7668, 9038.8380) + 6.6));
             _GLF_SWITCH_3_41v;
             if(_GLF_DEAD(false))
              continue;
            }
           else
            {
             bitfieldReverse(uvec2(187247u, 120076u));
             bvec4(true, false, false, false);
             mat3x2 _GLF_SWITCH_3_43v[27], _GLF_SWITCH_3_44v, _GLF_SWITCH_3_45v;
             ;
             float _GLF_SWITCH_3_46v, _GLF_SWITCH_3_47v, _GLF_SWITCH_3_48v;
             bool _GLF_SWITCH_3_49v, _GLF_SWITCH_3_50v, _GLF_SWITCH_3_51v;
            }
           uvec3(13434u, 23989u, 62007u);
           ivec2(-64911, 66337);
           while(true)
            {
             bvec2 _GLF_SWITCH_3_52v, _GLF_SWITCH_3_53v[21], _GLF_SWITCH_3_54v;
             mat2x3(mat3x4(-8.5, -2.5, 491.277, 2.5, -5.2, 6564.7253, -8.1, -5.0, 2.5, -3725.0954, 5.8, 4.9));
             (uvec3(182050u, 139934u, 109987u));
             asinh(vec4(7.3, -293.139, 608.076, 2707.6569));
             if(_GLF_DEAD(false))
              continue;
             bool _GLF_SWITCH_3_55v[53], _GLF_SWITCH_3_56v;
             if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
              break;
            }
           while(true)
            {
             bvec2 _GLF_SWITCH_3_57v;
             mix(7188.2839, -5.2, false);
             if(_GLF_DEAD(false))
              continue;
             mat4x2 _GLF_SWITCH_3_58v[35];
             ;
             if(_GLF_DEAD(false))
              continue;
             ivec4 _GLF_SWITCH_3_59v[48], _GLF_SWITCH_3_60v[28];
            }
           {
            uvec2 _GLF_SWITCH_3_61v[9], _GLF_SWITCH_3_62v;
            uvec3(172083u, 124339u, 117886u);
            mat4x3(mat4x2(90.13, 372.234, 655.795, -88.05, 91.33, 65.38, 511.678, 6.0));
            ;
            (mat3x2(7.8, -283.550, 7.9, -7.7, -3169.0922, -728.810) - outerProduct(vec2(-989.379, 944.054), vec3(9188.5365, 4393.6468, -413.795)));
            mat3 _GLF_SWITCH_3_63v, _GLF_SWITCH_3_64v, _GLF_SWITCH_3_65v;
            ivec3 _GLF_SWITCH_3_66v;
           }
          }
         if(true)
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           while(bool(151047u))
            {
             bvec3(true, true, true);
             bvec2 _GLF_SWITCH_3_67v, _GLF_SWITCH_3_68v, _GLF_SWITCH_3_69v;
             packSnorm4x8(vec4(4736.6961, 268.901, -0.6, -85.41));
             mat4x2 _GLF_SWITCH_3_70v, _GLF_SWITCH_3_71v, _GLF_SWITCH_3_72v[47];
             mat3(mat4x3(3.3, 8.8, -7.5, -7.2, -433.568, -672.199, -4.6, -7854.0377, -2.5, -1.3, 7.6, -0.0));
             uvec3(144665u, 188281u, 83076u);
             vec3 _GLF_SWITCH_3_73v, _GLF_SWITCH_3_74v, _GLF_SWITCH_3_75v;
            }
           int _GLF_SWITCH_3_76v, _GLF_SWITCH_3_77v;
           vec3(292.260, 2.0, -2514.4836);
           do
            {
             for(             -70.92;
 (mat3x4(-9.3, -7578.5159, 4.7, -5851.9868, 64.42, 1.5, 71.87, 1.8, -86.66, 768.388, -9011.7546, 2.8) != mat3x4(136.615, -386.804, 4.2, -0.2, -6.0, -7.2, 9546.5734, 2.1, 0.8, 312.799, -88.42, 2897.7011)); vec4(-6776.4389, 9.4, 1176.4558, -25.08))
              {
               vec3(696.351, -728.256, 6.9);
               if(_GLF_DEAD(false))
                continue;
               vec4(-5.6, 8253.6284, -755.348, 787.524);
               mat4(7.2, 887.747, 73.53, -37.71, 800.079, 3.0, -1.0, -945.528, 9.1, 832.390, 1949.5009, -3843.4961, -3.5, 7.6, -3551.4501, 54.18);
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 mat4(-4.3, -8694.4327, -585.537, 1.5, -21.94, -0.6, -770.890, -4921.5764, -2.1, -3.5, -1783.6842, -2059.6912, -25.71, 28.25, 332.360, 578.259);
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               mat2x3 _GLF_SWITCH_3_78v;
               ivec3 _GLF_SWITCH_3_79v[66], _GLF_SWITCH_3_80v[26], _GLF_SWITCH_3_81v;
               mat3x2 _GLF_SWITCH_3_82v[87];
              }
            }
           while(_GLF_WRAPPED_LOOP(false));
           for(int _GLF_SWITCH_3_83v, _GLF_SWITCH_3_84v; true; false)
            {
             mat4x2(2.1, -31.46, 9.6, -9380.6648, -0.1, -2284.6540, -627.052, -7.9);
             mat2x4 _GLF_SWITCH_3_85v;
             mat3 _GLF_SWITCH_3_86v;
            }
           mat2 _GLF_SWITCH_3_87v, _GLF_SWITCH_3_88v;
           3.2;
          }
         else
          {
           mat2 _GLF_SWITCH_3_89v;
           if((bvec3(true, false, true) == notEqual(uvec3(132143u, 75614u, 12688u), uvec3(171505u, 196391u, 81603u))))
            {
             do
              {
               mat2(mat4x2(-400.344, -91.61, -0.3, 4.5, 9432.2314, -49.48, -8.1, 9.7));
              }
             while(_GLF_WRAPPED_LOOP(false));
             matrixCompMult(mat4x2(431.144, -43.35, -8250.8515, 880.482, -8.3, 0.1, 2.8, -7.1), mat4x2(9.0, 7.3, 8.0, 3982.8583, 3.0, -317.877, 6283.3690, -826.672));
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 << _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), (int(2)) | (int(2)))))); _injected_loop_counter --)
              {
               mat2x3(3.4, -838.159, 8.6, -21.95, -88.85, -2.3);
              }
             uint _GLF_SWITCH_3_90v, _GLF_SWITCH_3_91v;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             (true ? _GLF_SWITCH_3_89v : _GLF_SWITCH_3_89v);
            }
           else
            {
            }
           uvec4(54177u, 82125u, 174318u, 106508u);
           bvec3 _GLF_SWITCH_3_92v[94];
           {
            uint _GLF_SWITCH_3_93v;
            if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
             break;
            for(int _injected_loop_counter = (((((1 << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), int(4))) << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), max(int(2), int(2))))) & 1); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
             {
              (mat4(-2024.4930, -100.521, -41.38, -8786.7620, 5.6, 369.466, -5.4, 4.3, 5.1, 659.114, 888.003, 4.6, 21.27, -5.9, 430.957, 6153.7430) , mat3(-3.1, -95.15, -81.46, 8.0, 756.975, -586.714, 22.43, -94.43, 431.999));
             }
            ;
            mat2x4 _GLF_SWITCH_3_94v;
            ivec2 _GLF_SWITCH_3_95v;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             break;
           }
           if(_GLF_DEAD(false))
            return;
           bvec3(true, false, true).xzy;
          }
         if(_GLF_DEAD(false))
          break;
         ;
         mat3x4(mat4x3(9372.9203, 9016.2697, 4266.0697, -694.628, 3794.9506, -4.6, 675.096, 9.9, 4406.5589, -4354.0261, -851.910, -137.618));
         while((injectionSwitch == vec2(-9.5, 5.7)))
          {
           if(_GLF_DEAD(false))
            continue;
           -50.42;
           (mat3x4(-8.7, -0.0, 4.6, -3792.0657, 291.691, 9428.9854, -989.559, -65.71, 4.6, -5.0, 819.389, -2.9) - mat3x4(8.1, -766.248, 825.628, 885.538, -983.123, 39.32, -348.772, 30.25, -76.17, 502.365, 179.343, 9.8));
           if(_GLF_DEAD(false))
            break;
           -86223;
          }
        }
       case 0:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       return;
       break;
       case 39:
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
        }
       else
        {
        }
       while(false)
        {
         ;
         if(true)
          {
           if(_GLF_DEAD(false))
            return;
           mat3x2 _GLF_SWITCH_3_96v[94], _GLF_SWITCH_3_97v;
           bvec4(bvec2(false, false), true, (bitfieldReverse(44257u) != 75476u));
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
              return;
            }
           while((bvec3(false, true, true) != lessThan(vec3(81.75, -300.737, -4910.6432), min(vec3(6087.4201, -1.7, 59.26), vec3(2660.3309, -6.2, -8.9)))))
            {
             float _GLF_SWITCH_3_98v[41], _GLF_SWITCH_3_99v[83];
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               ivec3(-93065, 10132, 66185);
              }
             else
              {
              }
             bvec2(true, false);
             ;
             ivec3(13683, -2124, 9398);
             mat4x2(7.3, -579.734, -1339.3993, 1.4, -4.2, -327.871, 8265.5634, 8.2);
             sqrt(vec4(-6.9, 118.844, -375.500, 3.8));
             (true == true);
            }
           for(           mat3(8670.1731, -5.4, -58.84, -614.203, 3966.3891, 2558.8779, 7996.9630, -7.6, 860.436);
 false; (mat3(27.28, -2958.0486, -2.2, -8.5, -8.5, -1.9, 24.52, 192.672, 934.354) - mat3(-26.54, 824.747, 164.861, 99.57, -0.5, 884.678, 1.7, 469.046, 0.6)))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             ;
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
              {
               uvec4(83468u, 127559u, 144794u, 164173u);
              }
            }
           {
            mat3x2 _GLF_SWITCH_3_100v[9], _GLF_SWITCH_3_101v, _GLF_SWITCH_3_102v;
            (189554u - uvec3(170287u, 180222u, 81594u));
            mat2 _GLF_SWITCH_3_103v, _GLF_SWITCH_3_104v, _GLF_SWITCH_3_105v[47];
            mat2x4(mat4x2(-9.1, 0.4, 720.044, 3.1, -176.648, -1392.8660, -78.62, -2.8));
           }
           ;
           roundEven(vec3(8955.2159, -81.20, -503.001));
          }
         else
          {
           ;
           {
           }
           mat3x2(8232.9569, 95.24, 2.5, 1.7, 3400.6150, -8423.1691);
           mat3 _GLF_SWITCH_3_106v[32], _GLF_SWITCH_3_107v;
           while(false)
            {
             uvec3 _GLF_SWITCH_3_108v[77], _GLF_SWITCH_3_109v;
             if(_GLF_DEAD(false))
              break;
             mat4 _GLF_SWITCH_3_110v;
             vec3 _GLF_SWITCH_3_111v;
             uvec2 _GLF_SWITCH_3_112v;
             if(_GLF_DEAD(false))
              break;
            }
           for(int _injected_loop_counter = (0 ^ 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
            {
             if(_GLF_DEAD(false))
              return;
            }
           {
            uint _GLF_SWITCH_3_113v, _GLF_SWITCH_3_114v, _GLF_SWITCH_3_115v;
            bvec2 _GLF_SWITCH_3_116v, _GLF_SWITCH_3_117v, _GLF_SWITCH_3_118v[27];
            (54481 > findMSB(_GLF_SWITCH_3_113v));
            ivec3 _GLF_SWITCH_3_119v[79];
            (bool(-5789.6920) , (uvec2(92795u, 141440u)));
           }
          }
         float _GLF_SWITCH_3_120v, _GLF_SWITCH_3_121v, _GLF_SWITCH_3_122v;
         for(         vec2(7.2, 1653.9394);
 false; false)
          {
           for(ivec4 _GLF_SWITCH_3_123v; (54286u < bitfieldExtract(packUnorm2x16(vec2(7761.8114, 1.6)), 503, -90106)); mat4(66.31, -225.687, -9.6, -4637.9980, 6.3, -53.57, 7.8, -19.71, 7.9, -3331.7188, 137.241, -1.2, -9532.9040, -3.5, -9.5, -8.8))
            {
             findMSB(bitCount(ivec3(50492, 70105, -92751)));
             (ivec3(_GLF_SWITCH_3_123v) >> 76078);
             (mat4x2(-281.952, -16.95, -192.606, -2830.0292, 5973.2869, -67.64, 4932.4907, 889.414) * vec4(-9374.5279, 7.9, -5943.8702, 6.0));
             ;
             (+ uvec3(57516u, 173848u, 36658u).zx);
            }
           (ivec2(-55703, -85206) >> -90724);
          }
         if(false)
          {
           {
            mat4x2 _GLF_SWITCH_3_124v[50], _GLF_SWITCH_3_125v, _GLF_SWITCH_3_126v;
            mat3x2(0.0, 4.4, -80.42, -8.4, 0.5, -22.43);
            min((ivec3(78894, 57399, -7789)), clamp(ivec3(59591, 58505, -3131), ivec3(-12273, 4491, 72916), ivec3(-5069, -46630, 65206)));
            mat3x4(2.6, 1.9, 3.7, 17.60, -1.8, -94.36, 0.9, 6.5, 185.115, 76.79, 8215.3294, 164.796);
            bvec4 _GLF_SWITCH_3_127v, _GLF_SWITCH_3_128v;
            mat3(-5724.0440, -18.94, -1572.0729, 9.7, -9.7, -85.44, -5.2, 2.6, 94.98);
            for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               return;
             }
            int _GLF_SWITCH_3_129v[6];
            (uvec2(122461u, 108427u) << 46257u);
           }
           for(mat4x2 _GLF_SWITCH_3_130v, _GLF_SWITCH_3_131v, _GLF_SWITCH_3_132v; (_GLF_SWITCH_3_120v == 1.7); mat4x3(-395.612, -336.600, 6.3, 5.4, 3.3, 5.8, -9.2, -2206.3344, -9043.9015, -18.24, -6.2, -787.340))
            {
             ivec3 _GLF_SWITCH_3_133v;
             ivec2(-89071, 25585).x;
             ivec2 _GLF_SWITCH_3_134v[62];
             max(abs(453), 14016);
            }
           for(vec2 _GLF_SWITCH_3_135v, _GLF_SWITCH_3_136v, _GLF_SWITCH_3_137v; (_GLF_SWITCH_3_121v > _GLF_SWITCH_3_120v); _GLF_SWITCH_3_136v)
            {
             mat3x2 _GLF_SWITCH_3_138v;
             ivec4(-72815, 41779, 88495, 83688);
             (179113u + 35564u);
             if(_GLF_DEAD(false))
              continue;
             ;
             ivec4(-94970, 27462, 52725, 37617);
             uvec2 _GLF_SWITCH_3_139v, _GLF_SWITCH_3_140v;
             ;
            }
           for(           ivec4(45068, -3469, 58348, 48185);
 (92605u >= mix(58101u, 74957u, false)); 3784u)
            {
             mat3x2(79.32, -6.1, 355.955, -6.9, -77.84, -5.8);
            }
           mat2x3(matrixCompMult(mat4(-3789.0377, 5.5, 5895.9969, -4064.2444, 7.3, 92.44, 3.0, -6495.7521, -3779.3679, -482.242, -3.3, -72.74, -3661.0313, -5069.1416, 2.7, -2.1), mat4(60.76, 8.0, 7.2, -2.8, -0.5, 0.7, -7.2, -3.4, -1155.6226, -49.42, -7.1, -0.9, 8934.2554, 75.06, -7.5, 4.3)));
           if(_GLF_DEAD(false))
            continue;
           if(false)
            {
             vec4(0.6, 269.256, 13.47, -68.63);
             uint _GLF_SWITCH_3_141v;
             mat3x4(305.755, 6.5, 121.464, -7511.6194, -67.96, -6.2, 20.42, 6.4, 2.5, -65.61, 95.62, -5.4);
            }
           for(mat3x4 _GLF_SWITCH_3_142v, _GLF_SWITCH_3_143v, _GLF_SWITCH_3_144v; true; mat4(-9.5, 5.0, 4684.5341, -7.5, 43.95, 404.737, -9.5, 142.775, -359.968, -176.245, 32.32, -9.2, 428.180, 0.0, -6835.8742, 98.09))
            {
             do
              {
               (+ -93631);
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
            }
           ivec4 _GLF_SWITCH_3_145v, _GLF_SWITCH_3_146v;
          }
         if((mat3(398.418, 0.3, -4.3, -6230.5075, 0.8, -806.800, 1.4, -331.671, 51.43) == mat3(-74.94, -548.778, -0.5, 2.1, -3.7, 5.2, 723.648, -4698.4294, -1.1)))
          {
           for(int _injected_loop_counter = _GLF_IDENTITY(0, min(_GLF_IDENTITY(0, 1 * (0)), _GLF_IDENTITY(0, max(0, 0)))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
            {
             for(             reflect(vec4(7.1, 28.40, -0.8, -21.20), vec4(5.1, 912.306, -665.085, -1.0));
 false; bitfieldExtract(61896u, 7880, 37608))
              {
               ;
               for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(2), int(2))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                {
                 (uvec3(53050u, 14446u, 24328u) >> uvec3(133482u, 173508u, 103214u));
                }
               ivec3(21005, -23705, -42100);
               mat2(-7340.4758, 0.0, 741.315, 176.847);
               injectionSwitch;
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 mat2x4(9.5, -9185.4579, 162.522, -2918.2371, -4.3, -769.851, 1.3, 485.682);
                }
               else
                {
                }
               mat4 _GLF_SWITCH_3_147v;
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   return;
                  }
                 else
                  {
                  }
                }
               mat4x2 _GLF_SWITCH_3_148v, _GLF_SWITCH_3_149v, _GLF_SWITCH_3_150v[70];
              }
            }
           if((ivec3(-68439, -23618, 61976) == ivec3(72680, 73521, 77930)))
            {
             uvec4(186583u, 110851u, 56178u, 134264u);
             outerProduct(vec3(5990.8648, 49.98, 1439.7717), vec3(-973.205, -2.9, 5.9));
             (ivec4(-87561, 85563, -92406, -64754) % ivec4(-61737, -7642, -2314, 32438));
             mat4 _GLF_SWITCH_3_151v, _GLF_SWITCH_3_152v;
             _GLF_SWITCH_3_152v;
            }
           {
            if(_GLF_DEAD(false))
             break;
            mat4x3 _GLF_SWITCH_3_153v, _GLF_SWITCH_3_154v[33];
            mat4 _GLF_SWITCH_3_155v;
            (-- _GLF_SWITCH_3_120v);
            vec3 _GLF_SWITCH_3_156v, _GLF_SWITCH_3_157v;
            (uvec4(17948u, 176435u, 165275u, 127915u));
            mat2x4 _GLF_SWITCH_3_158v;
           }
           while(true)
            {
             uvec2(155508u, 12381u);
             cosh((_GLF_SWITCH_3_122v ++));
             mat4 _GLF_SWITCH_3_159v;
             (_GLF_SWITCH_3_122v + mat4(7.1, 84.90, 3.5, -0.9, 9.8, -68.29, 5.6, 73.77, -634.568, 2355.8696, -2540.2808, -5935.6439, -358.937, 131.313, 82.22, 9769.4262));
             ;
            }
           ;
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          return;
         {
          uvec2 _GLF_SWITCH_3_160v, _GLF_SWITCH_3_161v;
          do
           {
            while(true)
             {
              _GLF_SWITCH_3_161v;
              if(_GLF_DEAD(false))
               return;
              mat3 _GLF_SWITCH_3_162v, _GLF_SWITCH_3_163v;
              mat2x3(8.8, -5461.9409, -4.4, 788.190, -3301.6485, -4.5);
              mat2x3 _GLF_SWITCH_3_164v[55];
             }
           }
          while(_GLF_WRAPPED_LOOP(false));
          cos(vec4(3294.1193, -5.1, 2.3, -8.8));
          mat3x4(1590.3301, -1.3, -23.30, -178.982, -36.78, -966.632, 3.1, -8509.5822, -3585.1783, -1.8, 917.828, -19.08);
          while(true)
           {
            86310;
            ivec4(-38226, 5648, -64283, 6051);
            for(int _injected_loop_counter = (1 & 1); _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 >> _GLF_IDENTITY(int(5), int(5)))); _injected_loop_counter --)
             {
              mat3x2(3805.6493, -2.9, -78.49, -606.469, -2.1, -998.483);
             }
            4820.8676;
            bvec2(false, false);
            if(_GLF_DEAD(false))
             continue;
            uvec2 _GLF_SWITCH_3_165v, _GLF_SWITCH_3_166v;
            if(_GLF_DEAD(false))
             return;
            false;
            (mat4(841.459, 6.6, 522.030, -258.063, 4492.1700, 44.14, 890.977, -3103.4196, -0.8, 1.3, 9747.8676, -8.6, 8282.2512, 3.5, -0.9, 6.0) * (true ? (mat3x4(71.92, 9.9, -6.0, 4.1, 449.116, -70.30, 26.53, -4452.4295, 3.5, 5877.0621, 257.000, -2.8) * mat2x3(738.815, -67.88, 6515.9497, 398.674, 938.342, 0.3)) : mat2x4(19.61, -5270.3241, -57.33, -2299.4461, -4.7, -9768.2934, -678.122, 4.5)));
            -56508;
           }
          bvec2(true, true);
          for(mat2x4 _GLF_SWITCH_3_167v[43]; (-79766 == 43162); mat4x3(-302.772, -2.7, -3662.2695, 7305.4033, -1223.5262, 9138.3282, 98.20, -3536.4502, 3.7, 95.33, 5.5, 4593.6992))
           {
            mat4x2(_GLF_SWITCH_3_122v, _GLF_SWITCH_3_121v, _GLF_SWITCH_3_120v, _GLF_SWITCH_3_120v, _GLF_SWITCH_3_121v, -9819.7819, _GLF_SWITCH_3_121v, _GLF_SWITCH_3_120v);
            (mat2x4(-434.408, -6418.9267, 2.4, 30.00, -523.265, -450.941, 416.134, -38.52) * mat3x2(mat4x3(-7.9, 818.742, 8017.0833, -8.0, 4189.6894, -6.3, -946.551, 415.827, 8.3, 85.87, 296.368, 7.2)));
            (mat4x2(3.4, 3.7, 0.9, -0.4, 3.7, -9.9, 641.284, -8065.5530) + _GLF_SWITCH_3_122v);
            mat3x2(mat3x4(-8.7, -377.855, -93.47, -2851.7278, -0.7, -5949.1359, 7.4, -6.6, -51.21, 5.3, 19.85, -5.9));
            mat3x4 _GLF_SWITCH_3_168v[32];
            mat4x2 _GLF_SWITCH_3_169v[71], _GLF_SWITCH_3_170v[5];
           }
         }
         bvec3(true, bvec2(false, false));
         if(false)
          {
           mat3x2(0.5, 0.0, -2068.9698, 53.71, 6153.2807, 0.4);
           vec2 _GLF_SWITCH_3_171v[97];
           while(false)
            {
             (false ? ceil(vec3(7.8, -3602.7835, -0.8)) : vec3(1.3, -494.145, 706.246));
             if(_GLF_DEAD(false))
              continue;
            }
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             if(_GLF_DEAD(false))
              return;
            }
           else
            {
            }
           uvec4(34676u, 54163u, 152861u, 167462u);
           vec3 _GLF_SWITCH_3_172v[52], _GLF_SWITCH_3_173v;
           mat4 _GLF_SWITCH_3_174v[56];
           ivec3 _GLF_SWITCH_3_175v;
           equal(_GLF_SWITCH_3_173v, (+ _GLF_SWITCH_3_173v));
           true;
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          break;
        }
       default:
       1;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
      }
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
      barrier();
     if(_GLF_DEAD(false))
      {
       do
        {
         return;
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
     return;
     if(_GLF_DEAD(false))
      return;
    }
   return;
   if(_GLF_DEAD(false))
    barrier();
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_DEAD(false))
    {
     do
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        break;
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           return;
          }
         else
          {
          }
        }
       else
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
          }
        }
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, clamp(injectionSwitch, injectionSwitch, injectionSwitch)).x > injectionSwitch.y))))
      return;
    }
   else
    {
    }
   barrier();
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 if(_GLF_DEAD(false))
  return;
 uint subgroup_id = gl_SubgroupID;
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, false, false)))))
      return;
     barrier();
    }
  }
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), bool(bool(_GLF_IDENTITY(! (false), false || (! (false))))))))))
    {
     do
      {
       if(_GLF_DEAD(false))
        break;
       return;
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
  }
 if(_GLF_DEAD(false))
  barrier();
 uint subgroup_size = gl_SubgroupSize;
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
   if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
    {
     if(_GLF_DEAD(false))
      return;
     return;
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
      {
       return;
      }
     else
      {
      }
    }
  }
 else
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, mix(float(_GLF_FUZZED(5.0)), _GLF_IDENTITY(float(injectionSwitch.y), (false ? _GLF_FUZZED(-720.400) : float(injectionSwitch.y))), bool(true)))))))
    return;
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        return;
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         barrier();
        }
       else
        {
        }
      }
    }
   else
    {
     if(_GLF_IDENTITY(_GLF_DEAD(false), bool(bool(_GLF_IDENTITY(_GLF_DEAD(false), _GLF_IDENTITY(bool(bvec2(_GLF_IDENTITY(_GLF_DEAD(false), false || (_GLF_DEAD(false))), true)), (bool(bvec2(_GLF_IDENTITY(_GLF_DEAD(false), false || (_GLF_DEAD(false))), true))) || false))))))
      {
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, (false) || false)))), bool(bvec3(false, false, true))))))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             switch(_GLF_SWITCH((1 ^ 1)))
              {
               case 0:
               case 99:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
               case 16:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                 if(_GLF_DEAD(false))
                  return;
                }
               else
                {
                 if(_GLF_DEAD(false))
                  continue;
                 barrier();
                }
               break;
               case 86:
               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                }
               else
                {
                 mat2x3(860.399, 8.1, 700.723, 1.1, -31.37, -3.2);
                }
               case 7:
               ;
               default:
               1;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
              }
            }
           if(_GLF_DEAD(false))
            break;
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
               do
                {
                 return;
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
            }
           else
            {
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             do
              {
               barrier();
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
           for(int _injected_loop_counter = (0 ^ 1); _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 >> _GLF_IDENTITY(_GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), 0 ^ (int(0)))), clamp(_GLF_IDENTITY(_GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), 0 ^ (int(0)))), 0 ^ (_GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), 0 ^ (int(0)))))), _GLF_IDENTITY(_GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), 0 ^ (int(0)))), min(_GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), 0 ^ (int(0)))), _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), 0 ^ (int(0)))))), _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), 0 ^ (int(0)))))))); _injected_loop_counter --)
            {
             return;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
            }
           if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ((injectionSwitch.x > injectionSwitch.y)) || false))))
            barrier();
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true)))
              {
               do
                {
                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 >> _GLF_IDENTITY(int(2), int(2)))); _injected_loop_counter --)
                  {
                   barrier();
                  }
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
            }
          }
        }
       if(_GLF_DEAD(false))
        return;
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
         if(_GLF_DEAD(false))
          return;
        }
       else
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         if(_GLF_DEAD(false))
          return;
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(false))
            {
             do
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  return;
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   return;
                  }
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
              }
             else
              {
               barrier();
              }
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ! (! ((injectionSwitch.x > injectionSwitch.y)))))), ! (! (_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), (_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, (false) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))), (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(954.333), _GLF_FUZZED(-485.676)), vec2(_GLF_IDENTITY((injectionSwitch)[0], 1.0 * ((injectionSwitch)[0])), (injectionSwitch)[1]), bvec2(true, true))).y)))) && true)))))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 return;
                }
               else
                {
                }
              }
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_DEAD(false))
                return;
              }
             else
              {
              }
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 >> _GLF_IDENTITY(int(3), int(3)))); _injected_loop_counter --)
              {
               barrier();
              }
            }
           return;
           if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
            barrier();
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             barrier();
            }
           else
            {
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, _GLF_IDENTITY(true, bool(bvec2(true, false))) && (false)), (injectionSwitch.x > injectionSwitch.y))))
          return;
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              {
               switch(_GLF_SWITCH((0 | 0)))
                {
                 case 6:
                 if(_GLF_DEAD(false))
                  return;
                 uvec4(8421u, 182364u, 58535u, 21605u);
                 if(_GLF_DEAD(false))
                  return;
                 case 0:
                 case 93:
                 case 86:
                 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                  {
                   if(_GLF_DEAD(false))
                    return;
                  }
                 case 17:
                 case 59:
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   barrier();
                  }
                 else
                  {
                  }
                 break;
                 case 89:
                 uvec2(196917u, 129529u);
                 case 4:
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                 float _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v, _GLF_SWITCH_3_2v;
                 default:
                 for(int _injected_loop_counter = (int(_GLF_ZERO(0.0, injectionSwitch.x)) >> _GLF_IDENTITY(int(8), int(8))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                  {
                   1;
                  }
                }
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             do
              {
               do
                {
                 barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
               if(_GLF_DEAD(false))
                continue;
              }
             while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), (_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), _GLF_IDENTITY(bool(bvec2((injectionSwitch.x > injectionSwitch.y), false)), ! (! (bool(bvec2((injectionSwitch.x > injectionSwitch.y), false))))))) || false)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || false)));
            }
           else
            {
             if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, bool(bvec3(false, false, true))), (_GLF_IDENTITY(injectionSwitch, (injectionSwitch) * mat2(_GLF_ONE(1.0, injectionSwitch.y))).x > _GLF_IDENTITY(injectionSwitch, (injectionSwitch) / vec2(1.0, 1.0)).y))))
              {
               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                 if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec3(false, false, false)), true && (bool(bvec3(false, false, false))))), (injectionSwitch.x > injectionSwitch.y))))
                  return;
                }
               else
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 return;
                }
               if(_GLF_DEAD(false))
                {
                 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                  {
                   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 & int(_GLF_ONE(1.0, injectionSwitch.y)))); _injected_loop_counter ++)
                    {
                     return;
                    }
                  }
                 if(_GLF_DEAD(false))
                  barrier();
                }
              }
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               return;
              }
            }
          }
         else
          {
          }
         if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, bool(bvec2(false, true))), (injectionSwitch.x > injectionSwitch.y))))
          return;
        }
      }
    }
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    return;
   return;
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 uint subgroup_local_id = gl_SubgroupInvocationID;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 uint num_workgroup = gl_NumWorkGroups.x;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) || false))
  {
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     switch(_GLF_SWITCH(0))
      {
       case 78:
       uint _GLF_SWITCH_3_0v;
       if(_GLF_DEAD(false))
        return;
       case 0:
       case 97:
       case 65:
       if(_GLF_DEAD(false))
        barrier();
       case 48:
       do
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         if(_GLF_DEAD(false))
          {
           do
            {
             if(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), false || (_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), (_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)).y)))) || false))))
              {
               if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                return;
              }
             else
              {
               barrier();
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
          }
         switch(_GLF_SWITCH(0))
          {
           case 40:
           for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
            {
             15920;
            }
           case 26:
           while(true)
            {
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               if(_GLF_DEAD(false))
                break;
               for(int _injected_loop_counter = (int(_GLF_ONE(1.0, injectionSwitch.y)) & 1); _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 << _GLF_IDENTITY(int(4), int(4)))); _injected_loop_counter --)
                {
                 while((bvec4(bvec2(false, _GLF_IDENTITY(true, (true) || false)), true, true) == bvec4(false, bvec2(true, false), _GLF_IDENTITY(false, (_GLF_IDENTITY(false, bool(bvec4(false, true, true, false)))) || _GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, clamp(injectionSwitch.x, injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y))))))
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    break;
                   for(int _injected_loop_counter = ((0 ^ 0) | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 & 1)); _injected_loop_counter ++)
                    {
                     while((num_workgroup < subgroup_size))
                      {
                       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                        {
                         _GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec3(false, false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))), (_GLF_IDENTITY(bool(bvec3(false, false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))), ! (! (bool(bvec3(false, false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))))) || false));
                        }
                       if(_GLF_WRAPPED_IF_FALSE(false))
                        {
                        }
                       else
                        {
                         if(_GLF_DEAD(false))
                          barrier();
                        }
                       ivec3 _GLF_SWITCH_2_0v[76], _GLF_SWITCH_2_1v, _GLF_SWITCH_2_2v;
                       if(_GLF_DEAD(false))
                        barrier();
                       _GLF_IDENTITY(uvec3(160179u, 2165u, 35771u), (true ? _GLF_IDENTITY(uvec3(160179u, 2165u, 35771u), max(uvec3(160179u, 2165u, 35771u), uvec3(160179u, 2165u, 35771u))) : _GLF_FUZZED(clamp(uvec3(39903u, 50254u, 100420u), subgroup_size, subgroup_size))));
                       if(_GLF_WRAPPED_IF_FALSE(false))
                        {
                        }
                       else
                        {
                         bvec4(true, bvec3(false, false, true));
                        }
                       uvec2 _GLF_SWITCH_2_3v;
                       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                        {
                         mat3x2(_GLF_IDENTITY(42.16, (42.16) - tan(0.0)), 4.1, 6.5, 17.75, 6.8, 8.5);
                        }
                      }
                    }
                  }
                }
              }
             else
              {
              }
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               barrier();
              }
             uvec4 _GLF_SWITCH_2_4v;
             ivec4 _GLF_SWITCH_2_5v, _GLF_SWITCH_2_6v, _GLF_SWITCH_2_7v[44];
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 for(int _injected_loop_counter = (int(_GLF_ZERO(0.0, injectionSwitch.x)) >> _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                  {
                   barrier();
                  }
                }
              }
             if(_GLF_DEAD(false))
              break;
            }
           if(_GLF_DEAD(false))
            barrier();
           case 0:
           case 66:
           case 25:
           case 96:
           case 48:
           case 81:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           do
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           case 6:
           case 39:
           if(_GLF_DEAD(false))
            continue;
           case 68:
           case 89:
           for(int _injected_loop_counter = (1 ^ int(_GLF_ZERO(0.0, injectionSwitch.x))); _GLF_WRAPPED_LOOP(_injected_loop_counter != (_GLF_IDENTITY(int(_GLF_ZERO(0.0, injectionSwitch.x)) | 0, (int(_GLF_ZERO(0.0, injectionSwitch.x)) | 0) | (_GLF_IDENTITY(int(_GLF_ZERO(0.0, injectionSwitch.x)) | 0, (int(_GLF_ZERO(0.0, injectionSwitch.x)) | 0) * 1))))); _injected_loop_counter --)
            {
             barrier();
            }
           break;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              return;
             barrier();
            }
           case 86:
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             while(false)
              {
               if((mat3x2(-90.13, 0.2, _GLF_IDENTITY(3.4, round(length(normalize(vec4(1.0, 1.0, 1.0, 1.0)))) * (3.4)), _GLF_IDENTITY(-26.91, (-26.91) - 0.0), 0.6, 330.693) != mat3x2(-0.9, 940.529, 4.9, _GLF_IDENTITY(-13.99, (_GLF_IDENTITY(-13.99, (-13.99) / 1.0)) / _GLF_ONE(1.0, injectionSwitch.y)), -774.365, 259.178)))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                 {
                  log2(vec4(-2657.4339, _GLF_IDENTITY(-87.82, (-87.82) * _GLF_IDENTITY(1.0, 0.0 + (1.0))), -1042.9475, -2537.4029));
                  if(_GLF_DEAD(false))
                   barrier();
                 }
                 while(true)
                  {
                   if(_GLF_DEAD(false))
                    return;
                  }
                 if(_GLF_DEAD(false))
                  break;
                 while(true)
                  {
                   switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                    {
                     case 0:
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      break;
                     case 12:
                     case 60:
                     if(_GLF_DEAD(false))
                      continue;
                     case 76:
                     case 51:
                     case 59:
                     mat4x2(mat2x4(-1822.1962, -6.8, -6.0, 6.4, 45.33, -32.78, 9.3, -29.71));
                     break;
                     case 68:
                     (+ mat2(-937.748, 17.86, -388.825, 591.600));
                     default:
                     1;
                    }
                  }
                 while(all(_GLF_IDENTITY(equal(ivec2(-97150, -99442), ivec2(47033, 12484)), _GLF_IDENTITY(bvec2(bvec3(equal(ivec2(-97150, -99442), ivec2(47033, 12484)), true)), bvec2(bvec2(_GLF_IDENTITY(bvec2(bvec3(equal(ivec2(-97150, -99442), ivec2(47033, 12484)), true)), bvec2(bvec4(bvec2(bvec3(equal(ivec2(-97150, -99442), ivec2(47033, 12484)), true)), true, true)))))))))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   uvec3(11562u, 6315u, 93496u);
                   vec2(9.1, 15.37);
                   uvec4(79008u, 191471u, 11794u, 174164u);
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                    }
                   else
                    {
                     vec2(8060.4705, 645.417);
                    }
                   bvec4(false, true, false, false);
                   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                    {
                     if(_GLF_DEAD(false))
                      break;
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                   else
                    {
                    }
                   (mat4x3(-3.5, 5.8, -459.111, 2.3, 1175.7642, -115.469, 882.529, 3282.1110, -10.48, 2.6, 9748.7194, -86.44) * mat4(-4.5, 671.327, -997.600, -8.3, -9.2, -2.5, 9.9, 7.6, 86.79, 580.135, -4571.7595, _GLF_IDENTITY(-642.801, min(_GLF_IDENTITY(-642.801, (-642.801) + length(0.0)), -642.801)), -6.8, -494.714, 127.269, 1.9));
                   mat3(4000.1492, 61.66, 76.38, 723.633, -4310.0939, 7.4, 1.9, -8688.7768, -4420.2321);
                  }
                 for(                 (uvec2(142033u, 61913u) >> uvec4(164549u, 51912u, 49983u, 129198u)[2]);
 false; (ivec3(79306, 87601, -62671) | ivec3(_GLF_IDENTITY(-87511, int(ivec2(-87511, (0 ^ 0)))), -21862, -68342)))
                  {
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                    }
                   else
                    {
                     mat2(692.553, 3.5, -8.4, -5.6);
                    }
                   mat3x4(-109.943, -3.1, -5.7, 4779.5229, 3122.8942, 90.73, -2.8, -0.3, 7241.8283, 7.9, 7.4, _GLF_IDENTITY(-2.0, max(-2.0, -2.0)));
                   do
                    {
                     radians(-5.1);
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                   ivec2 _GLF_SWITCH_2_8v;
                  }
                 ;
                 do
                  {
                   if(_GLF_WRAPPED_IF_TRUE(true))
                    {
                     (mat4(4651.9110, 6.4, -8.9, -6419.6853, -831.332, 6.8, -141.143, 2810.5563, _GLF_IDENTITY(6972.4386, clamp(_GLF_IDENTITY(6972.4386, (6972.4386) - 0.0), 6972.4386, _GLF_IDENTITY(6972.4386, min(6972.4386, 6972.4386)))), 50.04, -1.9, 831.427, -907.659, 9.1, -664.987, -6220.5790) * (mat2x4(-965.356, 572.578, 3.9, -8.6, 906.936, 896.639, 9.6, -6.8)));
                    }
                   else
                    {
                    }
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, (_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, (false) && true))))) || false))))))
                  {
                   if(_GLF_DEAD(false))
                    break;
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                    }
                   else
                    {
                     barrier();
                    }
                  }
                 8905.2830;
                }
               for(mat3x4 _GLF_SWITCH_2_9v[21]; true; determinant(mat4(51.92)))
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                    }
                   else
                    {
                     for(bool _GLF_SWITCH_2_10v[89], _GLF_SWITCH_2_11v[19]; _GLF_IDENTITY(false, (false) || false); false)
                      {
                       ;
                       vec4(-8240.1531, 7.1, 8.2, 3.5);
                       uvec3(48588u, 119805u, 955u).xxx;
                      }
                     if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
                      break;
                    }
                  }
                 mat3 _GLF_SWITCH_2_12v[23];
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, ! (! (true)))))
                    {
                     switch(_GLF_SWITCH(0))
                      {
                       case 33:
                       ivec2 _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v, _GLF_SWITCH_3_2v;
                       case 4:
                       ;
                       case 0:
                       case 76:
                       case 75:
                       case 25:
                       case 41:
                       case 74:
                       barrier();
                       break;
                       default:
                       1;
                      }
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      continue;
                    }
                   else
                    {
                     if(_GLF_DEAD(false))
                      continue;
                    }
                  }
                 mat4x2(-5.0, 130.462, -2168.7380, -2053.8739, -9325.0531, 4.7, 6.3, 846.718);
                }
               if(_GLF_DEAD(false))
                continue;
              }
            }
           else
            {
            }
           default:
           1;
          }
         if(_GLF_DEAD(false))
          break;
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               return;
              }
             else
              {
              }
            }
          }
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 ^ 1)); _injected_loop_counter ++)
              {
               barrier();
              }
             if(_GLF_DEAD(false))
              return;
            }
          }
         barrier();
         if(_GLF_DEAD(false))
          return;
        }
       case 77:
       if(_GLF_DEAD(false))
        barrier();
       break;
       case 13:
       {
        {
        }
        do
         {
          while(true)
           {
            ;
            (uvec2(104117u, 147127u) ^ _GLF_SWITCH_3_0v);
            mat3 _GLF_SWITCH_3_1v, _GLF_SWITCH_3_2v;
            mat3x2 _GLF_SWITCH_3_3v, _GLF_SWITCH_3_4v[62];
           }
          if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
           continue;
          for(          mat2x3(-8.4, -368.481, 16.59, 1.1, -9.5, -3.3);
 false; mat2x3(8.7, 2.0, -4663.2530, 9.8, 28.39, -4.2))
           {
            int _GLF_SWITCH_3_5v, _GLF_SWITCH_3_6v[41], _GLF_SWITCH_3_7v;
            mat4x3 _GLF_SWITCH_3_8v[24], _GLF_SWITCH_3_9v;
            mat3x2(7599.9287, -8387.7919, -6.2, -7.3, 9269.8467, 9.0);
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             break;
            ivec2 _GLF_SWITCH_3_10v[91], _GLF_SWITCH_3_11v;
            mat2(2.5, 34.86, 4.4, 78.30);
            injectionSwitch;
            bvec2(false, false);
            mat2x3(5.9, 401.122, 5296.7523, -7.7, -4427.5921, -599.197);
           }
          if((mat2x4(2714.5499, -6.6, -3.2, 24.40, -24.86, -37.44, -3157.7303, 6346.9681) == mat2x4(24.65, 3.3, -36.05, -85.09, 0.4, 288.639, 4.6, 0.4)))
           {
            bvec3(false, false, false);
            vec4(-955.241, -567.194, -4.6, 9039.3698);
            mat3x4(mat2(vec2(-8.3, 448.816), injectionSwitch));
            if(_GLF_DEAD(false))
             continue;
            -5502.9907;
            (ivec3(-93239, -27230, -50765).zxy[0] % (60717 / 7578));
            54561u;
            mat3x2(-3.8, -3.3, 74.56, 91.09, 96.44, -468.525);
           }
          else
           {
            do
             {
              ;
             }
            while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
            (- mat3x4(-2.0, 4.3, -4421.9946, 6.5, 280.089, -2.9, -5485.9704, -37.60, 7.3, 55.90, -7.9, -267.295));
            vec2(8.5, -6364.1123);
            if(_GLF_DEAD(false))
             break;
            inverse(mat4(-71.71, 5.3, 260.635, 12.84, -67.12, 81.04, 9447.8995, -2.5, 4277.9848, -0.0, 91.63, 4.1, 85.00, -5427.2026, 9.1, -499.521));
            uvec4 _GLF_SWITCH_3_12v, _GLF_SWITCH_3_13v[69], _GLF_SWITCH_3_14v[5];
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             return;
            mat3x4(mat3x2(8.4, 68.46, -7.5, 868.954, 6.6, 51.75));
            do
             {
              (uvec4(19160u, 132855u, 134218u, 49494u) & _GLF_SWITCH_3_12v);
             }
            while(_GLF_WRAPPED_LOOP(false));
            transpose(mat4x2(93.76, -9.2, 7586.2879, -99.92, -9.9, -5.1, -7.7, 20.25));
            -65333;
           }
          mat3x2(-6476.4935, 789.720, 1.4, 5.3, 8.2, -7.2);
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           continue;
          do
           {
            uvec2 _GLF_SWITCH_3_15v, _GLF_SWITCH_3_16v, _GLF_SWITCH_3_17v;
            vec3 _GLF_SWITCH_3_18v, _GLF_SWITCH_3_19v[91];
            if(_GLF_WRAPPED_IF_FALSE(false))
             {
             }
            else
             {
              mat4(-0.5, -2276.0683, -772.024, 9.4, 7.2, -15.45, 3.8, 7.3, 2443.9359, 3.7, 5.1, 3293.8557, -3.3, 75.66, 5100.6524, 3985.8280);
             }
            mat2x3 _GLF_SWITCH_3_20v[74], _GLF_SWITCH_3_21v, _GLF_SWITCH_3_22v;
            ;
            uvec4(69993u, 70310u, 70242u, 2902u);
            if(_GLF_DEAD(false))
             break;
           }
          while(true);
          mat3x2 _GLF_SWITCH_3_23v, _GLF_SWITCH_3_24v, _GLF_SWITCH_3_25v;
          {
          }
          if(_GLF_DEAD(false))
           continue;
         }
        while((mat4x2(9.4, -8277.4461, -9421.2599, -3.9, 7063.3814, 5.8, 2.4, 5161.1047) == mat4x2(-9.9, -7.0, 8.5, -4.7, 366.976, -24.20, -980.131, -6.8)));
        uvec3(117201u, 32697u, 3294u);
        for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 ^ 0)); _injected_loop_counter ++)
         {
          uvec4(uvec3(39776u, 27008u, 146365u), num_workgroup);
         }
        for(mat3 _GLF_SWITCH_3_26v, _GLF_SWITCH_3_27v[73]; (-77688 < ((-89309 , true) ? -18174 : -68890)); (false ? mat2x3(-86.32, -848.722, -2.9, 59.02, 92.37, 5840.1560) : mat2x3(-5.0, -3736.6498, 9.5, 906.661, -9.2, 5763.0158)))
         {
          mat4x2(4.5, 1.4, 299.817, 686.349, 579.695, -7.6, -3.7, 3389.0204);
         }
        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         return;
        if(false)
         {
          if(_GLF_WRAPPED_IF_TRUE(true))
           {
            bvec4(true, false, true, true);
           }
          else
           {
           }
          for(vec2 _GLF_SWITCH_3_28v[1], _GLF_SWITCH_3_29v; (bvec2(false, false) != bvec3(true, false, false).sp); (mat4x2(-124.426, -9.4, 42.04, 3621.1098, -3060.5764, -99.98, 4860.3447, -0.6) / mat4x2(0.0, 2.3, -2.1, -761.139, 62.17, 974.497, 2586.2398, -45.78)))
           {
            (- mat2(6.6, -15.43, -2420.0714, 807.873));
            mat2x4(97.81, 552.749, -590.635, -9.6, 28.61, 20.48, -0.0, -40.07);
           }
          if(true)
           {
            if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true)))
             return;
            mat2(mat4(0.6, 116.403, -7.3, -61.28, -1.2, 3.3, -55.58, -8735.7390, 0.6, -7479.2364, -8.8, -9.3, -37.21, 29.27, -9.1, -7.3));
            subgroup_size;
            uvec2 _GLF_SWITCH_3_30v;
            bvec4(false, true, true, false);
            uvec2(135871u, 126396u);
            vec4(9.6, 4.1, -5.1, 7294.1479);
            if(_GLF_DEAD(false))
             return;
            bvec2(true, false);
           }
          else
           {
            (13213 & ivec3(-89994, 96172, 54239));
            ;
           }
         }
        mat3x2 _GLF_SWITCH_3_31v[59];
       }
       default:
       1;
      }
    }
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        return;
       barrier();
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     barrier();
    }
  }
 for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY(1, 0 ^ (1))); _injected_loop_counter ++)
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     return;
    }
  }
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     do
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(false))
          barrier();
         return;
        }
      }
     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (injectionSwitch.x > injectionSwitch.y) && true)))));
    }
   else
    {
    }
  }
 uint workgroup_size = gl_WorkGroupSize.x;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
    }
   else
    {
     barrier();
    }
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    {
     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
      {
       return;
      }
    }
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
    {
     if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
      return;
    }
   do
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, true && (injectionSwitch.x > injectionSwitch.y))))))
      {
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(false))
          break;
         barrier();
        }
       else
        {
        }
      }
    }
   while(_GLF_WRAPPED_LOOP(false));
   if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, false || (false))))
    {
    }
   else
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       do
        {
         barrier();
        }
       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
       if(_GLF_DEAD(false))
        return;
      }
    }
   return;
  }
 uint workgroup_id = _GLF_IDENTITY(gl_WorkGroupID, min(gl_WorkGroupID, gl_WorkGroupID)).x;
 uint workgroup_base = workgroup_size * workgroup_id;
 do
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        {
         do
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
          }
         while(_GLF_WRAPPED_LOOP(false));
         return;
        }
       if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(_GLF_IDENTITY(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false, true), bvec3(bvec3(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false, true))))))))
        {
        }
       else
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           do
            {
             return;
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          break;
        }
       if(_GLF_DEAD(false))
        break;
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          continue;
         for(int _injected_loop_counter = (((1 << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), int(2))) ^ 1); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
          {
           barrier();
           if(_GLF_DEAD(false))
            return;
          }
        }
      }
    }
   else
    {
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
      {
       barrier();
      }
     else
      {
      }
    }
  }
 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(vec2(mat3x4(injectionSwitch, 0.0, sin(0.0), 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0)), mix(vec2(_GLF_FUZZED(59.52), _GLF_FUZZED(-7971.5550)), vec2((vec2(mat3x4(injectionSwitch, 0.0, sin(0.0), 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0)))[0], (vec2(mat3x4(injectionSwitch, 0.0, sin(0.0), 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0)))[1]), bvec2(true, true)))).x > injectionSwitch.y))));
 for(int _injected_loop_counter = int(_GLF_ONE(1.0, _GLF_IDENTITY(injectionSwitch, (injectionSwitch) * mat2(1.0)).y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
  {
   for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < (((1 << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), int(4))) ^ 0)); _injected_loop_counter ++)
    {
     if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
      barrier();
    }
  }
 if(_GLF_DEAD(false))
  return;
 uint virtual_gid = workgroup_base + subgroup_id * subgroup_size + subgroup_local_id;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    {
     do
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          return;
         barrier();
        }
      }
     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
        {
         return;
        }
      }
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       return;
       if(_GLF_DEAD(false))
        barrier();
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
        }
      }
     else
      {
       if(_GLF_DEAD(false))
        return;
      }
    }
   if(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) && (_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
        }
       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, true && (_GLF_IDENTITY(false, false || (false)))), bool(bvec3(false, false, true)))))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             barrier();
            }
           return;
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
          }
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 << _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(6), 0 ^ (int(6)))))); _injected_loop_counter --)
          {
           if(_GLF_DEAD(false))
            return;
           barrier();
           if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec4(false, true, true, true)), bool(bvec4(bool(bvec4(false, true, true, true)), false, false, false))))))
            continue;
          }
        }
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 | 1)); _injected_loop_counter ++)
            {
             barrier();
            }
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
            {
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   barrier();
                  }
                 else
                  {
                  }
                }
              }
            }
           if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, false || (false)), (injectionSwitch.x > _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, vec2(mat3x2(injectionSwitch, 1.0, 0.0, determinant(mat3(1.0, 1.0, 1.0, 0.0, 1.0, exp(0.0), log(1.0), 0.0, 1.0)), 1.0))).y, mix(float(_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, vec2(mat3x2(injectionSwitch, 1.0, 0.0, determinant(mat3(1.0, 1.0, 1.0, 0.0, 1.0, exp(0.0), log(1.0), 0.0, 1.0)), 1.0))).y, max(_GLF_IDENTITY(injectionSwitch, vec2(mat3x2(injectionSwitch, 1.0, 0.0, determinant(mat3(1.0, 1.0, 1.0, 0.0, 1.0, exp(0.0), log(1.0), 0.0, 1.0)), 1.0))).y, _GLF_IDENTITY(injectionSwitch, vec2(mat3x2(injectionSwitch, 1.0, 0.0, determinant(mat3(1.0, 1.0, 1.0, 0.0, 1.0, exp(0.0), log(1.0), 0.0, 1.0)), 1.0))).y))), float(_GLF_FUZZED((9.3 - -0.9))), bool(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))))
            break;
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             do
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, _GLF_IDENTITY(float(float(_GLF_IDENTITY(injectionSwitch.y, (false ? _GLF_FUZZED(-936.347) : _GLF_IDENTITY(injectionSwitch.y, max(injectionSwitch.y, injectionSwitch.y)))))), mix(float(float(float(_GLF_IDENTITY(injectionSwitch.y, (false ? _GLF_FUZZED(-936.347) : _GLF_IDENTITY(injectionSwitch.y, max(injectionSwitch.y, injectionSwitch.y))))))), float(_GLF_FUZZED(3.5)), bool(false))))))))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 barrier();
                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    return;
                  }
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
           else
            {
            }
           if(_GLF_DEAD(false))
            continue;
          }
         if(_GLF_DEAD(false))
          return;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       do
        {
         if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), (_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))) && true))
          {
           if(_GLF_DEAD(false))
            continue;
           return;
          }
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         do
          {
           return;
           if(_GLF_DEAD(false))
            continue;
          }
         while(_GLF_IDENTITY(_GLF_WRAPPED_LOOP(false), true && (_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, bool(bool(false)))))));
        }
      }
     else
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
      }
    }
   else
    {
     do
      {
       barrier();
       if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
        barrier();
      }
     while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) && (! (false)))))));
     if(_GLF_DEAD(false))
      return;
    }
   if(_GLF_DEAD(false))
    return;
  }
 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], _GLF_FUZZED(302.717)), vec2(_GLF_FUZZED(68.66), (injectionSwitch)[1]), bvec2(false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))).y))))
  {
  }
 else
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       return;
      }
     else
      {
       if(_GLF_DEAD(false))
        return;
      }
    }
   do
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       do
        {
         do
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         return;
        }
       else
        {
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          break;
         return;
        }
       if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(false || (false), (_GLF_IDENTITY(false || (false), true && (false || (false)))) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
        barrier();
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         if(_GLF_DEAD(false))
          barrier();
        }
      }
    }
   while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
    barrier();
  }
 do
  {
   if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, (false) && true), (_GLF_IDENTITY(injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, _GLF_IDENTITY(injectionSwitch.y, 0.0 + (injectionSwitch.y)), _GLF_IDENTITY(injectionSwitch.y, mix(float(injectionSwitch.y), float(_GLF_FUZZED(float(126484u))), bool(false))))), ! (_GLF_IDENTITY(! (_GLF_IDENTITY(injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, _GLF_IDENTITY(injectionSwitch.y, 0.0 + (injectionSwitch.y)), _GLF_IDENTITY(injectionSwitch.y, mix(float(injectionSwitch.y), float(_GLF_FUZZED(float(126484u))), bool(false))))), (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, _GLF_IDENTITY(injectionSwitch.y, 0.0 + (injectionSwitch.y)), _GLF_IDENTITY(injectionSwitch.y, mix(float(injectionSwitch.y), float(_GLF_FUZZED(float(126484u))), bool(false)))))) && true)), ! (_GLF_IDENTITY(! (! (_GLF_IDENTITY(injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, _GLF_IDENTITY(injectionSwitch.y, 0.0 + (injectionSwitch.y)), _GLF_IDENTITY(injectionSwitch.y, mix(float(injectionSwitch.y), float(_GLF_FUZZED(float(126484u))), bool(false))))), (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, _GLF_IDENTITY(injectionSwitch.y, 0.0 + (injectionSwitch.y)), _GLF_IDENTITY(injectionSwitch.y, mix(float(injectionSwitch.y), float(_GLF_FUZZED(float(126484u))), bool(false)))))) && true))), ! (! (! (! (_GLF_IDENTITY(injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, _GLF_IDENTITY(injectionSwitch.y, 0.0 + (injectionSwitch.y)), _GLF_IDENTITY(injectionSwitch.y, mix(float(injectionSwitch.y), float(_GLF_FUZZED(float(126484u))), bool(false))))), (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, _GLF_IDENTITY(injectionSwitch.y, 0.0 + (injectionSwitch.y)), _GLF_IDENTITY(injectionSwitch.y, mix(float(injectionSwitch.y), float(_GLF_FUZZED(float(126484u))), bool(false)))))) && true))))))))))))))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          continue;
        }
       break;
      }
     switch(_GLF_SWITCH(0))
      {
       case 18:
       if(true)
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), true && ((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, float(mat2(injectionSwitch.y, 0.0, 1.0, 1.0)))))))))
          barrier();
         mat3x4(7.0, -73.67, 70.56, 1.8, 260.989, -3.5, 64.83, 14.90, -347.692, _GLF_IDENTITY(-2549.8139, (-2549.8139) + _GLF_IDENTITY(0.0, min(0.0, 0.0))), 4.4, 0.6);
         vec2 _GLF_SWITCH_0_0v, _GLF_SWITCH_0_1v;
         ;
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))))))))
            {
             for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
              {
               barrier();
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) && (injectionSwitch.x > injectionSwitch.y))))))
          {
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), false || (! (false)))))))
              {
               do
                {
                 if(_GLF_DEAD(false))
                  return;
                }
               while(_GLF_WRAPPED_LOOP(false));
               do
                {
                 barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           break;
          }
         {
          if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
           {
            uvec4(126288u, 192245u, 184737u, 174495u).rgr;
           }
          else
           {
           }
          mat4x2 _GLF_SWITCH_0_2v, _GLF_SWITCH_0_3v, _GLF_SWITCH_0_4v;
          if(_GLF_DEAD(false))
           {
            if(_GLF_DEAD(false))
             continue;
            continue;
           }
          uint _GLF_SWITCH_0_5v;
         }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           return;
          }
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(false, false, false, true)))))
              continue;
             greaterThan(uvec3(121357u, 71729u, 164787u), uvec3(9822u, 19462u, 25794u));
            }
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          return;
         while(false)
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
            return;
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
            }
           else
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, clamp(injectionSwitch.x, _GLF_IDENTITY(injectionSwitch.x, clamp(_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) - 0.0), injectionSwitch.x, _GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, injectionSwitch.x)))), _GLF_IDENTITY(injectionSwitch.x, mix(float(injectionSwitch.x), float(_GLF_FUZZED(672.254)), bool(false))))) > injectionSwitch.y))))
              {
               for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(1), int(1))); _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 ^ 1)); _injected_loop_counter ++)
                {
                 return;
                }
              }
            }
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           else
            {
            }
           int(atan(12.54));
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              continue;
             break;
            }
           uint _GLF_SWITCH_0_6v[18], _GLF_SWITCH_0_7v, _GLF_SWITCH_0_8v;
           true;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           (+ mat3x2(4.9, -3.9, _GLF_IDENTITY(-7760.4574, _GLF_IDENTITY(float(vec3(_GLF_IDENTITY(-7760.4574, max(-7760.4574, -7760.4574)), 1.0, 1.0)), max(float(vec3(_GLF_IDENTITY(-7760.4574, max(-7760.4574, -7760.4574)), 1.0, 1.0)), float(vec3(_GLF_IDENTITY(-7760.4574, max(-7760.4574, -7760.4574)), 1.0, 1.0))))), 3.5, -23.98, 9.4));
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              break;
             barrier();
            }
           if(_GLF_DEAD(false))
            break;
           for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
            {
             do
              {
               bvec2(true, false);
               if(_GLF_DEAD(false))
                continue;
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
            }
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
            }
           else
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               return;
              }
            }
           do
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               barrier();
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
          }
         if(bvec3(true, false, false).r)
          {
          }
         else
          {
           mat2x4(faceforward(-8281.2204, -121.740, vec3(-177.375, 6236.4600, -6.6)[2]));
           for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), int(2))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
            {
             if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ! (! ((_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) - 0.0) > injectionSwitch.y)))))))
              return;
            }
           if(_GLF_DEAD(false))
            return;
           if(_GLF_IDENTITY(_GLF_DEAD(false), bool(_GLF_IDENTITY(bvec3(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))), true, false), bvec3(bvec4(bvec3(_GLF_IDENTITY(_GLF_DEAD(false), ! (! _GLF_IDENTITY((_GLF_DEAD(false)), _GLF_IDENTITY(bool(_GLF_IDENTITY(bvec2((_GLF_DEAD(false)), true), _GLF_IDENTITY(bvec2(bvec3(bvec2((_GLF_DEAD(false)), true), false)), bvec2(bvec4(bvec2(bvec3(bvec2((_GLF_DEAD(false)), true), false)), false, false))))), (bool(_GLF_IDENTITY(bvec2((_GLF_DEAD(false)), true), _GLF_IDENTITY(bvec2(bvec3(bvec2((_GLF_DEAD(false)), true), false)), bvec2(bvec4(bvec2(bvec3(bvec2((_GLF_DEAD(false)), true), false)), false, false)))))) && true)))), true, false), false))))))
            return;
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               mat3x2(mat2x3(-2.2, 67.41, -5811.0724, -7.1, _GLF_IDENTITY(-2188.6551, clamp(-2188.6551, _GLF_IDENTITY(-2188.6551, float(vec4(-2188.6551, 0.0, _GLF_IDENTITY(dot(vec2(0.0, 1.0), vec2(0.0, 1.0)), dot(vec2(0.0, 1.0), vec2(0.0, 1.0))), exp(0.0)))), _GLF_IDENTITY(-2188.6551, clamp(-2188.6551, -2188.6551, -2188.6551)))), 55.97));
               if(_GLF_DEAD(false))
                continue;
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                    {
                     return;
                    }
                   else
                    {
                     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                      {
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_WRAPPED_IF_FALSE(false))
                          {
                          }
                         else
                          {
                           return;
                          }
                        }
                      }
                    }
                  }
                }
               else
                {
                }
              }
            }
           else
            {
            }
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false || (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true && (_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, mat2(1.0) * (injectionSwitch)).x > injectionSwitch.y))))))))
            continue;
          }
         if(_GLF_DEAD(false))
          continue;
         mat2(mat4x2(-695.554, 1.7, 6.8, -4.1, -9852.3629, -9180.7612, _GLF_IDENTITY(9.5, float(mat4x2(_GLF_IDENTITY(9.5, mix(float(_GLF_FUZZED((true ? -92.68 : 9956.1417))), float(9.5), bool(true))), 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0))), 4.3));
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                }
               else
                {
                }
               if(_GLF_DEAD(false))
                return;
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 do
                  {
                   return;
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                }
               else
                {
                }
              }
             else
              {
               if(_GLF_DEAD(false))
                barrier();
              }
            }
          }
         else
          {
           if(_GLF_DEAD(false))
            continue;
          }
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec3(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))), ! (! (bool(bvec3(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))), (injectionSwitch.x > injectionSwitch.y))))
            break;
          }
         mat3 _GLF_SWITCH_0_9v[77], _GLF_SWITCH_0_10v, _GLF_SWITCH_0_11v[59];
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              continue;
             continue;
            }
           continue;
           if(_GLF_DEAD(false))
            barrier();
          }
        }
       else
        {
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(false))
              continue;
             barrier();
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
              }
             else
              {
               do
                {
                 return;
                 if(_GLF_DEAD(false))
                  break;
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
            }
          }
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = (1 | int(_GLF_ZERO(0.0, injectionSwitch.x))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
            {
             do
              {
               if(_GLF_DEAD(false))
                {
                 do
                  {
                   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter != 1, _GLF_IDENTITY(bool(_GLF_IDENTITY(bvec2(_injected_loop_counter != 1, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))), bvec2(bvec2(bvec2(_injected_loop_counter != 1, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))))), (bool(_GLF_IDENTITY(bvec2(_injected_loop_counter != 1, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))), bvec2(bvec2(bvec2(_injected_loop_counter != 1, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))))) || false))); _injected_loop_counter ++)
                    {
                     if(_GLF_DEAD(false))
                      break;
                     barrier();
                    }
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
           if(_GLF_DEAD(false))
            barrier();
           barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY(int(_GLF_ZERO(0.0, injectionSwitch.x)), ~ (~ (int(_GLF_ZERO(0.0, injectionSwitch.x)))))); _injected_loop_counter --)
          {
           switch(_GLF_SWITCH(0))
            {
             case 0:
             case 31:
             case 58:
             uvec2(57327u, 6778u);
             break;
             default:
             1;
            }
           if(_GLF_DEAD(false))
            return;
          }
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
          }
        }
       if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, _GLF_IDENTITY(float(vec3(_GLF_IDENTITY(injectionSwitch.x, _GLF_IDENTITY(float(mat3x4(injectionSwitch.x, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)), (true ? float(mat3x4(injectionSwitch.x, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)) : _GLF_FUZZED(-86.87)))), 1.0, 1.0)), min(float(vec3(_GLF_IDENTITY(injectionSwitch.x, _GLF_IDENTITY(float(mat3x4(injectionSwitch.x, 1.0, 0.0, 0.0, _GLF_IDENTITY(1.0, mix(float(1.0), float(_GLF_FUZZED((-58.28))), bool(false))), 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)), (true ? float(mat3x4(injectionSwitch.x, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)) : _GLF_FUZZED(-86.87)))), 1.0, 1.0)), float(vec3(_GLF_IDENTITY(injectionSwitch.x, _GLF_IDENTITY(float(mat3x4(injectionSwitch.x, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)), (true ? float(mat3x4(injectionSwitch.x, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)) : _GLF_FUZZED(-86.87)))), 1.0, 1.0))))) > injectionSwitch.y))), (_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))) && true))
        {
         if(_GLF_DEAD(false))
          break;
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
          {
           return;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, false || (false))) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))
          {
           if(_GLF_DEAD(false))
            break;
           continue;
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
        }
       do
        {
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, bool(bvec4(false, true, false, _GLF_IDENTITY(true, bool(bool(true)))))), true && (false))))
          {
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             barrier();
            }
           else
            {
            }
          }
        }
       while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, ! (! (false)))));
       if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(bvec4(false, true, false, true)))))
        {
        }
       else
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       case 0:
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          {
           do
            {
             barrier();
             if(_GLF_DEAD(false))
              continue;
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
         break;
        }
       case 6:
       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bool(false), (bool(false)) && true)))))
        {
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_IDENTITY(_GLF_WRAPPED_IF_TRUE(true), ! (! (_GLF_WRAPPED_IF_TRUE(true)))))
              {
               barrier();
              }
             else
              {
              }
            }
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
            barrier();
           if(_GLF_DEAD(false))
            return;
           continue;
          }
         return;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        break;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        break;
       case 84:
       case 66:
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          break;
         barrier();
        }
       case 19:
       case 32:
       if(_GLF_DEAD(false))
        break;
       do
        {
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            break;
           do
            {
             barrier();
            }
           while(_GLF_WRAPPED_LOOP(false));
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
        }
       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
       case 53:
       case 93:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        continue;
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           barrier();
          }
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          break;
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          return;
         return;
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          continue;
        }
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         return;
        }
       else
        {
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             barrier();
            }
          }
         barrier();
         if(_GLF_DEAD(false))
          break;
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          break;
         if(_GLF_DEAD(false))
          continue;
         break;
        }
       if(_GLF_DEAD(false))
        continue;
       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           barrier();
          }
         else
          {
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          break;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.y, 1.0 * (injectionSwitch.y)), min(_GLF_IDENTITY(injectionSwitch.y, mix(float(injectionSwitch.y), float(_GLF_FUZZED(-5.5)), bool(false))), _GLF_IDENTITY(injectionSwitch.y, (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) ? _GLF_FUZZED(-4.1) : injectionSwitch.y))))))))
        barrier();
       break;
       default:
       _GLF_IDENTITY(1, (1) | (_GLF_IDENTITY(1, (1) >> 0)));
       if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
        {
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           do
            {
             barrier();
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
          }
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           return;
          }
         else
          {
          }
        }
      }
     if(_GLF_DEAD(false))
      continue;
     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        break;
       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
        {
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
          }
         else
          {
           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
            {
             do
              {
               return;
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           switch(_GLF_SWITCH(0))
            {
             case 16:
             uvec4 _GLF_SWITCH_3_0v[98];
             case 25:
             ;
             case 0:
             case 49:
             case 19:
             do
              {
               do
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                 barrier();
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
              }
             while(_GLF_WRAPPED_LOOP(false));
             break;
             default:
             1;
            }
          }
        }
       if(_GLF_DEAD(false))
        barrier();
      }
     if(_GLF_DEAD(false))
      break;
    }
  }
 while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, _GLF_IDENTITY(_GLF_IDENTITY(bool(bvec4(false, true, true, _GLF_FALSE(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bool(false), ! (! (bool(false)))))), (injectionSwitch.x > injectionSwitch.y)))), bool(bvec2(bool(bvec4(false, true, true, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))), false))), ! (! (bool(bvec4(false, true, true, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))))));
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 uint next_virtual_gid = workgroup_base + subgroup_id * _GLF_IDENTITY(subgroup_size, max(subgroup_size, subgroup_size)) + (_GLF_IDENTITY((_GLF_IDENTITY(subgroup_local_id + _GLF_IDENTITY(1, clamp(1, 1, 1)), (subgroup_local_id + 1) * _GLF_IDENTITY(1u, max(1u, 1u)))) % _GLF_IDENTITY(subgroup_size, (subgroup_size) * (_GLF_IDENTITY((1u << _GLF_IDENTITY(uint(5u), uint(5u))), ((1u << _GLF_IDENTITY(uint(5u), _GLF_IDENTITY(uint(5u), 0u ^ (uint(5u)))))) + (0u >> _GLF_IDENTITY(uint(8u), uint(8u)))) >> _GLF_IDENTITY(uint(5u), uint(5u)))), ((_GLF_IDENTITY(subgroup_local_id + 1, (_GLF_IDENTITY(subgroup_local_id, (subgroup_local_id) / 1u) + 1) * 1u)) % subgroup_size) | 0u));
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    {
     for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(5), int(5))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
      {
       barrier();
      }
    }
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     return;
    }
   else
    {
    }
  }
 do
  {
   if(_GLF_DEAD(false))
    {
     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
      {
       for(int _injected_loop_counter = (1 | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter != ((-53400 & 0) >> _GLF_IDENTITY(int(1), int(1)))); _injected_loop_counter --)
        {
         if(_GLF_DEAD(false))
          barrier();
         barrier();
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
            }
           else
            {
             barrier();
            }
          }
        }
      }
    }
   for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 | 1)); _injected_loop_counter ++)
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         return;
        }
       else
        {
        }
      }
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(false))
      break;
     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! _GLF_IDENTITY((false), _GLF_IDENTITY(bool(bvec3((false), false, false)), bool(_GLF_IDENTITY(bvec3(bool(bvec3((false), false, false)), true, true), bvec3(bvec3(bvec3(bool(bvec3((false), false, false)), true, true))))))), ! (! (! (false))))))))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
        }
       else
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         barrier();
        }
      }
     barrier();
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        barrier();
      }
     else
      {
      }
     barrier();
    }
   switch(_GLF_SWITCH(0))
    {
     case 0:
     case 94:
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, bool(bvec3(false, true, false))))))))
      continue;
     if(_GLF_DEAD(false))
      continue;
     case 99:
     if(_GLF_DEAD(false))
      barrier();
     case 36:
     case 57:
     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          continue;
         break;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       break;
      }
     if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(false, true, true, true)))))
      {
       if(_GLF_DEAD(false))
        continue;
       break;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true)))
        return;
       barrier();
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, min(_GLF_IDENTITY(injectionSwitch.x, float(mat3x2(injectionSwitch.x, 0.0, 1.0, 0.0, 1.0, 0.0))), injectionSwitch.x)) > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        continue;
       do
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           continue;
           do
            {
             if(_GLF_DEAD(false))
              return;
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
          }
         if(_GLF_DEAD(false))
          {
           switch(_GLF_SWITCH(0))
            {
             case 23:
             if(_GLF_DEAD(false))
              continue;
             do
              {
               -52608;
              }
             while(_GLF_WRAPPED_LOOP(false));
             case 0:
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    return;
                   barrier();
                  }
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
              }
             if(_GLF_DEAD(false))
              {
               switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                {
                 case 4:
                 ivec2 _GLF_SWITCH_3_0v;
                 case 0:
                 case 57:
                 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                  {
                   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                    }
                   else
                    {
                     barrier();
                    }
                  }
                 else
                  {
                  }
                 break;
                 if(_GLF_DEAD(false))
                  return;
                 case 87:
                 bvec3(true, false, true);
                 default:
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   1;
                  }
                 else
                  {
                  }
                }
              }
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, _GLF_IDENTITY(injectionSwitch.x, (false ? _GLF_FUZZED(-696.976) : injectionSwitch.x))))))
                {
                 case 29:
                 mat3x4 _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v, _GLF_SWITCH_2_2v;
                 case 33:
                 for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                  {
                   mat2(8257.4269, 0.3, -5.1, 293.485);
                  }
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    continue;
                   barrier();
                  }
                 case 0:
                 case 35:
                 case 13:
                 return;
                 case 50:
                 case 16:
                 if(_GLF_DEAD(false))
                  barrier();
                 case 86:
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                 break;
                 default:
                 1;
                }
              }
             else
              {
              }
             if(_GLF_DEAD(false))
              break;
             break;
             case 63:
             bvec3 _GLF_SWITCH_2_0v;
             default:
             1;
            }
          }
         if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
          return;
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(false))
        break;
       if(_GLF_DEAD(false))
        continue;
       if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && true))
        continue;
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 ^ 0)); _injected_loop_counter ++)
          {
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
            {
             if(_GLF_DEAD(false))
              {
               for(int _injected_loop_counter = _GLF_IDENTITY(0, (0) / 1); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                {
                 barrier();
                }
              }
            }
           barrier();
          }
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
          return;
         barrier();
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         continue;
        }
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], _GLF_IDENTITY(injectionSwitch[1], max(injectionSwitch[1], injectionSwitch[1])))).x > injectionSwitch.y))))
          return;
        }
       else
        {
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        break;
       if(_GLF_DEAD(false))
        barrier();
      }
     if(_GLF_DEAD(false))
      {
       switch(_GLF_SWITCH(_GLF_IDENTITY(0, (0) | (0))))
        {
         case 23:
         if(_GLF_DEAD(false))
          return;
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           for(           lessThanEqual(vec3(2043.3415, -7201.7216, -3322.2613), vec3(635.588, -3162.1216, -8620.9722));
 all(bvec4(false, true, true, true)); mat2(-5270.5600, 9494.5742, 9.2, 0.3))
            {
            }
          }
         else
          {
          }
         case 0:
         case 3:
         case 90:
         if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, ! (! (false)))))
          {
          }
         else
          {
           if(_GLF_DEAD(false))
            return;
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           continue;
          }
         if(_GLF_DEAD(false))
          barrier();
         case 10:
         case 96:
         if(_GLF_DEAD(false))
          return;
         barrier();
         if(_GLF_DEAD(false))
          break;
         break;
         default:
         1;
         if(_GLF_DEAD(false))
          return;
        }
      }
     case 6:
     if(_GLF_DEAD(false))
      break;
     case 72:
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        return;
       continue;
      }
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        {
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             barrier();
            }
           else
            {
            }
          }
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        break;
      }
     else
      {
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          break;
         barrier();
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            continue;
           break;
          }
        }
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
        {
         return;
        }
      }
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             return;
            }
           else
            {
            }
          }
        }
       else
        {
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          return;
         continue;
        }
       break;
       if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(bvec4(false, false, true, true)))))
        {
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
            {
             barrier();
            }
          }
        }
       else
        {
         if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
          {
          }
         else
          {
           do
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
        }
      }
     for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < _GLF_IDENTITY((1 | 1), (true ? (1 | 1) : _GLF_FUZZED(60565)))); _injected_loop_counter ++)
      {
       atomicStore(buf[next_virtual_gid], _GLF_IDENTITY(uint(1), uint(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), _GLF_IDENTITY((_GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), max(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), _GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), uvec3(0u, 0u, 0u) | (_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u)))))))), _GLF_IDENTITY(uvec3(_GLF_IDENTITY(uvec4((_GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), max(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), _GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), uvec3(0u, 0u, 0u) | (_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u)))))))), 0u), ~ (~ (uvec4((_GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), max(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), _GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), uvec3(0u, 0u, 0u) | (_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u)))))))), 0u))))), (_GLF_IDENTITY(uvec3(_GLF_IDENTITY(uvec4((_GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), max(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), _GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), uvec3(0u, 0u, 0u) | (_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u)))))))), 0u), ~ (~ (uvec4((_GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), max(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), _GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), uvec3(0u, 0u, 0u) | (_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u)))))))), 0u))))), min(uvec3(_GLF_IDENTITY(uvec4((_GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), max(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), _GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), uvec3(0u, 0u, 0u) | (_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u)))))))), 0u), ~ (~ (uvec4((_GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), max(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), _GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), uvec3(0u, 0u, 0u) | (_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u)))))))), 0u))))), uvec3(_GLF_IDENTITY(uvec4((_GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), max(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), _GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), uvec3(0u, 0u, 0u) | (_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u)))))))), 0u), ~ (~ (uvec4((_GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), max(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), _GLF_IDENTITY(_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u))), uvec3(0u, 0u, 0u) | (_GLF_IDENTITY(uvec3(uint(1), (1u | 1u), 1u), clamp(uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u), uvec3(uint(1), (1u | 1u), 1u)))))))), 0u)))))))) << uvec3(0u, 0u, 0u))) - uvec3(0u, 0u, 0u)))), 4, 64, 4);
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           return;
          }
         else
          {
          }
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
              }
             else
              {
               return;
              }
            }
          }
         else
          {
          }
        }
       break;
      }
     if(_GLF_DEAD(false))
      break;
     if(_GLF_DEAD(false))
      {
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(3), int(3))) >> _GLF_IDENTITY(int(3), _GLF_IDENTITY(int(3), (false ? _GLF_FUZZED(73218) : int(3)))))); _injected_loop_counter ++)
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       break;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      continue;
     break;
     if(_GLF_DEAD(false))
      break;
     default:
     _GLF_IDENTITY(1, clamp(_GLF_IDENTITY(1, (1) * 1), 1, 1));
     if(_GLF_DEAD(false))
      barrier();
    }
  }
 while(_GLF_WRAPPED_LOOP(false));
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         barrier();
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     if(_GLF_DEAD(false))
      return;
    }
   if(_GLF_DEAD(false))
    {
     do
      {
       if(_GLF_DEAD(false))
        continue;
       do
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(false))
            {
             do
              {
               barrier();
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              continue;
             do
              {
               for(int _injected_loop_counter = (1 ^ 0); _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                {
                 barrier();
                 if(_GLF_DEAD(false))
                  barrier();
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
            }
           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
            {
             if(_GLF_DEAD(false))
              break;
             return;
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              break;
             return;
            }
           for(int _injected_loop_counter = _GLF_IDENTITY(1, min(1, _GLF_IDENTITY(1, clamp(1, 1, 1)))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 return;
                }
               else
                {
                }
              }
            }
           switch(_GLF_SWITCH((int(_GLF_ZERO(0.0, injectionSwitch.x)) | 0)))
            {
             case 88:
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, (false) || false)))
              {
              }
             else
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                }
               else
                {
                }
               uvec3(129060u, 54236u, 187316u);
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             case 0:
             case 27:
             if(_GLF_DEAD(false))
              break;
             case 18:
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               for(int _injected_loop_counter = (int(_GLF_ZERO(0.0, injectionSwitch.x)) | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
              }
             else
              {
              }
             case 59:
             case 78:
             case 38:
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              return;
             case 99:
             return;
             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, min(injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y))))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 barrier();
                }
              }
             break;
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               do
                {
                 return;
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             if(_GLF_DEAD(false))
              return;
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
               else
                {
                }
               return;
              }
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                break;
               do
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                  {
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                    }
                   else
                    {
                     barrier();
                    }
                  }
                 else
                  {
                  }
                }
               switch(_GLF_SWITCH(0))
                {
                 case 4:
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, 0.0 + (injectionSwitch.y))))))
                  barrier();
                 vec2 _GLF_SWITCH_1_0v, _GLF_SWITCH_1_1v;
                 if(_GLF_DEAD(false))
                  break;
                 case 91:
                 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                  {
                   mat4(78.38, 5.7, 2.9, 4.8, -116.021, 5.4, -2.3, -9.0, -6.8, _GLF_IDENTITY(2415.2947, mix(float(_GLF_FUZZED((7812.0451 / 2.0))), float(2415.2947), bool(true))), -2895.8052, 3371.5740, -264.616, -5580.7859, 0.4, 9.1);
                  }
                 case 0:
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    continue;
                   barrier();
                  }
                 case 27:
                 if(_GLF_DEAD(false))
                  return;
                 if(_GLF_DEAD(false))
                  barrier();
                 case 71:
                 if(_GLF_IDENTITY(_GLF_DEAD(false), true && (_GLF_DEAD(false))))
                  break;
                 for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 >> _GLF_IDENTITY(int(7), int(7)))); _injected_loop_counter --)
                  {
                   if(_GLF_DEAD(false))
                    {
                     for(int _injected_loop_counter = (1 ^ 1); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                      {
                       barrier();
                      }
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_WRAPPED_IF_TRUE(true))
                        {
                         barrier();
                        }
                       else
                        {
                        }
                      }
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_WRAPPED_IF_TRUE(true))
                        {
                         if(_GLF_DEAD(false))
                          return;
                         for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                          {
                           barrier();
                          }
                        }
                       else
                        {
                        }
                       if(_GLF_WRAPPED_IF_FALSE(false))
                        {
                        }
                       else
                        {
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_WRAPPED_IF_FALSE(false))
                            {
                            }
                           else
                            {
                             barrier();
                            }
                          }
                        }
                      }
                     if(_GLF_DEAD(false))
                      return;
                    }
                  }
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   do
                    {
                     barrier();
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                  }
                 else
                  {
                  }
                 break;
                 case 45:
                 (_GLF_IDENTITY(63.48, determinant(mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, _GLF_ONE(1.0, _GLF_IDENTITY(injectionSwitch.y, min(_GLF_IDENTITY(injectionSwitch.y, max(injectionSwitch.y, _GLF_IDENTITY(injectionSwitch.y, (injectionSwitch.y) * 1.0))), injectionSwitch.y))), 0.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 0.0, 1.0, _GLF_IDENTITY(1.0, mix(float(_GLF_FUZZED(-1.2)), float(_GLF_IDENTITY(1.0, float(vec4(1.0, 0.0, 1.0, 0.0)))), bool(true))), abs(1.0))) * (63.48)) - mat3(34.02, -6.8, -1186.9830, 530.116, -34.13, 35.40, -7.6, 3.8, 7.2));
                 default:
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   if(_GLF_DEAD(false))
                    return;
                   1;
                  }
                 else
                  {
                  }
                }
              }
             default:
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                 if(_GLF_DEAD(false))
                  return;
                }
               else
                {
                 if(_GLF_DEAD(false))
                  return;
                 if(_GLF_DEAD(false))
                  return;
                }
              }
             else
              {
              }
             if(_GLF_DEAD(false))
              barrier();
             do
              {
               do
                {
                 1;
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_IDENTITY(_GLF_DEAD(false), false || (_GLF_DEAD(false))))
              barrier();
             do
              {
               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                }
               else
                {
                 for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 ^ 0)); _injected_loop_counter ++)
                  {
                   if(_GLF_WRAPPED_IF_TRUE(true))
                    {
                     if(_GLF_DEAD(false))
                      return;
                    }
                   else
                    {
                    }
                  }
                 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), (_GLF_IDENTITY(! (false), bool(bool(! (false))))) && true)))))
                  barrier();
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, true)))))
              return;
            }
          }
         else
          {
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             if(_GLF_DEAD(false))
              barrier();
            }
          }
        }
       while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, bool(bvec3(_GLF_IDENTITY(false, ! (! (false))), _GLF_IDENTITY(true, false || (true)), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))));
       if(_GLF_DEAD(false))
        break;
      }
     while(_GLF_WRAPPED_LOOP(false));
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
    }
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec3(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true), bvec3(bvec4(bvec3(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true), false))))), (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     do
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) * 1.0), mix(float(_GLF_FUZZED(8.3)), float(_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) * 1.0), _GLF_ONE(1.0, injectionSwitch.y) * (_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) * 1.0)))), bool(true))) > injectionSwitch.y))))
        return;
      }
     while(_GLF_WRAPPED_LOOP(false));
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        return;
      }
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        barrier();
      }
     else
      {
      }
     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
      }
     else
      {
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         return;
        }
       else
        {
        }
      }
     if(_GLF_DEAD(false))
      {
       switch(_GLF_SWITCH((0 >> _GLF_IDENTITY(int(8), _GLF_IDENTITY(int(8), (int(8)) + 0)))))
        {
         case 10:
         for(         mat2x4(-702.180, 5.1, -238.837, -553.963, 86.41, -9.8, -26.87, 1.9);
 false; mat4(7370.2600, -42.20, 51.19, 1.3, 4.4, -228.858, -807.039, 542.443, 8764.3886, -42.66, -4989.2941, 1851.5180, 2314.7564, 40.41, -9398.4031, 1159.2018))
          {
           for(mat4x2 _GLF_SWITCH_3_0v; (mat2x3(5.7) == mat2x3(6422.1224, -136.995, 768.169, 98.42, 9.6, 46.44)); ivec4(-53068, 24217, 88829, 32264))
            {
             num_workgroup;
             uvec3(85951u, 75511u, 8332u);
             ivec4(53959, 69776, -4635, -9499);
             bvec3 _GLF_SWITCH_3_1v;
             3644.7084;
             mat4 _GLF_SWITCH_3_2v[20];
            }
           {
            if(_GLF_DEAD(false))
             continue;
            mat4(73.46, -63.74, -793.863, 19.70, -230.442, 582.670, -6735.5517, -404.287, -45.86, -6686.4523, -7.5, 1450.2146, 367.019, 2366.4282, -0.3, 59.22);
            atan(vec4(6.8, 6.2, -7.2, -3037.5877), vec4(5903.1957, 911.412, -990.229, 20.34));
            smoothstep(vec3(287.271, -6.9, -9.4).p, 7.2, vec4(-1.0, -8039.8938, -35.40, 5.0));
            mat4x3 _GLF_SWITCH_3_3v, _GLF_SWITCH_3_4v, _GLF_SWITCH_3_5v;
            mat2(-9245.5789, 7923.3030, -9.9, -862.780);
            ;
            mat2(-3926.3509, -9.1, 4688.2675, -727.844);
            uvec3 _GLF_SWITCH_3_6v, _GLF_SWITCH_3_7v;
           }
           mat3x4 _GLF_SWITCH_3_8v[25], _GLF_SWITCH_3_9v;
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
            {
             mat3x2(mat4x2(-6.1, -1.6, 6.7, 8.7, 16.66, -7811.8733, -0.7, 1814.5154));
             mat2x3(3.5, 524.035, -9.5, 891.841, 0.0, 2.7);
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               mod(vec2(-56.36, 838.240), 86.98);
              }
             bitCount(-63292);
             uvec4 _GLF_SWITCH_3_10v[34], _GLF_SWITCH_3_11v, _GLF_SWITCH_3_12v[94];
             tanh(vec4(-55.13, -4733.2322, -2.0, -81.77));
            }
          }
         case 69:
         vec3(1.8, 3.6, -5.8);
         case 0:
         case 46:
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
          }
         case 2:
         return;
         break;
         case 71:
         mat4x2(1800.6066, -5.0, -4.8, -8175.7178, -7.8, 2.7, 8232.6971, -4.7);
         case 67:
         vec2(1.7, -5.8);
         default:
         1;
         if(_GLF_DEAD(false))
          return;
        }
      }
    }
   if(_GLF_DEAD(false))
    return;
   if(_GLF_IDENTITY(_GLF_DEAD(false), bool(bvec3(_GLF_DEAD(false), false, true))))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       barrier();
      }
    }
  }
 if(_GLF_DEAD(false))
  {
   for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(6), (true ? int(6) : _GLF_FUZZED(89675))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY(int(_GLF_ONE(1.0, injectionSwitch.y)), int(_GLF_IDENTITY(ivec2(int(_GLF_ONE(1.0, injectionSwitch.y)), 0), max(ivec2(int(_GLF_ONE(1.0, injectionSwitch.y)), 0), ivec2(int(_GLF_ONE(1.0, injectionSwitch.y)), 0)))))); _GLF_IDENTITY(_injected_loop_counter ++, (_injected_loop_counter ++) - 0))
    {
     barrier();
    }
  }
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
      }
     else
      {
       barrier();
      }
    }
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_IDENTITY(_GLF_DEAD(false), _GLF_IDENTITY(bool(bvec4(_GLF_IDENTITY(_GLF_DEAD(false), true && (_GLF_DEAD(false))), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), true, true)), ! (! (bool(bvec4(_GLF_IDENTITY(_GLF_DEAD(false), true && (_GLF_DEAD(false))), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), true, _GLF_IDENTITY(true, _GLF_IDENTITY(false || (true), (false || (true)) || false)))))))))
      {
       if(_GLF_DEAD(false))
        barrier();
       barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
      }
    }
   else
    {
    }
  }
 else
  {
   if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
    {
     switch(_GLF_SWITCH((0 ^ 0)))
      {
       case 15:
       for(uint _GLF_SWITCH_3_0v[27], _GLF_SWITCH_3_1v; (injectionSwitch != vec2(806.795, -66.02)); (+ mat2x3(-33.48, 52.93, -33.93, -4590.4915, 60.95, 77.68)))
        {
         bvec3 _GLF_SWITCH_3_2v, _GLF_SWITCH_3_3v;
         while(true)
          {
           -1.4;
           clamp((vec2(67.02, 1.1) * mat4x2(949.023, -6.5, 278.048, -9.8, 70.47, 3.2, 7153.0245, 8073.8320)), 68.45, -6657.5520);
           mat2(mat4(66.71, 3385.3890, -909.739, -76.23, 71.37, -9.2, -4.0, 5.5, 345.571, 4.3, 23.48, 2.7, 4663.6203, -7.6, -6.6, -93.97));
           if(_GLF_DEAD(false))
            return;
          }
         if((mat2x4(-3.6, -45.71, -3.2, 0.6, 1.0, -51.34, -1.7, -0.1) == mat2x4(-34.48, 5707.1698, -9.0, 1.9, -1934.7838, 32.77, 944.423, -5715.4962)))
          {
           mat3x2 _GLF_SWITCH_3_4v, _GLF_SWITCH_3_5v[88];
           uvec2 _GLF_SWITCH_3_6v[93], _GLF_SWITCH_3_7v, _GLF_SWITCH_3_8v;
           mat2 _GLF_SWITCH_3_9v;
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               return;
              }
             else
              {
              }
            }
           uvec3(120951u, 105395u, 76082u);
           vec2(-4.4, 1.5);
           float _GLF_SWITCH_3_10v, _GLF_SWITCH_3_11v[50];
           _GLF_SWITCH_3_7v;
           ;
           uvec3(28231u, 153788u, 46964u);
           if(_GLF_DEAD(false))
            break;
          }
         if((bvec3(true, false, false)).p)
          {
           mat2x4 _GLF_SWITCH_3_12v;
           uvec2 _GLF_SWITCH_3_13v;
           vec4(-2.5, 612.296, 4.3, -609.964).w;
           bvec2(false, true);
           uvec4(123590u, 186916u, 189027u, 139635u);
           if(_GLF_DEAD(false))
            return;
           bvec4(true, false, false, true);
           mat3 _GLF_SWITCH_3_14v, _GLF_SWITCH_3_15v, _GLF_SWITCH_3_16v;
           bool _GLF_SWITCH_3_17v, _GLF_SWITCH_3_18v[4], _GLF_SWITCH_3_19v;
          }
         else
          {
          }
         if(true)
          {
           mat4x3(8.8);
           mat3x2((mat4(4716.3426, 876.877, 43.61, 3.7, -9.6, 5.7, -87.05, -7.7, -7.6, -93.07, -45.36, -6.4, -9831.1483, -211.913, 805.807, -4.4) + mat4(4.5, 1433.1923, 9.5, 79.82, 31.80, 89.48, -2.7, 92.13, -6.3, -0.1, 6.0, 6.3, -1772.2270, 608.590, 0.9, -8.6)));
           ;
           exp2(vec3(317.277, -3.0, -2.6));
           ;
          }
         do
          {
          }
         while(false);
         mat2x4 _GLF_SWITCH_3_20v, _GLF_SWITCH_3_21v;
         mat4x2(mat3x4(51.04, 70.74, 269.252, -67.81, 57.49, -79.57, -765.886, 60.53, 2.8, 11.20, 5.3, -8.6));
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
          {
           ivec4(39094, -35734, -8852, -2950);
          }
        }
       if(_GLF_DEAD(false))
        {
         do
          {
           return;
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
        }
       case 6:
       if(_GLF_DEAD(false))
        {
         for(int _injected_loop_counter = (1 ^ _GLF_IDENTITY(1, (1) >> 0)); _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), ~ (~ (int(2)))))) >> _GLF_IDENTITY(int(2), int(2)))); _injected_loop_counter ++)
          {
           return;
          }
        }
       if(false)
        {
         bvec3(false, true, false);
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, bool(bvec4(false, false, true, false))))))))
          return;
         -57196;
         ivec3 _GLF_SWITCH_3_22v;
         for(ivec4 _GLF_SWITCH_3_23v; true; lessThan(vec4(849.543, 57.87, -5202.9431, -7.0), vec4(4907.8662, 72.72, -0.5, -2993.1947)))
          {
           ivec2(32959, -69710);
           mat4x2(-59.16, 6785.6774, 0.9, 7.4, -286.077, -4.0, -3276.3923, -67.05);
           vec4 _GLF_SWITCH_3_24v[29], _GLF_SWITCH_3_25v;
           ivec4 _GLF_SWITCH_3_26v;
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             (-3671.5729 / acosh(acosh(vec3(-705.779, -6.9, 8156.1485))));
            }
           else
            {
            }
           mat4x2 _GLF_SWITCH_3_27v, _GLF_SWITCH_3_28v, _GLF_SWITCH_3_29v;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           ;
           mat2x4(5.7, 7.8, 0.5, 3.6, 8.6, -74.74, -7497.3791, 18.73);
           (bvec3(true, true, true));
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         lessThan(tan(injectionSwitch), vec2(-14.06, -243.814));
         ivec4 _GLF_SWITCH_3_30v, _GLF_SWITCH_3_31v;
        }
       case 0:
       case 57:
       case 16:
       case 27:
       case 88:
       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, false)))))
        return;
       case 79:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       case 69:
       if(_GLF_DEAD(false))
        return;
       case 89:
       case 83:
       case 29:
       return;
       break;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       case 45:
       (uvec4(17618u, 171313u, 192147u, 54041u) & uvec4(156172u, 164584u, 131994u, 58494u));
       default:
       1;
      }
    }
  }
 if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, false || (false))))
  {
  }
 else
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, true && (false)), true && (_GLF_IDENTITY(false, bool(bvec4(false, false, true, false)))))))
    {
     if(_GLF_DEAD(false))
      return;
     return;
    }
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(false))
      barrier();
    }
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     return;
    }
  }
 uint read = atomicLoad(buf[virtual_gid], 4, 64, 0);
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
     if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || false))))))
      {
       if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, true && (false))))
        {
        }
       else
        {
         return;
        }
      }
     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
      {
       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
        }
       else
        {
         barrier();
        }
      }
    }
   else
    {
     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
      }
     else
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, bool(bvec4(false, false, true, false))))))))
        barrier();
      }
     atomicStore(checker[virtual_gid], read, 4, _GLF_IDENTITY(_GLF_IDENTITY(64, 0 ^ (64)), _GLF_IDENTITY((_GLF_IDENTITY(_GLF_IDENTITY(64, (64) - 0), 0 ^ (64))), int(int((_GLF_IDENTITY(_GLF_IDENTITY(64, (64) - 0), 0 ^ (64)))))) << 0), 4);
    }
  }
 if(_GLF_DEAD(false))
  return;
}
