#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 do
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     barrier();
    }
  }
 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
 do
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, clamp(_GLF_IDENTITY(injectionSwitch, (true ? injectionSwitch : _GLF_FUZZED(mat2(1609.9134, -496.336, 2012.2988, -63.86)[0]))), injectionSwitch, injectionSwitch)).x > injectionSwitch.y))))
        break;
       barrier();
      }
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY(1, max(1, 1))); _injected_loop_counter ++)
        {
         if(_GLF_DEAD(false))
          barrier();
         barrier();
        }
       if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
        barrier();
      }
     else
      {
      }
    }
   if(_GLF_DEAD(false))
    {
     switch(_GLF_SWITCH(((_GLF_IDENTITY(0, 0 ^ (0)) | 0) >> _GLF_IDENTITY(int(7), int(7)))))
      {
       case 69:
       if(_GLF_DEAD(false))
        barrier();
       mat3x2(-40.32, -7.1, 5385.6261, -95.83, 205.690, 9484.7355);
       case 88:
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          barrier();
         for(         (- mat4(394.443, 141.844, 6330.2418, 8.9, 73.46, -694.829, -81.97, -37.71, 5017.0806, -2.0, -3.9, 1.4, -5.3, -53.62, 1092.9134, 9.7));
 true; equal(uvec4(124930u, 75802u, 143975u, 4389u), (uvec4(133602u, 170008u, 84479u, 185517u) ^ uvec4(187743u, 129187u, 123015u, 160556u))))
          {
           if(_GLF_DEAD(false))
            barrier();
           ;
           64326;
           ;
           if(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(false), ! (! (_GLF_WRAPPED_IF_FALSE(false)))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           else
            {
             if((bvec4(true, true, true, false) != bvec4(true, true, false, false)))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 6939u;
                }
               else
                {
                }
               vec3 _GLF_SWITCH_4_0v;
               (mat4(-58.99, 928.756, 7497.1682, -2.1, 113.123, 4.8, -72.00, 5.8, 3859.0278, 299.281, -8.9, -0.0, 817.362, -31.95, 34.06, -3039.8191) == (mat3x4(-2716.0781, 33.67, -2.6, 649.000, 5183.5769, -9285.5090, -935.104, 4944.1497, 9.6, 898.704, -760.244, 2407.1225) * mat4x3(41.90, 3843.1800, 6.0, 761.051, -836.146, -940.086, 315.790, -99.81, -652.959, 56.86, 675.640, -5655.4228)));
               if(_GLF_DEAD(false))
                continue;
               vec4(1361.2294, 328.610, -400.779, -8.7);
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
             else
              {
               vec3 _GLF_SWITCH_4_1v, _GLF_SWITCH_4_2v[7];
               bvec3(false, true, false);
              }
            }
           if(_GLF_DEAD(false))
            return;
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             do
              {
               switch(_GLF_SWITCH(0))
                {
                 case 41:
                 ((36044u ^ 173465u) + uvec2(198217u, 150760u));
                 case 51:
                 mat4(48.20, 5.7, 317.134, _GLF_IDENTITY(57.38, mix(float(57.38), float(_GLF_FUZZED(-739.587)), bool(false))), 9268.3277, -1892.9594, 57.87, -8451.3019, 7.5, -1.2, -8866.0574, 3.1, 86.50, 3.2, 8117.7387, -57.11);
                 case 0:
                 case 21:
                 case 84:
                 case 77:
                 mat3x2(-98.52, -7037.2521, 56.29, _GLF_IDENTITY(537.478, mix(float(537.478), float(_GLF_FUZZED((8.9))), bool(false))), 6.5, 2966.6150);
                 case 67:
                 case 78:
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                   if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                    {
                     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                      barrier();
                     return;
                    }
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   unpackSnorm4x8(7617u);
                   if(_GLF_DEAD(false))
                    barrier();
                  }
                 for(int _injected_loop_counter = (((0 << _GLF_IDENTITY(int(4), int(4))) << _GLF_IDENTITY(int(7), int(7))) << _GLF_IDENTITY(int(1), int(1))); _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                  {
                   ivec3(36844, ivec4(83200, -83513, 34758, -60496).s, -6606);
                  }
                 case 28:
                 case 33:
                 if(_GLF_DEAD(false))
                  barrier();
                 case 92:
                 uvec2 _GLF_SWITCH_4_3v;
                 break;
                 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                  barrier();
                 default:
                 1;
                }
              }
             while((false && (mat3x4(-7.3, -533.259, -20.85, -3.3, -3443.3149, -171.021, -522.028, 2967.5617, -5.9, 0.5, 9.3, -345.764) == mat3x4(92.58, -8484.9088, 5748.6316, -3.9, -3.5, 39.24, -57.41, -0.8, 3968.4382, 58.07, -53.72, -77.36))));
            }
           else
            {
            }
           bvec2 _GLF_SWITCH_4_4v[73];
           {
            if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
             barrier();
            vec3 _GLF_SWITCH_4_5v, _GLF_SWITCH_4_6v, _GLF_SWITCH_4_7v[93];
            vec4(51.11, -5.0, -20.52, -75.99);
            mat3(6.0, -9.7, 3.7, -0.6, -4849.6364, -5026.4117, -1.8, -1.8, 68.50);
            do
             {
              ;
             }
            while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           }
           {
            do
             {
              switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
               {
                case 0:
                case 22:
                case 12:
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 barrier();
                case 75:
                case 70:
                case 21:
                115832u;
                break;
                case 97:
                ivec2(-43793, 3945);
                default:
                1;
               }
             }
            while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, bool(bool(false)))));
            if(_GLF_DEAD(false))
             continue;
            mat3x2 _GLF_SWITCH_4_8v[7];
            vec4 _GLF_SWITCH_4_9v[7], _GLF_SWITCH_4_10v;
            ;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            uvec2(152545u, 191516u);
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
           }
          }
        }
       else
        {
        }
       case 0:
       case 8:
       case 50:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       case 85:
       case 25:
       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec4(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false, true, false)))))
        barrier();
       case 56:
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, _GLF_IDENTITY(bool(bvec2(injectionSwitch.x > injectionSwitch.y, true)), ! (! (bool(bvec2(injectionSwitch.x > injectionSwitch.y, true))))))))))
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
          {
           barrier();
          }
        }
       case 14:
       case 60:
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          continue;
         barrier();
        }
       case 49:
       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, ! (! (false))), ! (_GLF_IDENTITY(! (false), ! (! (! (false))))))))
        continue;
       barrier();
       break;
       case 61:
       lessThanEqual(ivec4(-65395, 40887, 8363, 69002), ivec4(-42140, 31670, 19311, -70489));
       default:
       1;
      }
    }
   if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      break;
     continue;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
  }
 while(_GLF_WRAPPED_LOOP(false));
 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
  {
   switch(_GLF_SWITCH(0))
    {
     case 56:
     bitCount((34188 * 714));
     case 0:
     case 46:
     case 40:
     if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, ! (! (injectionSwitch.x > injectionSwitch.y)))) || false)))))
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true && (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
          barrier();
         barrier();
        }
       barrier();
       if(_GLF_DEAD(false))
        barrier();
      }
     case 39:
     if(_GLF_DEAD(false))
      barrier();
     case 44:
     if(_GLF_DEAD(false))
      barrier();
     case 33:
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
      {
       return;
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         barrier();
        }
      }
     else
      {
       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (_GLF_IDENTITY(! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bool(bvec3(! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), true, true)))))))
        barrier();
      }
     break;
     case 94:
     mat3 _GLF_SWITCH_4_0v;
     case 99:
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(true)
        {
         if(true)
          {
           if(_GLF_DEAD(false))
            barrier();
           (mat2x4(-38.56, -2.4, -9.5, 7686.5797, -7.9, -53.87, -0.4, -9.7));
           uvec3 _GLF_SWITCH_4_1v;
          }
         else
          {
           if(_GLF_DEAD(false))
            return;
           uvec2 _GLF_SWITCH_4_2v;
           while(true)
            {
             if(_GLF_DEAD(false))
              return;
             mat3 _GLF_SWITCH_4_3v, _GLF_SWITCH_4_4v, _GLF_SWITCH_4_5v;
             bvec4 _GLF_SWITCH_4_6v, _GLF_SWITCH_4_7v, _GLF_SWITCH_4_8v;
             _GLF_IDENTITY((mat4(5259.0374, -1.2, 19.32, -57.85, _GLF_IDENTITY(4.3, max(4.3, 4.3)), -1633.3686, 5.5, 75.40, 1.0, -4.0, 39.73, -0.8, -1.3, -3.6, 7657.2990, 766.124) + mat4(9.5, -6.2, -0.0, -30.64, -3.8, 7210.1401, 81.24, 9.3, 4388.2720, 98.10, -6435.6618, -3.7, -52.23, 2.1, 8.8, 64.35)), (true ? (mat4(5259.0374, -1.2, 19.32, -57.85, _GLF_IDENTITY(4.3, max(4.3, 4.3)), -1633.3686, 5.5, 75.40, 1.0, -4.0, 39.73, -0.8, -1.3, -3.6, 7657.2990, 766.124) + mat4(9.5, -6.2, -0.0, -30.64, -3.8, 7210.1401, 81.24, 9.3, 4388.2720, 98.10, -6435.6618, -3.7, -52.23, 2.1, 8.8, 64.35)) : _GLF_FUZZED(mat4(10.46, -325.932, -9.8, -560.560, -9.8, -0.4, 5215.7025, 70.35, 2520.4283, -915.696, 89.18, 5.8, 6717.5803, 2528.6830, -7752.0532, 472.665))));
             vec3(9.2, -35.31, 8.7).zz;
            }
           int _GLF_SWITCH_4_9v;
           bvec2 _GLF_SWITCH_4_10v, _GLF_SWITCH_4_11v[62], _GLF_SWITCH_4_12v[67];
           mat4x3(6.7, 1699.0085, -1.2, 3.2, _GLF_IDENTITY(-14.98, min(_GLF_IDENTITY(-14.98, max(-14.98, -14.98)), _GLF_IDENTITY(-14.98, clamp(-14.98, -14.98, -14.98)))), 9.2, 7951.1193, 5.7, 966.576, -805.180, 5.6, 19.68);
          }
        }
      }
     else
      {
      }
     default:
     1;
    }
  }
 uint subgroup_id = gl_SubgroupID;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, (false) && true), (_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) * 1.0) > injectionSwitch.y))))
  return;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, (false ? _GLF_FUZZED((injectionSwitch + -58.76)) : injectionSwitch)).y))))
  {
   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
    {
     barrier();
    }
   else
    {
    }
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         switch(_GLF_SWITCH(0))
          {
           case 16:
           if(_GLF_DEAD(false))
            barrier();
           uvec3 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v[66], _GLF_SWITCH_5_2v;
           if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, (false) || false), (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           case 71:
           if(false)
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, false || (injectionSwitch.x > injectionSwitch.y))))))
              barrier();
             mat2x3(-6.4, 1.7, -417.766, 6.3, 80.12, 60.37);
             uvec3 _GLF_SWITCH_5_3v;
             while(true)
              {
               while(false)
                {
                 bvec4 _GLF_SWITCH_5_4v, _GLF_SWITCH_5_5v;
                 vec2 _GLF_SWITCH_5_6v, _GLF_SWITCH_5_7v[20];
                }
               if(_GLF_DEAD(false))
                barrier();
               bvec2(false, false);
               ivec3 _GLF_SWITCH_5_8v;
               for(mat4x2 _GLF_SWITCH_5_9v; true; mat2x4(-6.0, -0.0, 6.8, 1.9, -633.748, -3.9, -2063.2957, -4.7))
                {
                }
               if(false)
                {
                 (+ mat4(90.18, -785.972, -548.565, -94.31, 3088.8006, 21.41, -92.22, 485.393, -4.1, -1593.4218, 560.516, -7199.6918, -8.5, 3297.4438, 1323.0979, 3.6));
                 if(_GLF_DEAD(false))
                  barrier();
                 0.2;
                 mat2x4 _GLF_SWITCH_5_10v, _GLF_SWITCH_5_11v[65];
                 uvec4(uvec2(44905u, 21700u), uvec2(52879u, 136203u));
                 bvec3 _GLF_SWITCH_5_12v, _GLF_SWITCH_5_13v;
                 mat3x4(_GLF_SWITCH_5_10v);
                 if(_GLF_DEAD(false))
                  barrier();
                 bitCount(15966);
                 mat4x2 _GLF_SWITCH_5_14v, _GLF_SWITCH_5_15v, _GLF_SWITCH_5_16v;
                 if(_GLF_DEAD(false))
                  barrier();
                }
               else
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 ivec4 _GLF_SWITCH_5_17v, _GLF_SWITCH_5_18v[85];
                 mat4(-4.4, -2.8, 5646.5281, 6.3, 2.9, 7820.0136, 1.8, 9.1, -68.83, -488.118, 2645.5862, 8.6, -7.0, -1.1, 3.0, 523.981);
                 ;
                 mat2x3 _GLF_SWITCH_5_19v, _GLF_SWITCH_5_20v, _GLF_SWITCH_5_21v;
                 mat2(-387.343, -3.6, -6.3, 76.69);
                }
               for(bool _GLF_SWITCH_5_22v; _GLF_SWITCH_5_22v; (- vec3(-4820.0033, 5.8, -3672.9670)))
                {
                 if(_GLF_IDENTITY(_GLF_DEAD(false), false || (_GLF_DEAD(false))))
                  barrier();
                 float _GLF_SWITCH_5_23v;
                 lessThanEqual(vec3(35.62, -3.0, 9655.0074), vec3(37.10, -570.440, 98.17));
                 float _GLF_SWITCH_5_24v, _GLF_SWITCH_5_25v[70], _GLF_SWITCH_5_26v;
                 mat4x2((+ mat3(-8.3, 192.077, 9.3, 4293.1876, 1.2, 9.5, -80.84, -817.995, -7308.5762)));
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                }
               if(_GLF_DEAD(false))
                barrier();
              }
             do
              {
               if(isinf(82.33))
                {
                 outerProduct(vec4(-1844.0679, -1.0, 32.33, 8.8), vec4(3.4, -2.8, -9613.2871, -3.6));
                }
               while((false))
                {
                 uint _GLF_SWITCH_5_27v;
                 ivec3 _GLF_SWITCH_5_28v[19];
                 bvec2(true, _GLF_IDENTITY(false, true && (false)));
                 mat2x4(94.43, 2.2, 5400.7760, 51.83, _GLF_IDENTITY(-785.763, mix(float(-785.763), float(_GLF_FUZZED(-3532.1568)), bool(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), 0.5, -892.645, -3.9);
                 ;
                 vec2 _GLF_SWITCH_5_29v, _GLF_SWITCH_5_30v;
                 ;
                 ;
                }
               bvec2(_GLF_IDENTITY(false, (false) && true), false);
               while(true)
                {
                 -4.5;
                 uvec2 _GLF_SWITCH_5_31v;
                 mat2x4(665.704, -646.681, 1.8, -1768.7543, -4.9, -587.851, -38.64, -9.2);
                 ;
                 ;
                 ;
                 vec3 _GLF_SWITCH_5_32v[90], _GLF_SWITCH_5_33v, _GLF_SWITCH_5_34v;
                 if(_GLF_DEAD(false))
                  barrier();
                 bvec4 _GLF_SWITCH_5_35v;
                 mat3x4 _GLF_SWITCH_5_36v;
                }
              }
             while(bool(subgroup_id));
             if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bool(false), ! (! (bool(false))))))))
              barrier();
            }
           else
            {
             ;
             if(_GLF_IDENTITY(_GLF_DEAD(false), _GLF_IDENTITY(bool(bvec3(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))), true, true)), true && (bool(bvec3(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))), true, true))))))
              barrier();
             int _GLF_SWITCH_5_37v[70], _GLF_SWITCH_5_38v;
             while(false)
              {
              }
             if(_GLF_DEAD(false))
              barrier();
             bvec3 _GLF_SWITCH_5_39v, _GLF_SWITCH_5_40v, _GLF_SWITCH_5_41v;
             uvec2 _GLF_SWITCH_5_42v[56], _GLF_SWITCH_5_43v, _GLF_SWITCH_5_44v;
             uvec4 _GLF_SWITCH_5_45v, _GLF_SWITCH_5_46v, _GLF_SWITCH_5_47v;
             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, max(_GLF_IDENTITY(injectionSwitch.x, max(_GLF_IDENTITY(injectionSwitch.x, 1.0 * (injectionSwitch.x)), _GLF_IDENTITY(injectionSwitch.x, min(injectionSwitch.x, injectionSwitch.x)))), _GLF_IDENTITY(injectionSwitch.x, min(injectionSwitch.x, injectionSwitch.x)))) > injectionSwitch.y))))
              barrier();
             for(             (_GLF_SWITCH_5_0v / _GLF_SWITCH_5_0v);
 (180471u < atomicCompSwap(_GLF_SWITCH_5_44v.t, subgroup_id, subgroup_id)); mat2x4(mat3x4(3.2, -25.28, -40.85, -7.4, -14.73, 49.52, 6.6, _GLF_IDENTITY(-3954.2421, clamp(-3954.2421, -3954.2421, -3954.2421)), 1.6, 5.4, 779.736, 904.760)[2], vec4(8.0, 473.757, -2540.2652, 6638.8496)))
              {
               ;
               if(_GLF_DEAD(false))
                barrier();
               mat3 _GLF_SWITCH_5_48v;
               if((mat3x4(206.925, 2.6, -525.066, 943.509, -484.584, -8.0, -34.66, -1342.5662, -41.23, -512.114, -549.148, -7.6) != mat3x4(-144.232, -36.88, -83.72, 366.624, 4053.6105, -7020.5171, -4.4, 477.515, -1.4, 5138.8012, -74.94, -416.052)))
                {
                 mat3x4 _GLF_SWITCH_5_49v[3];
                 bool _GLF_SWITCH_5_50v[66];
                 vec2 _GLF_SWITCH_5_51v;
                 if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
                  barrier();
                 mat3 _GLF_SWITCH_5_52v, _GLF_SWITCH_5_53v;
                 if(_GLF_DEAD(false))
                  barrier();
                 ivec4(52964, 35399, -83562, -56019);
                 mat3x2(mat4(-9.9, 2.1, 42.26, -5536.0883, -2960.9274, -206.307, 227.358, 1.9, 6.5, -0.3, -769.217, 16.20, 83.75, -9580.5597, -3.6, -6.2));
                 mat4x3 _GLF_SWITCH_5_54v;
                 uint _GLF_SWITCH_5_55v;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               ;
               mat2x4 _GLF_SWITCH_5_56v, _GLF_SWITCH_5_57v, _GLF_SWITCH_5_58v;
              }
             for(             uvec4(68349u, 108137u, 148132u, 123760u);
 false; (51550u + uvec2(43689u, 184834u)))
              {
               for(bvec4 _GLF_SWITCH_5_59v, _GLF_SWITCH_5_60v; (vec3(-12.41, -8886.0055, 228.404) == vec3(-5054.3501, 25.53, -3.6)); mat3x4(198.399, 372.202, 1814.3513, 938.983, -70.83, _GLF_IDENTITY(-808.787, clamp(-808.787, _GLF_IDENTITY(-808.787, max(-808.787, -808.787)), -808.787)), 2.9, 4883.8939, 5993.7499, -3.7, 461.535, -3.9))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 vec3 _GLF_SWITCH_5_61v;
                 uint _GLF_SWITCH_5_62v, _GLF_SWITCH_5_63v[81];
                 greaterThan(ivec3(56162, -30392, 85387), ivec3(-18586, 59689, 79261));
                 (+ mat3x4(9.6, 3.5, -501.667, 61.05, 891.924, -38.70, 2.5, 509.688, -1.7, 9.3, 6526.9286, 3.7));
                 mat3 _GLF_SWITCH_5_64v, _GLF_SWITCH_5_65v[61];
                 matrixCompMult(mat2x4(-89.35, -22.62, 491.879, -9.8, 0.5, -6.9, -6.3, 1.5), mat2x4(5.9, -3.1, _GLF_IDENTITY(417.683, clamp(417.683, 417.683, 417.683)), 287.505, -9923.4444, -545.081, -3.4, -7.1));
                 false;
                }
               bool _GLF_SWITCH_5_66v;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               sign(-11936);
               while(true)
                {
                 mat2(-1.3, -8.7, -35.99, -50.33);
                 float _GLF_SWITCH_5_67v, _GLF_SWITCH_5_68v[65], _GLF_SWITCH_5_69v;
                 ivec4(-38281, -61652, 7323, 25740);
                 inversesqrt(injectionSwitch);
                 mat2 _GLF_SWITCH_5_70v;
                 vec2(-0.9, 4.3);
                 ivec4(-97842, 62824, -10753, -74996);
                }
              }
            }
           if(_GLF_DEAD(false))
            barrier();
           case 0:
           if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, bool(bool(injectionSwitch.x > injectionSwitch.y)))))))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               barrier();
              }
            }
           break;
           default:
           1;
           if(_GLF_DEAD(false))
            barrier();
          }
        }
       return;
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = ((((1 << _GLF_IDENTITY(int(_GLF_IDENTITY(1, (1) + 0)), int(1))) >> _GLF_IDENTITY(int(1), _GLF_IDENTITY(_GLF_IDENTITY(int(_GLF_IDENTITY(1, (_GLF_IDENTITY(1, min(_GLF_IDENTITY(1, (1) | 0), 1))) + (0 >> _GLF_IDENTITY(int(3), _GLF_IDENTITY(int(3), 0 | (int(3))))))), 0 | (int(_GLF_IDENTITY(1, (_GLF_IDENTITY(1, min(_GLF_IDENTITY(1, (1) | 0), 1))) + (0 >> _GLF_IDENTITY(int(3), _GLF_IDENTITY(int(3), 0 | (int(3))))))))), ~ (~ (int(1)))))) << _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), ~ (_GLF_IDENTITY(~ (int(2)), (~ (int(2))) | 0))))) >> _GLF_IDENTITY(int(2), int(2))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
              {
               if(_GLF_DEAD(false))
                barrier();
               do
                {
                 switch(_GLF_SWITCH(0))
                  {
                   case 17:
                   if(_GLF_DEAD(false))
                    barrier();
                   ;
                   if(_GLF_DEAD(false))
                    barrier();
                   case 0:
                   case 56:
                   case 61:
                   case 87:
                   case 72:
                   case 64:
                   case 35:
                   case 51:
                   case 80:
                   case 29:
                   barrier();
                   break;
                   case 73:
                   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
                    barrier();
                   ivec4(63594, 31629, 32619, 57898);
                   case 54:
                   injectionSwitch;
                   default:
                   1;
                  }
                }
               while(_GLF_WRAPPED_LOOP(false));
               if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, ! (! (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, ! (! (injectionSwitch.x > injectionSwitch.y))))))))))
                barrier();
              }
            }
          }
         else
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(false))
          barrier();
        }
       else
        {
        }
      }
     for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
      {
       if(_GLF_IDENTITY(_GLF_DEAD(false), bool(bvec4(_GLF_DEAD(false), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))))
        barrier();
       if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     barrier();
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        {
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
          {
           barrier();
          }
         if(_GLF_DEAD(false))
          barrier();
        }
       barrier();
      }
    }
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
      barrier();
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      barrier();
     barrier();
    }
   do
    {
     barrier();
    }
   while(_GLF_WRAPPED_LOOP(false));
   if(_GLF_DEAD(false))
    barrier();
  }
 if(_GLF_DEAD(false))
  barrier();
 uint subgroup_size = gl_SubgroupSize;
 if(_GLF_DEAD(false))
  {
   do
    {
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec4(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, _GLF_IDENTITY(true, ! (! (true))), true)))))
      barrier();
    }
   while(_GLF_WRAPPED_LOOP(false));
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       return;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     barrier();
    }
   if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, bool(bvec3(false, false, true)))) && true)))
    return;
   barrier();
   if(_GLF_DEAD(false))
    barrier();
  }
 if(_GLF_DEAD(false))
  {
   switch(_GLF_SWITCH(0))
    {
     case 51:
     if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), true && (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_IDENTITY(! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))), true && (! (! _GLF_IDENTITY((_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (_GLF_IDENTITY(! (_GLF_IDENTITY((_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ((_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))) && true)), ! (! (! (_GLF_IDENTITY((_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ((_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))) && true)))))))))))))))
      barrier();
     for(bvec4 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v, _GLF_SWITCH_5_2v[67]; false; (mat4x3(mat2(-8.7, 19.84, 2803.8018, -0.6)) , mat4x3(788.875, 3283.1024, 4.3, -576.271, 83.22, -4.4, 43.49, 3706.9278, -2682.4794, -6866.0205, 661.815, 4.7)))
      {
       if(_GLF_DEAD(false))
        barrier();
       {
        for(        false;
 false; (ivec4(34205, 61743, -48316, -14356) - (87352 % -847)))
         {
          mat4(vec4(749.855, -3403.5241, -3.8, -6.6), mat4(-8.2, 773.628, 6208.4489, 992.435, 8195.1638, -6531.2742, -1.7, -115.987, 300.674, 6.4, 0.0, 1626.5756, _GLF_IDENTITY(66.14, _GLF_IDENTITY(float(mat2(66.14, 0.0, 1.0, 1.0)), float(mat4(float(mat2(66.14, 0.0, 1.0, 1.0)), 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0)))), 62.54, -9589.2717, 290.898)[2], smoothstep(vec4(2.4, -7898.6625, -17.73, -6.6), vec4(-4.9, 7.2, 7.3, 7527.3369), vec4(-56.95, -4.4, 4508.6601, -830.141)), vec4(0.7, -1.8, -89.58, 6.6));
          mat4 _GLF_SWITCH_5_3v;
          mat3x2 _GLF_SWITCH_5_4v;
          uint _GLF_SWITCH_5_5v, _GLF_SWITCH_5_6v[8];
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           barrier();
          bvec2 _GLF_SWITCH_5_7v, _GLF_SWITCH_5_8v, _GLF_SWITCH_5_9v;
         }
        bvec3 _GLF_SWITCH_5_10v, _GLF_SWITCH_5_11v[80], _GLF_SWITCH_5_12v;
        if(_GLF_DEAD(false))
         barrier();
        ;
        uvec2(7331u, 31207u);
        uvec4(199594u, 49716u, 96087u, 154995u);
        if(true)
         {
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           barrier();
          mat3 _GLF_SWITCH_5_13v[85], _GLF_SWITCH_5_14v[87];
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           barrier();
          (ivec3(27752, -1619, 56340) >> ivec3(-31685, -58746, -572));
          mat2x3(mat4(969.557, -7842.2500, 8638.6720, 0.6, 1.8, -5662.7308, _GLF_IDENTITY(-70.61, max(-70.61, -70.61)), -344.740, -74.66, _GLF_IDENTITY(-417.898, max(-417.898, -417.898)), 51.05, -3.2, -39.28, -10.70, 4592.0385, 5.9));
          ivec3(-29861, -14272, -10121);
          bvec4 _GLF_SWITCH_5_15v, _GLF_SWITCH_5_16v;
          true;
         }
       }
      }
     case 0:
     if(_GLF_DEAD(false))
      barrier();
     case 26:
     if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, _GLF_IDENTITY(bool(bool(_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, bool(bvec3(injectionSwitch.x > injectionSwitch.y, true, false))))), bool(bvec4(bool(bool(_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, bool(bvec3(injectionSwitch.x > injectionSwitch.y, true, false))))), true, false, true))))))))
      return;
     return;
     break;
     default:
     1;
    }
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, (false) && _GLF_TRUE(_GLF_IDENTITY(true, (true) || false), (injectionSwitch.x < injectionSwitch.y)))))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
    }
   else
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       if(_GLF_DEAD(false))
        barrier();
       switch(_GLF_SWITCH((0 | (0 >> _GLF_IDENTITY(_GLF_IDENTITY(int(4), ~ (~ (int(4)))), int(4))))))
        {
         case 31:
         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.x, clamp(injectionSwitch.x, injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y, bool(bvec3(_GLF_IDENTITY(injectionSwitch.x, clamp(injectionSwitch.x, injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y, true, false)))))))
          barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               barrier();
               if(_GLF_DEAD(false))
                barrier();
              }
             else
              {
              }
            }
           return;
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          return;
         do
          {
           if(_GLF_DEAD(false))
            break;
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               barrier();
              }
             if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(false, true, true, false)))))
              continue;
            }
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
         for(int _injected_loop_counter = (0 ^ 0); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(false))
            return;
          }
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           while(false)
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
              barrier();
             (mat4x3(_GLF_IDENTITY(29.54, mix(float(_GLF_FUZZED(-381.566)), float(29.54), bool(true))), -8.2, -805.859, -61.85, _GLF_IDENTITY(3.1, _GLF_IDENTITY(float(vec2(3.1, 0.0)), _GLF_IDENTITY(max(float(vec2(3.1, 0.0)), float(vec2(3.1, 0.0))), (max(float(vec2(3.1, 0.0)), float(vec2(3.1, 0.0)))) - 0.0))), -7106.1944, -7.1, -6.7, -11.38, -891.989, 3.6, 26.44) != mat4x3(-611.500, -3.2, 29.78, -8918.7396, -43.55, 9.7, 45.36, 9.7, 28.80, -556.102, 9653.7070, 6.4));
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(false))
                barrier();
               barrier();
              }
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    continue;
                   return;
                  }
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                }
               else
                {
                }
              }
            }
          }
         else
          {
           switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
            {
             case 18:
             if(_GLF_DEAD(false))
              barrier();
             (injectionSwitch * 23.80);
             case 9:
             bvec3 _GLF_SWITCH_5_0v[60], _GLF_SWITCH_5_1v;
             case 0:
             case 54:
             case 43:
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
              return;
             break;
             case 14:
             while(false)
              {
               if(_GLF_DEAD(false))
                barrier();
               (mat2x4(25.41, 96.59, _GLF_IDENTITY(6.7, (6.7) * 1.0), -5.2, -6.8, _GLF_IDENTITY(2178.4534, (2178.4534) - 0.0), 7.8, 0.6) * mat2(20.49, 51.17, -4.8, -0.0));
               uvec2(167477u, 41649u);
               if(_GLF_DEAD(false))
                barrier();
              }
             case 97:
             mat2x3 _GLF_SWITCH_5_2v;
             default:
             1;
            }
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             barrier();
            }
           else
            {
            }
           if(_GLF_DEAD(false))
            return;
          }
         case 0:
         case 1:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
            {
             if(_GLF_DEAD(false))
              return;
             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
              }
             else
              {
               if(_GLF_IDENTITY(_GLF_DEAD(false), true && (_GLF_DEAD(false))))
                barrier();
               barrier();
              }
            }
          }
         case 90:
         case 69:
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
         case 75:
         for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(5), int(5))) >> _GLF_IDENTITY(int(5), _GLF_IDENTITY(int(5), (int(5)) | 0))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            barrier();
           do
            {
             barrier();
            }
           while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, true && (_GLF_IDENTITY(false, (false) || false)))));
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
         case 30:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         case 78:
         case 40:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, ! (! (true)))))
            {
             barrier();
             if(_GLF_DEAD(false))
              barrier();
            }
           else
            {
            }
          }
         if(_GLF_DEAD(false))
          barrier();
         case 67:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, true)))))
            return;
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
            {
             return;
            }
          }
         case 89:
         if(_GLF_DEAD(false))
          return;
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))
            barrier();
           barrier();
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             do
              {
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 barrier();
                }
               if(_GLF_DEAD(false))
                return;
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
            }
           else
            {
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           if(_GLF_DEAD(false))
            barrier();
          }
         do
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
          }
         while(_GLF_WRAPPED_LOOP(false));
         break;
         case 36:
         (_GLF_IDENTITY((mat3x2(-6.6, -3.9, -0.1, 0.7, -9963.4267, -4980.1693) != mat3x2(45.86, -3.4, -4.9, -764.816, -274.973, -8.0)), bool(bool((mat3x2(-6.6, -3.9, _GLF_IDENTITY(-0.1, (false ? _GLF_FUZZED(sinh(-463.514)) : _GLF_IDENTITY(-0.1, mix(float(-0.1), float(_GLF_FUZZED(1.7)), bool(false))))), 0.7, -9963.4267, -4980.1693) != mat3x2(45.86, -3.4, -4.9, -764.816, -274.973, -8.0))))) ? mat3x2(-5.8, -34.19, -199.904, _GLF_IDENTITY(3.8, max(3.8, 3.8)), -67.01, 1590.9046) : mat3x2(sin(vec2(841.212, 8.0)), injectionSwitch, reflect(vec2(-8447.4089, 3983.9502), injectionSwitch)));
         default:
         1;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
      }
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     if(_GLF_DEAD(false))
      barrier();
     barrier();
    }
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, false || (_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec3(false, false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bvec3(bvec4(bvec3(false, false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), true))))))), (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       return;
      }
     do
      {
       barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, min(injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y))))
        barrier();
      }
     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     return;
    }
   return;
   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (_GLF_IDENTITY(! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))))))
    return;
  }
 uint subgroup_local_id = gl_SubgroupInvocationID;
 if(_GLF_IDENTITY(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(_GLF_IDENTITY(bvec2(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false), bvec2(bvec3(bvec2(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (injectionSwitch.x > injectionSwitch.y) && true))), false), true)))))), true && (_GLF_IDENTITY(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(_GLF_IDENTITY(bvec2(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false), bvec2(bvec3(bvec2(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false), true)))))), (_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(_GLF_IDENTITY(bvec2(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false), bvec2(bvec3(bvec2(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false), true))))))) && true))))
  {
   if(_GLF_DEAD(false))
    barrier();
   return;
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.y, _GLF_IDENTITY(float(mat2x3(_GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y)), 0.0, _GLF_IDENTITY(dot(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0)), dot(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0))), 0.0, cos(0.0), 0.0)), max(float(mat2x3(_GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y)), 0.0, _GLF_IDENTITY(dot(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0)), dot(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0))), 0.0, cos(0.0), 0.0)), float(mat2x3(_GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y)), 0.0, _GLF_IDENTITY(dot(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0)), dot(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0))), 0.0, cos(0.0), 0.0))))), (false ? _GLF_FUZZED(76.52) : _GLF_IDENTITY(injectionSwitch.y, _GLF_IDENTITY(float(mat2x3(_GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y)), 0.0, _GLF_IDENTITY(dot(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0)), dot(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0))), 0.0, cos(0.0), 0.0)), max(float(mat2x3(_GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y)), 0.0, _GLF_IDENTITY(dot(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0)), dot(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0))), 0.0, cos(0.0), 0.0)), float(mat2x3(_GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y)), 0.0, _GLF_IDENTITY(dot(vec3(_GLF_IDENTITY(0.0, max(0.0, 0.0)), 0.0, 0.0), vec3(1.0, 1.0, 1.0)), dot(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0))), 0.0, cos(0.0), 0.0)))))))))))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       do
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
          barrier();
         do
          {
           barrier();
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
     barrier();
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_DEAD(false))
    {
     do
      {
       if(_GLF_DEAD(false))
        barrier();
       barrier();
       if(_GLF_DEAD(false))
        barrier();
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
   barrier();
  }
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(false))
      barrier();
     for(int _injected_loop_counter = 0; _GLF_IDENTITY(_GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))), (_GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y)))) || false); _injected_loop_counter ++)
      {
       switch(_GLF_SWITCH(0))
        {
         case 5:
         mat3x4 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v, _GLF_SWITCH_5_2v;
         case 0:
         case 96:
         case 29:
         case 10:
         case 30:
         case 83:
         case 97:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         case 6:
         if(_GLF_DEAD(false))
          barrier();
         case 20:
         case 77:
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           return;
          }
         break;
         default:
         1;
         if(_GLF_DEAD(false))
          barrier();
        }
      }
     if(_GLF_DEAD(false))
      barrier();
    }
  }
 else
  {
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (! (_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), bool(bvec4((injectionSwitch.x > injectionSwitch.y), true, false, false)))))))))
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(false, false, false, true)))))
    return;
   switch(_GLF_SWITCH((0 >> _GLF_IDENTITY(int(2), int(2)))))
    {
     case 0:
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              continue;
            }
           else
            {
             barrier();
            }
          }
        }
      }
     else
      {
      }
     do
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(_GLF_IDENTITY(1.0, min(_GLF_IDENTITY(1.0, (1.0) / 1.0), _GLF_IDENTITY(1.0, 0.0 + (1.0)))), injectionSwitch.y))); _injected_loop_counter ++)
          {
           barrier();
          }
        }
      }
     while(_GLF_WRAPPED_LOOP(false));
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     case 57:
     case 20:
     if(_GLF_DEAD(false))
      barrier();
     case 73:
     if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, (false) || false), (injectionSwitch.x > injectionSwitch.y))))
      {
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
        {
         barrier();
        }
      }
     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 | (1 ^ 0))); _injected_loop_counter ++)
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             return;
             if(_GLF_DEAD(false))
              barrier();
            }
          }
        }
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(false), false || (_GLF_WRAPPED_IF_FALSE(false))))
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
        }
       else
        {
         barrier();
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
          }
         else
          {
           if(_GLF_DEAD(false))
            return;
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
            {
             barrier();
            }
           if(_GLF_DEAD(false))
            barrier();
          }
        }
       if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
        barrier();
       if(_GLF_DEAD(false))
        barrier();
      }
     case 71:
     if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((_GLF_IDENTITY(injectionSwitch, clamp(_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)), _GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_IDENTITY((injectionSwitch)[0], float(mat4x2((injectionSwitch)[0], 1.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0))), _GLF_FUZZED(-3.2)), vec2(_GLF_FUZZED(-64.72), (injectionSwitch)[1]), bvec2(false, true))), _GLF_IDENTITY(injectionSwitch, min(injectionSwitch, _GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])))))).x > _GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y))), ((_GLF_IDENTITY(injectionSwitch, clamp(_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)), _GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_IDENTITY((injectionSwitch)[0], float(mat4x2((injectionSwitch)[0], 1.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0))), _GLF_FUZZED(-3.2)), vec2(_GLF_FUZZED(-64.72), (injectionSwitch)[1]), bvec2(false, true))), injectionSwitch)).x > injectionSwitch.y)) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))))
      {
       if(_GLF_DEAD(false))
        {
         do
          {
           return;
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
       if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, ! (! (false)))))
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       else
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_DEAD(false))
        return;
       barrier();
      }
     case 3:
     if(_GLF_DEAD(false))
      barrier();
     case 93:
     case 97:
     if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, min(_GLF_IDENTITY(injectionSwitch.y, max(injectionSwitch.y, injectionSwitch.y)), _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.y, 1.0 * (injectionSwitch.y)), clamp(_GLF_IDENTITY(injectionSwitch.y, 1.0 * (injectionSwitch.y)), _GLF_IDENTITY(injectionSwitch.y, 1.0 * (injectionSwitch.y)), _GLF_IDENTITY(injectionSwitch.y, 1.0 * (injectionSwitch.y)))))), (injectionSwitch.x > injectionSwitch.y) && true)))))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, clamp(injectionSwitch.x, injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y))))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           return;
          }
         else
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || _GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, (injectionSwitch) - sin(vec2(0.0, 0.0))).y)))))
          barrier();
        }
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, (_GLF_IDENTITY(injectionSwitch.y, (false ? _GLF_FUZZED(sin(2236.8121)) : injectionSwitch.y))) / 1.0)))))
          barrier();
         barrier();
        }
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), _GLF_IDENTITY((! (false)), bool(bool((! (false))))) && true)))))
        barrier();
       if(_GLF_DEAD(false))
        barrier();
       do
        {
         barrier();
        }
       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
       if(_GLF_DEAD(false))
        return;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(false))
      barrier();
     case 70:
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       switch(_GLF_SWITCH((_GLF_IDENTITY(69482 & 0, (69482 & 0) - 0))))
        {
         case 12:
         1.3;
         case 0:
         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, (_GLF_IDENTITY(injectionSwitch, (false ? _GLF_FUZZED(vec2(-12.78, 26.00)) : injectionSwitch))) - vec2(0.0, 0.0)).x > injectionSwitch.y))))
          barrier();
         case 91:
         case 67:
         if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, true)))))
          barrier();
         case 24:
         case 15:
         case 39:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, mix(float(injectionSwitch.y), float(_GLF_FUZZED(-2588.0564)), bool(false)))))))
          barrier();
         case 82:
         case 33:
         case 25:
         case 75:
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
          {
           barrier();
          }
         break;
         case 49:
         if(false)
          {
           bvec2(true, false);
           mat3x2(-304.720, 1.1, -7.8, 44.63, -367.071, 0.6);
           bvec3 _GLF_SWITCH_5_0v[90], _GLF_SWITCH_5_1v, _GLF_SWITCH_5_2v[3];
           ivec2(_GLF_IDENTITY(-41469, (_GLF_IDENTITY(-41469, 0 ^ (-41469))) ^ 0), 9319);
          }
         case 13:
         while(all(bvec3(true, false, true)))
          {
           for(ivec4 _GLF_SWITCH_5_3v, _GLF_SWITCH_5_4v, _GLF_SWITCH_5_5v; false; uvec3(148592u, 170940u, 171682u))
            {
             (((_GLF_IDENTITY(false, (false) && true) || true) ? mat3x4(-37.81, -9.9, 21.13, 635.717, 9.8, -7.9, -5.7, -7.7, -786.441, 7.8, -2859.8637, -3.9) : mat3x4(2.5, -724.387, 323.005, -7.1, -4.2, -9.6, 504.552, 0.7, -5.7, -6.8, 0.2, 9.1)) + transpose(mat4x3(0.5, -928.049, 2.9, 7.0, -883.458, -7330.9827, -80.33, -87.34, 39.62, 248.817, 9.9, 5.2)));
             vec3 _GLF_SWITCH_5_6v;
            }
           {
            if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
             barrier();
            mat3(-0.7, 1.8, -7.8, 6819.7624, 0.3, 2.9, 7.8, 8.6, 364.877);
            ;
            equal(bvec2(true, false), _GLF_IDENTITY(bvec2(true, true), _GLF_IDENTITY(bvec2(_GLF_IDENTITY(bvec3(bvec2(true, true), true), bvec3(bvec3(bvec3(bvec2(true, true), true))))), bvec2(_GLF_IDENTITY(bvec2(bvec2(_GLF_IDENTITY(bvec3(bvec2(true, true), true), bvec3(bvec3(bvec3(bvec2(true, true), true)))))), bvec2(bvec2(bvec2(bvec2(_GLF_IDENTITY(bvec3(bvec2(true, true), true), bvec3(bvec3(bvec3(bvec2(true, true), true)))))))))))));
            mat3x2 _GLF_SWITCH_5_7v, _GLF_SWITCH_5_8v;
            uvec4 _GLF_SWITCH_5_9v, _GLF_SWITCH_5_10v, _GLF_SWITCH_5_11v[79];
            false;
            vec3(-985.009, -43.78, 229.785);
            bvec3 _GLF_SWITCH_5_12v, _GLF_SWITCH_5_13v;
           }
          }
         default:
         1;
        }
      }
     if(_GLF_DEAD(false))
      barrier();
     return;
     break;
     case 24:
     if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, ! (! (_GLF_IDENTITY(true, ! (! (true))))))))
      {
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          return;
        }
      }
     else
      {
      }
     do
      {
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         do
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             barrier();
            }
          }
         while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) || false)));
        }
       else
        {
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false || (_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, min(injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y)))), bool(bool(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
          break;
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             barrier();
            }
          }
         return;
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_DEAD(false))
        barrier();
      }
     while(_GLF_WRAPPED_LOOP(false));
     ivec4 _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v, _GLF_SWITCH_2_2v;
     default:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) && (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))
        barrier();
       if(_GLF_DEAD(false))
        return;
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         1;
        }
       else
        {
        }
       if(_GLF_DEAD(false))
        barrier();
      }
     else
      {
      }
    }
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), false || (_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), false || ((injectionSwitch.x > injectionSwitch.y))))))))
    barrier();
  }
 if(_GLF_DEAD(false))
  barrier();
 uint num_workgroup = gl_NumWorkGroups.x;
 if(_GLF_DEAD(false))
  return;
 uint workgroup_size = _GLF_IDENTITY(gl_WorkGroupSize, uvec3(1u, 1u, 1u) * (gl_WorkGroupSize)).x;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  return;
 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), (_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), bool(bvec3((injectionSwitch.x > injectionSwitch.y), true, true)))) || false))))
  {
  }
 else
  {
   if(_GLF_DEAD(false))
    barrier();
  }
 for(int _injected_loop_counter = (0 | (0 | 0)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
  {
   if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
    {
     if(_GLF_DEAD(false))
      barrier();
     return;
    }
  }
 uint workgroup_id = gl_WorkGroupID.x;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, vec2(1.0, 1.0) * (_GLF_IDENTITY(injectionSwitch, vec2(1.0, 1.0) * (injectionSwitch)))).x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec4(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, _GLF_IDENTITY(true, ! (! (true))), true)))))
      barrier();
     return;
    }
   barrier();
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
    }
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, (true ? injectionSwitch : _GLF_FUZZED(vec2(9.7, 7.9)))).y))))
      barrier();
     do
      {
       switch(_GLF_SWITCH(0))
        {
         case 0:
         case 4:
         case 47:
         if(_GLF_DEAD(false))
          barrier();
         case 10:
         case 64:
         case 41:
         case 56:
         case 71:
         case 9:
         switch(_GLF_SWITCH((0 << _GLF_IDENTITY(int(2), int(2)))))
          {
           case 42:
           if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, (injectionSwitch) * mat2(1.0)).x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               break;
              }
             if(_GLF_DEAD(false))
              barrier();
             barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           if(_GLF_DEAD(false))
            barrier();
           bvec2 _GLF_SWITCH_0_0v[86], _GLF_SWITCH_0_1v, _GLF_SWITCH_0_2v[90];
           if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec3(false, true, false), bvec3(bvec4(bvec3(false, true, false), false)))))))
            return;
           case 0:
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(false))
                barrier();
               return;
              }
             if(_GLF_DEAD(false))
              barrier();
             barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(false))
                barrier();
               return;
              }
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(false))
                barrier();
               break;
              }
             if(_GLF_DEAD(false))
              return;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             break;
            }
           case 70:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            barrier();
           case 24:
           case 3:
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              continue;
             barrier();
             if(_GLF_DEAD(false))
              barrier();
            }
           case 21:
           case 87:
           if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
             barrier();
            }
           case 40:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, vec2(_GLF_IDENTITY(mat4(_GLF_IDENTITY(injectionSwitch, max(injectionSwitch, injectionSwitch)), 1.0, _GLF_IDENTITY(dot(vec2(1.0, round(length(normalize(1.0)))), vec2(determinant(mat3(0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)), 0.0)), dot(vec2(1.0, round(length(normalize(1.0)))), vec2(determinant(mat3(0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)), 0.0))), _GLF_IDENTITY(dot(vec4(0.0, 1.0, 0.0, 0.0), vec4(length(vec3(0.0, 0.0, 0.0)), 1.0, sqrt(0.0), 0.0)), dot(vec4(0.0, 1.0, 0.0, 0.0), vec4(length(vec3(0.0, 0.0, 0.0)), 1.0, sqrt(0.0), 0.0))), 1.0, 0.0, 1.0, determinant(mat4(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, abs(0.0), length(0.0), 0.0, 1.0, 0.0, 0.0, 0.0)), 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0), (true ? mat4(_GLF_IDENTITY(injectionSwitch, max(injectionSwitch, injectionSwitch)), 1.0, _GLF_IDENTITY(dot(vec2(1.0, round(length(normalize(1.0)))), vec2(determinant(mat3(0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)), 0.0)), dot(vec2(1.0, round(length(normalize(1.0)))), vec2(determinant(mat3(0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)), 0.0))), _GLF_IDENTITY(dot(vec4(0.0, 1.0, 0.0, 0.0), vec4(length(vec3(0.0, 0.0, 0.0)), 1.0, sqrt(0.0), 0.0)), dot(vec4(0.0, 1.0, 0.0, 0.0), vec4(length(vec3(0.0, 0.0, 0.0)), 1.0, sqrt(0.0), 0.0))), 1.0, 0.0, 1.0, determinant(mat4(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, abs(0.0), length(0.0), 0.0, 1.0, 0.0, 0.0, 0.0)), 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0) : _GLF_FUZZED(mat4(4.6, -84.99, 3.2, 78.23, 4.7, 17.35, 9304.0941, 9816.2576, -18.40, 4.6, -8.3, -5103.3449, -1.9, -997.882, -2.2, -24.18)))))).y))))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
             break;
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_IDENTITY(_GLF_DEAD(false), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (_GLF_DEAD(false))))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             break;
             if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, ! (! (false)))) && true)))
              barrier();
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               continue;
              }
            }
           case 5:
           case 16:
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
              {
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 continue;
                }
              }
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), int(1)))); _injected_loop_counter ++)
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, vec2(mat3x2(_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])), 1.0, 1.0, 0.0, _GLF_IDENTITY(dot(vec4(0.0, 1.0, 0.0, 0.0), vec4(0.0, 1.0, 0.0, 0.0)), dot(vec4(0.0, 1.0, 0.0, 0.0), vec4(0.0, 1.0, 0.0, 0.0)))))).x > injectionSwitch.y))))
                barrier();
              }
             do
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               barrier();
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, (_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(-3110.8425), (injectionSwitch)[1]), vec2((injectionSwitch)[0], _GLF_FUZZED(13.16)), bvec2(true, false))), (_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(-3110.8425), (injectionSwitch)[1]), vec2((injectionSwitch)[0], _GLF_FUZZED(13.16)), bvec2(true, false))), clamp(_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(-3110.8425), (injectionSwitch)[1]), vec2((injectionSwitch)[0], _GLF_FUZZED(13.16)), bvec2(true, false))), _GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(-3110.8425), (injectionSwitch)[1]), vec2((injectionSwitch)[0], _GLF_FUZZED(13.16)), bvec2(true, false))), _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(-3110.8425), (injectionSwitch)[1]), vec2((injectionSwitch)[0], _GLF_FUZZED(13.16)), bvec2(true, false))), (_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(-3110.8425), (injectionSwitch)[1]), vec2((injectionSwitch)[0], _GLF_FUZZED(13.16)), bvec2(true, false)))) - vec2(0.0, 0.0))))) / vec2(1.0, 1.0))) - vec2(0.0, 0.0)).x, clamp(_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY((_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(-3110.8425), (injectionSwitch)[1]), vec2((injectionSwitch)[0], _GLF_FUZZED(13.16)), bvec2(true, _GLF_IDENTITY(false, (false) && true))))) - vec2(0.0, 0.0), mix(vec2(((_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(-3110.8425), (injectionSwitch)[1]), vec2((injectionSwitch)[0], _GLF_FUZZED(13.16)), bvec2(true, _GLF_IDENTITY(false, (false) && true))))) - vec2(0.0, 0.0))[0], _GLF_FUZZED(-2.7)), vec2(_GLF_FUZZED(-9806.7777), ((_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(-3110.8425), (injectionSwitch)[1]), vec2((injectionSwitch)[0], _GLF_FUZZED(13.16)), bvec2(true, _GLF_IDENTITY(false, (false) && true))))) - vec2(0.0, 0.0))[1]), bvec2(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_IDENTITY(true, ! (! (true))))))).x, _GLF_IDENTITY(injectionSwitch, (_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(-3110.8425), (injectionSwitch)[1]), vec2((injectionSwitch)[0], _GLF_FUZZED(13.16)), bvec2(true, false)))) - vec2(0.0, 0.0)).x, _GLF_IDENTITY(injectionSwitch, (_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(-3110.8425), _GLF_IDENTITY((injectionSwitch), max(_GLF_IDENTITY((injectionSwitch), ((injectionSwitch)) / vec2(1.0, 1.0)), (injectionSwitch)))[1]), vec2((injectionSwitch)[0], _GLF_FUZZED(13.16)), bvec2(true, false)))) - vec2(0.0, 0.0)).x)) > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   barrier();
                  }
                 if(_GLF_DEAD(false))
                  barrier();
                }
               if(_GLF_DEAD(false))
                barrier();
              }
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
             barrier();
            }
           for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
            }
           for(int _injected_loop_counter = _GLF_IDENTITY((-78324 & 0), max(_GLF_IDENTITY((-78324 & 0), 0 | ((-78324 & 0))), _GLF_IDENTITY((-78324 & 0), ((-78324 & 0)) | ((-78324 & 0))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
            {
             switch(_GLF_SWITCH(_GLF_IDENTITY(0, (0) - 0)))
              {
               case 7:
               bitfieldReverse(_injected_loop_counter);
               case 83:
               smoothstep(vec3(39.20, -5788.9089, -5006.7361), vec3(_GLF_IDENTITY(2130.3982, (false ? _GLF_FUZZED(899.952) : 2130.3982)), -1.0, -1.8), vec3(0.0, 0.4, 9.2));
               case 0:
               case 5:
               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                }
               else
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
               break;
               case 12:
               vec3(0.3, -911.700, -0.4);
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               case 65:
               ;
               default:
               1;
              }
            }
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(false))
            barrier();
           return;
           if(_GLF_DEAD(false))
            barrier();
           break;
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               switch(_GLF_SWITCH(_GLF_IDENTITY(0, min(0, 0))))
                {
                 case 59:
                 bvec4(true, false, true, true);
                 case 8:
                 if(_GLF_DEAD(false))
                  barrier();
                 ivec4 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v, _GLF_SWITCH_5_2v[14];
                 case 0:
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 case 13:
                 case 63:
                 case 19:
                 if(_GLF_DEAD(false))
                  barrier();
                 case 22:
                 case 90:
                 case 73:
                 case 37:
                 case 27:
                 case 4:
                 barrier();
                 break;
                 case 46:
                 ivec2 _GLF_SWITCH_5_3v, _GLF_SWITCH_5_4v, _GLF_SWITCH_5_5v;
                 default:
                 if(_GLF_DEAD(false))
                  barrier();
                 1;
                }
               if(_GLF_DEAD(false))
                barrier();
              }
             else
              {
               if(_GLF_DEAD(false))
                barrier();
              }
            }
           case 34:
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_IDENTITY(_GLF_DEAD(false), _GLF_IDENTITY((_GLF_DEAD(false)) && true, true && ((_GLF_DEAD(false)) && true))))
            break;
           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              return;
             if(_GLF_DEAD(false))
              barrier();
             continue;
            }
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, (false ? _GLF_FUZZED(5.9) : _GLF_IDENTITY(injectionSwitch.y, max(injectionSwitch.y, injectionSwitch.y))))))))
                barrier();
               return;
              }
             continue;
            }
           if(_GLF_IDENTITY(_GLF_WRAPPED_IF_TRUE(true), ! (! (_GLF_WRAPPED_IF_TRUE(true)))))
            {
             if(_GLF_DEAD(false))
              break;
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
              {
               if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (false)), bool(bvec2(_GLF_IDENTITY(_GLF_IDENTITY(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (false)), (_GLF_IDENTITY(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (false))) || false), true)))))
                barrier();
               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(_GLF_IDENTITY(false, _GLF_IDENTITY((false) && _GLF_TRUE(true, (_GLF_IDENTITY(injectionSwitch.x < injectionSwitch.y, true && (injectionSwitch.x < injectionSwitch.y)))), ((false) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))) || false)), (injectionSwitch.x > injectionSwitch.y))))
                {
                }
               else
                {
                 do
                  {
                   while(false)
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      {
                       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, true)))))
                        {
                         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                          break;
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_DEAD(false))
                            barrier();
                           continue;
                          }
                         continue;
                        }
                       continue;
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(false))
                          barrier();
                         break;
                        }
                      }
                     if(_GLF_DEAD(false))
                      barrier();
                     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                      {
                       if(_GLF_DEAD(false))
                        barrier();
                       switch(_GLF_SWITCH(0))
                        {
                         case 50:
                         mat4x3(71.36, 8.9, 994.404, 37.07, -7829.4010, 6.1, -872.727, -9021.7103, 4185.6361, 7865.0356, -9.8, 5491.3912);
                         case 30:
                         mat4x3(mat2(18.67, -4.9, -85.99, 8339.3632));
                         case 0:
                         case 23:
                         if(_GLF_DEAD(false))
                          continue;
                         case 22:
                         if(_GLF_DEAD(false))
                          barrier();
                         case 51:
                         case 24:
                         case 54:
                         if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ! (! ((injectionSwitch.x > injectionSwitch.y)))))))
                          barrier();
                         if(_GLF_DEAD(false))
                          barrier();
                         break;
                         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, bool(bvec3(false, true, true))), true && (false))))
                          barrier();
                         case 28:
                         ivec3(-44951, -73123, 77081);
                         case 7:
                         if(_GLF_DEAD(false))
                          barrier();
                         (exp(vec3(-5659.0547, 56.49, -325.984)) * mat4x3(-6.6, 8.1, 17.55, 6.1, 76.70, 6733.3667, -2611.0783, 3.8, -8.5, -3.1, 5046.7769, 0.3));
                         default:
                         1;
                        }
                      }
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                     do
                      {
                       if(_GLF_DEAD(false))
                        barrier();
                      }
                     while(_GLF_WRAPPED_LOOP(false));
                     if(_GLF_IDENTITY(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))), (_GLF_DEAD(_GLF_IDENTITY(false, false || (false)))) || false))
                      {
                       if(_GLF_DEAD(false))
                        continue;
                       if(_GLF_IDENTITY(_GLF_DEAD(false), true && (_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), (! (false)) && true)))))))
                        {
                         if(_GLF_WRAPPED_IF_FALSE(false))
                          {
                          }
                         else
                          {
                           if(_GLF_DEAD(false))
                            barrier();
                           if(_GLF_DEAD(false))
                            barrier();
                          }
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bool(bool(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), false || (_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))))
                            barrier();
                           barrier();
                          }
                         if(_GLF_DEAD(false))
                          return;
                         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          {
                           if(_GLF_DEAD(false))
                            {
                             if(_GLF_DEAD(false))
                              {
                               if(_GLF_DEAD(false))
                                barrier();
                               if(_GLF_WRAPPED_IF_TRUE(true))
                                {
                                 switch(_GLF_SWITCH(0))
                                  {
                                   case 0:
                                   case 98:
                                   case 89:
                                   case 82:
                                   if(_GLF_DEAD(false))
                                    barrier();
                                   barrier();
                                   break;
                                   case 41:
                                   _injected_loop_counter;
                                   if(_GLF_DEAD(false))
                                    barrier();
                                   case 1:
                                   vec3 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v[86], _GLF_SWITCH_5_2v;
                                   default:
                                   1;
                                  }
                                }
                               else
                                {
                                 if(_GLF_DEAD(false))
                                  barrier();
                                }
                               if(_GLF_DEAD(false))
                                barrier();
                               if(_GLF_DEAD(false))
                                continue;
                              }
                             if(_GLF_DEAD(false))
                              {
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                break;
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                barrier();
                               continue;
                               if(_GLF_DEAD(false))
                                barrier();
                              }
                             break;
                             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, true && (injectionSwitch.x > injectionSwitch.y))))))
                              barrier();
                            }
                           if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, clamp(injectionSwitch, _GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)), injectionSwitch)).x > injectionSwitch.y))))
                            barrier();
                           if(_GLF_DEAD(false))
                            barrier();
                          }
                         else
                          {
                           switch(_GLF_SWITCH(0))
                            {
                             case 31:
                             ;
                             case 0:
                             if(_GLF_DEAD(false))
                              barrier();
                             case 91:
                             if(_GLF_DEAD(false))
                              barrier();
                             barrier();
                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              {
                               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 & 1)); _injected_loop_counter ++)
                                {
                                 do
                                  {
                                   if(_GLF_WRAPPED_IF_TRUE(true))
                                    {
                                     barrier();
                                    }
                                   else
                                    {
                                    }
                                  }
                                 while(_GLF_WRAPPED_LOOP(false));
                                }
                               if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true)))
                                barrier();
                              }
                             case 42:
                             if(_GLF_DEAD(false))
                              barrier();
                             do
                              {
                               for(int _injected_loop_counter = (((1 << _GLF_IDENTITY(int(5), _GLF_IDENTITY(int(5), (int(5)) - 0))) >> _GLF_IDENTITY(int(5), int(5))) ^ 0); _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 | 0)); _injected_loop_counter --)
                                {
                                 if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                                  {
                                   if(_GLF_DEAD(false))
                                    barrier();
                                   barrier();
                                  }
                                 if(_GLF_DEAD(false))
                                  break;
                                }
                              }
                             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                             break;
                             default:
                             1;
                            }
                          }
                        }
                       if(_GLF_DEAD(false))
                        barrier();
                       barrier();
                       if(_GLF_DEAD(false))
                        barrier();
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        return;
                       if(_GLF_IDENTITY(_GLF_DEAD(false), bool(bvec2(_GLF_DEAD(false), false))))
                        barrier();
                      }
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, ! (! (false)))));
                 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_DEAD(false))
                    return;
                   if(_GLF_DEAD(false))
                    barrier();
                  }
                 if(_GLF_DEAD(false))
                  break;
                }
              }
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (injectionSwitch.x > injectionSwitch.y) || false)))))
              break;
             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, (_GLF_IDENTITY(injectionSwitch.x, _GLF_IDENTITY(float(_GLF_IDENTITY(vec4(_GLF_IDENTITY(injectionSwitch.x, (false ? _GLF_FUZZED(1623.6436) : injectionSwitch.x)), 1.0, 0.0, 0.0), clamp(vec4(_GLF_IDENTITY(injectionSwitch.x, (false ? _GLF_FUZZED(1623.6436) : injectionSwitch.x)), 1.0, 0.0, 0.0), vec4(_GLF_IDENTITY(injectionSwitch.x, (false ? _GLF_FUZZED(1623.6436) : injectionSwitch.x)), 1.0, 0.0, 0.0), vec4(_GLF_IDENTITY(injectionSwitch.x, (false ? _GLF_FUZZED(1623.6436) : injectionSwitch.x)), 1.0, 0.0, 0.0)))), (float(_GLF_IDENTITY(_GLF_IDENTITY(vec4(_GLF_IDENTITY(injectionSwitch.x, (false ? _GLF_FUZZED(1623.6436) : _GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) - 0.0))), 1.0, 0.0, 0.0), clamp(vec4(_GLF_IDENTITY(injectionSwitch.x, (false ? _GLF_FUZZED(1623.6436) : _GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) - 0.0))), 1.0, 0.0, 0.0), vec4(_GLF_IDENTITY(injectionSwitch.x, (false ? _GLF_FUZZED(1623.6436) : _GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) - 0.0))), 1.0, 0.0, 0.0), vec4(_GLF_IDENTITY(injectionSwitch.x, (false ? _GLF_FUZZED(1623.6436) : _GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) - 0.0))), 1.0, 0.0, 0.0))), clamp(vec4(_GLF_IDENTITY(injectionSwitch.x, (false ? _GLF_FUZZED(1623.6436) : injectionSwitch.x)), _GLF_IDENTITY(1.0, min(_GLF_IDENTITY(1.0, 0.0 + (1.0)), 1.0)), 0.0, 0.0), vec4(_GLF_IDENTITY(injectionSwitch.x, (false ? _GLF_FUZZED(_GLF_IDENTITY(1623.6436, mix(float(_GLF_IDENTITY(1623.6436, max(1623.6436, 1623.6436))), float(_GLF_FUZZED(-962.355)), bool(false)))) : injectionSwitch.x)), 1.0, 0.0, 0.0), vec4(_GLF_IDENTITY(injectionSwitch.x, (false ? _GLF_FUZZED(1623.6436) : injectionSwitch.x)), 1.0, 0.0, 0.0))))) + 0.0))) + 0.0) > injectionSwitch.y))))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 do
                  {
                   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, min(_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])), _GLF_IDENTITY(injectionSwitch, (injectionSwitch) + vec2(0.0, 0.0)))).y))))
                    {
                    }
                   else
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     barrier();
                    }
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                }
               return;
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           else
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(false))
            {
             do
              {
               barrier();
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
            }
           case 41:
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || false)))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             do
              {
               barrier();
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(bvec3(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true)))))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                break;
               barrier();
              }
            }
           uvec4 _GLF_SWITCH_0_3v[81];
           if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, false || (true))))
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           else
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           default:
           1;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
              barrier();
             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, (injectionSwitch) - vec2(0.0, 0.0)).x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bool(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
                barrier();
              }
             else
              {
               barrier();
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, min(injectionSwitch, _GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)))).y))))
              barrier();
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               barrier();
              }
             else
              {
              }
            }
           if(_GLF_DEAD(false))
            barrier();
           do
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_DEAD(false))
                barrier();
               barrier();
              }
             else
              {
              }
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, _GLF_IDENTITY(! (! (false)), (! (! (false))) && true)))))))
              barrier();
             break;
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             barrier();
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, (true ? injectionSwitch.y : _GLF_FUZZED(-21.77))))), (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (_GLF_IDENTITY(! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), _GLF_IDENTITY(true, _GLF_IDENTITY(bool(bvec4(_GLF_IDENTITY(true, ! (! (true))), true, _GLF_IDENTITY(true, bool(bvec2(true, true))), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))), true && (bool(bvec4(_GLF_IDENTITY(true, ! (! (true))), true, _GLF_IDENTITY(true, bool(bvec2(true, true))), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))))) && (! (_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, ! (! (injectionSwitch.x > injectionSwitch.y)))) || false))))))))) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               barrier();
              }
             else
              {
              }
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(false))
            barrier();
          }
         break;
         if(_GLF_DEAD(false))
          barrier();
         default:
         if(_GLF_DEAD(false))
          return;
         1;
        }
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (injectionSwitch.x > injectionSwitch.y) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
          barrier();
        }
      }
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec3(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false), bvec3(bvec3(bvec3(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false))))))), false || (_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec3(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false), bvec3(bvec3(bvec3(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false))))))))))
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        return;
      }
     else
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bool(false), (bool(false)) && true)))))
          return;
        }
       else
        {
        }
       do
        {
         barrier();
        }
       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          return;
         return;
         if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), _GLF_IDENTITY(bool(bvec3(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true)), true && (bool(bvec3(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true))))))
          barrier();
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
      }
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       else
        {
         barrier();
        }
      }
    }
  }
 do
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, ! (! (injectionSwitch.x > injectionSwitch.y)))))))
    {
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       return;
      }
     else
      {
      }
    }
  }
 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
 if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, max(injectionSwitch, injectionSwitch)).x > injectionSwitch.y))), bool(_GLF_IDENTITY(bvec2(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, max(injectionSwitch, injectionSwitch)).x > injectionSwitch.y))), false), bvec2(bvec3(bvec2(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, max(injectionSwitch, injectionSwitch)).x > injectionSwitch.y))), false), false))))))
  {
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        return;
      }
    }
   do
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
    }
   while(_GLF_WRAPPED_LOOP(false));
   do
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     return;
     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), ! (! (! (false))))))))
      continue;
    }
   while(_GLF_WRAPPED_LOOP(false));
  }
 uint workgroup_base = workgroup_size * workgroup_id;
 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 << _GLF_IDENTITY(int(7), int(7)))); _injected_loop_counter --)
  {
   switch(_GLF_SWITCH(0))
    {
     case 0:
     if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (_GLF_IDENTITY(! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))) && true)))))
      {
       if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, bool(bvec4(_GLF_IDENTITY(true, bool(bvec4(true, _GLF_IDENTITY(false, true && (_GLF_IDENTITY(false, false || (false)))), true, false))), true, false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
          barrier();
         for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(8), int(8))); _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 & ((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), int(1))))); _injected_loop_counter ++)
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              return;
             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, false || (injectionSwitch.x > injectionSwitch.y))))))
              barrier();
            }
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           do
            {
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
            }
           while(_GLF_WRAPPED_LOOP(false));
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             continue;
            }
           barrier();
          }
         barrier();
         if(_GLF_DEAD(false))
          continue;
        }
       else
        {
        }
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         barrier();
        }
      }
     if(_GLF_IDENTITY(_GLF_DEAD(false), true && (_GLF_IDENTITY(_GLF_DEAD(false), bool(bvec4(_GLF_DEAD(false), false, false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))))))
      barrier();
     break;
     default:
     1;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
    }
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, false || (false))) && true), _GLF_IDENTITY(bool(_GLF_IDENTITY(bool(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, false || (false))) && true)), (bool(_GLF_IDENTITY(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, true && (_GLF_IDENTITY(false, true && (false))))) || false), (_GLF_IDENTITY(false, false || (false))) && true))) || false)), true && (bool(_GLF_IDENTITY(bool(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, false || (false))) && true)), (bool(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, false || (false))) && true))) || false))))), (_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec3(false, true, false)), bool(bool(bool(bvec3(false, true, _GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec4(false, _GLF_IDENTITY(true, (true) && true), true, true)), ! (! (bool(bvec4(false, true, true, true))))))))))))) || false)))
    barrier();
   return;
   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, true && (false)), _GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (true), false || (! (true))))) && (_GLF_IDENTITY(false, true && (false))))))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        return;
       barrier();
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     return;
     if(_GLF_DEAD(false))
      barrier();
    }
   if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
    return;
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bool(false), ! (! (bool(false))))))))
      return;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     barrier();
    }
   if(_GLF_DEAD(false))
    barrier();
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 do
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, max(injectionSwitch, injectionSwitch)).y))))
    barrier();
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    continue;
  }
 while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec4(false, true, false, true)), ! (! (bool(bvec4(false, true, false, true))))))));
 if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_IDENTITY(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, (false) || false)))), true && (_GLF_IDENTITY(false, (false) && true)))), false || (_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && true)))) || false))
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     barrier();
    }
   barrier();
   if(_GLF_DEAD(false))
    barrier();
  }
 if(_GLF_DEAD(false))
  barrier();
 uint virtual_gid = workgroup_base + subgroup_id * _GLF_IDENTITY(subgroup_size, (_GLF_IDENTITY(subgroup_size, 0u ^ (subgroup_size))) - (0u | 0u)) + subgroup_local_id;
 if(_GLF_DEAD(false))
  barrier();
 uint next_virtual_gid = _GLF_IDENTITY(workgroup_base + _GLF_IDENTITY(subgroup_id * subgroup_size, (true ? _GLF_IDENTITY(subgroup_id * subgroup_size, min(subgroup_id * subgroup_size, subgroup_id * subgroup_size)) : _GLF_FUZZED(subgroup_local_id))) + ((_GLF_IDENTITY(subgroup_local_id, (false ? _GLF_FUZZED(workgroup_size) : _GLF_IDENTITY(subgroup_local_id, (subgroup_local_id) | 0u))) + 1) % subgroup_size), _GLF_IDENTITY(clamp(_GLF_IDENTITY(_GLF_IDENTITY(workgroup_base, (workgroup_base) * 1u) + _GLF_IDENTITY(_GLF_IDENTITY(subgroup_id * subgroup_size, ~ (_GLF_IDENTITY(~ (subgroup_id * subgroup_size), ~ (~ (~ (subgroup_id * subgroup_size)))))), (_GLF_IDENTITY(_GLF_IDENTITY(subgroup_id * subgroup_size, clamp(subgroup_id * subgroup_size, subgroup_id * subgroup_size, _GLF_IDENTITY(subgroup_id * subgroup_size, clamp(subgroup_id * subgroup_size, subgroup_id * subgroup_size, subgroup_id * subgroup_size)))), ~ (_GLF_IDENTITY(~ (subgroup_id * subgroup_size), ~ (~ (~ (subgroup_id * subgroup_size))))))) * 1u) + (_GLF_IDENTITY((subgroup_local_id + 1), ~ (~ ((subgroup_local_id + 1)))) % subgroup_size), min(workgroup_base + subgroup_id * subgroup_size + ((_GLF_IDENTITY(subgroup_local_id + 1, (subgroup_local_id + 1) | 0u)) % subgroup_size), workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size))), _GLF_IDENTITY(workgroup_base + subgroup_id * subgroup_size + ((_GLF_IDENTITY(subgroup_local_id, (subgroup_local_id) / 1u) + 1) % subgroup_size), clamp(workgroup_base + subgroup_id * subgroup_size + (_GLF_IDENTITY(_GLF_IDENTITY((subgroup_local_id + 1), 0u | ((subgroup_local_id + 1))) % subgroup_size, ((subgroup_local_id + 1) % subgroup_size) | ((subgroup_local_id + 1) % subgroup_size))), workgroup_base + subgroup_id * subgroup_size + (_GLF_IDENTITY((subgroup_local_id + 1) % subgroup_size, ((subgroup_local_id + 1) % subgroup_size) ^ 0u)), workgroup_base + _GLF_IDENTITY(subgroup_id, 0u | (subgroup_id)) * subgroup_size + ((subgroup_local_id + 1) % subgroup_size))), _GLF_IDENTITY(workgroup_base + _GLF_IDENTITY(subgroup_id, 0u | (subgroup_id)) * subgroup_size + ((subgroup_local_id + _GLF_IDENTITY(1, ~ _GLF_IDENTITY((_GLF_IDENTITY(~ (_GLF_IDENTITY(1, _GLF_IDENTITY((1) ^ 0, ((1) ^ 0) >> 0))), 0 + (~ (_GLF_IDENTITY(1, (1) ^ 0))))), min((_GLF_IDENTITY(~ (_GLF_IDENTITY(1, _GLF_IDENTITY((1) ^ 0, ((1) ^ 0) >> 0))), 0 + (_GLF_IDENTITY(~ (_GLF_IDENTITY(1, (1) ^ 0)), (_GLF_IDENTITY(~ (_GLF_IDENTITY(1, (1) ^ 0)), (true ? ~ (_GLF_IDENTITY(1, (1) ^ 0)) : _GLF_FUZZED(63091)))) | 0)))), (_GLF_IDENTITY(~ (_GLF_IDENTITY(1, _GLF_IDENTITY((1) ^ 0, ((1) ^ 0) >> 0))), 0 + (~ (_GLF_IDENTITY(_GLF_IDENTITY(1, (1) ^ 0), (_GLF_IDENTITY(1, (1) ^ 0)) | 0))))))))) % subgroup_size), (workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size)) | (_GLF_IDENTITY(workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size), max(workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size), workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size)))))), min(clamp(_GLF_IDENTITY(_GLF_IDENTITY(workgroup_base, (workgroup_base) * 1u) + _GLF_IDENTITY(_GLF_IDENTITY(subgroup_id * subgroup_size, ~ (_GLF_IDENTITY(~ (subgroup_id * subgroup_size), ~ (~ (~ (subgroup_id * subgroup_size)))))), (_GLF_IDENTITY(_GLF_IDENTITY(subgroup_id * subgroup_size, clamp(subgroup_id * subgroup_size, subgroup_id * subgroup_size, _GLF_IDENTITY(subgroup_id * subgroup_size, clamp(subgroup_id * subgroup_size, subgroup_id * subgroup_size, subgroup_id * subgroup_size)))), ~ (_GLF_IDENTITY(~ (subgroup_id * subgroup_size), ~ (~ (~ (subgroup_id * subgroup_size))))))) * 1u) + (_GLF_IDENTITY((subgroup_local_id + 1), ~ (~ ((subgroup_local_id + 1)))) % subgroup_size), min(workgroup_base + subgroup_id * subgroup_size + ((_GLF_IDENTITY(subgroup_local_id + 1, (subgroup_local_id + 1) | 0u)) % subgroup_size), workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size))), _GLF_IDENTITY(workgroup_base + subgroup_id * subgroup_size + ((_GLF_IDENTITY(subgroup_local_id, (subgroup_local_id) / 1u) + 1) % subgroup_size), clamp(workgroup_base + subgroup_id * subgroup_size + (_GLF_IDENTITY(_GLF_IDENTITY((subgroup_local_id + 1), 0u | ((subgroup_local_id + 1))) % subgroup_size, ((subgroup_local_id + 1) % subgroup_size) | ((subgroup_local_id + 1) % subgroup_size))), workgroup_base + subgroup_id * subgroup_size + (_GLF_IDENTITY((subgroup_local_id + 1) % subgroup_size, ((subgroup_local_id + 1) % subgroup_size) ^ 0u)), workgroup_base + _GLF_IDENTITY(subgroup_id, 0u | (subgroup_id)) * subgroup_size + ((subgroup_local_id + 1) % subgroup_size))), _GLF_IDENTITY(workgroup_base + _GLF_IDENTITY(subgroup_id, 0u | (subgroup_id)) * subgroup_size + ((subgroup_local_id + _GLF_IDENTITY(1, ~ _GLF_IDENTITY((_GLF_IDENTITY(~ (_GLF_IDENTITY(1, _GLF_IDENTITY((1) ^ 0, ((1) ^ 0) >> 0))), 0 + (~ (_GLF_IDENTITY(1, (1) ^ 0))))), min((_GLF_IDENTITY(~ (_GLF_IDENTITY(1, _GLF_IDENTITY((1) ^ 0, ((1) ^ 0) >> 0))), 0 + (_GLF_IDENTITY(~ (_GLF_IDENTITY(1, (1) ^ 0)), (_GLF_IDENTITY(~ (_GLF_IDENTITY(1, (1) ^ 0)), (true ? ~ (_GLF_IDENTITY(1, (1) ^ 0)) : _GLF_FUZZED(63091)))) | 0)))), (_GLF_IDENTITY(~ (_GLF_IDENTITY(1, _GLF_IDENTITY((1) ^ 0, ((1) ^ 0) >> 0))), 0 + (~ (_GLF_IDENTITY(_GLF_IDENTITY(1, (1) ^ 0), (_GLF_IDENTITY(1, (1) ^ 0)) | 0))))))))) % subgroup_size), (workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size)) | (_GLF_IDENTITY(workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size), max(workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size), workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size)))))), clamp(_GLF_IDENTITY(_GLF_IDENTITY(workgroup_base, (workgroup_base) * 1u) + _GLF_IDENTITY(_GLF_IDENTITY(subgroup_id * subgroup_size, ~ (_GLF_IDENTITY(~ (subgroup_id * subgroup_size), ~ (~ (~ (subgroup_id * subgroup_size)))))), (_GLF_IDENTITY(_GLF_IDENTITY(subgroup_id * subgroup_size, clamp(subgroup_id * subgroup_size, subgroup_id * subgroup_size, _GLF_IDENTITY(subgroup_id * subgroup_size, clamp(subgroup_id * subgroup_size, subgroup_id * subgroup_size, subgroup_id * subgroup_size)))), ~ (_GLF_IDENTITY(~ (subgroup_id * subgroup_size), ~ (~ (~ (subgroup_id * subgroup_size))))))) * 1u) + (_GLF_IDENTITY((subgroup_local_id + 1), ~ (~ ((subgroup_local_id + 1)))) % subgroup_size), min(workgroup_base + subgroup_id * subgroup_size + ((_GLF_IDENTITY(subgroup_local_id + 1, (subgroup_local_id + 1) | 0u)) % subgroup_size), workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size))), _GLF_IDENTITY(workgroup_base + subgroup_id * subgroup_size + ((_GLF_IDENTITY(subgroup_local_id, (subgroup_local_id) / 1u) + 1) % subgroup_size), clamp(workgroup_base + subgroup_id * subgroup_size + (_GLF_IDENTITY(_GLF_IDENTITY((subgroup_local_id + 1), 0u | ((subgroup_local_id + 1))) % subgroup_size, ((subgroup_local_id + 1) % subgroup_size) | ((subgroup_local_id + 1) % subgroup_size))), workgroup_base + subgroup_id * subgroup_size + (_GLF_IDENTITY((subgroup_local_id + 1) % subgroup_size, ((subgroup_local_id + 1) % subgroup_size) ^ 0u)), workgroup_base + _GLF_IDENTITY(subgroup_id, 0u | (subgroup_id)) * subgroup_size + ((subgroup_local_id + 1) % subgroup_size))), _GLF_IDENTITY(workgroup_base + _GLF_IDENTITY(subgroup_id, 0u | (subgroup_id)) * subgroup_size + ((subgroup_local_id + _GLF_IDENTITY(1, ~ _GLF_IDENTITY((_GLF_IDENTITY(~ (_GLF_IDENTITY(1, _GLF_IDENTITY((1) ^ 0, ((1) ^ 0) >> 0))), 0 + (~ (_GLF_IDENTITY(1, (1) ^ 0))))), min((_GLF_IDENTITY(~ (_GLF_IDENTITY(1, _GLF_IDENTITY((1) ^ 0, ((1) ^ 0) >> 0))), 0 + (_GLF_IDENTITY(~ (_GLF_IDENTITY(1, (1) ^ 0)), (_GLF_IDENTITY(~ (_GLF_IDENTITY(1, (1) ^ 0)), (true ? ~ (_GLF_IDENTITY(1, (1) ^ 0)) : _GLF_FUZZED(63091)))) | 0)))), (_GLF_IDENTITY(~ (_GLF_IDENTITY(1, _GLF_IDENTITY((1) ^ 0, ((1) ^ 0) >> 0))), 0 + (~ (_GLF_IDENTITY(_GLF_IDENTITY(1, (1) ^ 0), (_GLF_IDENTITY(1, (1) ^ 0)) | 0))))))))) % subgroup_size), (workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size)) | (_GLF_IDENTITY(workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size), max(workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size), workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size)))))))));
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    return;
  }
 else
  {
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, float(mat2x3(injectionSwitch.y, _GLF_IDENTITY(dot(vec4(1.0, 0.0, 0.0, determinant(mat4(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0))), vec4(1.0, 0.0, 0.0, 0.0)), dot(vec4(1.0, 0.0, 0.0, determinant(mat4(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0))), vec4(1.0, 0.0, 0.0, 0.0))), 0.0, 0.0, 0.0, abs(1.0))))))))
  return;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   do
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(false))
      continue;
     atomicStore(buf[virtual_gid], uint(1), 4, 64, 4);
    }
   while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
  }
 else
  {
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   return;
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_IDENTITY(subgroup_local_id, min(subgroup_local_id, subgroup_local_id)) + 1 < subgroup_size)
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
        barrier();
       barrier();
      }
     barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
    }
   if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && true))
    return;
   switch(_GLF_SWITCH(0))
    {
     case 0:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, clamp(_GLF_IDENTITY(injectionSwitch, vec2(_GLF_IDENTITY(vec4(injectionSwitch, 1.0, 0.0), clamp(vec4(injectionSwitch, 1.0, 0.0), vec4(injectionSwitch, 1.0, 0.0), vec4(injectionSwitch, 1.0, 0.0))))), injectionSwitch, injectionSwitch)).y))))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       do
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          return;
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              return;
            }
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          {
           switch(_GLF_SWITCH(0))
            {
             case 39:
             {
              vec2 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v, _GLF_SWITCH_5_2v[71];
              uvec4(139835u, 125917u, 121393u, 65441u);
              mat2 _GLF_SWITCH_5_3v, _GLF_SWITCH_5_4v;
             }
             case 0:
             if(_GLF_DEAD(false))
              barrier();
             case 12:
             case 32:
             do
              {
               barrier();
               if(_GLF_DEAD(false))
                barrier();
              }
             while(_GLF_WRAPPED_LOOP(false));
             break;
             default:
             1;
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         barrier();
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, (injectionSwitch) * vec2(1.0, 1.0)).x > injectionSwitch.y)))))))
            barrier();
           do
            {
             if(_GLF_DEAD(false))
              return;
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(false))
        return;
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (_GLF_IDENTITY(injectionSwitch.x < injectionSwitch.y, false || (_GLF_IDENTITY(injectionSwitch.x < injectionSwitch.y, bool(bvec2(injectionSwitch.x < injectionSwitch.y, true)))))))))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true), true && (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)).x > injectionSwitch.y))) && true)))))
          barrier();
         if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bool(false)), false || (bool(bool(false)))))))
          return;
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(_GLF_IDENTITY(false, true && (false)), false, false, false)))))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, ! (! (false)))) && true)))
              return;
             barrier();
            }
           barrier();
          }
         if(_GLF_DEAD(false))
          barrier();
        }
       else
        {
        }
       if(_GLF_DEAD(false))
        return;
       barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
          return;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, injectionSwitch.y, injectionSwitch.y))))))
          barrier();
         barrier();
        }
      }
     if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
      barrier();
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      {
       switch(_GLF_SWITCH(0))
        {
         case 98:
         do
          {
           if((mat3(_GLF_IDENTITY(-4.9, (false ? _GLF_FUZZED(-1974.8348) : _GLF_IDENTITY(-4.9, float(vec2(-4.9, 1.0))))), -2118.4188, -4.2, 2.0, 66.97, 72.71, -5341.6741, -8.6, -2370.0105) != mat3(-61.59, -90.30, -8439.2546, -64.65, 4.5, 91.84, 5809.6298, 9998.5979, -809.210)))
            {
             do
              {
               switch(_GLF_SWITCH(0))
                {
                 case 6:
                 mat2 _GLF_SWITCH_5_0v[1];
                 case 3:
                 mat3x4(step(dot(vec3(-587.051, -5.6, -5.1), vec3(1479.8615, 9.6, 7711.3119)), determinant(mat3(-2319.7584, 762.743, -1.8, -1.9, -4.5, -8.2, -5.8, 8632.4201, -837.732))));
                 case 0:
                 case 99:
                 case 48:
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 case 93:
                 case 30:
                 if(_GLF_DEAD(false))
                  barrier();
                 case 11:
                 uvec3(26623u, _GLF_IDENTITY(103712u, max(_GLF_IDENTITY(103712u, (_GLF_IDENTITY(103712u, min(103712u, 103712u))) | (103712u)), _GLF_IDENTITY(103712u, min(103712u, 103712u)))), 154240u);
                 break;
                 default:
                 1;
                 if(_GLF_DEAD(false))
                  barrier();
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
             mat2 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v[68];
             (injectionSwitch != vec2(-932.556, -414.510));
             (_GLF_SWITCH_4_0v - _GLF_SWITCH_4_0v);
             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (injectionSwitch.x > injectionSwitch.y) && true)))))
              barrier();
            }
           else
            {
             mat3x2(-3674.6669, 32.05, -5.2, -1090.5310, 289.259, 57.41);
             mat2x3 _GLF_SWITCH_4_2v[23];
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(3), int(3))) >> _GLF_IDENTITY(int(3), _GLF_IDENTITY(int(3), (_GLF_IDENTITY(int(3), (int(3)) << 0)) / 1))); _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
              {
               ;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               mat4(5205.3057, -48.98, -63.46, -58.01, 4276.1568, -5.8, -960.561, 8744.9421, 3.0, -4434.0347, 9.9, 62.63, -668.016, -335.596, -80.82, -3.1);
              }
             else
              {
               if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                barrier();
              }
             pow(reflect(vec2(-2.7, -9.9), injectionSwitch), vec2(1197.5166, -655.105));
            }
          }
         while(_GLF_WRAPPED_LOOP(false));
         if(_GLF_DEAD(false))
          barrier();
         case 73:
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          return;
         if(false)
          {
          }
         case 0:
         case 80:
         case 27:
         case 69:
         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, _GLF_IDENTITY(float(mat4x3(injectionSwitch.x, 1.0, 0.0, _GLF_ONE(1.0, injectionSwitch.y), 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), _GLF_ONE(1.0, injectionSwitch.y), 1.0, 1.0, 1.0)), (false ? _GLF_FUZZED(mix(-9347.5249, 1.5, -847.326)) : float(mat4x3(injectionSwitch.x, 1.0, 0.0, _GLF_ONE(1.0, injectionSwitch.y), 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), _GLF_ONE(1.0, injectionSwitch.y), 1.0, 1.0, 1.0))))) > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            return;
           return;
           if(_GLF_DEAD(false))
            barrier();
          }
         case 78:
         case 19:
         case 26:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_DEAD(false))
          return;
         barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         break;
         case 14:
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), int(0)))); _injected_loop_counter ++)
          {
           if(false)
            {
             ;
             mat3 _GLF_SWITCH_4_3v;
             uvec4(35034u, 60327u, 45245u, 150552u);
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             do
              {
               mat4x2(5.5, 1.1, 2509.4218, -4474.7519, 5.5, 3.5, -992.398, -24.59);
              }
             while(_GLF_WRAPPED_LOOP(false));
             bvec4 _GLF_SWITCH_4_4v, _GLF_SWITCH_4_5v[34], _GLF_SWITCH_4_6v[45];
             bvec2(true, false);
            }
           else
            {
             if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              return;
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
              barrier();
             bool _GLF_SWITCH_4_7v[77];
             ;
             if(_GLF_DEAD(false))
              barrier();
             ;
             if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, false || (true))))
              {
               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 & 1)); _injected_loop_counter ++)
                {
                 mat3x4(-7.4);
                 if(_GLF_DEAD(false))
                  barrier();
                }
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(false))
                barrier();
              }
             else
              {
              }
             if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, bool(bvec2(true, true)))))
              {
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(false))
                barrier();
               mat2(-2292.9244, 95.44, -0.9, 38.62);
              }
             else
              {
              }
             if(_GLF_DEAD(false))
              barrier();
             mat3x2 _GLF_SWITCH_4_8v, _GLF_SWITCH_4_9v, _GLF_SWITCH_4_10v[35];
             if(_GLF_DEAD(false))
              barrier();
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
              {
               false;
              }
             _GLF_IDENTITY(uvec4(32498u, _GLF_IDENTITY(19809u, clamp(19809u, 19809u, 19809u)), 63817u, 91256u), (uvec4(32498u, _GLF_IDENTITY(19809u, clamp(19809u, 19809u, 19809u)), 63817u, 91256u)) - (uvec4(0u, 0u, 0u, 0u) >> _GLF_IDENTITY(uvec4(2u), uvec4(2u))));
             if(_GLF_DEAD(false))
              barrier();
            }
          }
         default:
         for(int _injected_loop_counter = _GLF_IDENTITY(0, (0) | (0)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _GLF_IDENTITY(_injected_loop_counter ++, (_GLF_IDENTITY(_injected_loop_counter ++, ~ (~ (_injected_loop_counter ++)))) >> 0))
          {
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           1;
          }
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       switch(_GLF_SWITCH(0))
        {
         case 29:
         while(false)
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, false || (true))))
            {
             -1435;
            }
           else
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
            }
           else
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             ;
            }
           int _GLF_SWITCH_4_0v[48], _GLF_SWITCH_4_1v, _GLF_SWITCH_4_2v;
           uint _GLF_SWITCH_4_3v;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           uvec2 _GLF_SWITCH_4_4v, _GLF_SWITCH_4_5v[60], _GLF_SWITCH_4_6v;
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
            barrier();
          }
         case 99:
         if(_GLF_DEAD(false))
          barrier();
         ivec4(43441, -82119, -50574, -8269);
         case 0:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         case 64:
         if(_GLF_DEAD(false))
          barrier();
         case 49:
         if(_GLF_DEAD(false))
          return;
         case 4:
         if(_GLF_DEAD(false))
          return;
         case 34:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         case 47:
         barrier();
         break;
         case 87:
         vec3(-44.59, 8000.4759, 893.899);
         case 12:
         if((injectionSwitch != (vec2(-59.30, 564.517) + floor(_GLF_IDENTITY(vec2(616.436, 965.406), (vec2(616.436, 965.406)) / vec2(1.0, 1.0))))))
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
           mat3x4 _GLF_SWITCH_4_7v[71];
          }
         default:
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(_GLF_IDENTITY(false, true && (false)), (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           1;
          }
        }
       if(_GLF_DEAD(false))
        barrier();
      }
     if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
      barrier();
     if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_IDENTITY(false, ! (! (false))), (_GLF_IDENTITY(false, (false) && _GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (true), (! (true)) && true))))) && true), (_GLF_IDENTITY(false, _GLF_IDENTITY((_GLF_IDENTITY(false, (false) && _GLF_IDENTITY(true, false || (true)))), true && ((_GLF_IDENTITY(false, (false) && _GLF_IDENTITY(true, false || (true)))))) && true)) || false)))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         barrier();
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, (injectionSwitch.y) + tan(0.0))))))
        barrier();
       do
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         barrier();
        }
       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
      }
     case 53:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
      }
     else
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
        barrier();
      }
     int i = 0;
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       return;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
      {
       switch(_GLF_SWITCH(0))
        {
         case 43:
         ;
         case 76:
         mat3 _GLF_SWITCH_4_0v[68];
         case 0:
         case 36:
         case 42:
         switch(_GLF_SWITCH(_GLF_IDENTITY(int(_GLF_ZERO(0.0, _GLF_IDENTITY(injectionSwitch, clamp(injectionSwitch, injectionSwitch, injectionSwitch)).x)), (int(_GLF_ZERO(0.0, injectionSwitch.x))) | 0)))
          {
           case 0:
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           case 36:
           case 9:
           case 8:
           if(_GLF_DEAD(false))
            continue;
           case 45:
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(false))
            break;
           atomicStore(buf[next_virtual_gid], uint(2), 4, 64, 4);
           break;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             continue;
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(mat2(1.0) * (injectionSwitch), max(mat2(1.0) * (injectionSwitch), mat2(1.0) * (injectionSwitch)))).y))))
            barrier();
           case 65:
           if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && true)) && true))
            {
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               barrier();
              }
             else
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 continue;
                }
               if(_GLF_DEAD(false))
                barrier();
              }
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             switch(_GLF_SWITCH(0))
              {
               case 80:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(3), int(3))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                  {
                   barrier();
                  }
                }
               uvec3 _GLF_SWITCH_3_0v;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               case 48:
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                return;
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                  {
                   if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                    {
                     do
                      {
                       if(_GLF_DEAD(false))
                        barrier();
                       barrier();
                       if(_GLF_DEAD(false))
                        barrier();
                      }
                     while(_GLF_WRAPPED_LOOP(false));
                    }
                   if(_GLF_DEAD(false))
                    barrier();
                   barrier();
                  }
                }
               bvec3 _GLF_SWITCH_3_1v, _GLF_SWITCH_3_2v;
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
               else
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
               if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ((injectionSwitch.x > injectionSwitch.y)) && true))))
                {
                 if(_GLF_DEAD(false))
                  {
                   for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(8), int(8))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                    {
                     return;
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                  }
                 if(_GLF_DEAD(false))
                  {
                   do
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     if(_GLF_WRAPPED_IF_TRUE(true))
                      {
                       if(_GLF_IDENTITY(_GLF_DEAD(false), bool(_GLF_IDENTITY(bvec3(_GLF_DEAD(false), true, true), bvec3(bvec3(bvec3(_GLF_DEAD(false), true, true)))))))
                        barrier();
                       barrier();
                      }
                     else
                      {
                      }
                    }
                   while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, bool(bvec4(false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), true)))));
                  }
                 barrier();
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, vec2(mat4x3(injectionSwitch, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, sqrt(0.0), 1.0, 1.0, 0.0))).y))))
                  barrier();
                }
               case 0:
               case 20:
               if(_GLF_IDENTITY(_GLF_WRAPPED_IF_TRUE(true), ! (! (_GLF_WRAPPED_IF_TRUE(true)))))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).x > injectionSwitch.y))))
                  barrier();
                }
               else
                {
                }
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, clamp(injectionSwitch.x, _GLF_IDENTITY(injectionSwitch.x, 1.0 * (injectionSwitch.x)), injectionSwitch.x)) > injectionSwitch.y))))
                    continue;
                   barrier();
                   if(_GLF_DEAD(false))
                    barrier();
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                  }
                }
               case 36:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 do
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    break;
                   barrier();
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                }
               case 67:
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 break;
                }
               if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && true))
                {
                 switch(_GLF_SWITCH(0))
                  {
                   case 25:
                   bvec4 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v, _GLF_SWITCH_5_2v;
                   case 64:
                   vec3 _GLF_SWITCH_5_3v[32], _GLF_SWITCH_5_4v[84];
                   case 0:
                   case 44:
                   if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, ! (! (false)))) && true)))
                    barrier();
                   case 98:
                   case 94:
                   if(_GLF_DEAD(false))
                    barrier();
                   case 48:
                   case 54:
                   case 93:
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                    }
                   else
                    {
                     barrier();
                    }
                   break;
                   case 81:
                   ivec3(47064, -61445, -85664);
                   case 74:
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                   isinf(vec4(-6.6, -5.5, 0.7, 9.1));
                   default:
                   1;
                  }
                }
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec2(false, true), bvec2(_GLF_IDENTITY(bvec2(bvec2(false, true)), bvec2(_GLF_IDENTITY(bvec2(bvec2(bvec2(false, true))), bvec2(bvec3(bvec2(bvec2(bvec2(false, true))), false)))))))))))
                  return;
                 if(_GLF_DEAD(false))
                  return;
                 if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && true))
                  barrier();
                 barrier();
                }
               case 37:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, mix(float(_GLF_FUZZED(919.474)), float(injectionSwitch.y), bool(true)))))))
                return;
               if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(true, false || (true)) && (_GLF_IDENTITY(false, ! (! (false)))))))
                continue;
               case 50:
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 continue;
                }
               case 74:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
               return;
               if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                barrier();
               break;
               case 64:
               (mat3(-7.3, 7.3, _GLF_IDENTITY(_GLF_IDENTITY(-2189.3443, float(_GLF_IDENTITY(mat4x2(-2189.3443, 0.0, 1.0, abs(0.0), cos(0.0), _GLF_ZERO(0.0, injectionSwitch.x), 0.0, 0.0), transpose(transpose(_GLF_IDENTITY(mat4x2(-2189.3443, 0.0, 1.0, abs(0.0), cos(0.0), _GLF_ZERO(0.0, injectionSwitch.x), 0.0, 0.0), (true ? mat4x2(-2189.3443, 0.0, 1.0, abs(0.0), cos(0.0), _GLF_ZERO(0.0, _GLF_IDENTITY(injectionSwitch, (injectionSwitch) * mat2(1.0)).x), 0.0, 0.0) : _GLF_FUZZED(mat4x2(2.0, -4248.8696, 6.5, -27.99, 284.860, -4.6, -347.868, -610.730))))))))), 0.0 + (_GLF_IDENTITY(-2189.3443, float(_GLF_IDENTITY(mat4x2(-2189.3443, 0.0, 1.0, abs(0.0), cos(0.0), _GLF_ZERO(0.0, injectionSwitch.x), 0.0, 0.0), transpose(transpose(_GLF_IDENTITY(mat4x2(-2189.3443, 0.0, 1.0, abs(0.0), cos(0.0), _GLF_ZERO(0.0, injectionSwitch.x), 0.0, 0.0), (true ? mat4x2(-2189.3443, 0.0, 1.0, abs(0.0), cos(0.0), _GLF_ZERO(0.0, injectionSwitch.x), 0.0, 0.0) : _GLF_FUZZED(mat4x2(2.0, -4248.8696, 6.5, -27.99, 284.860, -4.6, -347.868, -610.730))))))))))), 29.81, -511.616, 747.899, -8483.2198, -2.8, -602.240) - -7.2);
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
               else
                {
                }
               default:
               do
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                  {
                   switch(_GLF_SWITCH((int(_GLF_ZERO(0.0, injectionSwitch.x)) | 0)))
                    {
                     case 52:
                     uint _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v;
                     case 0:
                     do
                      {
                       if(_GLF_WRAPPED_IF_TRUE(true))
                        {
                         barrier();
                         if(_GLF_DEAD(false))
                          barrier();
                        }
                       else
                        {
                        }
                       if(_GLF_DEAD(false))
                        barrier();
                      }
                     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                     break;
                     default:
                     1;
                    }
                  }
                }
               while(_GLF_WRAPPED_LOOP(false));
               if(_GLF_DEAD(false))
                barrier();
               1;
              }
            }
           if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], _GLF_FUZZED(362.960)), vec2(_GLF_FUZZED((false ? 449.385 : -6.7)), (injectionSwitch)[1]), bvec2(false, true))).y), ((injectionSwitch.x > injectionSwitch.y)) || false))))
            continue;
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, _GLF_IDENTITY(bool(bvec2(injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, clamp(_GLF_IDENTITY(injectionSwitch, (false ? _GLF_FUZZED(injectionSwitch) : injectionSwitch)), injectionSwitch, injectionSwitch)).y, false)), true && (bool(bvec2(injectionSwitch.x > injectionSwitch.y, false)))))))))
            {
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 barrier();
                }
               else
                {
                }
               if(_GLF_DEAD(false))
                barrier();
              }
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              break;
             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
              }
             else
              {
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 if(_GLF_DEAD(false))
                  barrier();
                }
               else
                {
                }
               barrier();
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                {
                 do
                  {
                   barrier();
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), bool(bvec2((injectionSwitch.x > injectionSwitch.y), false))))));
                }
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, bool(bool(true)))))
                  {
                   if(_GLF_DEAD(false))
                    break;
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                    }
                   else
                    {
                     return;
                    }
                  }
                 else
                  {
                  }
                 if(_GLF_DEAD(false))
                  barrier();
                }
              }
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               barrier();
              }
            }
           vec4 _GLF_SWITCH_1_0v, _GLF_SWITCH_1_1v[72], _GLF_SWITCH_1_2v;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           case 14:
           if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
            continue;
           if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
            barrier();
           vec3 _GLF_SWITCH_1_3v[66];
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && true))
            return;
           default:
           for(int _injected_loop_counter = _GLF_IDENTITY((1 ^ 1), _GLF_IDENTITY(((1 ^ 1)), (((1 ^ 1))) * 1) | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                  {
                   return;
                  }
                 else
                  {
                  }
                }
               for(int _injected_loop_counter = (0 | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   barrier();
                  }
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, (injectionSwitch) * mat2(1.0)).y))))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                  }
                 else
                  {
                   barrier();
                  }
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                }
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               return;
              }
             break;
            }
           if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(_GLF_IDENTITY(bool(bool(false)), (_GLF_IDENTITY(bool(bool(false)), (bool(bool(false))) && true)) && true), true && (bool(bool(false)))))))
            barrier();
           if(_GLF_DEAD(false))
            barrier();
           for(int _injected_loop_counter = (-66980 & _GLF_IDENTITY(0, 0 ^ (0))); _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
            {
             do
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  return;
                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                  {
                   barrier();
                  }
                }
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
            }
           do
            {
             1;
            }
           while(_GLF_WRAPPED_LOOP(false));
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               switch(_GLF_SWITCH(0))
                {
                 case 25:
                 mat2 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v;
                 case 17:
                 _GLF_SWITCH_1_2v;
                 case 0:
                 case 75:
                 case 64:
                 if(_GLF_DEAD(false))
                  barrier();
                 barrier();
                 break;
                 case 91:
                 mat4x2 _GLF_SWITCH_5_2v[44];
                 default:
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 1;
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
             else
              {
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
            }
           if(_GLF_DEAD(false))
            {
             do
              {
               barrier();
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
              {
               barrier();
              }
             if(_GLF_DEAD(false))
              barrier();
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         case 10:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         case 67:
         case 68:
         case 16:
         do
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              {
               do
                {
                 barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             barrier();
            }
          }
         while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, bool(bvec2(false, false))))))));
         if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (! (_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
          barrier();
         break;
         case 5:
         ivec3 _GLF_SWITCH_4_1v, _GLF_SWITCH_4_2v, _GLF_SWITCH_4_3v;
         default:
         if(_GLF_DEAD(false))
          barrier();
         1;
        }
      }
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(_GLF_IDENTITY(bool(false), (bool(false)) && true)), bool(bool(bool(_GLF_IDENTITY(bool(false), (bool(false)) && true)))))), (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, (injectionSwitch) - log(vec2(1.0, 1.0))).x > injectionSwitch.y)), false || (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(vec2(_GLF_IDENTITY(vec4(_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(vec2(mat4x3(injectionSwitch, 1.0, 0.0, 0.0, 0.0, sqrt(1.0), 1.0, 1.0, 1.0, 0.0, 1.0)), (vec2(mat4x3(injectionSwitch, 1.0, 0.0, 0.0, 0.0, sqrt(1.0), 1.0, 1.0, 1.0, 0.0, 1.0))) * mat2(1.0))), 0.0, 1.0), min(vec4(_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(vec2(mat4x3(injectionSwitch, 1.0, 0.0, 0.0, 0.0, sqrt(1.0), 1.0, 1.0, 1.0, 0.0, 1.0)), (vec2(mat4x3(injectionSwitch, 1.0, 0.0, 0.0, 0.0, sqrt(1.0), 1.0, 1.0, 1.0, 0.0, 1.0))) * mat2(1.0))), 0.0, 1.0), vec4(_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(vec2(mat4x3(injectionSwitch, 1.0, 0.0, 0.0, 0.0, sqrt(1.0), 1.0, 1.0, 1.0, 0.0, 1.0)), (vec2(mat4x3(injectionSwitch, 1.0, 0.0, 0.0, 0.0, sqrt(1.0), 1.0, 1.0, 1.0, 0.0, 1.0))) * mat2(1.0))), 0.0, 1.0)))), (vec2(_GLF_IDENTITY(vec4(_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(vec2(mat4x3(injectionSwitch, 1.0, 0.0, 0.0, 0.0, sqrt(1.0), 1.0, 1.0, 1.0, 0.0, 1.0)), (vec2(mat4x3(injectionSwitch, 1.0, 0.0, 0.0, 0.0, sqrt(1.0), 1.0, 1.0, 1.0, 0.0, 1.0))) * mat2(1.0))), 0.0, 1.0), min(vec4(_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(vec2(mat4x3(injectionSwitch, 1.0, 0.0, 0.0, 0.0, sqrt(1.0), 1.0, 1.0, 1.0, 0.0, 1.0)), (vec2(mat4x3(injectionSwitch, 1.0, 0.0, 0.0, 0.0, sqrt(1.0), 1.0, 1.0, 1.0, 0.0, 1.0))) * mat2(1.0))), 0.0, 1.0), vec4(_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(vec2(mat4x3(injectionSwitch, 1.0, 0.0, 0.0, 0.0, sqrt(1.0), 1.0, 1.0, 1.0, 0.0, 1.0)), (vec2(mat4x3(injectionSwitch, 1.0, 0.0, 0.0, 0.0, sqrt(1.0), 1.0, 1.0, 1.0, 0.0, 1.0))) * mat2(1.0))), 0.0, 1.0))))) / vec2(1.0, 1.0))).x > injectionSwitch.y))) && true)))))
            barrier();
           return;
          }
        }
       else
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_DEAD(false))
        barrier();
      }
     else
      {
       if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
          barrier();
         switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
          {
           case 14:
           (vec4(95.39, 996.178, -9.7, -95.49) * vec4(34.52, 798.709, 9.0, 778.693));
           case 18:
           atomicMin(i, (-96028 - -34109));
           if(_GLF_DEAD(false))
            barrier();
           case 0:
           case 31:
           case 13:
           if(_GLF_DEAD(false))
            barrier();
           case 42:
           case 69:
           case 3:
           switch(_GLF_SWITCH(0))
            {
             case 57:
             mat2 _GLF_SWITCH_4_0v;
             case 80:
             if(_GLF_DEAD(false))
              return;
             if(_GLF_DEAD(false))
              barrier();
             bool _GLF_SWITCH_4_1v;
             case 0:
             case 41:
             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
             case 59:
             case 62:
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), true && (_GLF_IDENTITY(! (false), true && (! (false)))))))))
              {
               if(_GLF_DEAD(false))
                {
                 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                  {
                   switch(_GLF_SWITCH(_GLF_IDENTITY(0, (0) / 1)))
                    {
                     case 18:
                     ivec4(-95231, 82669, 57741, 82102);
                     case 58:
                     bvec4 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v[27], _GLF_SWITCH_5_2v;
                     if(_GLF_DEAD(false))
                      barrier();
                     case 0:
                     case 76:
                     case 8:
                     case 3:
                     case 72:
                     if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec2(false, true)), (bool(bvec2(false, true))) && true))))
                      return;
                     if(_GLF_DEAD(false))
                      barrier();
                     case 40:
                     case 9:
                     case 27:
                     if(_GLF_DEAD(false))
                      barrier();
                     return;
                     break;
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                     case 41:
                     ;
                     default:
                     1;
                    }
                  }
                }
               do
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), ! (_GLF_IDENTITY(! (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))), false || (! (_GLF_IDENTITY(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, false || (injectionSwitch.x > injectionSwitch.y)))), ! (! (_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, ! (! (injectionSwitch.x > injectionSwitch.y)))))))))))))))
                  continue;
                 barrier();
                 if(_GLF_DEAD(false))
                  barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             if(_GLF_DEAD(false))
              barrier();
             case 10:
             if(_GLF_DEAD(false))
              barrier();
             case 86:
             case 76:
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                {
                 return;
                }
              }
             else
              {
              }
             case 47:
             case 54:
             case 19:
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               for(int _injected_loop_counter = _GLF_IDENTITY(1, clamp(_GLF_IDENTITY(1, min(_GLF_IDENTITY(1, min(1, 1)), 1)), _GLF_IDENTITY(1, 0 + (1)), 1)); _GLF_WRAPPED_LOOP(_injected_loop_counter > ((0 << _GLF_IDENTITY(int(6), int(6))) ^ 0)); _injected_loop_counter --)
                {
                 return;
                }
              }
             if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true)))
              barrier();
             break;
             if(_GLF_DEAD(false))
              barrier();
             case 3:
             (mat4x2(-4.3, 52.80, -6.8, 5.4, -3.4, -3121.4973, -7.4, 3.5) / mat4x2(36.18, 7.4, -8.3, 5.4, 6617.1915, -8.4, -82.66, -9.8));
             case 16:
             if(_GLF_DEAD(false))
              barrier();
             ivec4 _GLF_SWITCH_4_2v[63], _GLF_SWITCH_4_3v, _GLF_SWITCH_4_4v;
             default:
             if(_GLF_DEAD(false))
              return;
             1;
            }
           if(_GLF_DEAD(false))
            barrier();
           break;
           case 43:
           mat2x3(mat3(-2143.7219, -5.7, -1161.6201, -617.841, 1.9, 83.07, 2701.6932, 805.511, -783.024));
           default:
           1;
          }
         if(_GLF_DEAD(false))
          barrier();
        }
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
        {
         barrier();
         if(_GLF_DEAD(false))
          barrier();
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        barrier();
       return;
      }
     break;
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       switch(_GLF_SWITCH(0))
        {
         case 82:
         do
          {
           ;
           ivec4(_GLF_IDENTITY(-73610, int(int(_GLF_IDENTITY(-73610, (-73610) | (-73610))))), -71394, -97963, 75937);
           bvec2(bvec3(false, false, false));
           mat2x4 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v, _GLF_SWITCH_5_2v;
           mat2x3(-956.800, -73.04, -9846.9317, 7354.6351, -8092.9447, -6.2);
           (clamp(uvec3(159870u, 97296u, 171855u), _GLF_IDENTITY(subgroup_size, 0u + (subgroup_size)), subgroup_size) % next_virtual_gid);
           if(_GLF_DEAD(false))
            barrier();
           mat4x2(3954.5568, -7.7, 4054.4575, _GLF_IDENTITY(-0.1, float(mat4x2(_GLF_IDENTITY(-0.1, float(float(_GLF_IDENTITY(-0.1, min(-0.1, -0.1))))), 1.0, 0.0, 1.0, 0.0, tan(0.0), 1.0, 1.0))), -3.4, -7.1, 2.9, -6918.1450);
           bvec2 _GLF_SWITCH_5_3v;
          }
         while(false);
         case 86:
         if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
          barrier();
         ivec2 _GLF_SWITCH_5_4v[98], _GLF_SWITCH_5_5v;
         case 0:
         case 27:
         case 31:
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           do
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
            }
           while(_GLF_WRAPPED_LOOP(false));
           if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(_GLF_TRUE(true, (injectionSwitch.x < _GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).y)), _GLF_IDENTITY(bool(_GLF_IDENTITY(bvec3(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), false), bvec3(bvec4(bvec3(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), false), true)))), ! (! (bool(_GLF_IDENTITY(bvec3(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), _GLF_TRUE(true, (injectionSwitch.x < _GLF_IDENTITY(injectionSwitch.y, (injectionSwitch.y) - 0.0))), false), bvec3(bvec4(bvec3(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), _GLF_TRUE(_GLF_IDENTITY(true, (true) && true), (_GLF_IDENTITY(injectionSwitch.x < injectionSwitch.y, (injectionSwitch.x < injectionSwitch.y) && true))), false), true))))))))))
            {
             barrier();
            }
           else
            {
            }
           if(_GLF_DEAD(false))
            return;
          }
         break;
         default:
         1;
        }
      }
     if(_GLF_DEAD(false))
      barrier();
     default:
     if(_GLF_DEAD(false))
      {
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
        {
         if(_GLF_DEAD(false))
          barrier();
         return;
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        barrier();
       return;
      }
     1;
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       barrier();
      }
     else
      {
      }
     if(_GLF_DEAD(false))
      barrier();
    }
  }
 else
  {
   if(_GLF_DEAD(false))
    barrier();
   atomicStore(buf[next_virtual_gid], uint(_GLF_IDENTITY(2, max(2, 2))), 4, _GLF_IDENTITY(_GLF_IDENTITY(64, (64) / 1), ~ (_GLF_IDENTITY(~ _GLF_IDENTITY((64), _GLF_IDENTITY(_GLF_IDENTITY(int(_GLF_IDENTITY(ivec4((64), 0, 0, ((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (int(4)) | 0)))), clamp(ivec4((64), 0, 0, ((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (int(4)) | 0)))), ivec4((64), 0, 0, ((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (int(4)) | 0)))), _GLF_IDENTITY(ivec4((64), 0, 0, ((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (int(4)) | 0)))), (ivec4((64), 0, 0, ((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (int(4)) | 0))))) * ivec4(1, 1, 1, 1))))), ~ (~ (int(ivec4((64), 0, 0, ((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), _GLF_IDENTITY((int(4)), (_GLF_IDENTITY((int(4)), ~ (~ ((int(4)))))) | ((int(4)))) | 0)))))))), min(_GLF_IDENTITY(_GLF_IDENTITY(int(ivec4((64), 0, 0, ((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (int(4)) | 0))))), ~ (~ (int(_GLF_IDENTITY(ivec4((64), 0, 0, ((_GLF_IDENTITY(int(_GLF_ONE(1.0, injectionSwitch.y)), (int(_GLF_ONE(1.0, injectionSwitch.y))) | 0) << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (int(4)) | 0)))), ivec4(0, 0, 0, 0) | (_GLF_IDENTITY(ivec4((64), 0, 0, ((_GLF_IDENTITY(int(_GLF_ONE(1.0, injectionSwitch.y)), (int(_GLF_ONE(1.0, injectionSwitch.y))) | 0) << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (int(4)) | 0)))), max(ivec4((64), 0, 0, ((_GLF_IDENTITY(int(_GLF_ONE(1.0, injectionSwitch.y)), (int(_GLF_ONE(1.0, injectionSwitch.y))) | 0) << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (int(4)) | 0)))), ivec4((64), 0, 0, ((_GLF_IDENTITY(int(_GLF_ONE(1.0, injectionSwitch.y)), (int(_GLF_ONE(1.0, injectionSwitch.y))) | 0) << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (int(4)) | 0)))))))))))), (_GLF_IDENTITY(int(ivec4((64), 0, _GLF_IDENTITY(0, (0) | (_GLF_IDENTITY(0, clamp(0, 0, 0)))), ((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (int(4)) | 0))))), ~ (~ (int(ivec4((64), 0, 0, ((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (int(4)) | 0))))))))) / 1), _GLF_IDENTITY(int(ivec4((64), 0, 0, ((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (int(4)) | 0))))), ~ (~ (int(ivec4((64), 0, 0, ((int(_GLF_ONE(1.0, injectionSwitch.y)) << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (int(4)) | 0))))))))))), 0 ^ (~ (64))))), 4);
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      return;
     barrier();
    }
   if(_GLF_DEAD(false))
    barrier();
  }
 for(int _injected_loop_counter = (_GLF_IDENTITY(0 & -93311, max(0 & -93311, 0 & -93311))); _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 & 1)); _injected_loop_counter ++)
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)).x, (_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.x, 0.0 + (injectionSwitch.x)), (false ? _GLF_FUZZED(5.9) : _GLF_IDENTITY(injectionSwitch.x, 0.0 + (injectionSwitch.x))))) * 1.0) > injectionSwitch.y))))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, max(injectionSwitch, injectionSwitch)).y))))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       do
        {
         switch(_GLF_SWITCH(0))
          {
           case 41:
           for(           mat3x2(8532.0467, 5.4, 3.3, 3.7, 9703.7221, _GLF_IDENTITY(411.988, (true ? _GLF_IDENTITY(411.988, 1.0 * (411.988)) : _GLF_FUZZED(71.16))));
 ((ivec3(17657, -48708, 9630) != ivec3(69720, 84787, -55365)) == true); bvec3(false, true, _GLF_IDENTITY(true, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (true))))
            {
            }
           if(_GLF_DEAD(false))
            barrier();
           case 0:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           case 24:
           case 37:
           case 92:
           case 74:
           case 63:
           case 39:
           case 12:
           case 89:
           switch(_GLF_SWITCH(0))
            {
             case 0:
             case 1:
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             case 33:
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                }
               else
                {
                 barrier();
                }
              }
             case 35:
             if(_GLF_DEAD(false))
              barrier();
             case 20:
             do
              {
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 return;
                }
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
             if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, bool(bvec2(true, false)))))
              {
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 barrier();
                }
              }
             else
              {
              }
             case 97:
             case 61:
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 return;
                }
              }
             else
              {
              }
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               barrier();
               for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                {
                 if(_GLF_DEAD(false))
                  break;
                 if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, (false) && true), bool(_GLF_IDENTITY(bvec3(_GLF_IDENTITY(false, (false) && true), true, false), bvec3(bvec3(bvec3(_GLF_IDENTITY(false, (false) && true), true, false))))))))
                  barrier();
                 if(_GLF_DEAD(false))
                  barrier();
                }
              }
             break;
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   barrier();
                  }
                }
               barrier();
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
             default:
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_DEAD(false))
                  return;
                 if(_GLF_DEAD(false))
                  barrier();
                }
               else
                {
                }
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 return;
                }
               if(_GLF_DEAD(false))
                barrier();
               return;
              }
             for(int _injected_loop_counter = (_GLF_IDENTITY(0 << _GLF_IDENTITY(int(4), int(4)), (_GLF_IDENTITY(0 << _GLF_IDENTITY(int(4), int(4)), max(0 << _GLF_IDENTITY(int(4), int(4)), _GLF_IDENTITY(0 << _GLF_IDENTITY(int(4), int(4)), (0 << _GLF_IDENTITY(int(4), int(4))) / 1)))) / (1 ^ 0))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
              {
               do
                {
                 1;
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
              }
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           break;
           case 98:
           while(true)
            {
             mat3x2 _GLF_SWITCH_5_0v[1], _GLF_SWITCH_5_1v[6];
             uvec3(188804u, 44472u, 92119u);
             bvec3 _GLF_SWITCH_5_2v, _GLF_SWITCH_5_3v[81], _GLF_SWITCH_5_4v[91];
             mat4 _GLF_SWITCH_5_5v[72], _GLF_SWITCH_5_6v;
             ;
             if(_GLF_DEAD(false))
              barrier();
             virtual_gid;
             if(_GLF_DEAD(false))
              barrier();
             all(bvec3(true));
            }
           case 15:
           mat2x3 _GLF_SWITCH_5_7v, _GLF_SWITCH_5_8v;
           default:
           1;
           if(_GLF_DEAD(false))
            barrier();
          }
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), _GLF_IDENTITY(bool(bvec4(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), true, false, false)), _GLF_IDENTITY(bool(_GLF_IDENTITY(bool(bool(bvec4(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), true, false, false))), true && (bool(bool(bvec4(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), true, false, false)))))), ! (! (bool(_GLF_IDENTITY(bool(bool(bvec4(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), true, false, false))), true && (bool(bool(bvec4(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), true, false, false))))))))))))
        {
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 | 0)); _injected_loop_counter --)
          {
           return;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
          }
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(false))
        barrier();
      }
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
      {
       if(_GLF_DEAD(false))
        continue;
       if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)).x, clamp(_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)).x, _GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)).x, _GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)).x)) > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          return;
         barrier();
        }
       if(_GLF_DEAD(false))
        barrier();
      }
     return;
    }
   if(_GLF_DEAD(false))
    return;
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    barrier();
   barrier();
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   barrier();
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, true)))))
    barrier();
   if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, (injectionSwitch) + vec2(0.0, 0.0)).x > injectionSwitch.y, (_GLF_IDENTITY(injectionSwitch, (injectionSwitch) + vec2(0.0, 0.0)).x > injectionSwitch.y) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
    barrier();
   return;
  }
}
