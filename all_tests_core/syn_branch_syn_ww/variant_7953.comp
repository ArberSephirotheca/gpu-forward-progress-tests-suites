#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_maximal_reconvergence : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, _GLF_IDENTITY((injectionSwitch.x < injectionSwitch.y), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || ((injectionSwitch.x < injectionSwitch.y))))))
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     barrier();
    }
  }
 else
  {
  }
 do
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         switch(_GLF_SWITCH(_GLF_IDENTITY((0 & -68181), _GLF_IDENTITY(((0 & -68181)), (_GLF_IDENTITY(((0 & -68181)), max(((0 & -68181)), ((0 & -68181))))) | (((0 & -68181)))) << 0)))
          {
           case 8:
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 >> _GLF_IDENTITY(int(1), int(1)))); _injected_loop_counter --)
             {
              false;
              if(_GLF_DEAD(false))
               barrier();
             }
            for(            vec4(-5.9, -83.62, 5.6, -9948.4735);
 bool(packHalf2x16(injectionSwitch)); mat3x2(639.444, 7.1, 18.44, -6330.2418, 8.9, -73.46))
             {
              mat3(81.97, -37.71, 5017.0806, -2.0, 3.9, -1.4, 5.3, 53.62, -1092.9134);
              mat4x3(9.8, 7.7, 324.196, -472.114, 1.5, -0.7, -46.72, 60.55, 9969.2875, 7497.1682, 2.1, -113.123);
              do
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 barrier();
                (-90327 * (_GLF_IDENTITY(bitCount(uvec4(164460u, 133964u, 46728u, 198088u)), max(bitCount(uvec4(164460u, 133964u, 46728u, 198088u)), bitCount(uvec4(164460u, 133964u, 46728u, 198088u)))) | ivec4(-61600, -46849, 77542, 88743)));
               }
              while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
              if(_GLF_WRAPPED_IF_TRUE(true))
               {
                if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
                 barrier();
                ;
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 barrier();
               }
              else
               {
               }
              mat2x3(-1.9, 43.40, -830.398, 9.1, -697.320, 2716.0781);
              (false ? ivec2(-92383, -84437) : max(ivec2(54074, 37548), 14318));
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               barrier();
             }
           }
           case 57:
           for(float _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v, _GLF_SWITCH_4_2v[9]; true; (ivec4(98028, 56977, -38583, 99589) + ivec3(21498, 45325, 24487).r))
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               mat4x3(7.1, 2.5, -699.054, 9.0, 3843.1800, -6.0, 761.051, -7.0, -8.3, 146.694, -0.8, -731.579);
              }
             else
              {
              }
             if(_GLF_DEAD(false))
              break;
             vec3(-529.595, -68.66, -756.408).t;
             if(_GLF_DEAD(false))
              barrier();
             bvec3 _GLF_SWITCH_4_3v[24], _GLF_SWITCH_4_4v;
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               switch(_GLF_SWITCH(0))
                {
                 case 55:
                 abs(ivec4(-42445, -94192, 75429, 13881));
                 case 8:
                 mat2x4 _GLF_SWITCH_5_0v;
                 case 0:
                 case 57:
                 for(uvec2 _GLF_SWITCH_4_5v[39], _GLF_SWITCH_4_6v[86]; false; mat2(-9.4, 328.610, -400.779, 7271.4605))
                  {
                   do
                    {
                     _GLF_SWITCH_4_4v;
                     if(_GLF_DEAD(false))
                      continue;
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                   mat3 _GLF_SWITCH_4_7v[90], _GLF_SWITCH_4_8v;
                   mat2(_GLF_SWITCH_4_1v, _GLF_SWITCH_4_0v, -95.20, -9.3);
                   ivec4(-71796, _GLF_IDENTITY(-12795, 0 ^ (-12795)), 88532, 40466);
                   if(_GLF_DEAD(false))
                    continue;
                  }
                 break;
                 case 87:
                 if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), ! (! (! (false)))))), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), true, true)))))
                  barrier();
                 ivec3(-41311, -52611, 64619);
                 default:
                 if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ((injectionSwitch.x > injectionSwitch.y)) && true))))
                  barrier();
                 1;
                 if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, ! (! (false)))) || false)))
                  barrier();
                }
              }
             else
              {
              }
            }
           case 0:
           case 73:
           if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, true)))))
            barrier();
           case 5:
           case 19:
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             do
              {
               if(_GLF_DEAD(false))
                return;
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               barrier();
              }
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
              barrier();
            }
           case 55:
           barrier();
           break;
           case 28:
           vec3(2967.5617, 5.9, -0.5);
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           case 20:
           do
            {
             switch(_GLF_SWITCH(0))
              {
               case 0:
               case 37:
               if(_GLF_DEAD(false))
                barrier();
               notEqual(notEqual(log2(injectionSwitch), _GLF_IDENTITY(injectionSwitch, (injectionSwitch) - tan(vec2(0.0, 0.0)))), bvec2(true, false));
               case 86:
               for(int _injected_loop_counter = (1 ^ 1); _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 | 0)); _injected_loop_counter ++)
                {
                 while((bvec2(false, false) != bvec2(true, true)))
                  {
                   bitfieldInsert((ivec2(-18035, 2229)), ivec2(-81282, -81855), 29270, 71119);
                   (ivec3(-20594, 58345, -50786) | ivec3(47600, 57416, -32510));
                   ivec4 _GLF_SWITCH_4_9v[80], _GLF_SWITCH_4_10v;
                   uvec4 _GLF_SWITCH_4_11v, _GLF_SWITCH_4_12v[33], _GLF_SWITCH_4_13v;
                   bvec2(false, false);
                   bvec4 _GLF_SWITCH_4_14v;
                  }
                }
               case 98:
               case 7:
               case 18:
               bvec3 _GLF_SWITCH_4_15v, _GLF_SWITCH_4_16v;
               if(_GLF_DEAD(false))
                barrier();
               break;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               case 93:
               mat4(-5482.0357, -317.134, 57.38, 9268.3277, -1892.9594, 57.87, 8451.3019, 7.5, -1.2, 8866.0574, 3.1, -86.50, -3.2, 8117.7387, 57.11, 2.8);
               case 28:
               injectionSwitch;
               default:
               1;
              }
            }
           while(false);
           default:
           1;
          }
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         return;
        }
      }
    }
   if(_GLF_IDENTITY(_GLF_DEAD(false), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) && (_GLF_DEAD(false))))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(false))
      {
       switch(_GLF_SWITCH(0))
        {
         case 4:
         ivec3(36844, ivec4(83200, -83513, 34758, -60496).s, -6606);
         case 91:
         while((104931u > 30100u))
          {
           vec3 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v, _GLF_SWITCH_4_2v[93];
           for(int _GLF_SWITCH_4_3v[90]; (bvec3(false, true, true) != bvec3(false, true, false)); uvec4(56255u, 81608u, 159897u, 110196u))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             mat3(971.373, 6.9, -84.96, -6.4, -85.02, -411.731, -3185.6850, 0.1, -14.87);
             115832u;
             mat3x2 _GLF_SWITCH_4_4v[7];
             vec4 _GLF_SWITCH_4_5v[7], _GLF_SWITCH_4_6v;
             ;
             uvec2(152545u, 191516u);
             (1.0 + mat3x4(-65.60, 3654.1920, 7.5, 8282.6519, -87.39, 595.406, 55.95, 5943.8128, -552.362, 4.5, _GLF_IDENTITY(-4.8, clamp(-4.8, -4.8, -4.8)), 73.23));
             ivec2(97069, _GLF_IDENTITY(37338, int(ivec4(37338, 1, 1, 0))));
             bvec4(true, false, true, false);
             if(_GLF_DEAD(false))
              return;
            }
           if(_GLF_DEAD(false))
            barrier();
           (mat2x4(38.56, -2.4, 9.5, 7686.5797, 7.9, 53.87, -4.3, -7621.7562));
           while(false)
            {
             mat3 _GLF_SWITCH_4_7v, _GLF_SWITCH_4_8v, _GLF_SWITCH_4_9v;
             if(_GLF_DEAD(false))
              barrier();
             bvec4 _GLF_SWITCH_4_10v, _GLF_SWITCH_4_11v, _GLF_SWITCH_4_12v;
             (mat4(-5259.0374, 1.2, 19.32, -57.85, -4.3, 1633.3686, -5.5, 75.40, 1.0, 4.0, 39.73, 0.8, 1.3, -3.6, -7657.2990, 7.7) + mat4(-15.13, -9.5, 6.2, -0.0, 30.64, 3.8, -7210.1401, _GLF_IDENTITY(81.24, min(81.24, _GLF_IDENTITY(81.24, float(mat2x4(81.24, 0.0, abs(0.0), 1.0, 0.0, 1.0, 1.0, 1.0))))), 9.3, 4388.2720, -98.10, 6435.6618, 3.7, -22.31, 1.0, 8506.4357));
             vec3(-9.2, -35.31, 8.7).zz;
             if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, ! (! (false)))) || false)))
              barrier();
            }
          }
         case 0:
         case 74:
         if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
          {
           for(int _injected_loop_counter = (1 & int(_GLF_ONE(1.0, injectionSwitch.y))); _GLF_WRAPPED_LOOP(_injected_loop_counter != (43010 & 0)); _injected_loop_counter --)
            {
             return;
            }
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         case 36:
         case 53:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         case 45:
         barrier();
         break;
         case 8:
         vec4 _GLF_SWITCH_4_13v, _GLF_SWITCH_4_14v[32], _GLF_SWITCH_4_15v;
         if(_GLF_DEAD(false))
          barrier();
         case 51:
         for(uvec2 _GLF_SWITCH_4_16v, _GLF_SWITCH_4_17v[55]; false; mat3x2(asinh(-0.3)))
          {
           {
            mat4(-951.119, 2.5, 696.657, -680.518, 0.5, 419.688, -910.867, -8.5, -43.18, -7.0, -4.2, 66.84, -5272.0286, -977.784, 3.4, -8211.8418);
            _GLF_IDENTITY(uvec3(10964u, 81615u, 134801u), (uvec3(10964u, 81615u, 134801u)) ^ (uvec3(0u, 0u, 0u) ^ uvec3(0u, 0u, 0u)));
            mat4 _GLF_SWITCH_4_18v, _GLF_SWITCH_4_19v[9], _GLF_SWITCH_4_20v;
            mat3x2(-34.16, _GLF_IDENTITY(-413.868, (true ? -413.868 : _GLF_FUZZED(-2.7))), 3.7, -0.1, 5.3, 2.4);
           }
           uint _GLF_SWITCH_4_21v, _GLF_SWITCH_4_22v;
          }
         default:
         _GLF_IDENTITY(1, (_GLF_IDENTITY(1, int(_GLF_IDENTITY(ivec3(1, 1, ((1 << _GLF_IDENTITY(int(5), int(5))) >> _GLF_IDENTITY(int(5), int(5)))), ~ (~ (ivec3(1, 1, ((1 << _GLF_IDENTITY(int(5), int(5))) >> _GLF_IDENTITY(int(5), int(5)))))))))) ^ 0);
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_IDENTITY(_GLF_DEAD(false), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) && (_GLF_DEAD(false))))
        continue;
       barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          barrier();
         continue;
        }
      }
     barrier();
     if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))
      break;
    }
   if(_GLF_DEAD(false))
    break;
   if(_GLF_DEAD(false))
    barrier();
  }
 while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(_GLF_IDENTITY(false, false || (false)), false || (_GLF_IDENTITY(false, false || (_GLF_IDENTITY(false, (false) || false)))))));
 if(_GLF_DEAD(false))
  {
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _GLF_IDENTITY(_injected_loop_counter --, (_GLF_IDENTITY(_injected_loop_counter --, ~ (~ (_injected_loop_counter --)))) >> (0 << _GLF_IDENTITY(int(0), int(0)))))
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       barrier();
      }
    }
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_DEAD(false))
      {
       for(int _injected_loop_counter = (1 & 1); _GLF_WRAPPED_LOOP(_injected_loop_counter > ((0 << _GLF_IDENTITY(int(8), int(8))) ^ _GLF_IDENTITY(0, min(0, 0)))); _injected_loop_counter --)
        {
         switch(_GLF_IDENTITY(_GLF_SWITCH(0), (_GLF_SWITCH(0)) / 1))
          {
           case 81:
           do
            {
             bool _GLF_SWITCH_5_0v[74];
            }
           while(false);
           case 12:
           if(false)
            {
             ivec2(-43793, 3945);
             ;
             ;
            }
           case 0:
           case 16:
           barrier();
           break;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           case 58:
           mat2x3(-877.104, 64.32, -401.774, 7.7, _GLF_IDENTITY(616.348, (616.348) / 1.0), -1.2);
           case 50:
           if(true)
            {
             uvec3 _GLF_SWITCH_5_1v;
             (ivec4(10665, 22835, -17513, 28883) | 39268);
             if(_GLF_DEAD(false))
              barrier();
             vec2 _GLF_SWITCH_5_2v, _GLF_SWITCH_5_3v[20];
             if(_GLF_DEAD(false))
              barrier();
             bvec2(true, false);
             ivec3 _GLF_SWITCH_5_4v;
             if(_GLF_DEAD(false))
              barrier();
             uint _GLF_SWITCH_5_5v;
             mat3x4 _GLF_SWITCH_5_6v[17];
            }
           default:
           1;
          }
        }
       if(_GLF_DEAD(false))
        barrier();
      }
    }
   else
    {
    }
   if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(bvec3(false, false, _GLF_IDENTITY(true, true && (true)))))))
    {
    }
   else
    {
     do
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
        barrier();
       for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_IDENTITY(_GLF_WRAPPED_LOOP(_injected_loop_counter < 1), bool(bvec4(_GLF_IDENTITY(_GLF_WRAPPED_LOOP(_injected_loop_counter < 1), ! (! (_GLF_WRAPPED_LOOP(_injected_loop_counter < 1)))), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false))); _injected_loop_counter ++)
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           do
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                {
                 switch(_GLF_IDENTITY(_GLF_SWITCH(0), max(_GLF_IDENTITY(_GLF_SWITCH(0), (_GLF_SWITCH(0)) + 0), _GLF_SWITCH(0))))
                  {
                   case 0:
                   if(_GLF_DEAD(false))
                    barrier();
                   case 37:
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                   case 7:
                   case 60:
                   case 14:
                   case 95:
                   case 66:
                   if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, _GLF_IDENTITY(bool(bvec4(_GLF_IDENTITY(true, false || (true)), true, true, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))), false || (bool(bvec4(_GLF_IDENTITY(true, false || (true)), true, true, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))))))
                    {
                     return;
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                   else
                    {
                    }
                   break;
                   default:
                   if(_GLF_DEAD(false))
                    barrier();
                   1;
                   if(_GLF_DEAD(false))
                    barrier();
                  }
                }
              }
            }
           while(_GLF_WRAPPED_LOOP(false));
           barrier();
          }
        }
      }
     while(_GLF_WRAPPED_LOOP(false));
     return;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
    }
  }
 uint subgroup_id = gl_SubgroupID;
 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
  }
 else
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
  }
 if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec2(false, false)), _GLF_IDENTITY((bool(bvec2(false, false))), true && ((bool(bvec2(false, false))))) || false))))
  return;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, bool(bvec2(false, false))))))))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 else
  {
   if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(false || (false), _GLF_IDENTITY((_GLF_IDENTITY(false || (false), (false || (false)) && true)), ! (! ((_GLF_IDENTITY(false || (false), (false || (false)) && true))))) && true))))
    {
     if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bool(bvec4(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), true, true, true))))
      barrier();
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), (_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (! (_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))) && true))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, bool(bvec2(injectionSwitch.x > injectionSwitch.y, true)))))))
          {
           if(_GLF_DEAD(false))
            barrier();
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
            {
             barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
         return;
         if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), ! (! (! (false))))))))
        barrier();
       if(_GLF_DEAD(false))
        barrier();
       barrier();
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
        }
       if(_GLF_DEAD(false))
        barrier();
      }
     if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
      {
       switch(_GLF_SWITCH((0 >> _GLF_IDENTITY(int(1), int(1)))))
        {
         case 90:
         ivec3(-33353, -45008, 85947).p;
         case 0:
         if(_GLF_DEAD(false))
          barrier();
         case 42:
         case 86:
         case 99:
         case 67:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         case 6:
         case 19:
         case 87:
         if(_GLF_DEAD(false))
          barrier();
         barrier();
         break;
         case 33:
         {
          for(          (isnan(vec3(-559.431, 3088.8006, -21.41)) , bvec4(false, false, true, true));
 true; (false == _GLF_IDENTITY(true, false || (_GLF_IDENTITY(true, (true) && true)))))
           {
            mat4 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v[17];
           }
          while((length(vec2(8.8, -3.2)) < -923.630))
           {
            vec2 _GLF_SWITCH_5_2v[57];
            ivec4 _GLF_SWITCH_5_3v;
           }
          uvec4(uvec2(44905u, 21700u), uvec2(52879u, 136203u));
          if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
           barrier();
          bvec3 _GLF_SWITCH_5_4v, _GLF_SWITCH_5_5v;
          if(_GLF_DEAD(false))
           barrier();
          mat3x4(mat2x4(-235.145, 7.5, 87.95, -56.45, -2878.8972, -7849.7313, -1.1, 41.28));
         }
         default:
         1;
        }
      }
     barrier();
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), ! (! (_GLF_IDENTITY(! (false), bool(bvec4(! (false), false, false, true))))))))))
      barrier();
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        return;
       barrier();
      }
    }
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(_GLF_IDENTITY(bvec3(false, false, true), bvec3(bvec4(_GLF_IDENTITY(bvec3(false, false, true), bvec3(bvec4(bvec3(false, false, true), false))), false))), bvec3(bvec4(bvec3(false, false, true), false)))))))
  return;
 if(_GLF_DEAD(false))
  barrier();
 uint subgroup_size = gl_SubgroupSize;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  {
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > ((0 | 0) ^ int(_GLF_ZERO(0.0, injectionSwitch.x)))); _injected_loop_counter --)
    {
     if(_GLF_DEAD(false))
      return;
    }
   if(_GLF_DEAD(false))
    barrier();
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       barrier();
      }
    }
   if(_GLF_DEAD(_GLF_IDENTITY(false, ! _GLF_IDENTITY((! (false)), ! (! ((! (false))))))))
    barrier();
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     return;
    }
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
     switch(_GLF_IDENTITY(_GLF_SWITCH(0), (_GLF_SWITCH(0)) + 0))
      {
       case 27:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       while((mat4x3(-1.3, 731.839, 4.6, 8364.8811, -8264.5586, 3.8, 370.311, -3.0, -23.98, -0.4, -68.75, 5364.9738) != mat4x3(2.3, -363.576, -910.841, 25.19, -2179.4820, 0.3, -1.5, 8367.2967, -4.6, 3.9, 811.257, 61.04)))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         uvec4 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v[83];
         ;
         if((ivec4(-7847, -84900, -56961, 18731) != ivec4(-67427, -81293, 32799, 19373)))
          {
           ivec3(93593, 70865, -73636);
           if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ! (! ((injectionSwitch.x > injectionSwitch.y)))))))
            barrier();
           if((ivec4(40848, -19504, _GLF_IDENTITY(-1199, int(_GLF_ZERO(0.0, injectionSwitch.x)) | (_GLF_IDENTITY(-1199, ~ (_GLF_IDENTITY(~ (_GLF_IDENTITY(-1199, clamp(-1199, -1199, -1199))), int(ivec2(~ (_GLF_IDENTITY(-1199, clamp(-1199, -1199, -1199))), 0))))))), -32656) == ivec4(32968, 4639, 75128, -9365)))
            {
             mat4x2(-7.1, -2077.1938, -29.31, -7631.2095, 80.84, 817.995, 9730.8576, _GLF_IDENTITY(-9.5, max(-9.5, _GLF_IDENTITY(-9.5, min(-9.5, _GLF_IDENTITY(-9.5, (-9.5) / 1.0))))));
             if(_GLF_DEAD(false))
              barrier();
             ivec2 _GLF_SWITCH_5_2v, _GLF_SWITCH_5_3v;
             vec2 _GLF_SWITCH_5_4v[16], _GLF_SWITCH_5_5v;
             52488;
             outerProduct(vec4(-1844.0679, -1.0, 32.33, 8.8), vec4(3.4, 2.8, -9613.2871, -3.6));
             ;
             _GLF_SWITCH_5_5v[1];
             mat4x3 _GLF_SWITCH_5_6v, _GLF_SWITCH_5_7v, _GLF_SWITCH_5_8v;
            }
           else
            {
             bvec2(true, false);
             mat2x4(94.43, 2.2, -5400.7760, 51.83, 785.763, 0.5, -892.645, -3.9);
            }
           if(_GLF_DEAD(false))
            barrier();
           ;
           if(false)
            {
            }
           bool _GLF_SWITCH_5_9v, _GLF_SWITCH_5_10v[13], _GLF_SWITCH_5_11v[55];
           if(_GLF_DEAD(false))
            barrier();
           ivec4(36470, -98749, -15027, 6832);
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           uvec2 _GLF_SWITCH_5_12v;
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(true)
            {
             bvec3 _GLF_SWITCH_5_13v[48], _GLF_SWITCH_5_14v, _GLF_SWITCH_5_15v;
             mat2x3(-1768.7543, 4.9, 587.851, 4386.4292, 0.1, -705.091);
             bvec4 _GLF_SWITCH_5_16v;
             mat3x4 _GLF_SWITCH_5_17v;
             ;
             int _GLF_SWITCH_5_18v[70], _GLF_SWITCH_5_19v;
            }
           if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))
            barrier();
           while(true)
            {
            }
           bvec3 _GLF_SWITCH_5_20v, _GLF_SWITCH_5_21v, _GLF_SWITCH_5_22v;
           uvec2 _GLF_SWITCH_5_23v[56], _GLF_SWITCH_5_24v, _GLF_SWITCH_5_25v;
          }
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true && (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
          barrier();
        }
       case 0:
       if(_GLF_DEAD(false))
        barrier();
       case 30:
       if(_GLF_DEAD(false))
        barrier();
       case 82:
       if(_GLF_DEAD(false))
        barrier();
       case 92:
       if(_GLF_DEAD(false))
        return;
       break;
       default:
       if(_GLF_DEAD(false))
        barrier();
       1;
      }
    }
   else
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       return;
      }
     if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(_GLF_IDENTITY(false, false || (_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, (false) && true)))))), (false) && _GLF_TRUE(true, (injectionSwitch.x < _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.y, (injectionSwitch.y) - 0.0), (_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.y, (injectionSwitch.y) - 0.0), (true ? _GLF_IDENTITY(injectionSwitch.y, (injectionSwitch.y) - 0.0) : _GLF_FUZZED(-6.0)))) - 0.0))))))
      {
      }
     else
      {
       if(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_DEAD(false), ! (_GLF_IDENTITY(! (_GLF_DEAD(false)), bool(bvec2(! (_GLF_DEAD(false)), false))))), true && (_GLF_IDENTITY(_GLF_IDENTITY(_GLF_DEAD(false), ! (_GLF_IDENTITY(! (_GLF_DEAD(false)), bool(bvec2(! (_GLF_DEAD(false)), false))))), bool(bool(_GLF_IDENTITY(_GLF_DEAD(false), ! (_GLF_IDENTITY(! (_GLF_DEAD(false)), bool(bvec2(! (_GLF_DEAD(false)), false)))))))))), _GLF_IDENTITY((_GLF_IDENTITY(_GLF_IDENTITY(_GLF_DEAD(false), ! (_GLF_IDENTITY(! (_GLF_DEAD(false)), bool(bvec2(! (_GLF_DEAD(false)), false))))), false || (_GLF_IDENTITY(_GLF_DEAD(false), ! (_GLF_IDENTITY(_GLF_IDENTITY(! (_GLF_DEAD(false)), bool(bvec2(! (_GLF_DEAD(false)), false))), true && (_GLF_IDENTITY(! (_GLF_DEAD(false)), _GLF_IDENTITY(bool(bvec2(! (_GLF_DEAD(false)), false)), ! (_GLF_IDENTITY(! (bool(bvec2(! (_GLF_DEAD(false)), false))), false || (! (bool(bvec2(! (_GLF_DEAD(false)), false))))))))))))))) || false, (_GLF_IDENTITY((_GLF_IDENTITY(_GLF_IDENTITY(_GLF_DEAD(false), ! (_GLF_IDENTITY(! (_GLF_DEAD(false)), bool(bvec2(! (_GLF_DEAD(false)), false))))), false || (_GLF_IDENTITY(_GLF_DEAD(false), ! (_GLF_IDENTITY(_GLF_IDENTITY(! (_GLF_DEAD(false)), bool(bvec2(! (_GLF_DEAD(false)), false))), true && (_GLF_IDENTITY(! (_GLF_DEAD(false)), _GLF_IDENTITY(bool(bvec2(! (_GLF_DEAD(false)), false)), ! (_GLF_IDENTITY(! (bool(bvec2(! (_GLF_DEAD(false)), false))), false || (! (bool(bvec2(! (_GLF_DEAD(false)), false))))))))))))))) || false, bool(bvec3(_GLF_IDENTITY((_GLF_IDENTITY(_GLF_IDENTITY(_GLF_DEAD(false), ! (_GLF_IDENTITY(! (_GLF_DEAD(false)), bool(bvec2(! (_GLF_DEAD(false)), false))))), false || (_GLF_IDENTITY(_GLF_DEAD(false), ! (_GLF_IDENTITY(_GLF_IDENTITY(! (_GLF_DEAD(false)), bool(bvec2(! (_GLF_DEAD(false)), false))), true && (_GLF_IDENTITY(! (_GLF_DEAD(false)), _GLF_IDENTITY(bool(bvec2(! (_GLF_DEAD(false)), false)), ! (_GLF_IDENTITY(! (bool(bvec2(! (_GLF_DEAD(false)), false))), false || (! (bool(bvec2(! (_GLF_DEAD(false)), false))))))))))))))) || false, ((_GLF_IDENTITY(_GLF_IDENTITY(_GLF_DEAD(false), ! (_GLF_IDENTITY(! (_GLF_DEAD(false)), bool(bvec2(! (_GLF_DEAD(false)), false))))), false || (_GLF_IDENTITY(_GLF_DEAD(false), ! (_GLF_IDENTITY(_GLF_IDENTITY(! (_GLF_DEAD(false)), bool(bvec2(! (_GLF_DEAD(false)), false))), true && (_GLF_IDENTITY(! (_GLF_DEAD(false)), _GLF_IDENTITY(bool(bvec2(! (_GLF_DEAD(false)), false)), ! (_GLF_IDENTITY(! (bool(bvec2(! (_GLF_DEAD(false)), false))), false || (! (bool(bvec2(! (_GLF_DEAD(false)), false))))))))))))))) || false) && true), true, false)))) && true)))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
            {
             if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, ! (! (false))), (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             return;
            }
           return;
          }
         if(_GLF_DEAD(false))
          barrier();
         switch(_GLF_SWITCH(0))
          {
           case 0:
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
              {
               if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, bool(bvec3(false, true, false))), bool(_GLF_IDENTITY(bvec3(_GLF_IDENTITY(false, bool(bvec3(false, true, false))), false, true), bvec3(bvec4(bvec3(_GLF_IDENTITY(false, bool(bvec3(false, _GLF_IDENTITY(true, bool(_GLF_IDENTITY(bvec3(true, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false), _GLF_IDENTITY(bvec3(bvec4(bvec3(true, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false), true)), bvec3(bvec3(bvec3(bvec4(bvec3(true, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false), true)))))))), false))), false, true), false)))))))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 barrier();
                }
               if(_GLF_DEAD(false))
                barrier();
              }
            }
           else
            {
            }
           if(_GLF_DEAD(_GLF_IDENTITY(false, ! _GLF_IDENTITY((! (false)), bool(_GLF_IDENTITY(bvec2((! (false)), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), _GLF_IDENTITY(bvec2(bvec4(_GLF_IDENTITY(bvec2((! (false)), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bvec2(bvec2(bvec2((! (false)), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))), false, true)), bvec2(bvec3(bvec2(bvec4(_GLF_IDENTITY(bvec2((! (false)), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bvec2(bvec2(bvec2((! (false)), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))), false, true)), false)))))))))
            barrier();
           do
            {
             if(_GLF_DEAD(false))
              {
               do
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   barrier();
                  }
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
               if(_GLF_DEAD(false))
                continue;
               return;
              }
             if(_GLF_DEAD(false))
              return;
            }
           while(_GLF_WRAPPED_LOOP(false));
           do
            {
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               barrier();
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || _GLF_IDENTITY(false, ! (! (false))))));
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(5), int(5))) >> _GLF_IDENTITY(_GLF_IDENTITY(int(5), int(5)), min(_GLF_IDENTITY(int(5), int(5)), _GLF_IDENTITY(int(5), int(5)))))); _injected_loop_counter ++)
              {
               barrier();
              }
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           case 40:
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
           case 50:
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
            }
           else
            {
             if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true && (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
              {
               if(_GLF_DEAD(false))
                barrier();
               return;
              }
            }
           if(_GLF_DEAD(false))
            barrier();
           for(int _injected_loop_counter = _GLF_IDENTITY(1, (false ? _GLF_FUZZED(-674) : 1)); _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
            {
             if(_GLF_DEAD(false))
              return;
            }
           case 48:
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bool(false), ! (! (bool(false))))))))
              barrier();
             barrier();
            }
           for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(3), _GLF_IDENTITY(int(3), ~ (_GLF_IDENTITY(~ (int(3)), 0 | (~ (int(3)))))))); _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), _GLF_IDENTITY(int(1), clamp(int(1), int(1), int(1)))))); _injected_loop_counter ++)
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           case 43:
           case 94:
           if(_GLF_DEAD(false))
            {
             do
              {
               do
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   return;
                  }
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
               if(_GLF_DEAD(false))
                barrier();
              }
             else
              {
               barrier();
              }
            }
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              barrier();
             barrier();
             if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), (_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), (_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), false || (_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, false || (injectionSwitch.x > injectionSwitch.y)))))))) || false)) || false))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
            }
           break;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           case 44:
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
             if(_GLF_DEAD(false))
              return;
            }
           else
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           mat3x2 _GLF_SWITCH_3_0v[63], _GLF_SWITCH_3_1v;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                barrier();
               return;
              }
             return;
            }
           if(_GLF_DEAD(false))
            return;
           default:
           1;
           if(_GLF_DEAD(false))
            barrier();
          }
        }
       if(_GLF_DEAD(false))
        barrier();
      }
    }
   if(_GLF_DEAD(false))
    return;
   return;
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
  }
 uint subgroup_local_id = gl_SubgroupInvocationID;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, ! (! (injectionSwitch.x > injectionSwitch.y)))))) && true)))
  {
   if(_GLF_DEAD(false))
    return;
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        barrier();
       return;
      }
     else
      {
      }
    }
   else
    {
    }
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       barrier();
      }
     if(_GLF_DEAD(false))
      barrier();
    }
   if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) ? _GLF_FUZZED(-7718.2860) : injectionSwitch.y))))))
      barrier();
     for(int _injected_loop_counter = (1 ^ (1 ^ 0)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
      {
       barrier();
      }
     if(_GLF_DEAD(false))
      barrier();
    }
   if(_GLF_DEAD(false))
    barrier();
   do
    {
     switch(_GLF_SWITCH(0))
      {
       case 43:
       false;
       if(_GLF_DEAD(false))
        barrier();
       case 65:
       ivec3 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v[54];
       case 0:
       case 18:
       case 33:
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, vec2(mat2x3(injectionSwitch, 0.0, 0.0, 1.0, 1.0))).x > injectionSwitch.y))))
          barrier();
        }
       else
        {
        }
       break;
       case 83:
       vec2 _GLF_SWITCH_5_2v, _GLF_SWITCH_5_3v;
       case 60:
       mat2x4 _GLF_SWITCH_5_4v, _GLF_SWITCH_5_5v, _GLF_SWITCH_5_6v;
       default:
       1;
      }
    }
   while(_GLF_WRAPPED_LOOP(false));
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       return;
      }
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        barrier();
       barrier();
       if(_GLF_DEAD(false))
        barrier();
      }
    }
   for(int _injected_loop_counter = ((((1 << _GLF_IDENTITY(int(5), _GLF_IDENTITY(int(5), (int(5)) | (int(5))))) >> _GLF_IDENTITY(int(5), int(5))) << _GLF_IDENTITY(int(6), int(_GLF_IDENTITY(6, min(6, 6))))) >> _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(6), int(ivec4(int(6), 1, 0, 1))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
    {
     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        {
         for(int _injected_loop_counter = (1 & int(_GLF_ONE(1.0, injectionSwitch.y))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
          {
           return;
           if(_GLF_DEAD(false))
            barrier();
          }
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
    }
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     barrier();
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      return;
     do
      {
       return;
      }
     while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, bool(bvec2(false, false)))));
    }
   if(_GLF_DEAD(false))
    barrier();
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(max(_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])), injectionSwitch), vec2(mat3(_GLF_IDENTITY(max(_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])), injectionSwitch), (max(_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])), injectionSwitch)) * vec2(_GLF_ONE(1.0, injectionSwitch.y), _GLF_ONE(1.0, injectionSwitch.y))), 1.0, 1.0, _GLF_IDENTITY(dot(vec3(0.0, 1.0, tan(0.0)), vec3(_GLF_ONE(1.0, injectionSwitch.y), 0.0, 1.0)), dot(vec3(0.0, 1.0, tan(0.0)), vec3(_GLF_ONE(1.0, injectionSwitch.y), 0.0, 1.0))), 1.0, 1.0, 0.0, 0.0)))).y, _GLF_IDENTITY((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, max(_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])), injectionSwitch)).y) || false, ! (_GLF_IDENTITY(! ((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, max(_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])), injectionSwitch)).y) || false), bool(bvec2(! ((injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, max(_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])), injectionSwitch)).y) || false), false)))))), false || (_GLF_IDENTITY(injectionSwitch.x > _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, max(_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])), injectionSwitch)), vec2(0.0, 0.0) + (_GLF_IDENTITY(injectionSwitch, max(_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])), injectionSwitch)))).y, (injectionSwitch.x > _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, max(_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])), injectionSwitch)), (_GLF_IDENTITY(injectionSwitch, max(_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])), injectionSwitch))) * vec2(1.0, 1.0)).y) || false)))))))
  {
   switch(_GLF_SWITCH((0 >> _GLF_IDENTITY(int(2), int(2)))))
    {
     case 0:
     if(_GLF_DEAD(false))
      barrier();
     case 57:
     if(_GLF_DEAD(false))
      return;
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
        barrier();
       do
        {
         if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ! (! ((injectionSwitch.x > injectionSwitch.y)))))))
          {
           if(_GLF_DEAD(false))
            barrier();
           barrier();
          }
        }
       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
      }
     else
      {
       if(_GLF_DEAD(false))
        barrier();
      }
     case 20:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(false))
        barrier();
       barrier();
      }
     case 73:
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      {
       do
        {
         if(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(false), ! (! (_GLF_WRAPPED_IF_FALSE(false)))), (_GLF_WRAPPED_IF_FALSE(false)) && true))
          {
          }
         else
          {
           if(_GLF_DEAD(false))
            return;
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           else
            {
             barrier();
            }
           if(_GLF_DEAD(false))
            return;
          }
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
          barrier();
        }
       else
        {
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (0 | _GLF_IDENTITY(1, (1) - int(_GLF_ZERO(0.0, injectionSwitch.x))))); _injected_loop_counter ++)
            {
             barrier();
            }
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
        }
      }
     if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true)))
      return;
     case 71:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        barrier();
       barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         return;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     case 3:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        barrier();
      }
     else
      {
      }
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          barrier();
         return;
        }
       barrier();
      }
     if(_GLF_DEAD(false))
      barrier();
     case 93:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(false))
      {
       if(_GLF_IDENTITY(_GLF_WRAPPED_IF_TRUE(true), bool(bool(_GLF_WRAPPED_IF_TRUE(true)))))
        {
         barrier();
         if(_GLF_IDENTITY(_GLF_DEAD(false), _GLF_IDENTITY(bool(bool(_GLF_DEAD(false))), ! (! (bool(bool(_GLF_DEAD(false))))))))
          barrier();
        }
       else
        {
        }
      }
     case 97:
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        return;
       for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
        {
         barrier();
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
        {
         case 62:
         if((uvec2(52734u, 115427u) == uvec2(885u, 174749u)))
          {
           if(_GLF_DEAD(false))
            barrier();
           if(false)
            {
             if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, (false) && true)) && true), (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             bvec3(false, true, false);
            }
           uvec2 _GLF_SWITCH_5_0v;
           mat4x2 _GLF_SWITCH_5_1v;
           uvec3(25356u, 35706u, 21252u);
           if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
            barrier();
           uvec2 _GLF_SWITCH_5_2v, _GLF_SWITCH_5_3v;
          }
         else
          {
           for(           mat4x3(matrixCompMult(mat3x4(-83.80, 473.757, 2540.2652, 6638.8496, 16.82, 77.72, 3.6, -0.6, 2502.6652, 66.79, -35.09, -484.584), mat3x4(4.6, 813.425, 625.412, 7.5, -2.1, 4.7, -49.14, -1376.5605, -144.232, -36.88, 83.72, -366.624)));
 (ivec2(-74055, -85732) == clamp(ivec2(-77366, 58112), -14255, 42850)); bvec2(true, true))
            {
             uint _GLF_SWITCH_5_4v, _GLF_SWITCH_5_5v;
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
              barrier();
             not(bvec2(false, false));
            }
           atomicAdd(subgroup_size, 5846u);
           bool _GLF_SWITCH_5_6v[66];
           vec2 _GLF_SWITCH_5_7v;
           mat3 _GLF_SWITCH_5_8v, _GLF_SWITCH_5_9v;
           while(true)
            {
             vec3 _GLF_SWITCH_5_10v;
             mat3x2(mat4(-9.9, 2.1, 42.26, 53.60, 8382.9609, -7.4, 206.307, 227.358, -1.9, -6.5, -0.3, -769.217, -16.20, -83.75, 9580.5597, 3.6));
             uvec3 _GLF_SWITCH_5_11v, _GLF_SWITCH_5_12v;
            }
           {
            if(_GLF_DEAD(false))
             barrier();
            uint _GLF_SWITCH_5_13v;
            ;
            mat2x4 _GLF_SWITCH_5_14v, _GLF_SWITCH_5_15v, _GLF_SWITCH_5_16v;
            uvec2(108137u, 148132u);
            uvec3 _GLF_SWITCH_5_17v[77], _GLF_SWITCH_5_18v;
            mat2x3(-2.5, 0.2, 4856.3936, 8.4, 4.1, -4.1);
            if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            bvec2 _GLF_SWITCH_5_19v[29], _GLF_SWITCH_5_20v[84], _GLF_SWITCH_5_21v;
           }
          }
         case 0:
         case 49:
         if(_GLF_DEAD(false))
          barrier();
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(false))
            barrier();
           do
            {
             barrier();
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
         break;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         case 2:
         (mat4(14.25, 31.36, -1970.1983, 9637.2202, 1814.3513, 938.983, -70.83, 808.787, 2.9, -4883.8939, -5993.7499, -3.7, -461.535, -9.7, 6805.0155, -5.3) + 113.573);
         default:
         1;
         if(_GLF_DEAD(false))
          barrier();
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     if(_GLF_DEAD(false))
      barrier();
     case 70:
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       do
        {
         return;
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(false))
        return;
      }
     if(_GLF_DEAD(false))
      barrier();
     break;
     case 24:
     if(_GLF_DEAD(false))
      barrier();
     ivec4 _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v, _GLF_SWITCH_2_2v;
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        return;
      }
     default:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         for(int _injected_loop_counter = (1 | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
          {
           barrier();
          }
        }
       barrier();
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         return;
        }
       if(_GLF_DEAD(false))
        barrier();
      }
     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         return;
        }
       barrier();
      }
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        barrier();
       do
        {
         if(_GLF_DEAD(false))
          barrier();
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter > 0, ! (! (_injected_loop_counter > 0)))); _injected_loop_counter --)
          {
           _GLF_IDENTITY(1, (1) + (0 ^ 0));
          }
         if(_GLF_DEAD(false))
          {
           do
            {
             if(_GLF_DEAD(false))
              barrier();
             barrier();
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
          }
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(false))
        barrier();
      }
     else
      {
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         switch(_GLF_SWITCH(0))
          {
           case 89:
           (+ mat3x4(9.6, -3.5, 501.667, -61.05, 891.924, 38.70, 2.5, -509.688, -1.7, 9.3, -6526.9286, -3.7));
           if(_GLF_DEAD(false))
            barrier();
           case 63:
           for(bvec2 _GLF_SWITCH_5_0v[61], _GLF_SWITCH_5_1v[76]; all(bvec2(false, false)); isinf(vec3(-91.87, -2981.0506, 2631.1532)))
            {
             equal(ivec3(-9042, -61005, 57671), ivec3(-97188, -44401, 69731));
             vec3 _GLF_SWITCH_5_2v, _GLF_SWITCH_5_3v;
             _GLF_IDENTITY(ivec2(-1933, -1096), (ivec2(-1933, -1096)) | (_GLF_IDENTITY(ivec2(-1933, -1096), (_GLF_IDENTITY(ivec2(-1933, -1096), (true ? ivec2(-1933, -1096) : _GLF_FUZZED(ivec2(-34336, 26763))))) | (ivec2(-1933, -1096)))));
             bvec3 _GLF_SWITCH_5_4v, _GLF_SWITCH_5_5v[82];
            }
           case 0:
           case 29:
           case 41:
           case 72:
           case 73:
           if(_GLF_DEAD(false))
            return;
           barrier();
           break;
           case 33:
           (3074.1440 + mat2x3(-260.601, 1.8, 403.599, -50.33, -6075.2688, -4.2));
           case 13:
           (subgroup_size ++);
           default:
           1;
           if(_GLF_DEAD(false))
            barrier();
          }
        }
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, (false) || false)))
          {
          }
         else
          {
           return;
          }
        }
      }
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       barrier();
      }
    }
  }
 uint num_workgroup = gl_NumWorkGroups.x;
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    barrier();
   return;
  }
 uint workgroup_size = _GLF_IDENTITY(gl_WorkGroupSize.x, clamp(_GLF_IDENTITY(gl_WorkGroupSize, (gl_WorkGroupSize) * uvec3(_GLF_ONE(1.0, injectionSwitch.y), _GLF_ONE(1.0, injectionSwitch.y), _GLF_ONE(1.0, injectionSwitch.y))).x, gl_WorkGroupSize.x, _GLF_IDENTITY(gl_WorkGroupSize.x, _GLF_IDENTITY((gl_WorkGroupSize.x), _GLF_IDENTITY(((gl_WorkGroupSize.x)), (0u << _GLF_IDENTITY(uint(0u), _GLF_IDENTITY(uint(0u), (uint(0u)) ^ 0u))) ^ (_GLF_IDENTITY(((_GLF_IDENTITY(gl_WorkGroupSize.x, (_GLF_IDENTITY(gl_WorkGroupSize.x, _GLF_IDENTITY((gl_WorkGroupSize.x) + 0u, ((gl_WorkGroupSize.x) + 0u) | ((gl_WorkGroupSize.x) + 0u)))) - (1u ^ 1u)))), clamp(((gl_WorkGroupSize.x)), ((gl_WorkGroupSize.x)), ((gl_WorkGroupSize.x)))))) - 0u) << 0u)));
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_DEAD(false))
    barrier();
  }
 uint workgroup_id = gl_WorkGroupID.x;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    barrier();
   barrier();
  }
 if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
  {
   switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
    {
     case 36:
     bvec3(true, true, true);
     case 63:
     bool _GLF_SWITCH_4_0v;
     case 0:
     case 90:
     case 88:
     case 86:
     case 97:
     do
      {
       switch(_GLF_SWITCH(_GLF_IDENTITY((0 << _GLF_IDENTITY(int(2), int(2))), (_GLF_IDENTITY((0 << _GLF_IDENTITY(_GLF_IDENTITY(int(2), max(int(2), int(2))), int(2))), _GLF_IDENTITY(((0 << _GLF_IDENTITY(int(2), int(2)))) | (_GLF_IDENTITY((0 << _GLF_IDENTITY(_GLF_IDENTITY(int(2), int(2)), ~ (_GLF_IDENTITY(~ (_GLF_IDENTITY(int(2), int(_GLF_IDENTITY(2, (_GLF_IDENTITY(false, bool(bvec4(false, false, true, true))) ? _GLF_FUZZED(-99380) : 2))))), 0 | _GLF_IDENTITY((~ (_GLF_IDENTITY(int(2), int(_GLF_IDENTITY(2, (_GLF_IDENTITY(2, int(ivec4(2, 1, 1, 0)))) << 0))))), max((~ (_GLF_IDENTITY(int(2), int(_GLF_IDENTITY(2, (_GLF_IDENTITY(2, int(ivec4(2, 1, 1, 0)))) << 0))))), (~ (_GLF_IDENTITY(int(_GLF_IDENTITY(2, (2) | (_GLF_IDENTITY(2, (0 & -14089) ^ (_GLF_IDENTITY(2, clamp(2, 2, 2))))))), int(_GLF_IDENTITY(2, (_GLF_IDENTITY(2, int(ivec4(2, 1, 1, 0)))) << 0))))))))))), _GLF_IDENTITY(((0 << _GLF_IDENTITY(int(2), int(2)))) / 1, min(((0 << _GLF_IDENTITY(int(2), int(2)))) / 1, _GLF_IDENTITY(((0 << _GLF_IDENTITY(int(2), int(2)))) / 1, 0 | (((0 << _GLF_IDENTITY(int(2), int(2)))) / 1)))))), (false ? _GLF_FUZZED(-42494) : ((0 << _GLF_IDENTITY(int(2), int(2)))) | (_GLF_IDENTITY((0 << _GLF_IDENTITY(_GLF_IDENTITY(_GLF_IDENTITY(int(2), int(2)), min(_GLF_IDENTITY(_GLF_IDENTITY(int(2), int(2)), _GLF_IDENTITY(int(ivec3(_GLF_IDENTITY(_GLF_IDENTITY(int(2), int(2)), ~ (~ (_GLF_IDENTITY(int(2), int(2))))), 0, (0 >> _GLF_IDENTITY(int(1), int(1))))), 0 + (int(ivec3(_GLF_IDENTITY(_GLF_IDENTITY(int(2), int(2)), ~ (~ (_GLF_IDENTITY(int(2), int(2))))), 0, (0 >> _GLF_IDENTITY(int(1), int(1)))))))), _GLF_IDENTITY(_GLF_IDENTITY(int(2), int(2)), (_GLF_IDENTITY(int(2), int(2))) ^ 0))), ~ (_GLF_IDENTITY(~ (_GLF_IDENTITY(int(2), int(_GLF_IDENTITY(2, (_GLF_IDENTITY(false, bool(bvec4(false, false, true, true))) ? _GLF_FUZZED(-99380) : 2))))), 0 | _GLF_IDENTITY((~ (_GLF_IDENTITY(int(2), int(_GLF_IDENTITY(2, (_GLF_IDENTITY(2, int(ivec4(2, 1, 1, 0)))) << _GLF_IDENTITY(0, ~ (~ (_GLF_IDENTITY(0, (false ? _GLF_FUZZED(9072) : 0)))))))))), max((~ (_GLF_IDENTITY(int(2), int(_GLF_IDENTITY(2, (_GLF_IDENTITY(2, int(ivec4(2, 1, 1, 0)))) << 0))))), (_GLF_IDENTITY(~ (_GLF_IDENTITY(int(_GLF_IDENTITY(2, (2) | (_GLF_IDENTITY(2, (0 & -14089) ^ (_GLF_IDENTITY(2, clamp(2, 2, 2))))))), int(_GLF_IDENTITY(2, (_GLF_IDENTITY(2, int(ivec4(2, 1, 1, 0)))) << 0)))), (~ _GLF_IDENTITY((_GLF_IDENTITY(int(_GLF_IDENTITY(2, (2) | (_GLF_IDENTITY(2, (0 & -14089) ^ (_GLF_IDENTITY(2, clamp(2, 2, 2))))))), int(_GLF_IDENTITY(2, (_GLF_IDENTITY(2, int(ivec4(2, 1, 1, 0)))) << 0)))), min(_GLF_IDENTITY((_GLF_IDENTITY(int(_GLF_IDENTITY(2, (2) | (_GLF_IDENTITY(2, (0 & -14089) ^ (_GLF_IDENTITY(2, clamp(2, 2, 2))))))), int(_GLF_IDENTITY(2, (_GLF_IDENTITY(2, int(ivec4(2, 1, 1, 0)))) << 0)))), ((_GLF_IDENTITY(int(_GLF_IDENTITY(2, (2) | (_GLF_IDENTITY(2, (0 & -14089) ^ (_GLF_IDENTITY(2, clamp(2, 2, 2))))))), int(_GLF_IDENTITY(2, (_GLF_IDENTITY(2, int(ivec4(2, 1, 1, 0)))) << 0))))) | ((_GLF_IDENTITY(int(_GLF_IDENTITY(2, (2) | (_GLF_IDENTITY(2, (0 & -14089) ^ (_GLF_IDENTITY(2, clamp(2, 2, 2))))))), int(_GLF_IDENTITY(2, (_GLF_IDENTITY(2, int(ivec4(2, 1, 1, 0)))) << 0)))))), _GLF_IDENTITY((_GLF_IDENTITY(int(_GLF_IDENTITY(2, (2) | (_GLF_IDENTITY(2, (0 & -14089) ^ (_GLF_IDENTITY(2, clamp(2, 2, 2))))))), int(_GLF_IDENTITY(2, (_GLF_IDENTITY(2, int(ivec4(2, 1, 1, 0)))) << 0)))), _GLF_IDENTITY(int(ivec4((_GLF_IDENTITY(int(_GLF_IDENTITY(2, (2) | (_GLF_IDENTITY(2, (0 & -14089) ^ (_GLF_IDENTITY(2, clamp(2, 2, 2))))))), int(_GLF_IDENTITY(2, (_GLF_IDENTITY(2, int(ivec4(2, 1, 1, 0)))) << 0)))), 1, 0, 0)), ~ (~ (int(ivec4((_GLF_IDENTITY(int(_GLF_IDENTITY(2, (2) | (_GLF_IDENTITY(2, (0 & -14089) ^ (_GLF_IDENTITY(2, clamp(2, 2, 2))))))), int(_GLF_IDENTITY(2, (_GLF_IDENTITY(2, int(ivec4(2, 1, 1, 0)))) << 0)))), 1, 0, 0))))))))) - 0)))))))), _GLF_IDENTITY(((0 << _GLF_IDENTITY(int(2), int(2)))) / 1, min(((0 << _GLF_IDENTITY(int(2), int(2)))) / 1, _GLF_IDENTITY(((0 << _GLF_IDENTITY(int(2), int(2)))) / 1, 0 | (((0 << _GLF_IDENTITY(int(2), int(2)))) / 1)))))))))) / 1)))
        {
         case 42:
         bvec2 _GLF_SWITCH_0_0v[86], _GLF_SWITCH_0_1v, _GLF_SWITCH_0_2v[90];
         case 0:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         case 70:
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, true && (_GLF_IDENTITY(false, true && (false))))))
            continue;
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             continue;
            }
           barrier();
           if(_GLF_DEAD(false))
            barrier();
          }
         case 24:
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).x > injectionSwitch.y))))
          barrier();
         case 3:
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
          barrier();
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             continue;
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            return;
           barrier();
          }
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
         if(_GLF_DEAD(false))
          continue;
         case 21:
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, true && (_GLF_IDENTITY(false, bool(bvec3(false, false, true))))))))))
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           else
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, (injectionSwitch.y) + 0.0)))))
              barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           break;
          }
         if(_GLF_DEAD(false))
          break;
         case 87:
         case 40:
         if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
          break;
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          return;
         case 5:
         case 16:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, injectionSwitch.y, _GLF_IDENTITY(injectionSwitch.y, (injectionSwitch.y) / 1.0)))))))
          barrier();
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
          {
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), false || ((injectionSwitch.x > injectionSwitch.y)))), bool(bool(_GLF_FALSE(_GLF_IDENTITY(false, false || (false)), (injectionSwitch.x > injectionSwitch.y)))))))
            {
             if(_GLF_DEAD(false))
              return;
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               barrier();
              }
             else
              {
              }
            }
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         return;
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           continue;
          }
         break;
         case 34:
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
            {
             switch(_GLF_SWITCH(0))
              {
               case 91:
               if(_GLF_DEAD(false))
                barrier();
               mat2 _GLF_SWITCH_5_0v;
               if(_GLF_DEAD(false))
                barrier();
               case 0:
               case 26:
               case 95:
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 barrier();
                }
               case 34:
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(false))
                barrier();
               case 24:
               continue;
               break;
               case 13:
               if(_GLF_DEAD(false))
                barrier();
               47828;
               case 42:
               mat3x4(mat3x2(8.4, 2.5, 7148.1654, 8871.6930, 89.27, 908.744));
               default:
               1;
              }
            }
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           else
            {
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(false))
                barrier();
               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), int(1))), _GLF_IDENTITY(bool(bvec4(_GLF_IDENTITY(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), int(1))), (_injected_loop_counter != ((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), int(1)))) || false), false, false, true)), (bool(bvec4(_GLF_IDENTITY(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), int(1))), (_injected_loop_counter != ((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), int(1)))) || false), false, false, true))) || false))); _injected_loop_counter ++)
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
                  barrier();
                 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                  barrier();
                }
              }
             barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
            }
           break;
          }
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
           do
            {
             if(_GLF_IDENTITY(_GLF_DEAD(false), bool(bvec3(_GLF_IDENTITY(_GLF_DEAD(false), false || (_GLF_DEAD(false))), false, true))))
              barrier();
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                }
               else
                {
                 barrier();
                 if(_GLF_DEAD(false))
                  barrier();
                }
               if(_GLF_DEAD(false))
                barrier();
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           while(false)
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
              {
               if(_GLF_DEAD(false))
                barrier();
               return;
              }
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               for(int _injected_loop_counter = (1 | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 | 0)); _injected_loop_counter --)
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(false))
                  break;
                 if(_GLF_DEAD(false))
                  {
                   switch(_GLF_SWITCH(0))
                    {
                     case 66:
                     uvec4 _GLF_SWITCH_5_0v;
                     if(_GLF_DEAD(false))
                      barrier();
                     case 72:
                     vec4(-6979.0638, 6996.6216, -3.0, _GLF_IDENTITY(-7519.8492, max(_GLF_IDENTITY(-7519.8492, float(vec3(-7519.8492, 1.0, 0.0))), -7519.8492)));
                     if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))
                      barrier();
                     case 0:
                     case 2:
                     case 81:
                     case 20:
                     if(_GLF_DEAD(false))
                      barrier();
                     case 6:
                     case 61:
                     if(_GLF_DEAD(false))
                      barrier();
                     case 92:
                     case 19:
                     case 70:
                     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, (_GLF_IDENTITY(injectionSwitch.x, mix(float(injectionSwitch.x), float(_GLF_FUZZED(35.04)), bool(false)))) / _GLF_ONE(1.0, injectionSwitch.y)) > injectionSwitch.y))))
                        barrier();
                       barrier();
                       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), true && (! (false)))))))
                        barrier();
                      }
                     break;
                     case 82:
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                     mat4 _GLF_SWITCH_5_1v[87];
                     default:
                     _GLF_IDENTITY(1, max(1, 1));
                    }
                  }
                 if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, bool(bvec4(false, false, false, false)))) || false), (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                }
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))) || false)))
                  barrier();
                }
               for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(false))
                  break;
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               continue;
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (-78324 & 0)); _injected_loop_counter --)
              {
               switch(_GLF_SWITCH(0))
                {
                 case 0:
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   barrier();
                  }
                 break;
                 if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
                  barrier();
                 default:
                 1;
                }
              }
             if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, false || (_GLF_IDENTITY(false, false || (false)))), (_GLF_IDENTITY(false, false || (_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec3(false, false, true), bvec3(bvec3(bvec3(false, false, true))))))))) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                     if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))
                      {
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                          barrier();
                         return;
                        }
                       continue;
                      }
                     if(_GLF_DEAD(false))
                      barrier();
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(false))
                          continue;
                         break;
                        }
                       barrier();
                       if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), false || (_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (! (_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))))
                        return;
                      }
                     break;
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                   if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, false || (true))))
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                     barrier();
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                   else
                    {
                    }
                   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).x > injectionSwitch.y)), ! (_GLF_IDENTITY(! (_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).x > injectionSwitch.y))), bool(bvec3(! (_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).x > injectionSwitch.y))), false, false)))))))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     return;
                    }
                  }
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               barrier();
               if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, bool(bvec3(injectionSwitch.x > injectionSwitch.y, true, false)))))))
                break;
              }
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
             for(int _injected_loop_counter = _GLF_IDENTITY(0, 0 ^ (0)); _GLF_WRAPPED_LOOP(_injected_loop_counter < _GLF_IDENTITY(((1 << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), int(2))), (((1 << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), int(2)))) / 1)); _injected_loop_counter ++)
              {
               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                }
               else
                {
                 if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, (true) || false)))
                  {
                   do
                    {
                     if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))
                      {
                       if(_GLF_DEAD(false))
                        return;
                       break;
                       if(_GLF_DEAD(false))
                        barrier();
                      }
                     if(_GLF_WRAPPED_IF_TRUE(true))
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        continue;
                       if(_GLF_IDENTITY(_GLF_WRAPPED_IF_TRUE(true), ! (! (_GLF_WRAPPED_IF_TRUE(true)))))
                        {
                         if(_GLF_DEAD(false))
                          barrier();
                        }
                       else
                        {
                        }
                       if(_GLF_DEAD(false))
                        barrier();
                      }
                     else
                      {
                      }
                     barrier();
                     if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y))))
                      barrier();
                     if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ! (! ((injectionSwitch.x > injectionSwitch.y)))))))
                      barrier();
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      continue;
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                     if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec4(_GLF_IDENTITY(false, (false) && true), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), false, false)), (_GLF_IDENTITY(bool(bvec4(_GLF_IDENTITY(false, (false) && true), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), false, false)), (bool(bvec4(_GLF_IDENTITY(false, (false) && true), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), false, false))) && true)) && true))))
                      {
                       if(_GLF_DEAD(false))
                        barrier();
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(false))
                          {
                           do
                            {
                             barrier();
                            }
                           while(_GLF_WRAPPED_LOOP(false));
                          }
                         if(_GLF_DEAD(false))
                          return;
                         barrier();
                         if(_GLF_DEAD(false))
                          barrier();
                        }
                       if(_GLF_DEAD(false))
                        continue;
                       if(_GLF_DEAD(false))
                        barrier();
                       break;
                      }
                     do
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        barrier();
                       for(int _injected_loop_counter = (_GLF_IDENTITY(0 << _GLF_IDENTITY(int(7), int(7)), min(0 << _GLF_IDENTITY(int(7), int(7)), 0 << _GLF_IDENTITY(int(7), int(7))))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                        {
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          barrier();
                         if(_GLF_DEAD(false))
                          barrier();
                        }
                      }
                     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                    }
                   while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                  }
                 else
                  {
                  }
                 if(_GLF_DEAD(false))
                  barrier();
                }
              }
            }
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(false))
              barrier();
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (((_GLF_IDENTITY((1 << _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), int(ivec2(int(2), 0))))), clamp((1 << _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), int(ivec2(int(2), 0))))), (1 << _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), int(ivec2(int(2), 0))))), (1 << _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), int(ivec2(int(2), 0))))))) >> _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), clamp(int(2), _GLF_IDENTITY(int(2), 0 + (int(2))), _GLF_IDENTITY(int(2), ~ (~ (int(2)))))))) << _GLF_IDENTITY(int(5), _GLF_IDENTITY(_GLF_IDENTITY(int(5), 0 ^ (int(5))), (int(5)) << 0))) >> _GLF_IDENTITY(int(5), int(5)))); _injected_loop_counter ++)
              {
               barrier();
              }
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
            }
           else
            {
             switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
              {
               case 26:
               uvec2 _GLF_SWITCH_5_0v[59], _GLF_SWITCH_5_1v, _GLF_SWITCH_5_2v;
               if(_GLF_DEAD(false))
                barrier();
               case 0:
               case 21:
               case 45:
               case 43:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               case 50:
               barrier();
               break;
               default:
               1;
              }
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && true))
            barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         case 41:
         if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, true && (_GLF_IDENTITY(true, (true) || false)))))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             barrier();
            }
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
          }
         else
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             barrier();
            }
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, ! (! (false)))) && true)))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             continue;
            }
           continue;
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           else
            {
            }
          }
         uvec4 _GLF_SWITCH_0_3v[81];
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            barrier();
           break;
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            barrier();
           break;
          }
         do
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, min(_GLF_IDENTITY(injectionSwitch, (injectionSwitch) / cos(vec2(0.0, 0.0))), injectionSwitch)).y))))
              barrier();
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               barrier();
              }
             else
              {
              }
            }
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(_GLF_IDENTITY(false, bool(bvec4(_GLF_IDENTITY(false, true && (false)), true, false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))), (injectionSwitch.x > injectionSwitch.y))));
         default:
         if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), false || ((_GLF_IDENTITY(injectionSwitch.x, float(_GLF_IDENTITY(mat3x2(_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) / 1.0), 0.0, 1.0, 1.0, log(1.0), determinant(mat3(0.0, 0.0, abs(1.0), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0))), transpose(transpose(mat3x2(_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) / 1.0), 0.0, 1.0, 1.0, log(1.0), determinant(mat3(0.0, 0.0, abs(1.0), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)))))))) > injectionSwitch.y))))))
          barrier();
         do
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             barrier();
            }
           if(_GLF_DEAD(false))
            barrier();
          }
         while(_GLF_WRAPPED_LOOP(false));
         1;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             barrier();
            }
          }
         if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false))))))))
          {
           if(_GLF_DEAD(false))
            barrier();
           barrier();
          }
         if(_GLF_DEAD(false))
          break;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, injectionSwitch.y, _GLF_IDENTITY(injectionSwitch.y, min(_GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y)), injectionSwitch.y))))))))
          barrier();
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_IDENTITY(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), bool(_GLF_IDENTITY(bvec2(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), false), bvec2(bvec3(bvec2(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, mix(float(injectionSwitch.x), float(_GLF_FUZZED((7.0 - -2.6))), bool(false))) > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), false || (_GLF_IDENTITY(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, mix(float(injectionSwitch.x), float(_GLF_FUZZED((7.0 - -2.6))), bool(false))) > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))), false), false)))))) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))
          {
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             barrier();
            }
           else
            {
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
        }
      }
     while(_GLF_WRAPPED_LOOP(false));
     case 53:
     case 83:
     case 29:
     if(_GLF_DEAD(false))
      barrier();
     case 85:
     if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, _GLF_IDENTITY(float(mat2(injectionSwitch.x, 0.0, 0.0, 0.0)), max(float(mat2(injectionSwitch.x, 0.0, 0.0, 0.0)), float(mat2(injectionSwitch.x, 0.0, 0.0, 0.0))))) > injectionSwitch.y))))
      {
       if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec3(_GLF_IDENTITY(false, true && (false)), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false), bvec3(bvec3(bvec3(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false))))))))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            return;
           do
            {
             barrier();
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(false))
          barrier();
        }
       else
        {
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             barrier();
            }
          }
         barrier();
        }
       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false || (_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) ? _GLF_FUZZED(injectionSwitch) : injectionSwitch)).y))))))
        {
         if(_GLF_DEAD(false))
          return;
         if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (! (_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
          barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, min(injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y))))
          barrier();
         barrier();
        }
      }
     break;
     case 95:
     do
      {
       mat3x2 _GLF_SWITCH_4_1v, _GLF_SWITCH_4_2v;
      }
     while((73177 < 46886));
     default:
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
       if(_GLF_DEAD(false))
        return;
      }
     else
      {
       1;
      }
    }
   if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))
    barrier();
  }
 do
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
       if(_GLF_DEAD(false))
        barrier();
      }
     else
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         do
          {
           barrier();
           if(_GLF_DEAD(false))
            barrier();
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
       if(_GLF_DEAD(false))
        barrier();
      }
     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
      {
       switch(_GLF_SWITCH(0))
        {
         case 88:
         mat3x4 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v[23], _GLF_SWITCH_5_2v[58];
         case 66:
         if(_GLF_DEAD(false))
          barrier();
         if((-4.7 >= -4142.2495))
          {
           for(uvec4 _GLF_SWITCH_5_3v, _GLF_SWITCH_5_4v; true; clamp(uvec2(171283u, 99153u), 73813u, num_workgroup).gg)
            {
             (mat4x2(-3.5, 4.1, 3.8, -6.6, -8699.4438, -6.7, -362.896, 0.8) - -7992.4358);
             vec3 _GLF_SWITCH_5_5v, _GLF_SWITCH_5_6v, _GLF_SWITCH_5_7v;
             bvec2 _GLF_SWITCH_5_8v[28], _GLF_SWITCH_5_9v;
             if(_GLF_DEAD(false))
              barrier();
             uvec2(124375u, 35165u);
             if(_GLF_DEAD(false))
              barrier();
             mat4 _GLF_SWITCH_5_10v, _GLF_SWITCH_5_11v, _GLF_SWITCH_5_12v;
             mat2x3 _GLF_SWITCH_5_13v, _GLF_SWITCH_5_14v;
             injectionSwitch;
            }
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_IDENTITY(bool(bvec3(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), true, false)), (bool(bvec3(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), true, false))) && true))))
            barrier();
           ;
           if(_GLF_DEAD(false))
            barrier();
           uvec2 _GLF_SWITCH_5_15v, _GLF_SWITCH_5_16v, _GLF_SWITCH_5_17v;
           ivec3 _GLF_SWITCH_5_18v, _GLF_SWITCH_5_19v[43];
           if(_GLF_DEAD(false))
            barrier();
           mat2 _GLF_SWITCH_5_20v;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           (mat4x3(-7.7, -9.0, 9871.9848, -9.9, -2.4, 7898.6625, 17.73, -6.6, -6272.4937, -0.7, 8.7, -27.33) + -5.5);
           mat4x3 _GLF_SWITCH_5_21v[47], _GLF_SWITCH_5_22v;
          }
         else
          {
           float _GLF_SWITCH_5_23v, _GLF_SWITCH_5_24v, _GLF_SWITCH_5_25v[13];
           if((bvec4(true, _GLF_IDENTITY(true, ! (! (true))), false, true) != bvec4((uvec4(170448u, 152516u, 32858u, 14311u) , bvec2(true, true)), bvec2(false, true))))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))
              barrier();
             unpackUnorm2x16(subgroup_local_id);
             mat4 _GLF_SWITCH_5_26v, _GLF_SWITCH_5_27v;
             uvec2 _GLF_SWITCH_5_28v, _GLF_SWITCH_5_29v[10], _GLF_SWITCH_5_30v[5];
             _GLF_SWITCH_5_28v;
             uvec4(_GLF_IDENTITY(199594u, ~ (_GLF_IDENTITY(~ (_GLF_IDENTITY(199594u, (199594u) | uint(_GLF_ZERO(0.0, injectionSwitch.x)))), (~ (_GLF_IDENTITY(199594u, (199594u) | uint(_GLF_ZERO(0.0, injectionSwitch.x))))) >> 0u))), 49716u, 96087u, 154995u);
             if(_GLF_DEAD(false))
              barrier();
            }
           else
            {
             uvec2 _GLF_SWITCH_5_31v;
             34814;
             mat3 _GLF_SWITCH_5_32v[85], _GLF_SWITCH_5_33v[87];
             (ivec3(27752, -1619, 56340) >> ivec3(-31685, -58746, -572));
             mat2x3(mat4(969.557, -7842.2500, 8638.6720, -0.6, 1.8, 5662.7308, 70.61, -3.4, -74.05, -466.564, 7.8, -8551.0533, 5.3, 2841.0709, -4.5, 2038.5259));
             ivec3(-29861, -14272, -10121);
             bvec4 _GLF_SWITCH_5_34v, _GLF_SWITCH_5_35v;
            }
           {
            false;
            uvec3(41800u, 138566u, 34423u);
            (injectionSwitch * -23.80);
            ;
            if(_GLF_DEAD(false))
             barrier();
            bvec3 _GLF_SWITCH_5_36v[60], _GLF_SWITCH_5_37v;
            lessThanEqual(sign(ivec2(46025, 33397)), ivec2(38770, -8098));
            if(_GLF_DEAD(false))
             barrier();
            bvec2(false, true);
            mat4 _GLF_SWITCH_5_38v, _GLF_SWITCH_5_39v, _GLF_SWITCH_5_40v[63];
            ;
           }
           (ivec2(58989, 66362) & -75492);
           for(mat3 _GLF_SWITCH_5_41v[70]; isinf(-4.9); findMSB(uvec4(166272u, 74693u, 6721u, 856u)))
            {
             false;
             mat2x3 _GLF_SWITCH_5_42v;
             (mat3(2058.8375, 932.904, -3.8, 99.08, 2.7, 4.9, -1940.2421, -8.9, -6.0) / 8.3);
            }
           mat3 _GLF_SWITCH_5_43v, _GLF_SWITCH_5_44v[25], _GLF_SWITCH_5_45v;
           if(false)
            {
             (false ? uvec4(62391u, 3199u, 85181u, 157203u) : uvec4(34670u, 23406u, 75221u, 145771u));
             _GLF_SWITCH_5_23v;
            }
           else
            {
             mat2x4(-713.065, 57.29, -10.33, -2.5, 1870.3182, -5748.4751, 21.27, 8212.8849);
             mat2x3 _GLF_SWITCH_5_46v[98], _GLF_SWITCH_5_47v, _GLF_SWITCH_5_48v;
             if(_GLF_DEAD(false))
              barrier();
             (bvec4(true, false, true, false) , mat2(-1199.4211, 6.6, -5.7, 7.2));
             isinf((_GLF_SWITCH_5_47v * injectionSwitch));
             (_GLF_IDENTITY(false, bool(bool(false))) ? _GLF_SWITCH_5_45v : mat3(mat2x4(-67.24, -8.7, 323.005, 7.1, -4.2, 9675.0455, -3.0, 257.068)));
             if(_GLF_DEAD(false))
              barrier();
             vec2(-1965.0436, 0.5);
            }
           if((_GLF_SWITCH_5_23v != -2706.8834))
            {
             uvec4(161627u, 51218u, 145073u, 117092u);
             ivec3(-13999, -22184, _GLF_IDENTITY(93414, (93414) - 0))[2];
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             (ivec4(97422, -50073, 15423, _GLF_IDENTITY(-57558, (-57558) + ((0 >> _GLF_IDENTITY(int(6), int(6))) >> _GLF_IDENTITY(int(3), _GLF_IDENTITY(int(3), (int(3)) | 0))))) | -25988);
             mat3(0.7, 1.8, 7.8, -6819.7624, 0.3, 2.9, 7.8, 6636.4877, -2.4);
             mat3x2 _GLF_SWITCH_5_49v;
            }
           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
            barrier();
           ivec3 _GLF_SWITCH_5_50v, _GLF_SWITCH_5_51v, _GLF_SWITCH_5_52v[61];
          }
         if(_GLF_DEAD(false))
          barrier();
         case 0:
         case 40:
         case 35:
         case 50:
         case 32:
         case 65:
         case 2:
         case 25:
         case 43:
         case 84:
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           do
            {
             barrier();
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
         else
          {
          }
         break;
         case 78:
         vec3(-985.009, -43.78, 229.785);
         default:
         1;
        }
      }
     if(_GLF_DEAD(false))
      {
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
        {
         barrier();
        }
       if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ((injectionSwitch.x > injectionSwitch.y)) || false))))
        barrier();
      }
     return;
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        {
         do
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         while(_GLF_WRAPPED_LOOP(false));
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
          {
           do
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
           while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec4(false, false, true, false)), ! (! (bool(bvec4(false, false, true, false))))))));
           if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY((_GLF_IDENTITY(false, bool(bvec3(false, false, true)))), ! (! ((_GLF_IDENTITY(false, bool(bvec3(false, false, true))))))) && true)))
            break;
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_DEAD(false))
          return;
        }
       if(_GLF_DEAD(false))
        barrier();
      }
     else
      {
      }
    }
   if(_GLF_DEAD(false))
    barrier();
  }
 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, ! (! (false))))))))
    barrier();
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     return;
    }
  }
 else
  {
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(false))
    barrier();
   return;
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 uint workgroup_base = _GLF_IDENTITY(workgroup_size, (workgroup_size) / 1u) * workgroup_id;
 if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, (true ? _GLF_IDENTITY(injectionSwitch, vec2(_GLF_IDENTITY(injectionSwitch[0], 1.0 * (_GLF_IDENTITY(injectionSwitch[0], (false ? _GLF_FUZZED(-10.23) : injectionSwitch[0])))), _GLF_IDENTITY(injectionSwitch, vec2(0.0, 0.0) + (_GLF_IDENTITY(injectionSwitch, max(injectionSwitch, injectionSwitch))))[1])) : _GLF_FUZZED(injectionSwitch))).x > _GLF_IDENTITY(injectionSwitch, (true ? injectionSwitch : _GLF_FUZZED(vec2(-13.98, 9.1)))).y))))
  barrier();
 if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), true, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))))
  barrier();
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   barrier();
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))
    return;
   if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, bool(bvec3(false, true, false)))) || _GLF_IDENTITY(false, bool(bvec4(false, false, _GLF_IDENTITY(false, ! (! (false))), true))))))
    {
     for(int _injected_loop_counter = _GLF_IDENTITY((0 | 0), (true ? _GLF_IDENTITY((0 | 0), ((0 | 0)) | 0) : _GLF_FUZZED(33637))); _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(7), int(7))) >> _GLF_IDENTITY(int(7), int(7)))); _injected_loop_counter ++)
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         return;
        }
       barrier();
      }
    }
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    barrier();
   return;
   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, true && (false)), true && (_GLF_IDENTITY(false, true && (false))))))
    {
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true && (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            barrier();
           barrier();
           if(_GLF_DEAD(false))
            return;
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
          }
        }
       barrier();
      }
     if(_GLF_DEAD(false))
      barrier();
     return;
     if(_GLF_DEAD(false))
      return;
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(false))
      barrier();
     return;
     if(_GLF_DEAD(false))
      barrier();
    }
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     barrier();
     if(_GLF_DEAD(false))
      barrier();
    }
   else
    {
    }
  }
 uint subgroup_base = subgroup_id * subgroup_size;
 uint virtual_gid = workgroup_base + subgroup_base + _GLF_IDENTITY(subgroup_local_id, min(_GLF_IDENTITY(subgroup_local_id, clamp(subgroup_local_id, subgroup_local_id, subgroup_local_id)), _GLF_IDENTITY(subgroup_local_id, (subgroup_local_id) | (subgroup_local_id))));
 uint next_virtual_gid = workgroup_base + subgroup_base + ((subgroup_local_id + 1) % subgroup_size);
 if(_GLF_DEAD(false))
  barrier();
 atomicStore(buf[virtual_gid], uint(1), 4, 64, 4);
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    barrier();
   barrier();
  }
 do
  {
   if(_GLF_DEAD(false))
    barrier();
   do
    {
     if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(vec2(vec3(_GLF_IDENTITY(injectionSwitch, vec2(mat2x3(injectionSwitch, 1.0, 1.0, determinant(mat3(1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0)), 0.0))), 1.0)), clamp(vec2(vec3(injectionSwitch, 1.0)), vec2(vec3(injectionSwitch, 1.0)), vec2(vec3(injectionSwitch, 1.0))))).y)), bool(bvec2(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ((injectionSwitch.x > injectionSwitch.y)) && _GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (true), (! (true)) || false))))), false)))))
      {
       switch(_GLF_SWITCH(0))
        {
         case 31:
         do
          {
           vec3 _GLF_SWITCH_5_0v;
           mat2(-8921.3039, -2310.3185, -4.3, -0.1);
           ;
           if(_GLF_DEAD(false))
            barrier();
           vec2(-10.50, 3.7);
           ;
           injectionSwitch;
           ;
           vec3 _GLF_SWITCH_5_1v, _GLF_SWITCH_5_2v;
           normalize(vec4(-9547.3801, -1869.1024, 7793.0260, -15.37));
           if(_GLF_DEAD(false))
            barrier();
          }
         while((mat2x3(-8381.8089, 35.20, 25.88, 1.8, -2.7, 9753.7387) != mat2x3(0.4, -4780.8723, -249.484, -43.92, -8.5, _GLF_IDENTITY(-889.089, 0.0 + (-889.089)))));
         case 0:
         case 83:
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(false))
          return;
         case 89:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         switch(_GLF_SWITCH(0))
          {
           case 0:
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            barrier();
           case 53:
           if(_GLF_DEAD(false))
            {
             switch(_GLF_SWITCH((_GLF_IDENTITY(int(187665u) & 0, int(int(int(187665u) & 0))))))
              {
               case 32:
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               mat3 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v[11];
               case 0:
               case 60:
               case 57:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, (_GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, injectionSwitch.y, injectionSwitch.y))) + 0.0)))))
                {
                 switch(_GLF_SWITCH((0 << _GLF_IDENTITY(int(_GLF_IDENTITY(3, (3) >> 0)), int(3)))))
                  {
                   case 0:
                   case 4:
                   if(_GLF_DEAD(false))
                    continue;
                   for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != ((0 | 0) << _GLF_IDENTITY(int(8), int(8)))); _injected_loop_counter --)
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      return;
                    }
                   barrier();
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     break;
                    }
                   break;
                   default:
                   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), int(0)))); _injected_loop_counter ++)
                    {
                     if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))
                      barrier();
                     1;
                    }
                  }
                }
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(false))
                barrier();
               case 38:
               case 64:
               barrier();
               if(_GLF_DEAD(false))
                barrier();
               break;
               case 63:
               vec4(-0.7, 1114.6650, 5.3, -4858.0047);
               case 51:
               for(               vec4(8.3, 746.669, 32.05, 5.2);
 mix(true, true, false); mat4x2(5574.1118, 5611.2119, -9.4, 8052.0530, -74.48, 8563.4640, -80.19, -4276.1568))
                {
                }
               default:
               1;
              }
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
            }
           else
            {
             if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))
              {
               if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, ! (! (false))))))))
                barrier();
               barrier();
              }
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              break;
             barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
             break;
            }
           barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             if(_GLF_DEAD(false))
              {
               do
                {
                 return;
                 if(_GLF_IDENTITY(_GLF_DEAD(false), _GLF_IDENTITY(bool(bool(_GLF_IDENTITY(_GLF_DEAD(false), bool(bvec3(_GLF_DEAD(false), false, false))))), bool(bvec4(bool(bool(_GLF_IDENTITY(_GLF_DEAD(false), bool(bvec3(_GLF_DEAD(false), false, false))))), true, false, false)))))
                  barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             if(_GLF_DEAD(false))
              continue;
             barrier();
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
            {
             switch(_GLF_SWITCH((0 >> _GLF_IDENTITY(int(3), _GLF_IDENTITY(int(3), max(int(3), int(3)))))))
              {
               case 0:
               case 49:
               case 83:
               case 41:
               case 69:
               case 26:
               do
                {
                 switch(_GLF_SWITCH(0))
                  {
                   case 0:
                   case 66:
                   if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, ! (! (false))), (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                     barrier();
                    }
                   case 6:
                   if(_GLF_DEAD(false))
                    barrier();
                   case 98:
                   barrier();
                   break;
                   case 21:
                   ivec2 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v, _GLF_SWITCH_4_2v;
                   if(_GLF_DEAD(false))
                    barrier();
                   default:
                   1;
                  }
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
               break;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               case 86:
               uint _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v, _GLF_SWITCH_5_2v[64];
               case 12:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               mat2x4 _GLF_SWITCH_5_3v, _GLF_SWITCH_5_4v[85];
               default:
               if(_GLF_DEAD(false))
                barrier();
               1;
              }
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             barrier();
            }
           break;
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
            barrier();
           default:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             barrier();
            }
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              {
               do
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
                  break;
                 barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
            }
           else
            {
            }
           1;
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, false)))))
              continue;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             barrier();
            }
           do
            {
             if(_GLF_DEAD(false))
              {
               for(int _injected_loop_counter = (0 | int(_GLF_ZERO(0.0, injectionSwitch.x))); _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(7), int(7))) >> _GLF_IDENTITY(int(7), int(7)))); _injected_loop_counter ++)
                {
                 if(_GLF_DEAD(false))
                  continue;
                 if(_GLF_DEAD(false))
                  barrier();
                 return;
                }
              }
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
         case 61:
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
         case 74:
         case 7:
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
         break;
         case 68:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         while(any(bvec3(true, false, false)))
          {
           mat4x3(71.36, -9799.4404, -37.07, 7829.4010, 6.1, 872.727, 9021.7103, 4185.6361, -7865.0356, -9.8, 5491.3912, -2.9);
           ;
           if(_GLF_DEAD(false))
            barrier();
           uint _GLF_SWITCH_5_3v, _GLF_SWITCH_5_4v, _GLF_SWITCH_5_5v[44];
           mat3x4(mat3x2(-62.75, -12.20, -1834.2021, 2168.3891, 18.85, -590.547));
           bvec2 _GLF_SWITCH_5_6v, _GLF_SWITCH_5_7v, _GLF_SWITCH_5_8v;
          }
         default:
         if(_GLF_DEAD(false))
          barrier();
         1;
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
    }
   while(_GLF_WRAPPED_LOOP(false));
   if(_GLF_DEAD(false))
    barrier();
  }
 while(_GLF_WRAPPED_LOOP(false));
 if(_GLF_DEAD(false))
  {
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       continue;
      }
     barrier();
    }
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY((_GLF_IDENTITY(false, (_GLF_IDENTITY(false, (_GLF_IDENTITY(false, true && (false))) && true)) && true)), false || ((_GLF_IDENTITY(false, (false) && true)))) && true)))
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         return;
        }
      }
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       barrier();
      }
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter, (true ? _injected_loop_counter : _GLF_FUZZED(_injected_loop_counter))) != 0); _injected_loop_counter --)
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         barrier();
        }
      }
     else
      {
      }
     if(_GLF_DEAD(false))
      barrier();
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
    }
   else
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
        barrier();
       return;
      }
     if(_GLF_DEAD(false))
      barrier();
    }
   if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, false || (true))))
    {
     if(_GLF_DEAD(false))
      return;
    }
   else
    {
    }
  }
 if(_GLF_DEAD(false))
  barrier();
 do
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      return;
     barrier();
    }
  }
 while(_GLF_WRAPPED_LOOP(false));
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
  }
 else
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        barrier();
       barrier();
       if(_GLF_DEAD(false))
        barrier();
      }
    }
  }
 if((subgroup_local_id % _GLF_IDENTITY(2, min(2, 2))) == 0)
  {
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     switch(_GLF_SWITCH(_GLF_IDENTITY(int(_GLF_ZERO(0.0, injectionSwitch.x)), (_GLF_IDENTITY(int(_GLF_ZERO(0.0, injectionSwitch.x)), (int(_GLF_ZERO(0.0, injectionSwitch.x))) / 1)) | 0)))
      {
       case 0:
       if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
        barrier();
       case 36:
       if(_GLF_IDENTITY(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec3(false, true, true), bvec3(bvec4(bvec3(false, true, true), true)))))), (_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec3(false, true, true), bvec3(bvec4(bvec3(false, true, true), true))))))) && true))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         return;
        }
       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(_GLF_IDENTITY(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, false), bvec3(bvec4(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, false), true))))), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true), true && (_GLF_IDENTITY(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, clamp(injectionSwitch.x, _GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, injectionSwitch.x)), injectionSwitch.x)) > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true)))))
        barrier();
       if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
        {
         if(_GLF_DEAD(false))
          barrier();
         barrier();
        }
       if(_GLF_DEAD(false))
        barrier();
       case 9:
       if(_GLF_DEAD(false))
        barrier();
       do
        {
         if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, false || (false)), (injectionSwitch.x > injectionSwitch.y))))
          barrier();
        }
       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
       if(_GLF_DEAD(false))
        return;
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (injectionSwitch.x > injectionSwitch.y))))))
          {
           if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(_GLF_IDENTITY(true, bool(bvec2(_GLF_IDENTITY(true, _GLF_IDENTITY(bool(bvec4(_GLF_IDENTITY(true, ! (! (true))), false, false, false)), (bool(bvec4(_GLF_IDENTITY(true, ! (! (true))), false, false, false))) && true)), true))), bool(bvec2(true, true)))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             barrier();
            }
           else
            {
            }
          }
        }
       else
        {
        }
       case 8:
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         barrier();
        }
       case 45:
       if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
        barrier();
       atomicStore(buf[next_virtual_gid], uint(_GLF_IDENTITY(2, (2) | (2))), 4, 64, 4);
       if(_GLF_DEAD(false))
        barrier();
       break;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          return;
         for(int _injected_loop_counter = (0 | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
          {
           return;
          }
         if(_GLF_DEAD(false))
          barrier();
        }
       case 65:
       if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, ! (! (injectionSwitch.x > injectionSwitch.y)))), ! (! ((_GLF_IDENTITY(injectionSwitch.x, clamp(injectionSwitch.x, injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y)))))))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           return;
          }
         else
          {
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        continue;
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(false))
              return;
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
              }
             else
              {
               barrier();
              }
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           return;
          }
         if(_GLF_IDENTITY(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)), ! (! (_GLF_DEAD(_GLF_IDENTITY(false, (false) || false))))))
          barrier();
        }
       else
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
        }
       else
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(43.67), _GLF_FUZZED((- -4.3))), vec2(_GLF_IDENTITY((injectionSwitch), (_GLF_IDENTITY((injectionSwitch), vec2(1.0, 1.0) * ((injectionSwitch)))) * vec2(1.0, 1.0))[0], (injectionSwitch)[1]), bvec2(_GLF_IDENTITY(true, true && (true)), true))).x, (true ? _GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(43.67), _GLF_FUZZED((- -4.3))), vec2(_GLF_IDENTITY((injectionSwitch), (_GLF_IDENTITY((injectionSwitch), vec2(1.0, 1.0) * ((injectionSwitch)))) * vec2(1.0, 1.0))[0], (injectionSwitch)[1]), bvec2(_GLF_IDENTITY(true, true && (true)), true))).x : _GLF_FUZZED(-529.099))) > _GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(_GLF_IDENTITY(mat2(_GLF_ONE(1.0, injectionSwitch.y)), (mat2(_GLF_ONE(1.0, injectionSwitch.y))) - mat2(0.0, 0.0, 0.0, 0.0)) * (injectionSwitch), clamp(mat2(_GLF_ONE(1.0, injectionSwitch.y)) * (injectionSwitch), _GLF_IDENTITY(mat2(_GLF_IDENTITY(_GLF_ONE(1.0, injectionSwitch.y), min(_GLF_IDENTITY(_GLF_ONE(1.0, injectionSwitch.y), 1.0 * (_GLF_ONE(1.0, injectionSwitch.y))), _GLF_IDENTITY(_GLF_ONE(1.0, injectionSwitch.y), 0.0 + (_GLF_ONE(1.0, injectionSwitch.y)))))) * (injectionSwitch), vec2(1.0, 1.0) * (mat2(_GLF_ONE(1.0, injectionSwitch.y)) * (injectionSwitch))), mat2(_GLF_ONE(1.0, injectionSwitch.y)) * (injectionSwitch)))).y), _GLF_IDENTITY(true && (_GLF_IDENTITY((_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(43.67), _GLF_IDENTITY(_GLF_FUZZED((- -4.3)), min(_GLF_FUZZED((- -4.3)), _GLF_FUZZED((- -4.3))))), vec2(_GLF_IDENTITY((injectionSwitch), (_GLF_IDENTITY((injectionSwitch), vec2(1.0, 1.0) * _GLF_IDENTITY(((injectionSwitch)), clamp(((injectionSwitch)), ((injectionSwitch)), ((injectionSwitch)))))) * vec2(1.0, 1.0))[0], (injectionSwitch)[1]), bvec2(_GLF_IDENTITY(true, true && (true)), true))).x > _GLF_IDENTITY(injectionSwitch.y, (true ? injectionSwitch.y : _GLF_FUZZED(uintBitsToFloat(workgroup_base))))), bool(bvec2((_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(43.67), _GLF_FUZZED((- -4.3))), vec2(_GLF_IDENTITY((injectionSwitch), (_GLF_IDENTITY((injectionSwitch), vec2(1.0, 1.0) * ((injectionSwitch)))) * vec2(1.0, 1.0))[0], (injectionSwitch)[1]), bvec2(_GLF_IDENTITY(true, true && (true)), true))).x > injectionSwitch.y), true)))), _GLF_IDENTITY(bool(bvec2(true && (_GLF_IDENTITY(_GLF_IDENTITY((_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(43.67), _GLF_FUZZED((- -4.3))), vec2(_GLF_IDENTITY(_GLF_IDENTITY((injectionSwitch), (_GLF_IDENTITY((injectionSwitch), vec2(1.0, 1.0) * ((injectionSwitch)))) * vec2(1.0, 1.0))[0], clamp(_GLF_IDENTITY((injectionSwitch), (_GLF_IDENTITY((injectionSwitch), vec2(1.0, 1.0) * ((injectionSwitch)))) * vec2(1.0, 1.0))[0], _GLF_IDENTITY((injectionSwitch), (_GLF_IDENTITY((injectionSwitch), vec2(1.0, 1.0) * ((injectionSwitch)))) * vec2(1.0, 1.0))[0], _GLF_IDENTITY((injectionSwitch), (_GLF_IDENTITY((injectionSwitch), vec2(1.0, 1.0) * ((injectionSwitch)))) * vec2(1.0, 1.0))[0])), (injectionSwitch)[1]), bvec2(_GLF_IDENTITY(true, true && (true)), true))).x > injectionSwitch.y), ((_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(43.67), _GLF_FUZZED((- -4.3))), vec2(_GLF_IDENTITY(_GLF_IDENTITY((injectionSwitch), (_GLF_IDENTITY((injectionSwitch), vec2(1.0, 1.0) * ((injectionSwitch)))) * vec2(1.0, 1.0))[0], clamp(_GLF_IDENTITY((injectionSwitch), (_GLF_IDENTITY((injectionSwitch), vec2(1.0, 1.0) * ((injectionSwitch)))) * vec2(1.0, 1.0))[0], _GLF_IDENTITY((injectionSwitch), (_GLF_IDENTITY((injectionSwitch), vec2(1.0, 1.0) * ((injectionSwitch)))) * vec2(1.0, 1.0))[0], _GLF_IDENTITY((injectionSwitch), (_GLF_IDENTITY((injectionSwitch), vec2(1.0, 1.0) * ((injectionSwitch)))) * vec2(1.0, 1.0))[0])), (injectionSwitch)[1]), bvec2(_GLF_IDENTITY(true, true && (true)), true))).x > injectionSwitch.y)) && true), bool(bvec2((_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(43.67), _GLF_FUZZED((- -4.3))), vec2(_GLF_IDENTITY((injectionSwitch), (_GLF_IDENTITY((injectionSwitch), vec2(1.0, 1.0) * ((injectionSwitch)))) * vec2(1.0, 1.0))[0], (injectionSwitch)[1]), bvec2(_GLF_IDENTITY(true, true && (true)), true))).x > injectionSwitch.y), true)))), true)), ! (! (bool(bvec2(true && (_GLF_IDENTITY((_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_IDENTITY(_GLF_FUZZED(43.67), mix(float(_GLF_FUZZED((- -2236.8121))), float(_GLF_FUZZED(43.67)), bool(true))), _GLF_FUZZED(_GLF_IDENTITY((- -4.3), float(float((- -4.3)))))), vec2(_GLF_IDENTITY((injectionSwitch), (_GLF_IDENTITY((injectionSwitch), vec2(1.0, 1.0) * ((injectionSwitch)))) * vec2(1.0, 1.0))[0], (injectionSwitch)[1]), bvec2(_GLF_IDENTITY(true, true && (true)), true))).x > injectionSwitch.y), bool(bvec2((_GLF_IDENTITY(injectionSwitch, mix(vec2(_GLF_FUZZED(43.67), _GLF_FUZZED((- -4.3))), vec2(_GLF_IDENTITY((injectionSwitch), (_GLF_IDENTITY((injectionSwitch), _GLF_IDENTITY(vec2(1.0, 1.0), (vec2(1.0, 1.0)) + vec2(0.0, 0.0)) * ((_GLF_IDENTITY(injectionSwitch, (_GLF_IDENTITY(injectionSwitch, (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) ? injectionSwitch : _GLF_FUZZED(vec2(2.7, 4026.0009))))) + vec2(0.0, 0.0)))))) * vec2(1.0, 1.0))[0], (injectionSwitch)[1]), bvec2(_GLF_IDENTITY(true, true && (true)), true))).x > _GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y))), true)))), true))))))))))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             continue;
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(8), int(8))); _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter, _GLF_IDENTITY(int(_GLF_IDENTITY(ivec2(_GLF_IDENTITY(_injected_loop_counter, max(_injected_loop_counter, _injected_loop_counter)), 1), (_GLF_IDENTITY(ivec2(_GLF_IDENTITY(_injected_loop_counter, max(_injected_loop_counter, _injected_loop_counter)), 1), ~ (~ (ivec2(_GLF_IDENTITY(_injected_loop_counter, max(_injected_loop_counter, _injected_loop_counter)), 1))))) | (ivec2(_GLF_IDENTITY(_injected_loop_counter, max(_injected_loop_counter, _injected_loop_counter)), 1)))), (false ? _GLF_FUZZED(_injected_loop_counter) : int(_GLF_IDENTITY(ivec2(_GLF_IDENTITY(_injected_loop_counter, max(_injected_loop_counter, _injected_loop_counter)), 1), (_GLF_IDENTITY(ivec2(_GLF_IDENTITY(_injected_loop_counter, max(_injected_loop_counter, _injected_loop_counter)), 1), ~ (~ (ivec2(_GLF_IDENTITY(_injected_loop_counter, max(_injected_loop_counter, _injected_loop_counter)), 1))))) | (ivec2(_GLF_IDENTITY(_injected_loop_counter, max(_injected_loop_counter, _injected_loop_counter)), 1))))))) < 1); _injected_loop_counter ++)
              {
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), (_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ((injectionSwitch.x > injectionSwitch.y)) || false)) || false))))
                barrier();
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                barrier();
               barrier();
              }
             else
              {
              }
            }
           if(_GLF_DEAD(false))
            barrier();
           switch(_GLF_SWITCH(_GLF_IDENTITY(_GLF_IDENTITY(0, (0) - 0), (_GLF_IDENTITY(_GLF_IDENTITY(0, (0) - 0), (_GLF_IDENTITY(0, (0) - 0)) - 0)) << (0 << _GLF_IDENTITY(int(0), int(0))))))
            {
             case 24:
             if(_GLF_DEAD(false))
              barrier();
             (mat2x4(_GLF_IDENTITY(106.194, float(mat2(106.194, _GLF_ZERO(0.0, injectionSwitch.x), 1.0, sqrt(1.0)))), -17.10, 751.138, 891.989, 3.6, -26.44, -28.66, 1.5) + 2.4);
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
               else
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
              }
             case 92:
             do
              {
               switch(_GLF_SWITCH(0))
                {
                 case 0:
                 case 11:
                 case 85:
                 case 83:
                 case 32:
                 case 94:
                 case 8:
                 case 66:
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   barrier();
                  }
                 if(_GLF_DEAD(false))
                  barrier();
                 break;
                 case 74:
                 mat4x3 _GLF_SWITCH_5_0v[39];
                 case 24:
                 uvec2 _GLF_SWITCH_5_1v;
                 default:
                 1;
                }
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                }
               else
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   barrier();
                  }
                 if(_GLF_DEAD(false))
                  barrier();
                }
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 barrier();
                }
              }
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 return;
                }
               else
                {
                }
              }
             (29.74 - mat4x3(6.0, -7528.8075, 61.02, -9653.7070, -6.4, -0.6, -1657.4237, _GLF_IDENTITY(-34.69, clamp(-34.69, -34.69, -34.69)), 7.8, 3.7, 996.871, -73.66));
             case 0:
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), false || (_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), bool(bvec3((injectionSwitch.x > injectionSwitch.y), false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))))))))
                break;
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                return;
               barrier();
              }
             if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               barrier();
              }
             case 34:
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(false))
              continue;
             case 30:
             case 16:
             case 1:
             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, mat2(1.0) * (injectionSwitch)).x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) * 1.0) > injectionSwitch.y))))
              {
               switch(_GLF_SWITCH((0 | 0)))
                {
                 case 0:
                 case 39:
                 case 6:
                 if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                 case 57:
                 case 62:
                 case 9:
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 case 25:
                 barrier();
                 break;
                 case 19:
                 160806u;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 case 36:
                 lessThan(uvec3(37449u, 53166u, 140202u), (uvec3(169868u, 20649u, 39962u) & subgroup_size));
                 default:
                 if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), (_GLF_IDENTITY(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))) || false)) || false)))
                  barrier();
                 1;
                 if(_GLF_DEAD(false))
                  continue;
                }
              }
             if(_GLF_DEAD(false))
              continue;
             case 85:
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_IDENTITY(_GLF_DEAD(false), bool(bvec3(_GLF_DEAD(false), false, false)))) || false))
              barrier();
             do
              {
               switch(_GLF_SWITCH((0 << _GLF_IDENTITY(int(1), int(1)))))
                {
                 case 0:
                 for(int _injected_loop_counter = _GLF_IDENTITY((1 ^ 1), ((1 ^ 1)) | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _GLF_IDENTITY(_injected_loop_counter ++, (_injected_loop_counter ++) >> (0 << _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), (int(0)) << 0)))))
                  {
                   barrier();
                   if(_GLF_DEAD(false))
                    barrier();
                  }
                 break;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 default:
                 1;
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
             do
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   do
                    {
                     barrier();
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                  }
                 else
                  {
                  }
                }
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
             break;
             case 96:
             ivec2 _GLF_SWITCH_3_0v[67], _GLF_SWITCH_3_1v;
             if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((_GLF_IDENTITY(injectionSwitch, (injectionSwitch) - vec2(0.0, 0.0)).x > _GLF_IDENTITY(injectionSwitch, (true ? injectionSwitch : _GLF_FUZZED(vec2(9.7, -7.9)))).y), _GLF_IDENTITY(bool(bvec2((_GLF_IDENTITY(injectionSwitch, (injectionSwitch) - vec2(0.0, 0.0)).x > _GLF_IDENTITY(injectionSwitch, (true ? injectionSwitch : _GLF_FUZZED(vec2(9.7, -7.9)))).y), true)), (bool(bvec2((_GLF_IDENTITY(injectionSwitch, (injectionSwitch) - vec2(0.0, 0.0)).x > _GLF_IDENTITY(injectionSwitch, (true ? injectionSwitch : _GLF_FUZZED(vec2(9.7, -7.9)))).y), true))) && true)))))
              barrier();
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
              barrier();
             if(_GLF_IDENTITY(_GLF_DEAD(false), bool(bvec2(_GLF_IDENTITY(_GLF_DEAD(false), false || (_GLF_DEAD(false))), false))))
              barrier();
             if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, ! (! (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (injectionSwitch.x > injectionSwitch.y) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))), ! (! _GLF_IDENTITY((_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (_GLF_IDENTITY(! ((_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))), false || (! ((_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))))))))
              barrier();
             default:
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
              }
             else
              {
               if(_GLF_DEAD(false))
                barrier();
              }
             1;
            }
           if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(_GLF_IDENTITY(false, true && (false)), false, false, false)))))
            {
             do
              {
               barrier();
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 break;
                }
               if(_GLF_DEAD(false))
                barrier();
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
            }
           if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(false || (false), bool(bvec3(false || (false), true, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))))))
            barrier();
          }
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           return;
           if(_GLF_DEAD(false))
            break;
          }
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             continue;
            }
          }
         else
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             barrier();
            }
           else
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
          }
         else
          {
          }
         if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
          barrier();
         if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bool(bvec2(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), true))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              continue;
             continue;
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(false))
            barrier();
           barrier();
          }
         if(_GLF_DEAD(false))
          continue;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) ? _GLF_FUZZED(-98.92) : injectionSwitch.x)) > injectionSwitch.y))))
        barrier();
       vec4 _GLF_SWITCH_1_0v, _GLF_SWITCH_1_1v[72], _GLF_SWITCH_1_2v;
       case 14:
       vec3 _GLF_SWITCH_1_3v[66];
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         for(int _injected_loop_counter = _GLF_IDENTITY(int(_GLF_ONE(1.0, _GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).y)), 1 * (int(_GLF_ONE(1.0, _GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).y)))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           barrier();
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             return;
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         continue;
        }
       default:
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          break;
        }
       else
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
              barrier();
            }
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
          }
         for(int _injected_loop_counter = (1 | (1 | 1)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         1;
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
          {
           if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, bool(bool(true)))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
             if(_GLF_DEAD(false))
              {
               switch(_GLF_SWITCH(0))
                {
                 case 98:
                 mat3(3.5, -9.9, -16.40, 7310.0262, 3.0, -1.5, -8.7, -1.7, 337.678);
                 case 0:
                 case 6:
                 case 70:
                 case 61:
                 case 56:
                 case 46:
                 case 45:
                 case 12:
                 for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), min(int(4), int(4))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 ^ 1)); _injected_loop_counter --)
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                   if(_GLF_DEAD(false))
                    break;
                   barrier();
                  }
                 break;
                 if(_GLF_DEAD(false))
                  barrier();
                 case 75:
                 step(-938.710, (vec3(-7.5, 7051.2560, -16.89) * mat3(-8615.3968, 711.311, -1576.1239, 3.1, 7584.6762, -432.180, -9.3, -53.82, -5.8)));
                 if(_GLF_DEAD(false))
                  barrier();
                 case 82:
                 int _GLF_SWITCH_5_0v;
                 default:
                 1;
                }
              }
            }
           else
            {
            }
          }
         if(_GLF_DEAD(false))
          return;
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           barrier();
          }
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            barrier();
           barrier();
          }
         else
          {
          }
        }
       if(_GLF_DEAD(false))
        {
         do
          {
           barrier();
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
       if(_GLF_DEAD(false))
        break;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         barrier();
        }
       else
        {
         if(_GLF_DEAD(false))
          barrier();
        }
      }
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      barrier();
     do
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
        barrier();
      }
     while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, bool(bvec2(false, true))))))));
    }
   do
    {
     if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, bool(bvec3(false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))), (injectionSwitch.x > injectionSwitch.y))))
      barrier();
    }
   while(_GLF_WRAPPED_LOOP(false));
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     return;
    }
   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
    return;
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
     if(_GLF_DEAD(false))
      barrier();
    }
   else
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, max(injectionSwitch, _GLF_IDENTITY(injectionSwitch, (injectionSwitch) * vec2(1.0, 1.0)))).x > injectionSwitch.y))))
    return;
  }
 else
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
    }
   else
    {
     atomicStore(buf[next_virtual_gid], uint(_GLF_IDENTITY(2, (2) | (2))), 4, 64, _GLF_IDENTITY(4, ~ (_GLF_IDENTITY(~ (4), 0 ^ (~ (4))))));
     if(_GLF_DEAD(false))
      barrier();
    }
   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false, true)))))
    {
     switch(_GLF_SWITCH((0 ^ 0)))
      {
       case 0:
       case 81:
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, _GLF_IDENTITY(float(vec4(injectionSwitch.x, 1.0, 0.0, _GLF_ONE(1.0, injectionSwitch.y))), mix(float(_GLF_FUZZED(4189.8162)), float(_GLF_IDENTITY(float(vec4(injectionSwitch.x, 1.0, 0.0, _GLF_ONE(1.0, injectionSwitch.y))), min(float(vec4(injectionSwitch.x, 1.0, 0.0, _GLF_ONE(1.0, injectionSwitch.y))), float(vec4(injectionSwitch.x, 1.0, 0.0, _GLF_ONE(1.0, injectionSwitch.y)))))), bool(true)))) > injectionSwitch.y))))
        barrier();
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
        {
         barrier();
         if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
          continue;
        }
       break;
       case 35:
       if(((mix(vec4(9.6, 200.249, -68.57, 6503.1328), vec4(9.8, -8435.6980, 44.87, -0.7), bvec4(false, true, true, false)) / vec4(-5.3, 615.520, 391.250, -61.34)) != (distance(vec3(3139.2520, 65.64, -4.1), vec3(-7.1, 978.591, 4.3)) - vec4(-19.70, -2659.5393, 996.178, -9.7))))
        {
         while((ivec2(-17429, -21769) != ivec2(40460, 85532)))
          {
           mat4 _GLF_SWITCH_5_0v[91], _GLF_SWITCH_5_1v;
           true;
           uvec3(142188u, 101349u, 44075u);
           uvec2(43549u, 84305u);
           mat2x4(-8.4, 610.447, -977.746, 7.3, 2.9, -2143.7219, -5.7, 1161.6201);
           uint _GLF_SWITCH_5_2v, _GLF_SWITCH_5_3v, _GLF_SWITCH_5_4v[7];
           (true ? vec2(-805.511, 783.024) : injectionSwitch);
           uint _GLF_SWITCH_5_5v[47], _GLF_SWITCH_5_6v, _GLF_SWITCH_5_7v;
           if(_GLF_DEAD(false))
            barrier();
          }
         while(bvec2(false, false)[1])
          {
           ivec2(-8341, -85681);
           uvec4(143568u, 105117u, 17244u, 120170u);
           ivec3(-95141, 85707, -5480);
           ;
           mat3x2 _GLF_SWITCH_5_8v, _GLF_SWITCH_5_9v, _GLF_SWITCH_5_10v[11];
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, (false) || false), (_GLF_IDENTITY(false, ! (! (false)))) && true)))
            barrier();
           uvec3 _GLF_SWITCH_5_11v;
           clamp(vec2(-1.1, -8.3), unpackUnorm2x16((++ workgroup_base)), injectionSwitch);
          }
         if(_GLF_DEAD(false))
          barrier();
         for(         mat2x4(-895.220, -956.800, 73.04, 9846.9317, _GLF_IDENTITY(-354.635, (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) ? -354.635 : _GLF_FUZZED(cos(49.01)))), -9.8, 9.2, 4472.6262);
 false; bvec2(true, true))
          {
           mat2x4(486.573, -49.63, 51.11, -8.4, -9395.4556, 2778.4054, -57.54, -0.1);
           if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(vec2(mat4x2(injectionSwitch, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0)), (vec2(mat4x2(injectionSwitch, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0))) * mat2(1.0))).x > injectionSwitch.y))))
            barrier();
           ivec3(-66969, -31773, -43762);
           mat4x3 _GLF_SWITCH_5_12v;
           bvec3(false, false, true);
           uvec2 _GLF_SWITCH_5_13v, _GLF_SWITCH_5_14v[67], _GLF_SWITCH_5_15v;
           vec3(vec4(6.9, -5.4, -5.8, 487.159));
           ivec2 _GLF_SWITCH_5_16v[47];
           mat2x3 _GLF_SWITCH_5_17v;
           uvec3(70743u, 64823u, 159045u);
          }
         do
          {
           _GLF_IDENTITY(uint(true), (0u ^ 0u) | (uint(true)));
           if(_GLF_DEAD(false))
            barrier();
           mat2x4 _GLF_SWITCH_5_18v, _GLF_SWITCH_5_19v, _GLF_SWITCH_5_20v;
           bvec3 _GLF_SWITCH_5_21v;
           if(_GLF_DEAD(false))
            barrier();
          }
         while(false);
         if(_GLF_DEAD(false))
          barrier();
        }
       case 41:
       mat3x4(mat2(30.02, -5.3, 9.7, -366.371));
       default:
       1;
      }
    }
  }
 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       switch(_GLF_SWITCH(0))
        {
         case 0:
         if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
          barrier();
         case 23:
         case 66:
         case 99:
         do
          {
           if(_GLF_IDENTITY(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bool(false)), true && _GLF_IDENTITY((bool(bool(false))), false || (_GLF_IDENTITY((bool(bool(false))), bool(bool((bool(bool(false))))))))))), ! (! (_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bool(false)), true && (bool(bool(false))))), false || (_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bool(false)), true && (bool(bool(false))))))))))))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             break;
            }
          }
         while(_GLF_WRAPPED_LOOP(false));
         break;
         if(_GLF_DEAD(false))
          barrier();
         case 32:
         mat3(-94.17, 1979.2126, -49.07, -767.749, 5.6, 9.8, -4.1, 1.1, -0.0);
         case 15:
         for(         asinh(refract(asinh(-607.431), -894.715, 87.78));
 false; mat3x2(5.0, -367.294, -5.8, 6.5, 59.34, -1.4))
          {
           _GLF_IDENTITY(length(vec4(-1.8, -8726.8788, -8.6, -0.9)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) ? _GLF_FUZZED(1.7) : length(vec4(-1.8, -8726.8788, -8.6, -0.9))));
           int(60385u);
           if(_GLF_DEAD(false))
            barrier();
           (ivec4(17006, -63925, -43028, -40884).xw ^ _GLF_IDENTITY(findLSB(ivec2(-55002, 97510)), ivec2(_GLF_IDENTITY(ivec4(findLSB(ivec2(-55002, 97510)), (0 | 0), _GLF_IDENTITY((1 | 0), 0 + ((1 | 0)))), min(_GLF_IDENTITY(ivec4(findLSB(ivec2(-55002, 97510)), (0 | 0), _GLF_IDENTITY((1 | 0), 0 + ((1 | 0)))), clamp(ivec4(findLSB(ivec2(-55002, 97510)), (0 | 0), _GLF_IDENTITY((1 | 0), 0 + ((1 | 0)))), ivec4(findLSB(ivec2(-55002, 97510)), (0 | 0), _GLF_IDENTITY((1 | 0), 0 + ((1 | 0)))), ivec4(findLSB(ivec2(-55002, 97510)), (0 | 0), _GLF_IDENTITY((1 | 0), 0 + ((1 | 0)))))), _GLF_IDENTITY(ivec4(findLSB(ivec2(-55002, 97510)), (0 | 0), _GLF_IDENTITY((1 | 0), 0 + ((1 | 0)))), (false ? _GLF_FUZZED(ivec4(29153, -70101, -57188, 49929)) : ivec4(findLSB(ivec2(-55002, 97510)), (0 | 0), _GLF_IDENTITY((1 | 0), 0 + ((1 | 0)))))))))));
           bvec4 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v[21], _GLF_SWITCH_5_2v[91];
           mat4x2(15.75, 641.560, 4.8, 33.08, 6807.8973, 11.95, -344.168, -3.7);
           uvec4(102501u, 124296u, 144504u, 181516u);
           mat2 _GLF_SWITCH_5_3v;
          }
         if(_GLF_DEAD(false))
          barrier();
         default:
         1;
        }
       if(_GLF_DEAD(false))
        barrier();
      }
     else
      {
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(7), _GLF_IDENTITY(int(7), 0 | (int(7))))) >> _GLF_IDENTITY(int(7), int(7)))); _injected_loop_counter ++)
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           return;
          }
         barrier();
        }
      }
     if(_GLF_DEAD(false))
      return;
     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
      {
       if(_GLF_DEAD(false))
        break;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
          barrier();
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
          }
         else
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               barrier();
              }
            }
           else
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               barrier();
              }
            }
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = (int(_GLF_ZERO(0.0, injectionSwitch.x)) ^ ((_GLF_IDENTITY(0, min(_GLF_IDENTITY(0, (0) ^ 0), _GLF_IDENTITY(0, min(0, 0)))) | 0) | 0)); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
            {
             switch(_GLF_SWITCH(0))
              {
               case 0:
               barrier();
               break;
               case 66:
               (ivec3(-35612, -45852, -37769) + ivec3(87953, -79188, -66873));
               case 70:
               bvec3(true, true, false);
               default:
               1;
              }
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
            barrier();
           return;
          }
        }
      }
     if(_GLF_DEAD(false))
      barrier();
     return;
     for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(2), int(_GLF_IDENTITY(2, max(_GLF_IDENTITY(2, 0 | (2)), _GLF_IDENTITY(2, (2) | (2))))))) >> _GLF_IDENTITY(int(2), int(2))); _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 | 0)); _injected_loop_counter --)
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(false))
        barrier();
      }
    }
  }
}
