#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer Checker {
 uint checker[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = gl_NumWorkGroups.x;
 uint workgroup_size = gl_WorkGroupSize.x;
 uint workgroup_id = gl_WorkGroupID.x;
 uint workgroup_base = workgroup_size * workgroup_id;
 uint virtual_gid = workgroup_base + subgroup_id * subgroup_size + subgroup_local_id;
 uint next_virtual_gid = workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size);
 atomicStore(buf[next_virtual_gid], uint(1), 4, 64, 4);
 uint read = atomicLoad(buf[virtual_gid], 4, 64, 0);
 if(subgroup_local_id + 1 < subgroup_size)
  {
   switch(_GLF_SWITCH((0 >> _GLF_IDENTITY(int(7), int(7)))))
    {
     case 27:
     for(vec2 _GLF_SWITCH_0_0v, _GLF_SWITCH_0_1v[52]; (mat4x2(mat2x3(-554.052, 786.122, 0.8, -6316.2271, 67.72, 916.124)) == mat4x2(mat4(9.1, 415.036, -1133.8447, 4.1, -819.795, -88.69, -9.2, 2106.0944, 1.4, -3.7, -2.4, -8.9, 2.8, -95.40, 7556.4484, -9.7))); isinf(849.832))
      {
       bvec4 _GLF_SWITCH_0_2v;
       if((vec4(-1.4, -37.23, 7.8, -333.150) == vec4(-853.311, 853.001, -35.50, -8864.5001)))
        {
         injectionSwitch;
         uvec3(21000u, 87373u, 25009u);
         {
          (uvec4(177893u, 190221u, 157141u, 97587u) * uvec4(44591u, 97910u, 70758u, 174065u));
          mat4 _GLF_SWITCH_0_3v, _GLF_SWITCH_0_4v;
          uvec4 _GLF_SWITCH_0_5v;
          uvec2(79737u, 105374u);
          mat2(-5.3, 8366.7553, -96.07, 1546.7589);
          mat3x4(-980.247, 71.06, -76.09, 41.31, -4534.6118, 943.465, 60.07, -1.6, -318.880, 60.41, -9270.0457, -5.7);
          (ivec3(-71249, -63458, 94438) + -78416);
          lessThanEqual(injectionSwitch, vec2(-43.05, 8335.1004));
          greaterThanEqual(uvec2(workgroup_id), uvec2(102686u, 157299u));
         }
         ivec3 _GLF_SWITCH_0_6v;
         mat2 _GLF_SWITCH_0_7v;
         {
          packUnorm4x8((min(vec4(9168.0766, -5634.9533, 51.21, -2939.5877), -2.1) - 647.281));
          uvec3 _GLF_SWITCH_0_8v[35];
          (ivec4(53630, 85039, -18388, 20193) * ivec4(94847, 86694, -31469, -48785));
         }
         vec2 _GLF_SWITCH_0_9v, _GLF_SWITCH_0_10v[93];
         atan(vec3(-1.3, 3.3, -7.8), vec3(-718.655, -25.36, -63.88));
         ivec4 _GLF_SWITCH_0_11v, _GLF_SWITCH_0_12v, _GLF_SWITCH_0_13v[28];
        }
       else
        {
         uvec4 _GLF_SWITCH_0_14v, _GLF_SWITCH_0_15v, _GLF_SWITCH_0_16v;
         {
          (56569 ^ (-5274 + ivec2(64525, 8658)));
          (mat4x2(-2.8, 7.4, 4.2, -1.9, -967.377, 4.5, -379.743, 8.9) , mat4x3(-6.0, -64.90, 3.7, -91.87, 1403.0943, 6634.2822, 2.8, -3.2, -4.6, 860.437, 4.0, -0.5));
          mat4(-6.9, -983.817, 42.31, 7.2, 9.3, 1.0, 3991.1234, 790.440, -6.3, 17.54, -67.84, 2.1, 62.08, -7902.1871, 9768.3234, 60.28);
         }
         while(bvec2(true, false).x)
          {
           uint _GLF_SWITCH_0_17v;
           vec4(212.202, 9.3, -3.7, 3.2);
           mat3x2(76.88, -6686.2047, 859.276, -11.93, 69.17, 7100.5166);
           bvec2 _GLF_SWITCH_0_18v, _GLF_SWITCH_0_19v[45];
           mat3x2 _GLF_SWITCH_0_20v, _GLF_SWITCH_0_21v;
           equal(_GLF_SWITCH_0_2v.arbg, bvec4(true, false, true, false));
           mat4 _GLF_SWITCH_0_22v, _GLF_SWITCH_0_23v[63];
           mat3x4 _GLF_SWITCH_0_24v, _GLF_SWITCH_0_25v[16];
          }
         mat3x2(846.754, 557.742, -1525.6158, -5.9, -377.585, 9.0);
         vec4 _GLF_SWITCH_0_26v, _GLF_SWITCH_0_27v;
         mat2x4(3.8, 4063.4079, -1.4, 56.56, 5254.2657, 4.3, -9.1, -603.433);
        }
       while(true)
        {
         if(true)
          {
           ivec2(31902, 4081);
          }
         for(         uvec3(num_workgroup, virtual_gid, num_workgroup);
 (mat3x2(-7.3, -645.597, 94.60, 963.164, -3.6, 3.7) != mat3x2(16.56, -1.7, -338.134, -7.2, -9822.9807, -0.4)); (ivec4(-91070, -86000, -67867, 33966) ^ ivec4(90628, 11383, -95056, 58586)))
          {
          }
         ;
         (_GLF_SWITCH_0_2v == bvec4(false, true, true, false));
         bvec2(true, false);
         if((false && true))
          {
           ivec4(2728, 4505, 65174, -289);
          }
         bvec4 _GLF_SWITCH_0_28v;
        }
       bvec3 _GLF_SWITCH_0_29v[95], _GLF_SWITCH_0_30v[23];
       if(false)
        {
         for(mat4 _GLF_SWITCH_0_31v; true; mat3x4(-87.38, 838.048, 989.387, 8877.8420, 9.2, 632.292, -698.292, 20.32, 3672.5995, -8.1, -2.8, 1589.9575))
          {
           mat4 _GLF_SWITCH_0_32v, _GLF_SWITCH_0_33v[2], _GLF_SWITCH_0_34v;
           vec4(0.8, 7098.7008, 3259.0174, 489.975);
           ivec4 _GLF_SWITCH_0_35v, _GLF_SWITCH_0_36v, _GLF_SWITCH_0_37v;
           ;
           ivec3 _GLF_SWITCH_0_38v, _GLF_SWITCH_0_39v, _GLF_SWITCH_0_40v[76];
           98914;
          }
         {
          int(595.117);
          ;
          mat4x2 _GLF_SWITCH_0_41v, _GLF_SWITCH_0_42v;
          floor(vec4(2401.0599, -62.82, -992.682, -1.8));
          120.875;
          (20966 % ivec2(-78534, 56362));
          packUnorm4x8(roundEven(vec4(1748.3190, -7.9, 6.1, -4.2)));
          bool _GLF_SWITCH_0_43v, _GLF_SWITCH_0_44v[4];
          vec3 _GLF_SWITCH_0_45v[59], _GLF_SWITCH_0_46v[72];
         }
        }
       else
        {
         (mat4x3(-2.5, 252.633, -9.5, 0.6, -95.70, 6299.9826, 1.2, -7.9, -40.51, -29.32, 445.399, 383.854) - mat4x3(-7.7, -3191.8846, 1280.6830, 5.8, 945.813, 1.5, 7185.9124, -692.113, 7.3, -7.5, -9.4, -19.44));
        }
      }
     case 95:
     mat2 _GLF_SWITCH_0_47v, _GLF_SWITCH_0_48v;
     case 0:
     case 26:
     case 52:
     case 5:
     case 63:
     atomicStore(checker[virtual_gid], read, 4, 64, 4);
     case 51:
     case 94:
     case 49:
     case 10:
     subgroupAll(false);
     break;
     default:
     1;
    }
  }
 else
  {
   switch(_GLF_SWITCH((1 ^ 1)))
    {
     case 0:
     case 47:
     case 74:
     case 33:
     case 18:
     atomicStore(checker[virtual_gid], read, 4, 64, 4);
     case 77:
     case 76:
     case 51:
     case 92:
     case 38:
     subgroupAll(true);
     break;
     case 69:
     injectionSwitch;
     case 99:
     ivec4 _GLF_SWITCH_1_0v, _GLF_SWITCH_1_1v, _GLF_SWITCH_1_2v;
     default:
     1;
    }
  }
}
