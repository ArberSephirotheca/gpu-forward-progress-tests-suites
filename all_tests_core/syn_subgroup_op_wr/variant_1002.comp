#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_maximal_reconvergence : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer Checker {
 uint checker[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 uint subgroup_id = gl_SubgroupID;
 if(_GLF_DEAD(false))
  barrier();
 uint subgroup_size = gl_SubgroupSize;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(6), int(6))) >> _GLF_IDENTITY(int(6), int(6)))); _injected_loop_counter ++)
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       barrier();
      }
    }
  }
 uint num_workgroup = gl_NumWorkGroups.x;
 uint workgroup_size = gl_WorkGroupSize.x;
 uint workgroup_id = gl_WorkGroupID.x;
 if(_GLF_DEAD(false))
  return;
 uint workgroup_base = _GLF_IDENTITY(workgroup_size * workgroup_id, ~ (~ (workgroup_size * workgroup_id)));
 if(_GLF_DEAD(false))
  barrier();
 uint subgroup_base = subgroup_id * subgroup_size;
 if(_GLF_DEAD(false))
  barrier();
 uint virtual_gid = workgroup_base + subgroup_base + subgroup_local_id;
 uint next_virtual_gid = _GLF_IDENTITY(workgroup_base + subgroup_base, ~ (_GLF_IDENTITY(~ (workgroup_base + subgroup_base), 1u * (~ (workgroup_base + subgroup_base))))) + ((_GLF_IDENTITY(subgroup_local_id, 1u * (subgroup_local_id)) + _GLF_IDENTITY(1, (1) - 0)) % subgroup_size);
 uint read = 0;
 atomicStore(buf[_GLF_IDENTITY(next_virtual_gid, clamp(_GLF_IDENTITY(_GLF_IDENTITY(next_virtual_gid, (next_virtual_gid) >> 0u), (next_virtual_gid) / 1u), next_virtual_gid, next_virtual_gid))], uint(_GLF_IDENTITY(1, max(1, _GLF_IDENTITY(1, min(1, 1))))), 4, 64, 4);
 if(_GLF_DEAD(false))
  barrier();
 if((_GLF_IDENTITY(subgroup_local_id % 2, min(_GLF_IDENTITY(subgroup_local_id % 2, (subgroup_local_id % _GLF_IDENTITY(2, (2) + (0 << _GLF_IDENTITY(int(5), int(5))))) | 0u), _GLF_IDENTITY(subgroup_local_id % 2, (subgroup_local_id % 2) | (subgroup_local_id % 2))))) == 0)
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    barrier();
   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
    {
     subgroupAll(false);
    }
   if(_GLF_DEAD(false))
    {
     do
      {
       barrier();
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
   if(_GLF_DEAD(false))
    barrier();
   read = atomicLoad(buf[virtual_gid], 4, 64, 2);
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_IDENTITY(_GLF_DEAD(false), bool(_GLF_IDENTITY(bvec3(_GLF_DEAD(false), _GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, false || (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, bool(bvec4(injectionSwitch.x > injectionSwitch.y, false, true, true))))))), true), bvec3(bvec4(bvec3(_GLF_DEAD(false), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       barrier();
      }
    }
   if(_GLF_DEAD(false))
    barrier();
  }
 else
  {
   if(_GLF_DEAD(false))
    barrier();
   for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
    {
     if(_GLF_DEAD(false))
      barrier();
     switch(_GLF_SWITCH(0))
      {
       case 38:
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         barrier();
        }
       mat2(-95.91, 802.164, -891.906, 368.874);
       case 0:
       if(_GLF_DEAD(false))
        {
         do
          {
           barrier();
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
       subgroupAll(false);
       if(_GLF_DEAD(false))
        barrier();
       case 84:
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, clamp(injectionSwitch, injectionSwitch, injectionSwitch)).y))))
        break;
       read = atomicLoad(buf[virtual_gid], _GLF_IDENTITY(4, int(ivec4(_GLF_IDENTITY(4, int(ivec4(4, 0, 0, 1))), 1, 1, 0))), 64, 2);
       if(_GLF_DEAD(false))
        barrier();
       break;
       case 65:
       if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bool(false)), bool(bvec4(bool(bool(false)), false, true, true))))))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bool(_GLF_IDENTITY(false, bool(bvec4(_GLF_IDENTITY(false, ! (! (false))), false, true, true)))), (bool(_GLF_IDENTITY(false, bool(bvec4(_GLF_IDENTITY(false, ! (! (false))), false, true, true))))) && true))), _GLF_IDENTITY(_GLF_IDENTITY(bool(bvec4(false, true, true, _GLF_IDENTITY(true, ! (! _GLF_IDENTITY((true), ! (! ((true)))))))), true && (bool(bvec4(false, true, true, _GLF_IDENTITY(true, ! (! _GLF_IDENTITY((true), ! (! ((true)))))))))), false || (bool(bvec4(false, true, true, _GLF_IDENTITY(true, ! (! (true))))))))))
          break;
         barrier();
        }
       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(false, false, true, true)))))
        barrier();
       {
        if(_GLF_DEAD(false))
         continue;
        if(true)
         {
          do
           {
            if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))
             {
              for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
               {
                for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                 {
                  if(_GLF_WRAPPED_IF_FALSE(false))
                   {
                    if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     barrier();
                   }
                  else
                   {
                    barrier();
                   }
                 }
               }
             }
            if(_GLF_DEAD(false))
             barrier();
            mat2(-2.4, -0.2, 707.980, -879.970);
           }
          while(_GLF_WRAPPED_LOOP(false));
          for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
           {
            bvec2(true, true);
           }
          while((bvec3(true, false, false) == bvec3(true, false, false)))
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, true && (injectionSwitch.x > injectionSwitch.y))) && true)))))
             barrier();
            if(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_DEAD(false), bool(bvec4(_GLF_DEAD(false), false, false, true))), false || (_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))))
             {
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
                if(_GLF_WRAPPED_IF_TRUE(true))
                 {
                  barrier();
                 }
                else
                 {
                 }
               }
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 barrier();
                barrier();
               }
              if(_GLF_DEAD(false))
               barrier();
              do
               {
                barrier();
               }
              while(_GLF_WRAPPED_LOOP(false));
             }
            vec4 _GLF_SWITCH_0_0v[88], _GLF_SWITCH_0_1v, _GLF_SWITCH_0_2v;
            for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
             {
              for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
               {
                if(_GLF_DEAD(false))
                 barrier();
               }
              uintBitsToFloat(uvec2(3793u, 52856u));
             }
            if(_GLF_DEAD(false))
             barrier();
            uvec2(_GLF_IDENTITY(137413u, (_GLF_IDENTITY(137413u, (137413u) ^ 0u)) ^ 0u), 93068u);
            if(_GLF_DEAD(false))
             barrier();
            for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               barrier();
              if(_GLF_DEAD(false))
               return;
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 {
                  if(_GLF_DEAD(false))
                   barrier();
                  continue;
                  if(_GLF_DEAD(false))
                   barrier();
                 }
                barrier();
                if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, true)))))
                 barrier();
               }
              ;
              if(_GLF_DEAD(false))
               continue;
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               barrier();
             }
            if(_GLF_DEAD(false))
             continue;
            mat3x2 _GLF_SWITCH_0_3v[25], _GLF_SWITCH_0_4v;
            if(_GLF_DEAD(false))
             barrier();
            if(_GLF_DEAD(false))
             break;
            mat2x3 _GLF_SWITCH_0_5v, _GLF_SWITCH_0_6v[70], _GLF_SWITCH_0_7v;
            if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               barrier();
             }
            else
             {
              (vec4(-4.3, 2188.7133, -867.108, 542.262) == _GLF_SWITCH_0_2v);
             }
           }
          if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
           barrier();
          if(_GLF_DEAD(false))
           {
            for(int _injected_loop_counter = _GLF_IDENTITY(_GLF_IDENTITY(1, int(int(1))), (_GLF_IDENTITY(1, int(int(1)))) / 1); _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 ^ 0)); _injected_loop_counter --)
             {
              if(_GLF_WRAPPED_IF_FALSE(false))
               {
                if(_GLF_DEAD(false))
                 barrier();
               }
              else
               {
                barrier();
                if(_GLF_DEAD(false))
                 barrier();
               }
             }
           }
          if(_GLF_DEAD(false))
           break;
         }
        ivec3 _GLF_SWITCH_0_8v, _GLF_SWITCH_0_9v, _GLF_SWITCH_0_10v;
        do
         {
          if(_GLF_WRAPPED_IF_FALSE(false))
           {
           }
          else
           {
            _GLF_SWITCH_0_9v;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
           }
         }
        while(_GLF_WRAPPED_LOOP(false));
        if(_GLF_DEAD(false))
         barrier();
        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         {
          if(_GLF_WRAPPED_IF_TRUE(true))
           {
            if(_GLF_DEAD(false))
             barrier();
           }
          else
           {
           }
          if(_GLF_IDENTITY(_GLF_WRAPPED_IF_TRUE(true), bool(bvec2(_GLF_WRAPPED_IF_TRUE(true), false))))
           {
            do
             {
              barrier();
             }
            while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           }
          else
           {
            if(_GLF_DEAD(false))
             barrier();
            do
             {
              do
               {
                if(_GLF_DEAD(false))
                 barrier();
                if(_GLF_DEAD(false))
                 barrier();
               }
              while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, true && (false))));
             }
            while(_GLF_WRAPPED_LOOP(false));
            if(_GLF_DEAD(false))
             barrier();
           }
         }
        if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && true))
         {
          for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            barrier();
           }
         }
        mat2x3 _GLF_SWITCH_0_11v, _GLF_SWITCH_0_12v, _GLF_SWITCH_0_13v;
        while(true)
         {
          bvec4(false, false, true, true);
          atan(vec2(-5.1, -422.502));
          if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_IDENTITY((_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true, ((_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true) || false))))
           {
            if(_GLF_WRAPPED_IF_TRUE(true))
             {
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 barrier();
                barrier();
               }
             }
            else
             {
             }
            barrier();
           }
         }
        for(        mat2(50.82, 9.4, -8.3, -4.3);
 (mat2(determinant(mat2(3593.6551, -204.854, -3.3, -4450.8509))) == mat2(-796.520, -958.619, -82.67, 53.67)); isinf(vec2(9.3, 577.756)))
         {
          if(_GLF_DEAD(false))
           barrier();
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           barrier();
          if(_GLF_DEAD(false))
           barrier();
          while(false)
           {
            do
             {
              (uvec2(47125u, 133320u) >> (subgroup_base << workgroup_id));
             }
            while(_GLF_WRAPPED_LOOP(false));
            mat3(-2124.9310, 8.2, 563.545, -516.827, -9.2, 643.160, -2.7, -68.53, 7.3);
            if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
             }
            else
             {
              (bvec2(_GLF_IDENTITY(false, _GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, (_GLF_IDENTITY(injectionSwitch.x, float(vec2(injectionSwitch.x, 1.0)))) * 1.0) > _GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, injectionSwitch.y, injectionSwitch.y)))) || (false)), _GLF_IDENTITY(_GLF_IDENTITY(true, _GLF_IDENTITY(bool(bvec4(_GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (true), (! (true)) || false))), false, true, false)), ! (_GLF_IDENTITY(! (bool(bvec4(_GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (true), (! (true)) || false))), false, true, false))), ! (! (! (bool(bvec4(_GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (true), (! (true)) || false))), false, true, false))))))))), true && (_GLF_IDENTITY(true, _GLF_IDENTITY(bool(bvec4(_GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (true), (! (true)) || false))), false, true, false)), ! (_GLF_IDENTITY(! (bool(bvec4(_GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (true), (! _GLF_IDENTITY((true), bool(bool((true))))) || false))), false, true, false))), ! (_GLF_IDENTITY(! (! (bool(bvec4(_GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (true), (! (true)) || false))), false, true, false)))), ! (! (! (! (bool(bvec4(_GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (true), _GLF_IDENTITY((! (true)) || false, bool(bool((! (true)) || false)))))), false, true, false))))))))))))))));
              if(_GLF_DEAD(false))
               barrier();
             }
            if(_GLF_DEAD(false))
             barrier();
           }
          if(_GLF_DEAD(false))
           barrier();
          if(_GLF_DEAD(false))
           {
            if(_GLF_DEAD(false))
             barrier();
            continue;
           }
          -218.018;
         }
        do
         {
          _GLF_IDENTITY(bitfieldInsert((ivec2(22094, -82736) - ivec2(-84652, -64457)), ivec2(-88565, 30140), -11419, _GLF_IDENTITY(-45022, (false ? _GLF_FUZZED(_injected_loop_counter) : -45022))), max(bitfieldInsert((ivec2(22094, -82736) - ivec2(-84652, -64457)), _GLF_IDENTITY(ivec2(-88565, 30140), ivec2(_GLF_IDENTITY(ivec2(_GLF_IDENTITY(ivec2(-88565, 30140), ivec2(0, 0) | (ivec2(-88565, 30140)))), max(ivec2(_GLF_IDENTITY(ivec2(-88565, 30140), ivec2(0, 0) | (ivec2(-88565, 30140)))), ivec2(_GLF_IDENTITY(ivec2(-88565, 30140), ivec2(0, 0) | (ivec2(-88565, 30140)))))))), -11419, -45022), bitfieldInsert(_GLF_IDENTITY((_GLF_IDENTITY(ivec2(22094, -82736), (ivec2(22094, -82736)) | _GLF_IDENTITY(ivec2(0, 0), ivec2(ivec4(ivec2(0, 0), 0, 1)))) - ivec2(-84652, -64457)), ((_GLF_IDENTITY(ivec2(22094, -82736) - ivec2(-84652, -64457), (false ? _GLF_FUZZED(ivec2(17804, 62112)) : ivec2(22094, -82736) - ivec2(-84652, -64457))))) ^ ivec2(0, _GLF_IDENTITY(0, min(0, 0)))), ivec2(-88565, 30140), -11419, -45022)));
         }
        while(_GLF_WRAPPED_LOOP(false));
        mat4x3(3.6, 2.5, -1.3, 6.8, -49.31, 4788.6485, 6.1, 8.1, _GLF_IDENTITY(4.2, min(4.2, _GLF_IDENTITY(4.2, _GLF_IDENTITY((_GLF_IDENTITY(4.2, max(4.2, 4.2))) - 0.0, mix(float(_GLF_IDENTITY((_GLF_IDENTITY(4.2, max(4.2, 4.2))) - 0.0, max((_GLF_IDENTITY(4.2, max(4.2, 4.2))) - 0.0, _GLF_IDENTITY((_GLF_IDENTITY(4.2, max(4.2, 4.2))) - 0.0, max((_GLF_IDENTITY(4.2, max(4.2, 4.2))) - 0.0, (_GLF_IDENTITY(4.2, max(4.2, 4.2))) - 0.0))))), float(_GLF_FUZZED(-8207.1535)), bool(false)))))), 2303.1690, -6.6, _GLF_IDENTITY(-255.540, (_GLF_IDENTITY(-255.540, clamp(-255.540, -255.540, -255.540))) - 0.0));
        if(_GLF_DEAD(false))
         {
          if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           {
           }
          else
           {
            if(_GLF_DEAD(false))
             barrier();
           }
          barrier();
         }
       }
       if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(_GLF_IDENTITY(false, (false) && true))))))
        {
         if(_GLF_DEAD(false))
          barrier();
         barrier();
        }
       if(_GLF_DEAD(false))
        barrier();
       case 32:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        break;
       if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
          }
         barrier();
        }
       if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
         continue;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)).x > injectionSwitch.y, false || (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, max(injectionSwitch, injectionSwitch)).y))))))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
         else
          {
          }
        }
       if(_GLF_DEAD(false))
        barrier();
       for(       (_GLF_IDENTITY(mat4(-40.91, 435.643, -768.817, -7.8, 8.5, -15.99, _GLF_IDENTITY(-13.72, mix(float(-13.72), float(_GLF_FUZZED(-518.643)), bool(false))), -1642.8153, -80.25, 14.69, 7.8, 323.321, _GLF_IDENTITY(-301.235, float(mat2x3(-301.235, 0.0, 1.0, 0.0, abs(1.0), 1.0))), 7.9, -80.12, 5.7), (_GLF_IDENTITY(mat4(-40.91, 435.643, -768.817, -7.8, 8.5, _GLF_IDENTITY(-15.99, clamp(-15.99, -15.99, -15.99)), -13.72, -1642.8153, _GLF_IDENTITY(-80.25, (-80.25) / 1.0), 14.69, _GLF_IDENTITY(7.8, (7.8) - 0.0), 323.321, -301.235, 7.9, -80.12, 5.7), (false ? _GLF_FUZZED(mat4(-109.553, 5.4, 27.07, -2803.0816, _GLF_IDENTITY(-2.7, float(mat3x4(_GLF_IDENTITY(-2.7, 0.0 + (-2.7)), log(1.0), sqrt(1.0), 1.0, 0.0, abs(1.0), 0.0, 1.0, 1.0, 1.0, _GLF_IDENTITY(dot(vec4(0.0, 0.0, 1.0, 1.0), vec4(determinant(mat3(1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0)), 1.0, 0.0, 0.0)), _GLF_IDENTITY(dot(vec4(0.0, 0.0, 1.0, 1.0), vec4(determinant(mat3(1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0)), 1.0, 0.0, 0.0)), (dot(_GLF_IDENTITY(vec4(0.0, 0.0, _GLF_IDENTITY(1.0, length(0.0) + (1.0)), 1.0), _GLF_IDENTITY(vec4(mat3(vec4(0.0, 0.0, _GLF_IDENTITY(1.0, length(0.0) + (1.0)), 1.0), 1.0, 1.0, 1.0, 1.0, 1.0)), vec4(vec4(_GLF_IDENTITY(vec4(mat3(vec4(0.0, 0.0, _GLF_IDENTITY(1.0, length(0.0) + (1.0)), 1.0), 1.0, 1.0, 1.0, 1.0, 1.0)), (vec4(mat3(vec4(0.0, 0.0, _GLF_IDENTITY(1.0, length(0.0) + (1.0)), 1.0), 1.0, 1.0, 1.0, 1.0, 1.0))) * mat4(1.0)))))), _GLF_IDENTITY(vec4(determinant(mat3(1.0, 0.0, 0.0, 1.0, _GLF_IDENTITY(1.0, max(_GLF_IDENTITY(1.0, mix(float(1.0), float(_GLF_FUZZED(670.057)), bool(false))), _GLF_IDENTITY(1.0, float(_GLF_IDENTITY(mat2(_GLF_IDENTITY(1.0, min(1.0, 1.0)), 0.0, 0.0, 1.0), (mat2(_GLF_IDENTITY(1.0, min(1.0, 1.0)), 0.0, 0.0, 1.0)) - mat2(0.0, 0.0, 0.0, 0.0)))))), 0.0, 0.0, 1.0, 1.0)), 1.0, 0.0, 0.0), min(vec4(determinant(mat3(1.0, 0.0, 0.0, 1.0, _GLF_IDENTITY(1.0, max(_GLF_IDENTITY(1.0, mix(float(1.0), float(_GLF_FUZZED(670.057)), bool(false))), _GLF_IDENTITY(1.0, float(_GLF_IDENTITY(mat2(_GLF_IDENTITY(1.0, min(1.0, 1.0)), 0.0, 0.0, 1.0), (mat2(_GLF_IDENTITY(1.0, min(1.0, 1.0)), 0.0, 0.0, 1.0)) - mat2(0.0, 0.0, 0.0, 0.0)))))), 0.0, 0.0, 1.0, 1.0)), 1.0, 0.0, 0.0), _GLF_IDENTITY(vec4(determinant(mat3(1.0, 0.0, 0.0, 1.0, _GLF_IDENTITY(1.0, max(_GLF_IDENTITY(1.0, mix(float(1.0), float(_GLF_FUZZED(670.057)), bool(false))), _GLF_IDENTITY(1.0, float(_GLF_IDENTITY(mat2(_GLF_IDENTITY(1.0, min(1.0, 1.0)), 0.0, 0.0, 1.0), (mat2(_GLF_IDENTITY(1.0, min(1.0, 1.0)), 0.0, 0.0, 1.0)) - mat2(0.0, 0.0, 0.0, 0.0)))))), 0.0, 0.0, 1.0, 1.0)), 1.0, 0.0, 0.0), mat4(1.0) * (vec4(determinant(mat3(1.0, 0.0, 0.0, 1.0, _GLF_IDENTITY(1.0, max(_GLF_IDENTITY(1.0, mix(float(1.0), float(_GLF_FUZZED(670.057)), bool(false))), _GLF_IDENTITY(1.0, float(_GLF_IDENTITY(mat2(_GLF_IDENTITY(1.0, min(1.0, 1.0)), 0.0, 0.0, 1.0), (mat2(_GLF_IDENTITY(1.0, min(1.0, 1.0)), 0.0, 0.0, 1.0)) - mat2(0.0, 0.0, 0.0, 0.0)))))), 0.0, 0.0, 1.0, 1.0)), 1.0, 0.0, 0.0))))))) * 1.0)), 1.0))), 0.2, -511.220, 0.9, -9.0, -70.71, -6.9, -9.9, 3.3, 4778.0054, -1.6, -3.5)) : mat4(-40.91, _GLF_IDENTITY(435.643, clamp(_GLF_IDENTITY(435.643, min(435.643, 435.643)), 435.643, 435.643)), -768.817, -7.8, 8.5, -15.99, _GLF_IDENTITY(-13.72, _GLF_IDENTITY((_GLF_IDENTITY(-13.72, max(-13.72, -13.72))), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) ? _GLF_FUZZED(1.2) : (_GLF_IDENTITY(-13.72, max(-13.72, -13.72))))) - determinant(mat4(_GLF_IDENTITY(0.0, (_GLF_IDENTITY(0.0, (true ? _GLF_IDENTITY(0.0, clamp(0.0, 0.0, 0.0)) : _GLF_FUZZED(22.84)))) - 0.0), 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, abs(0.0), 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0))), _GLF_IDENTITY(-1642.8153, _GLF_IDENTITY(1.0 * (-1642.8153), clamp(1.0 * (-1642.8153), 1.0 * (-1642.8153), 1.0 * (-1642.8153)))), -80.25, 14.69, _GLF_IDENTITY(_GLF_IDENTITY(7.8, min(_GLF_IDENTITY(7.8, (7.8) / 1.0), 7.8)), (_GLF_IDENTITY(_GLF_IDENTITY(7.8, min(_GLF_IDENTITY(7.8, (7.8) / 1.0), 7.8)), clamp(_GLF_IDENTITY(7.8, min(_GLF_IDENTITY(7.8, (7.8) / 1.0), 7.8)), _GLF_IDENTITY(7.8, min(_GLF_IDENTITY(7.8, (7.8) / 1.0), 7.8)), _GLF_IDENTITY(7.8, min(_GLF_IDENTITY(7.8, (7.8) / 1.0), 7.8))))) / 1.0), 323.321, -301.235, 7.9, -80.12, 5.7)))) / mat4(1.0, 1.0, 1.0, 1.0, _GLF_IDENTITY(_GLF_IDENTITY(1.0, clamp(1.0, _GLF_IDENTITY(1.0, (false ? _GLF_FUZZED(-637.070) : 1.0)), 1.0)), min(_GLF_IDENTITY(_GLF_IDENTITY(1.0, clamp(1.0, _GLF_IDENTITY(1.0, (false ? _GLF_FUZZED(-637.070) : 1.0)), 1.0)), mix(float(_GLF_IDENTITY(1.0, clamp(1.0, _GLF_IDENTITY(1.0, (false ? _GLF_FUZZED(-637.070) : 1.0)), 1.0))), float(_GLF_FUZZED(-3015.4660)), bool(false))), _GLF_IDENTITY(1.0, clamp(1.0, _GLF_IDENTITY(1.0, (false ? _GLF_FUZZED(-637.070) : 1.0)), 1.0)))), _GLF_IDENTITY(1.0, (_GLF_IDENTITY(1.0, clamp(1.0, _GLF_IDENTITY(1.0, mix(float(1.0), float(_GLF_FUZZED(-54.06)), bool(false))), 1.0))) / _GLF_ONE(1.0, injectionSwitch.y)), 1.0, 1.0, _GLF_IDENTITY(1.0, min(1.0, 1.0)), 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0)));
 (_GLF_IDENTITY(mat2x4(-7.8, 1.2, 8.9, 7.6, 0.6, -2.8, 20.60, -219.773) != mat2x4(mat3x4(799.001, -402.818, -9736.3171, 8.5, -425.420, -1.2, 18.38, 5.1, 7.3, 23.74, 7.8, -8136.9879)), bool(bvec4(mat2x4(-7.8, 1.2, 8.9, 7.6, 0.6, -2.8, 20.60, -219.773) != mat2x4(mat3x4(799.001, -402.818, -9736.3171, 8.5, -425.420, -1.2, 18.38, 5.1, 7.3, 23.74, 7.8, -8136.9879)), _GLF_FALSE(false, _GLF_IDENTITY((_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)).x > injectionSwitch.y), bool(bvec3(_GLF_IDENTITY((_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)).x > injectionSwitch.y), (_GLF_IDENTITY((_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)).x > injectionSwitch.y), bool(bvec4((_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)).x > injectionSwitch.y), false, false, true)))) && true), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), false)))), false, true)))); -24426)
        {
         uint _GLF_SWITCH_0_14v, _GLF_SWITCH_0_15v[88];
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(4), int(4))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
              return;
            }
           barrier();
          }
         if(_GLF_DEAD(false))
          barrier();
         {
          if(_GLF_DEAD(false))
           {
            if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_DEAD(false))
               barrier();
             }
            else
             {
              barrier();
             }
            if(_GLF_DEAD(false))
             barrier();
           }
          bvec3(false, true, true);
          if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
           {
            if(_GLF_DEAD(false))
             barrier();
            for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
             {
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 {
                  for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > _GLF_IDENTITY(0, (0) >> 0)); _injected_loop_counter --)
                   {
                    return;
                   }
                 }
                if(_GLF_DEAD(false))
                 return;
                do
                 {
                  barrier();
                 }
                while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 barrier();
               }
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               barrier();
             }
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             barrier();
            for(mat3x2 _GLF_SWITCH_0_16v, _GLF_SWITCH_0_17v[94]; false; bvec4(false, false, true, true))
             {
              mod(vec2(6545.0692, 628.831), -28.27);
              uvec2 _GLF_SWITCH_0_18v[12], _GLF_SWITCH_0_19v;
              if(_GLF_WRAPPED_IF_TRUE(true))
               {
                if(_GLF_DEAD(false))
                 barrier();
                true;
               }
              else
               {
               }
             }
            if(_GLF_DEAD(false))
             barrier();
           }
          else
           {
           }
         }
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
          {
           for(int _GLF_SWITCH_0_20v, _GLF_SWITCH_0_21v; (true != true); (+ mat4(mat2x3(3784.6358, -5.2, -3841.2279, 4.4, -1.2, -292.563))))
            {
             if(_GLF_DEAD(false))
              barrier();
             mat3x4(transpose(mat3x2(736.988, 9.7, -700.289, 750.983, 4.9, -0.8)));
             mat3x2(_GLF_IDENTITY(-22.72, max(-22.72, -22.72)), 8.1, 3.8, _GLF_IDENTITY(29.15, _GLF_IDENTITY(float(mat2x3(_GLF_IDENTITY(29.15, (29.15) / 1.0), 1.0, _GLF_IDENTITY(1.0, float(_GLF_IDENTITY(vec3(1.0, 0.0, sin(0.0)), (vec3(_GLF_IDENTITY(1.0, float(float(1.0))), 0.0, sin(0.0))) * vec3(_GLF_IDENTITY(_GLF_ONE(1.0, injectionSwitch.y), min(_GLF_ONE(1.0, injectionSwitch.y), _GLF_ONE(1.0, injectionSwitch.y))), _GLF_ONE(1.0, injectionSwitch.y), _GLF_ONE(1.0, injectionSwitch.y))))), _GLF_IDENTITY(exp(0.0), min(_GLF_IDENTITY(exp(0.0), clamp(exp(0.0), exp(0.0), exp(0.0))), exp(0.0))), _GLF_IDENTITY(1.0, clamp(1.0, 1.0, 1.0)), _GLF_ZERO(0.0, _GLF_IDENTITY(injectionSwitch.x, clamp(injectionSwitch.x, injectionSwitch.x, injectionSwitch.x))))), max(float(mat2x3(_GLF_IDENTITY(29.15, float(mat4x2(29.15, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0))), 1.0, 1.0, exp(0.0), 1.0, _GLF_ZERO(0.0, injectionSwitch.x))), float(mat2x3(29.15, 1.0, _GLF_IDENTITY(1.0, _GLF_IDENTITY(float(_GLF_IDENTITY(mat2x3(1.0, 1.0, 1.0, tan(0.0), 1.0, 0.0), mat2x3(mat3(mat2x3(1.0, 1.0, 1.0, tan(0.0), 1.0, 0.0))))), clamp(float(_GLF_IDENTITY(mat2x3(1.0, 1.0, 1.0, tan(0.0), 1.0, 0.0), mat2x3(mat3(mat2x3(1.0, 1.0, 1.0, tan(0.0), 1.0, 0.0))))), float(_GLF_IDENTITY(mat2x3(1.0, 1.0, 1.0, tan(0.0), 1.0, 0.0), mat2x3(mat3(mat2x3(1.0, 1.0, 1.0, tan(0.0), 1.0, 0.0))))), float(_GLF_IDENTITY(mat2x3(1.0, 1.0, 1.0, tan(0.0), 1.0, 0.0), mat2x3(mat3(mat2x3(1.0, 1.0, 1.0, tan(0.0), 1.0, 0.0)))))))), exp(0.0), 1.0, _GLF_ZERO(0.0, injectionSwitch.x)))))), -12.32, 6.8);
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
             uvec4(_GLF_IDENTITY(50036u, (_GLF_IDENTITY((1u << _GLF_IDENTITY(_GLF_IDENTITY(uint(5u), uint(5u)), (_GLF_IDENTITY(uint(5u), uint(5u))) << 0u)) >> _GLF_IDENTITY(uint(5u), uint(5u)), 0u ^ ((1u << _GLF_IDENTITY(_GLF_IDENTITY(uint(5u), uint(5u)), (_GLF_IDENTITY(uint(5u), uint(5u))) << 0u)) >> _GLF_IDENTITY(_GLF_IDENTITY(uint(5u), uint(5u)), min(_GLF_IDENTITY(uint(5u), uint(5u)), _GLF_IDENTITY(uint(5u), uint(5u))))))) * (50036u)), 101734u, 39185u, 23935u);
             bvec2 _GLF_SWITCH_0_22v[36], _GLF_SWITCH_0_23v[72];
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
                if(_GLF_DEAD(false))
                 barrier();
                return;
               }
              do
               {
                (3.6 - mat2(-653.994, -862.234, -0.9, -9.4));
               }
              while(_GLF_WRAPPED_LOOP(false));
              mat2 _GLF_SWITCH_0_24v;
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_DEAD(false))
               {
                for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                 {
                  if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, false)))))
                   barrier();
                  barrier();
                 }
                if(_GLF_DEAD(false))
                 barrier();
                if(_GLF_DEAD(false))
                 barrier();
               }
              mat2x3 _GLF_SWITCH_0_25v, _GLF_SWITCH_0_26v;
              if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, vec2(vec3(_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)), 1.0))).x, mix(float(_GLF_IDENTITY(injectionSwitch, vec2(vec3(_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)), 1.0))).x), float(_GLF_FUZZED(6.2)), bool(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))) > injectionSwitch.y, (injectionSwitch.x > injectionSwitch.y) || false)))))
               {
                if(_GLF_WRAPPED_IF_TRUE(true))
                 {
                  return;
                 }
                else
                 {
                 }
               }
              bvec2 _GLF_SWITCH_0_27v, _GLF_SWITCH_0_28v;
              mat4 _GLF_SWITCH_0_29v;
              equal(tanh(vec4(-820.206, -9.4, -0.0, -0.3)), vec4(52.90, -6743.0334, -6285.3520, -2.9));
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_IDENTITY(bool(bvec4(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec4(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false, false, false))), true, false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))), true && (bool(bvec4(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec4(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false, false, false))), true, false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))))
               {
                do
                 {
                  for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                   {
                    barrier();
                   }
                 }
                while(_GLF_WRAPPED_LOOP(false));
               }
              if(_GLF_WRAPPED_IF_FALSE(false))
               {
               }
              else
               {
                subgroup_size;
               }
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_DEAD(false))
               barrier();
             }
            }
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
         while(false)
          {
           vec3 _GLF_SWITCH_0_30v;
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_DEAD(false))
                barrier();
               do
                {
                 return;
                }
               while(_GLF_WRAPPED_LOOP(false));
               if(_GLF_DEAD(false))
                barrier();
              }
             else
              {
              }
            }
           ivec4 _GLF_SWITCH_0_31v;
           ;
           if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, false || (false)), (injectionSwitch.x > injectionSwitch.y))))
            break;
           for(mat2x3 _GLF_SWITCH_0_32v; false; (ivec2(81386, -43392) , mat4x3(-7.1, 72.70, 193.870, _GLF_IDENTITY(-19.04, max(_GLF_IDENTITY(-19.04, (-19.04) + 0.0), _GLF_IDENTITY(-19.04, float(vec4(-19.04, determinant(mat4(1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0)), 1.0, 1.0))))), -9598.5955, 905.464, 34.56, 57.27, _GLF_IDENTITY(8.9, mix(float(_GLF_FUZZED(1.1)), float(8.9), _GLF_IDENTITY(bool(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))), true && (bool(_GLF_TRUE(true, (injectionSwitch.x < _GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, injectionSwitch.y, injectionSwitch.y))))))))), 0.6, 366.246, 8755.8468)))
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               barrier();
              }
            }
           do
            {
             mat4(_GLF_IDENTITY(3.3, max(3.3, 3.3)), -1842.9747, 4.8, -2145.9372, -3351.8543, -57.66, -5.6, 26.78, 228.507, 64.04, 1600.9549, -8986.7233, 527.927, 2.6, -9366.1114, 31.83);
             do
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               if(_GLF_DEAD(false))
                barrier();
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y)), true && (_GLF_IDENTITY(injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y)), ! (! (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y)))))))))))
              {
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 barrier();
                }
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, false)))))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, (injectionSwitch) / vec2(1.0, 1.0)).x > _GLF_IDENTITY(injectionSwitch.y, float(mat2x3(injectionSwitch.y, tan(0.0), round(length(normalize(vec2(1.0, 1.0)))), 1.0, 0.0, 0.0)))))))
                continue;
               for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                {
                 barrier();
                }
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, mix(float(_GLF_FUZZED((-49.62 * -0.7))), float(_GLF_IDENTITY(injectionSwitch.y, mix(float(_GLF_FUZZED(683.983)), float(injectionSwitch.y), bool(true)))), bool(true)))))));
           mat2x3(mat4x3(mat4x2(-7405.6711, -19.04, -8555.9512, 7.2, -8.6, -29.58, 21.64, -7.8)));
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
             barrier();
            }
          }
         {
          _GLF_IDENTITY((mat2(mat4x3(47.62, -3.2, 73.46, -91.21, _GLF_IDENTITY(-4.0, max(-4.0, -4.0)), -3961.6787, -7.4, 72.29, 1.2, 261.473, -7.5, -51.51)) * mat2(0.8, 6316.0455, 0.6, 64.26)), (false ? _GLF_FUZZED((- mat2(189.480, 3489.3055, -6376.0165, -553.427))) : (mat2(mat4x3(47.62, -3.2, 73.46, -91.21, _GLF_IDENTITY(-4.0, max(-4.0, -4.0)), -3961.6787, -7.4, 72.29, 1.2, 261.473, -7.5, -51.51)) * mat2(0.8, 6316.0455, 0.6, 64.26))));
          (mat2x3(65.37, _GLF_IDENTITY(-3.2, clamp(_GLF_IDENTITY(-3.2, clamp(_GLF_IDENTITY(-3.2, (-3.2) / 1.0), -3.2, -3.2)), _GLF_IDENTITY(-3.2, clamp(-3.2, _GLF_IDENTITY(-3.2, clamp(-3.2, -3.2, -3.2)), -3.2)), _GLF_IDENTITY(-3.2, min(-3.2, -3.2)))), -1.9, 5708.2709, -754.146, 1.6) * mat4x2(-90.56, 76.08, -49.98, -8213.1864, 3.1, -151.977, -4642.8074, 4.6));
          if((ivec2(66056, 80734) != ivec2(25228, _GLF_IDENTITY(72483, min(72483, 72483)))))
           {
            if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
             break;
            do
             {
              (-5.2 - mat4(-454.516, 4.3, 9.5, 4.3, 9.2, -179.718, 7.9, 786.776, 131.504, -654.175, -6259.9655, 64.73, 7188.3677, _GLF_IDENTITY(-261.896, (-261.896) * abs(1.0)), 608.535, 931.419));
             }
            while(_GLF_WRAPPED_LOOP(false));
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
              do
               {
                if(_GLF_WRAPPED_IF_TRUE(true))
                 {
                  barrier();
                 }
                else
                 {
                 }
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 barrier();
               }
              while(_GLF_WRAPPED_LOOP(false));
              if(_GLF_DEAD(false))
               barrier();
             }
           }
          do
           {
            do
             {
              if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
               barrier();
              if(_GLF_DEAD(false))
               barrier();
             }
            while(_GLF_WRAPPED_LOOP(false));
           }
          while(_GLF_WRAPPED_LOOP(false));
          bvec3 _GLF_SWITCH_0_33v[29], _GLF_SWITCH_0_34v, _GLF_SWITCH_0_35v;
          if(_GLF_DEAD(false))
           barrier();
          for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
           {
            for(int _injected_loop_counter = _GLF_IDENTITY(1, clamp(1, 1, _GLF_IDENTITY(1, (_GLF_IDENTITY(1, max(1, 1))) << (0 & 23800)))); _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter, (_injected_loop_counter) / 1) != 0); _injected_loop_counter --)
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               barrier();
              if(_GLF_DEAD(false))
               {
                if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                 {
                  barrier();
                 }
                else
                 {
                 }
               }
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 barrier();
                continue;
               }
              if(_GLF_WRAPPED_IF_FALSE(false))
               {
               }
              else
               {
                ((+ subgroup_base) * _GLF_IDENTITY(uvec3(_GLF_IDENTITY(198348u, ~ (~ (_GLF_IDENTITY(198348u, uint(uint(198348u)))))), 72655u, 126669u), clamp(uvec3(198348u, 72655u, 126669u), uvec3(198348u, 72655u, 126669u), uvec3(198348u, 72655u, 126669u))));
                if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
                 barrier();
               }
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_DEAD(false))
               barrier();
             }
           }
          if(_GLF_DEAD(false))
           {
            do
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               barrier();
              if(_GLF_WRAPPED_IF_FALSE(false))
               {
               }
              else
               {
                barrier();
               }
             }
            while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, float(vec4(injectionSwitch.x, log(1.0), sin(0.0), length(vec2(0.0, 0.0))))) > injectionSwitch.y))));
            if(_GLF_WRAPPED_IF_TRUE(true))
             {
              if(_GLF_DEAD(false))
               return;
             }
            else
             {
             }
           }
          mat2(737.808, _GLF_IDENTITY(2829.9117, max(2829.9117, 2829.9117)), 3.0, -382.174);
          mat3x4(598.412, -5.0, _GLF_IDENTITY(-486.496, (_GLF_IDENTITY(_GLF_IDENTITY(-486.496, (false ? _GLF_FUZZED(1.4) : -486.496)), (false ? _GLF_FUZZED(-5.5) : _GLF_IDENTITY(-486.496, _GLF_IDENTITY((_GLF_IDENTITY(-486.496, min(-486.496, -486.496))), ((_GLF_IDENTITY(-486.496, min(-486.496, -486.496)))) * 1.0) - 0.0)))) / 1.0), 9.2, 829.148, -74.28, -1.8, -7.0, -9207.8283, _GLF_IDENTITY(8710.4406, (8710.4406) * _GLF_IDENTITY(_GLF_IDENTITY(1.0, (1.0) - log(1.0)), mix(float(1.0), float(_GLF_FUZZED(90.95)), bool(false)))), 7.0, 708.713);
          if(_GLF_DEAD(false))
           barrier();
          if(_GLF_WRAPPED_IF_TRUE(true))
           {
            for(            -56789;
 _GLF_IDENTITY(isnan(8977.9953), (isnan(8977.9953)) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))); ivec3(-32562, 11787, -15832))
             {
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_DEAD(false))
               barrier();
              mat2x3 _GLF_SWITCH_0_36v[9];
              (+ (-34390 ^ bitfieldReverse(ivec3(-43680, -79113, -25920))));
              ivec4 _GLF_SWITCH_0_37v;
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 barrier();
                barrier();
               }
              do
               {
                if(_GLF_DEAD(false))
                 barrier();
                if(_GLF_DEAD(false))
                 barrier();
                if(_GLF_WRAPPED_IF_FALSE(false))
                 {
                 }
                else
                 {
                  bvec4(false, true, false, true);
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   barrier();
                 }
                if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, bool(bvec3(false, false, true))), (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, true && (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, true && (injectionSwitch.x > injectionSwitch.y))))) && true)))))
                 barrier();
               }
              while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, bool(bvec2(injectionSwitch.x > injectionSwitch.y, false)))))));
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_WRAPPED_IF_FALSE(false))
               {
               }
              else
               {
                if(_GLF_DEAD(false))
                 barrier();
                vec4(8.9, vec3(9.9, 5.2, 203.341));
                if(_GLF_DEAD(false))
                 barrier();
               }
             }
           }
          else
           {
           }
          if(_GLF_DEAD(false))
           barrier();
         }
         while(false)
          {
           if(false)
            {
             vec2 _GLF_SWITCH_0_38v[79];
            }
           else
            {
             uint _GLF_SWITCH_0_39v;
             do
              {
               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                }
               else
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 do
                  {
                   if(_GLF_DEAD(false))
                    return;
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                }
               ivec4(-76614, _GLF_IDENTITY(-43418, ~ (~ (_GLF_IDENTITY(-43418, min(-43418, -43418))))), _GLF_IDENTITY(-23189, ~ (~ (-23189))), -28984);
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).y))))
              {
               if(_GLF_DEAD(false))
                barrier();
               continue;
              }
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < _GLF_IDENTITY(1, (1) << 0)); _injected_loop_counter ++)
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               if(_GLF_DEAD(false))
                barrier();
              }
             mat3x2 _GLF_SWITCH_0_40v[95], _GLF_SWITCH_0_41v[23];
             (ivec4(_GLF_IDENTITY(-96170, min(-96170, -96170)), -82448, -97561, 76142) * ivec4(86921, 86201, 47647, -38532));
             int _GLF_SWITCH_0_42v;
            }
           mix((_GLF_IDENTITY(_GLF_IDENTITY(ivec4(-6198, -74748, 48362, 67252), (ivec4(-6198, -74748, 48362, 67252)) << ivec4(0, 0, 0, 0)) & ivec4(53584, -30389, -86874, -65612), (ivec4(-6198, -74748, 48362, 67252) & _GLF_IDENTITY(ivec4(53584, -30389, -86874, _GLF_IDENTITY(-65612, (true ? -65612 : _GLF_FUZZED(-95003)))), (ivec4(53584, -30389, -86874, _GLF_IDENTITY(-65612, (true ? -65612 : _GLF_FUZZED(-95003))))) / ivec4(1, 1, 1, 1))) - _GLF_IDENTITY(ivec4(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)), (ivec4(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x))) | (ivec4(_GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x), _GLF_ZERO(0.0, injectionSwitch.x)))))), (ivec4(ivec2(88092, 7085), 12649, 393)), bvec4(false, bvec3(true, _GLF_IDENTITY(_GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (true), ! (_GLF_IDENTITY(! (! (true)), false || (! (! (true)))))))), ! (_GLF_IDENTITY(! (_GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (true), ! (_GLF_IDENTITY(! _GLF_IDENTITY((! (true)), ! (! ((! (true))))), false || (! (! (true))))))))), bool(bool(! (_GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (true), ! (_GLF_IDENTITY(! (! (true)), false || (! (! (_GLF_IDENTITY(true, ! (! (true))))))))))))))))), true)));
           uvec4(72755u, 100380u, _GLF_IDENTITY(30419u, uint(uvec2(30419u, 1u))), 190510u);
           bvec4(true, true, true, false);
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 barrier();
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(bvec2(false, true)))))
                  {
                  }
                 else
                  {
                   for(int _injected_loop_counter = _GLF_IDENTITY(1, max(1, 1)); _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                    {
                     if(_GLF_DEAD(false))
                      {
                       do
                        {
                         barrier();
                         if(_GLF_DEAD(false))
                          barrier();
                        }
                       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                      }
                    }
                  }
                }
               else
                {
                }
              }
             else
              {
              }
            }
           {
            if(_GLF_DEAD(false))
             {
              if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || false)) || false), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
               {
               }
              else
               {
                return;
               }
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(false))
                 barrier();
                break;
               }
             }
            if(_GLF_WRAPPED_IF_TRUE(true))
             {
              if(_GLF_DEAD(false))
               barrier();
              if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
                if(_GLF_WRAPPED_IF_TRUE(true))
                 {
                  if(_GLF_DEAD(false))
                   {
                    if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     barrier();
                    barrier();
                   }
                 }
                else
                 {
                 }
               }
              else
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 barrier();
                if(_GLF_DEAD(false))
                 barrier();
                if(_GLF_WRAPPED_IF_TRUE(true))
                 {
                  do
                   {
                    if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, ! (! (injectionSwitch.x > injectionSwitch.y)))))))
                     barrier();
                   }
                  while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                 }
                else
                 {
                 }
                ;
               }
             }
            else
             {
             }
            if(_GLF_DEAD(false))
             barrier();
            if(_GLF_WRAPPED_IF_FALSE(false))
             {
             }
            else
             {
              mat3(-466.945, 445.920, -4302.4662, -5799.9091, 185.810, 1080.7127, -968.499, 21.90, -7.4);
             }
            if(_GLF_DEAD(false))
             barrier();
            do
             {
              _GLF_IDENTITY(uvec2(199078u, 134044u), max(uvec2(199078u, 134044u), uvec2(199078u, 134044u)));
             }
            while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, vec2(1.0, 1.0) * _GLF_IDENTITY((injectionSwitch), min((injectionSwitch), _GLF_IDENTITY((injectionSwitch), max((injectionSwitch), (injectionSwitch)))))).y)), false || (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))));
            (vec4(37.95, -3.5, injectionSwitch) / _GLF_IDENTITY(vec4(-293.427, 28.76, _GLF_IDENTITY(-816.161, (true ? -816.161 : _GLF_FUZZED(9.5))), 62.25), mat4(1.0) * (vec4(-293.427, 28.76, _GLF_IDENTITY(-816.161, (true ? -816.161 : _GLF_FUZZED(9.5))), 62.25))));
            if(_GLF_DEAD(false))
             barrier();
           }
           if(_GLF_DEAD(false))
            barrier();
           do
            {
             (acos(injectionSwitch) * mat2(-9.9, -6099.5046, _GLF_IDENTITY(537.028, clamp(_GLF_IDENTITY(537.028, (537.028) * 1.0), _GLF_IDENTITY(537.028, max(537.028, 537.028)), 537.028)), -7394.5817));
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
         ;
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
        }
       else
        {
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
        }
       default:
       _GLF_IDENTITY(1, ~ (~ (1)));
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, (false ? _GLF_FUZZED(log(-5866.0911)) : injectionSwitch.x)) > injectionSwitch.y))))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         barrier();
        }
      }
    }
   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
    {
     if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && true))
      barrier();
    }
   else
    {
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     barrier();
    }
  }
 do
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
  }
 while(_GLF_WRAPPED_LOOP(false));
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     barrier();
    }
  }
 if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
  barrier();
 for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
  {
   if(_GLF_DEAD(false))
    barrier();
  }
 subgroupBarrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    barrier();
   barrier();
  }
 if(_GLF_DEAD(_GLF_IDENTITY(false, false || (_GLF_IDENTITY(false, ! (! (false)))))))
  barrier();
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, bool(bvec2(false, false))), (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(_GLF_IDENTITY(bvec2(_GLF_FALSE(_GLF_IDENTITY(false, false || (false)), (_GLF_IDENTITY(injectionSwitch.x, float(float(_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) * 1.0)))) > injectionSwitch.y)), _GLF_IDENTITY(true, false || (_GLF_IDENTITY(true, bool(bvec2(true, true)))))), bvec2(bvec2(bvec2(_GLF_FALSE(_GLF_IDENTITY(false, false || (false)), (_GLF_IDENTITY(injectionSwitch.x, float(float(_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) * 1.0)))) > injectionSwitch.y)), _GLF_IDENTITY(true, false || (_GLF_IDENTITY(true, bool(bvec2(true, true)))))))))))))
    {
     do
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(false))
          return;
        }
       else
        {
        }
      }
     while(_GLF_WRAPPED_LOOP(false));
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     barrier();
    }
   atomicStore(checker[virtual_gid], read, 4, _GLF_IDENTITY(64, ~ (~ (_GLF_IDENTITY(64, 0 ^ (_GLF_IDENTITY(_GLF_IDENTITY(64, (64) >> 0), max(_GLF_IDENTITY(64, (64) >> 0), _GLF_IDENTITY(64, (64) >> 0)))))))), 4);
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    {
     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter > 0, bool(bvec2(_injected_loop_counter > 0, false)))); _GLF_IDENTITY(_injected_loop_counter --, 0 | (_injected_loop_counter --)))
      {
       barrier();
      }
    }
  }
 else
  {
   if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec4(_GLF_IDENTITY(false, true && (false)), true, true, true)), ! (! (bool(bvec4(_GLF_IDENTITY(false, true && (false)), true, true, true))))))))
    {
    }
   else
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
        }
       else
        {
         do
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (injectionSwitch.x > injectionSwitch.y) || false)))))
            barrier();
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
        }
       barrier();
      }
    }
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
      {
       for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
        {
         if(_GLF_DEAD(false))
          barrier();
         for(int _injected_loop_counter = ((1 ^ 1) ^ 1); _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 << _GLF_IDENTITY(int(2), int(2)))); _injected_loop_counter --)
          {
           barrier();
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
        }
      }
    }
  }
}
