#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer Checker {
 uint checker[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = gl_NumWorkGroups.x;
 uint workgroup_size = gl_WorkGroupSize.x;
 uint workgroup_id = gl_WorkGroupID.x;
 uint workgroup_base = workgroup_size * workgroup_id;
 uint virtual_gid = workgroup_base + subgroup_id * subgroup_size + subgroup_local_id;
 uint next_virtual_gid = workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size);
 atomicStore(buf[next_virtual_gid], uint(1), 4, 64, 4);
 uint read = atomicLoad(buf[virtual_gid], 4, 64, 0);
 if(subgroup_local_id + 1 < subgroup_size)
  {
   switch(_GLF_SWITCH(0))
    {
     case 21:
     mat4(70.83, 3.9, -3.9, 4.0, -7.9, -5343.2943, -4.2, 52.68, -2516.8705, -29.91, -8120.5226, 8.5, -0.2, -17.01, -7.4, -7.2);
     case 30:
     for(     mat2x3(98.81, -1298.0861, 1343.7760, 5458.2299, 4529.8322, 85.45);
 true; bvec2(bvec3(true, false, true)))
      {
       ;
      }
     case 0:
     atomicStore(checker[virtual_gid], read, 4, 64, 4);
     subgroupAll(false);
     break;
     default:
     1;
    }
  }
 else
  {
   switch(_GLF_SWITCH(0))
    {
     case 94:
     while(false)
      {
       switch(_GLF_SWITCH(0))
        {
         case 0:
         case 17:
         case 39:
         if((bvec2(false, true) == not(bvec2(true, true))))
          {
           if(true)
            {
             ;
             ;
            }
           else
            {
             ivec3 _GLF_SWITCH_1_0v[76], _GLF_SWITCH_1_1v[2];
             subgroup_local_id;
             mat4 _GLF_SWITCH_1_2v, _GLF_SWITCH_1_3v;
             ;
             mod(vec4(0.7, vec2(-24.55, -969.943), 7.0), vec4(2.6, 44.89, 2169.3904, 1396.6282));
             uvec4(57029u, 81674u, 103697u, 54463u);
            }
          }
         else
          {
           if((uvec4(virtual_gid, workgroup_id, atomicOr(read, 137161u), subgroup_size) == uvec4(22102u, 174302u, 39870u, 142115u)))
            {
             (mat2x4(72.84, -4.3, -8414.0509, 69.73, -408.470, 8813.3163, 297.172, 2.7) - fma(8422.5123, -4991.5071, -8554.6198));
             bool _GLF_SWITCH_1_4v, _GLF_SWITCH_1_5v, _GLF_SWITCH_1_6v;
             bool _GLF_SWITCH_1_7v[67];
             mat3(6.0, 61.21, -18.82, -5.2, -0.9, 82.60, -6287.2315, -7245.2098, 8.2);
             ivec2 _GLF_SWITCH_1_8v;
             mat4x2(-9.3, 2.0, -66.58, 4.9, 5.3, 357.132, 13.03, 431.906);
            }
           else
            {
             mat3x2 _GLF_SWITCH_1_9v[10];
             subgroup_local_id;
             mat3x4(-2.3, -60.67, 3.0, 8.2, 744.843, -6.2, 2860.0791, -927.200, -50.37, -1.5, -93.17, -3329.7979);
             ;
             ivec2 _GLF_SWITCH_1_10v;
             vec3 _GLF_SWITCH_1_11v[40], _GLF_SWITCH_1_12v, _GLF_SWITCH_1_13v;
             bvec4 _GLF_SWITCH_1_14v, _GLF_SWITCH_1_15v[71], _GLF_SWITCH_1_16v[93];
             mat4(9.9, -2.8, -0.9, -53.37, -822.565, -74.64, 681.496, 4311.4470, -6.8, -5.6, 8.6, -62.25, -42.25, 81.95, -99.18, 2.2);
            }
           mat4 _GLF_SWITCH_1_17v[34], _GLF_SWITCH_1_18v;
           clamp((63597 + 9965), -2181, -1130);
           {
            mat4x3 _GLF_SWITCH_1_19v;
            mat2x4 _GLF_SWITCH_1_20v, _GLF_SWITCH_1_21v, _GLF_SWITCH_1_22v[90];
            int _GLF_SWITCH_1_23v, _GLF_SWITCH_1_24v[70];
            vec3 _GLF_SWITCH_1_25v[92], _GLF_SWITCH_1_26v, _GLF_SWITCH_1_27v;
            _GLF_SWITCH_1_21v;
            uvec4 _GLF_SWITCH_1_28v[56];
           }
           if(true)
            {
             bvec3 _GLF_SWITCH_1_29v[67], _GLF_SWITCH_1_30v, _GLF_SWITCH_1_31v;
             (+ ivec4(85778, 88174, 78708, 23015));
            }
           else
            {
             mat2x4(-5539.3847, -87.18, -3557.8370, 4.4, -3.2, -3.6, -9.5, 0.7);
             lessThan(vec4(-0.4, -5.9, -1185.6381, 6841.3548), vec4(62.12, -775.438, -831.520, 2.1));
            }
           vec4(27.58, 6210.2767, 7.5, 8.4);
           min((workgroup_id - uvec2(87541u, 47949u)), uvec2(67117u, 182369u));
           ;
           {
            ;
            ivec2 _GLF_SWITCH_1_32v, _GLF_SWITCH_1_33v;
           }
          }
         case 24:
         case 55:
         case 26:
         case 70:
         case 78:
         case 28:
         {
          while(true)
           {
            (trunc(391.396) - mat2x4(-984.636, -85.37, -8.6, -5894.2254, 6.4, 5.5, 627.049, 0.3));
            mat2(3.0, -906.580, 364.596, 4.5);
            ivec4 _GLF_SWITCH_1_34v, _GLF_SWITCH_1_35v[96];
            uvec4 _GLF_SWITCH_1_36v[39];
            mat4x2 _GLF_SWITCH_1_37v[46];
            uvec3 _GLF_SWITCH_1_38v;
            ivec2(-30340, 14884);
            ivec3 _GLF_SWITCH_1_39v, _GLF_SWITCH_1_40v, _GLF_SWITCH_1_41v;
           }
          bool _GLF_SWITCH_1_42v, _GLF_SWITCH_1_43v;
          do
           {
           }
          while(bvec4(false, true, false, false).b);
          if(all(bvec2(false, true)))
           {
            ivec2(-76199, 97241);
            ;
            ;
            bool _GLF_SWITCH_1_44v[58], _GLF_SWITCH_1_45v;
           }
          if(true)
           {
            mat4x2(194.749, 43.81, 165.272, 568.808, 1.9, -496.260, -9.6, -2.7);
            (uvec4(137351u, 34314u, 173098u, 53942u) * uvec4(104703u, 121421u, 43597u, 107563u));
            ;
            ivec4(98449, -38810, -91319, -91292);
           }
          while(_GLF_SWITCH_1_42v)
           {
            uvec3 _GLF_SWITCH_1_46v, _GLF_SWITCH_1_47v, _GLF_SWITCH_1_48v[32];
            mat2 _GLF_SWITCH_1_49v;
            mat3x2 _GLF_SWITCH_1_50v;
            uint _GLF_SWITCH_1_51v, _GLF_SWITCH_1_52v;
            bvec3(false, true, true);
           }
         }
         break;
         case 37:
         ;
         case 66:
         if(false)
          {
           not(bvec2(false, false));
           ;
           (vec4(2001.3702, 3.1, -6.9, 3.5));
           clamp(54559, 47714, 65625);
           (uvec4(112217u, 102783u, 117345u, 14124u));
           mat2x4 _GLF_SWITCH_0_0v, _GLF_SWITCH_0_1v, _GLF_SWITCH_0_2v[43];
          }
         default:
         1;
        }
      }
     case 0:
     atomicStore(checker[virtual_gid], read, 4, 64, 4);
     case 76:
     case 34:
     case 53:
     subgroupAll(true);
     break;
     case 59:
     if(true)
      {
      }
     case 18:
     for(mat4 _GLF_SWITCH_1_53v[95], _GLF_SWITCH_1_54v[72]; (mat2(-1.4, 991.290, -8276.4458, 5258.7626) != mat2(mat4x2(711.151, 451.535, -816.088, -2584.3524, -0.2, -954.484, 6.2, 5311.2429))); (uvec3(197725u, 9776u, 21948u) << workgroup_id))
      {
       uvec4 _GLF_SWITCH_1_55v, _GLF_SWITCH_1_56v[17], _GLF_SWITCH_1_57v;
       bvec4(false, false, false, false);
       uvec2(58338u, 65396u).stss;
       (92274 / ivec4(56328, -46774, 58387, 64139)[0]);
       not(bvec3(true, false, true));
      }
     default:
     1;
    }
  }
}
