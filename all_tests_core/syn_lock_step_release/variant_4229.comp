#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, false)))))
  {
   for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
    }
   if(_GLF_DEAD(false))
    {
     switch(_GLF_SWITCH(0))
      {
       case 0:
       case 36:
       case 80:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           barrier();
          }
         else
          {
          }
        }
       case 47:
       case 72:
       case 76:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       if(_GLF_DEAD(false))
        return;
       case 44:
       case 81:
       case 37:
       for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(4), int(4))); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             return;
            }
           else
            {
            }
          }
        }
       return;
       break;
       if(_GLF_DEAD(false))
        return;
       default:
       1;
      }
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      return;
     do
      {
       if(_GLF_DEAD(false))
        barrier();
      }
     while(_GLF_WRAPPED_LOOP(false));
     if(_GLF_DEAD(false))
      return;
     return;
    }
   return;
   if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), bool(bvec3(_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ((injectionSwitch.x > injectionSwitch.y)) && true), true, true))))))
    {
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
      {
       barrier();
      }
     else
      {
      }
    }
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
          }
         else
          {
           do
            {
             return;
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
        }
       else
        {
        }
      }
     if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, false || (injectionSwitch.x > injectionSwitch.y)))), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true)))
      barrier();
     do
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
   barrier();
   if(_GLF_DEAD(false))
    return;
  }
 uint subgroup_id = gl_SubgroupID;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, (true) && true)))
    {
     barrier();
    }
   else
    {
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
  {
   do
    {
     return;
    }
   while(_GLF_WRAPPED_LOOP(false));
  }
 uint subgroup_size = gl_SubgroupSize;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, _GLF_IDENTITY(_GLF_IDENTITY(bool(bvec3(false, true, false)), _GLF_IDENTITY(bool(bvec4(bool(bvec3(false, _GLF_IDENTITY(true, (true) || false), false)), true, true, true)), bool(bool(bool(bvec4(bool(bvec3(false, _GLF_IDENTITY(true, false || (true)), false)), true, true, true)))))), (_GLF_IDENTITY(_GLF_IDENTITY(bool(bvec3(false, true, false)), _GLF_IDENTITY(bool(bvec4(bool(bvec3(false, _GLF_IDENTITY(true, (true) || false), false)), true, true, true)), bool(bool(bool(bvec4(bool(bvec3(false, _GLF_IDENTITY(true, false || (true)), false)), true, true, true)))))), (_GLF_IDENTITY(bool(bvec3(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), bool(bool(_GLF_IDENTITY(! (false), false || (! (false)))))))), true, false)), _GLF_IDENTITY(bool(bvec4(bool(bvec3(false, _GLF_IDENTITY(true, (true) || false), false)), true, true, true)), bool(bool(bool(bvec4(bool(bvec3(false, _GLF_IDENTITY(true, false || (true)), false)), true, true, true))))))) && true)) || false))))
  {
   if(_GLF_DEAD(false))
    return;
  }
 else
  {
   if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, false || (false)))))))
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        return;
       barrier();
      }
     for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
      {
       if(_GLF_DEAD(false))
        return;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     do
      {
       if(_GLF_DEAD(false))
        return;
      }
     while(_GLF_WRAPPED_LOOP(false));
     if(_GLF_DEAD(false))
      return;
    }
   else
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        {
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
          {
           return;
          }
        }
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           barrier();
          }
         else
          {
          }
        }
       else
        {
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 << _GLF_IDENTITY(int(5), int(5)))); _injected_loop_counter --)
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, clamp(injectionSwitch.x, _GLF_IDENTITY(injectionSwitch.x, 1.0 * (injectionSwitch.x)), injectionSwitch.x)) > injectionSwitch.y))))
            return;
          }
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            return;
           switch(_GLF_SWITCH(0))
            {
             case 8:
             (mat4(45.11, -32.89, 48.75, 580.276, 87.95, -8998.6555, -0.5, 0.1, -4.3, -1054.8392, -8.1, 7.2, 127.868, 50.86, 89.28, 8.1) - (+ mat4(515.165, -6168.2609, 139.939, -812.994, 6450.6515, 775.178, -2446.7127, -6.1, -696.553, 7.1, 4.2, -7.6, -56.22, -465.867, -628.556, 65.68)));
             case 3:
             do
              {
               ;
               (mat2(-4375.2549, -85.10, -7.6, -2713.1154));
               ;
               bvec3 _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v[87];
               bvec2 _GLF_SWITCH_3_2v, _GLF_SWITCH_3_3v, _GLF_SWITCH_3_4v;
               mat4x3 _GLF_SWITCH_3_5v;
              }
             while(false);
             case 0:
             case 37:
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             case 62:
             case 25:
             case 57:
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             case 14:
             case 21:
             case 67:
             do
              {
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(_GLF_IDENTITY(true, (true) || false), (injectionSwitch.x < injectionSwitch.y))))
                {
                 barrier();
                }
               else
                {
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
             break;
             case 80:
             while(false)
              {
               ivec3 _GLF_SWITCH_3_6v;
               mat3x4(-177.556, -2373.9061, 13.07, -251.834, 3.9, -6.3, 6000.9341, -949.170, -7932.4805, -3.5, -1.8, 793.802);
               (-95385 > -38703);
               uint _GLF_SWITCH_3_7v;
               72859;
               float _GLF_SWITCH_3_8v, _GLF_SWITCH_3_9v[80];
              }
             default:
             if(_GLF_DEAD(false))
              return;
             do
              {
               1;
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
          }
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
          {
           barrier();
          }
        }
       do
        {
         if(_GLF_DEAD(false))
          return;
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec2(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), bool(bool((injectionSwitch.x > injectionSwitch.y))))), false)))))
        return;
       if(_GLF_DEAD(false))
        {
         do
          {
           if(_GLF_DEAD(false))
            continue;
           barrier();
           if(_GLF_DEAD(false))
            continue;
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec2(false, false), bvec2(bvec3(bvec2(false, false), false)))))))
        return;
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 >> _GLF_IDENTITY(int(5), int(5)))); _injected_loop_counter --)
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
        }
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
            {
             if(_GLF_DEAD(false))
              return;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 barrier();
                }
               else
                {
                }
              }
            }
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 if(_GLF_DEAD(false))
                  return;
                }
               barrier();
               if(_GLF_DEAD(false))
                return;
              }
             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
              }
             else
              {
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               if(_GLF_DEAD(false))
                return;
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   return;
                  }
                }
               if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec3(false, true, false)), true && (bool(bvec3(false, true, false)))))))
                barrier();
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_DEAD(false))
                  return;
                }
               else
                {
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               return;
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
              barrier();
             for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(5), _GLF_IDENTITY(int(5), (int(5)) << 0))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
              {
               if(_GLF_DEAD(false))
                barrier();
               for(int _injected_loop_counter = (1 ^ 1); _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 ^ 1)); _injected_loop_counter ++)
                {
                 switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                  {
                   case 6:
                   bvec2 _GLF_SWITCH_3_0v[49], _GLF_SWITCH_3_1v;
                   case 24:
                   mat4x2 _GLF_SWITCH_3_2v, _GLF_SWITCH_3_3v[13], _GLF_SWITCH_3_4v[14];
                   case 0:
                   case 1:
                   case 31:
                   case 80:
                   case 85:
                   if(_GLF_DEAD(false))
                    return;
                   case 2:
                   case 5:
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                    }
                   else
                    {
                     barrier();
                    }
                   if(_GLF_DEAD(false))
                    return;
                   break;
                   if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                    continue;
                   case 73:
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                    }
                   else
                    {
                     mat3x2(-0.2, -8.2, 374.215, 201.969, 5436.2631, -28.64);
                    }
                   case 94:
                   mat2(5.6, 165.022, 314.527, 1371.1429);
                   default:
                   do
                    {
                     1;
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                  }
                }
              }
            }
           else
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, bool(bvec4(_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, false || (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, false || (injectionSwitch.x > injectionSwitch.y)))), true, true, true)))))))
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                    }
                   else
                    {
                     barrier();
                    }
                  }
                }
               else
                {
                }
              }
             else
              {
              }
             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
              }
             else
              {
               if(_GLF_DEAD(false))
                return;
               return;
              }
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, mix(float(injectionSwitch.x), float(_GLF_FUZZED(6.8)), bool(false))) > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              return;
             barrier();
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 return;
                }
              }
            }
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                return;
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 barrier();
                }
               else
                {
                }
              }
             return;
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
          }
         if(_GLF_DEAD(false))
          return;
        }
       else
        {
        }
      }
    }
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
  }
 else
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = _GLF_IDENTITY(gl_NumWorkGroups.x, 0u + (gl_NumWorkGroups.x));
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   return;
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     switch(_GLF_SWITCH(0))
      {
       case 25:
       if(_GLF_DEAD(false))
        return;
       -38525;
       case 4:
       ivec2 _GLF_SWITCH_3_0v;
       case 0:
       case 8:
       case 22:
       case 69:
       case 41:
       case 53:
       case 63:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       case 42:
       do
        {
         if(_GLF_DEAD(false))
          barrier();
         do
          {
           barrier();
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
         do
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
       while(_GLF_WRAPPED_LOOP(false));
       break;
       case 70:
       if((vec2(-9.6, 5.0) != vec2(362.668, 149.843)))
        {
         if(false)
          {
           bool _GLF_SWITCH_3_1v, _GLF_SWITCH_3_2v, _GLF_SWITCH_3_3v;
           greaterThanEqual(min(uvec4(34278u, 157978u, 108919u, 16256u), num_workgroup), uvec4(149707u, 102069u, 20417u, 97443u));
           ivec3 _GLF_SWITCH_3_4v, _GLF_SWITCH_3_5v;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           bvec3 _GLF_SWITCH_3_6v[1], _GLF_SWITCH_3_7v[99], _GLF_SWITCH_3_8v;
           mat4x2 _GLF_SWITCH_3_9v[21], _GLF_SWITCH_3_10v, _GLF_SWITCH_3_11v;
           while(_GLF_SWITCH_3_2v)
            {
             int _GLF_SWITCH_3_12v, _GLF_SWITCH_3_13v;
             if(_GLF_DEAD(false))
              continue;
             subgroup_id;
            }
          }
         while(true)
          {
           if(true)
            {
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               mat2(-6.9, -5.5, 5.4, 19.25);
              }
             else
              {
              }
             (uvec4(180544u, 7100u, 134488u, 33328u) ^ (33815u & uvec4(52479u, 193766u, 123049u, 32604u)));
             mat2x4(-4230.9907, -919.276, -9.5, 39.57, 561.133, 799.394, -0.2, 0.5);
             (false ? mat3x4(7.2, 3.4, 13.91, 2.9, -2.3, -5593.7429, 7.8, 533.702, -836.575, 8879.9324, 59.96, 3276.0461) : mat3x4(2641.1717, -0.4, 883.647, 5.7, 6084.8622, 0.8, 82.28, 30.49, 7702.5884, 6550.6508, -390.226, 96.71));
             bool _GLF_SWITCH_3_14v[38], _GLF_SWITCH_3_15v, _GLF_SWITCH_3_16v;
             ;
             (mat4x3(-2.1, 8.3, 37.39, -95.08, 3324.5265, -910.282, 9.0, -679.078, 22.59, 148.843, 3718.9433, 9.9) * mat4(724.765, 8572.9776, 5845.6329, 65.11, -69.50, -76.99, -5.0, -2.4, -913.760, -5.4, 565.267, -0.4, 8018.6766, -8.0, -25.92, 8651.1424));
             if(_GLF_DEAD(false))
              continue;
            }
           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
            continue;
           vec4 _GLF_SWITCH_3_17v[20], _GLF_SWITCH_3_18v, _GLF_SWITCH_3_19v;
           while(false)
            {
             bool _GLF_SWITCH_3_20v[17];
             bool _GLF_SWITCH_3_21v, _GLF_SWITCH_3_22v, _GLF_SWITCH_3_23v;
            }
           inversesqrt(39.16);
           do
            {
             vec2 _GLF_SWITCH_3_24v, _GLF_SWITCH_3_25v;
             mat2x4 _GLF_SWITCH_3_26v;
             uvec3 _GLF_SWITCH_3_27v[79], _GLF_SWITCH_3_28v[98], _GLF_SWITCH_3_29v;
             false;
             uint _GLF_SWITCH_3_30v, _GLF_SWITCH_3_31v[43], _GLF_SWITCH_3_32v;
             ivec3(-54546, 33028, 77704);
             mat4 _GLF_SWITCH_3_33v, _GLF_SWITCH_3_34v, _GLF_SWITCH_3_35v[29];
             uvec3 _GLF_SWITCH_3_36v, _GLF_SWITCH_3_37v;
            }
           while(true);
          }
         outerProduct(vec3(-938.829, 958.358, -29.22), vec4(-9.1, 9.1, -668.890, 8.8));
         mat3(6.1, 603.908, -426.043, -9.6, 6.4, 6772.2448, 7.1, -5.0, -458.546);
         -36782;
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), int(0))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
            {
             return;
            }
          }
        }
       else
        {
         if(_GLF_DEAD(false))
          return;
        }
       case 12:
       ivec4(63830, -64911, 66337, 78447);
       default:
       1;
      }
    }
   if(_GLF_DEAD(false))
    return;
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       barrier();
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
        {
         if(_GLF_DEAD(false))
          return;
         return;
        }
       if(_GLF_DEAD(false))
        return;
      }
     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
      {
       if(_GLF_DEAD(false))
        barrier();
      }
    }
  }
 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 & 1)); _injected_loop_counter ++)
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     return;
    }
  }
 if(_GLF_DEAD(false))
  return;
 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
  }
 else
  {
   if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), _GLF_IDENTITY(true, bool(bvec2(true, true))) && ((injectionSwitch.x > injectionSwitch.y))))))
    {
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       do
        {
         return;
        }
       while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bool(false), true && (bool(false)))))));
      }
     else
      {
      }
    }
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 uint workgroup_size = gl_WorkGroupSize.x;
 if(_GLF_DEAD(false))
  {
   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
    {
     do
      {
       barrier();
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
  }
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  {
   switch(_GLF_SWITCH((0 << _GLF_IDENTITY(int(0), int(0)))))
    {
     case 0:
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter, (_injected_loop_counter) | (_GLF_IDENTITY(_injected_loop_counter, _GLF_IDENTITY(int(ivec2(_injected_loop_counter, 0)), (int(ivec2(_injected_loop_counter, 0))) ^ 0)))) < 1); _injected_loop_counter ++)
      {
       if(_GLF_DEAD(false))
        barrier();
      }
     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        return;
      }
     else
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
        barrier();
      }
     case 5:
     do
      {
       if(_GLF_DEAD(false))
        return;
      }
     while(_GLF_WRAPPED_LOOP(false));
     case 89:
     if(_GLF_DEAD(false))
      {
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 | 0)); _injected_loop_counter --)
        {
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter, (_GLF_IDENTITY(_injected_loop_counter, (_injected_loop_counter) | 0)) | (_injected_loop_counter)) != 0); _GLF_IDENTITY(_injected_loop_counter --, (false ? _GLF_FUZZED(floatBitsToInt(0.9)) : _injected_loop_counter --)))
          {
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
              {
               barrier();
              }
            }
           return;
          }
        }
      }
     if(_GLF_DEAD(false))
      return;
     case 60:
     if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
      return;
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        {
         do
          {
           barrier();
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         do
          {
           switch(_GLF_SWITCH((-8960 & 0)))
            {
             case 52:
             if((-932.731 < inversesqrt(-2.7)))
              {
               mix(uvec3(139595u, 119098u, 128631u), uvec3(61990u, 4033u, 163184u), bvec3(false, true, true));
               if(_GLF_DEAD(false))
                return;
               isnan(injectionSwitch);
               ;
               ivec4 _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v;
               findMSB(uvec4(103920u, 49815u, 27965u, 56252u));
               (mat4x2(-512.173, 293.139, 608.076, 2707.6569, -6.4, 25.98, 4.5, -652.788) - mat4x2(459.112, -7188.2839, -483.526, -67.59, -2.3, 5431.4222, 525.007, 22.48));
               bvec3 _GLF_SWITCH_3_2v;
              }
             else
              {
               mat2(-90.13, 372.234, 655.795, 88.05);
               mat4x3(4.6, -38.75, -1.6, 836.019, -478.877, 7590.9548, 4.3, 862.835, -17.93, 793.169, 9.2, 728.810);
               mat3 _GLF_SWITCH_3_3v[92], _GLF_SWITCH_3_4v;
               do
                {
                 (mat2(-5.4, 98.91, -8536.5943, 3646.8741) * ((+ -15.40) - mat3x2(998.713, 27.71, 53.95, 64.76, 1.6, 3.0)));
                }
               while(_GLF_WRAPPED_LOOP(false));
               mat4x2 _GLF_SWITCH_3_5v, _GLF_SWITCH_3_6v;
               if(_GLF_DEAD(false))
                continue;
               mat2 _GLF_SWITCH_3_7v, _GLF_SWITCH_3_8v[77], _GLF_SWITCH_3_9v[67];
              }
             case 80:
             ;
             if(_GLF_DEAD(false))
              break;
             case 0:
             if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false || (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false || (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))))
              continue;
             case 4:
             case 61:
             case 88:
             case 49:
             case 57:
             barrier();
             break;
             case 90:
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
              {
               while((false && true))
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
                  break;
                 -86662;
                }
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
             default:
             1;
             if(_GLF_DEAD(false))
              break;
            }
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, (injectionSwitch) * mat2(1.0)).y))));
        }
       if(_GLF_DEAD(false))
        barrier();
      }
     case 39:
     if(_GLF_DEAD(false))
      return;
     case 78:
     return;
     break;
     case 85:
     do
      {
       for(bvec2 _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v; (vec2(0.7, -705.741) == injectionSwitch); ivec2(29029, 351))
        {
        }
      }
     while(_GLF_WRAPPED_LOOP(false));
     default:
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       1;
      }
     else
      {
      }
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     if(_GLF_DEAD(false))
      return;
    }
   if(_GLF_DEAD(false))
    return;
  }
 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
  }
 else
  {
   if(_GLF_DEAD(false))
    return;
  }
 for(int _injected_loop_counter = (int(_GLF_ZERO(0.0, injectionSwitch.x)) ^ (1 & 1)); _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x)), (_injected_loop_counter != int(_GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), min(_GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), mix(float(_GLF_ZERO(0.0, injectionSwitch.x)), float(_GLF_FUZZED(51.69)), bool(false))), _GLF_ZERO(0.0, injectionSwitch.x))))) || false)); _injected_loop_counter --)
  {
   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
    {
     if(_GLF_DEAD(false))
      barrier();
    }
  }
 uint workgroup_id = gl_WorkGroupID.x;
 uint workgroup_base = workgroup_size * workgroup_id;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (_GLF_IDENTITY(! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))) && true)))), ! (! (_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
  {
  }
 else
  {
   if(_GLF_DEAD(false))
    return;
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        return;
      }
     else
      {
      }
    }
   if(_GLF_IDENTITY(_GLF_DEAD(false), false || (_GLF_DEAD(false))))
    return;
   if(_GLF_DEAD(false))
    return;
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, _GLF_IDENTITY(bool(bvec4(true, true, true, false)), true && (bool(bvec4(true, true, true, false)))))))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, (false) || false))))))
          barrier();
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            {
             do
              {
               do
                {
                 barrier();
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, bool(bvec3(injectionSwitch.x > injectionSwitch.y, false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))))));
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
          }
         else
          {
          }
         return;
        }
      }
     else
      {
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
    }
   if(_GLF_DEAD(false))
    return;
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  return;
 uint virtual_gid = workgroup_base + _GLF_IDENTITY(subgroup_id, _GLF_IDENTITY(uint(uvec2(subgroup_id, 0u)), (0u << _GLF_IDENTITY(uint(1u), uint(1u))) ^ (_GLF_IDENTITY(uint(uvec2(subgroup_id, 0u)), (uint(uvec2(subgroup_id, 0u))) | (_GLF_IDENTITY(uint(uvec2(subgroup_id, 0u)), (uint(uvec2(subgroup_id, 0u))) * 1u)))))) * subgroup_size + subgroup_local_id;
 if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, (false) && true)) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))), (injectionSwitch.x > injectionSwitch.y))))
  {
   switch(_GLF_SWITCH(0))
    {
     case 80:
     if((mat4x3(3468.7854, -3.7, 125.313, 7.6, -0.0, 7.4, 3.1, 949.760, 7786.3378, -0.0, 702.922, 320.925) == mat4x3(-3601.8051, 67.96, 4.5, -70.92, 7453.4093, -578.515, -3479.5851, -8684.6442, -1.5, 71.87, 1.8, 86.66)))
      {
       if(((false && true) ? (uvec3(168812u, 181852u, 173150u) == uvec3(27385u, 67950u, 138338u)) : true))
        {
         mat4x2(-2.0, 2.6, -3.2, 299.546, -73.40, 1.0, 8.6, -1.2);
         for(mat4 _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v, _GLF_SWITCH_3_2v; true; _GLF_SWITCH_3_2v)
          {
           ;
           ;
           ((-81.17 + _GLF_SWITCH_3_1v) / mat4(87.78, -17.98, -3.6, 696.351, -728.256, -6.9, -7.3, 0.2, 5.6, -8253.6284, -755.348, 875.249, -8.2, -1217.3921, -7.2, 887.747));
           if(_GLF_DEAD(false))
            break;
           mat2x4 _GLF_SWITCH_3_3v;
           ivec3(41092, -69973, 27644);
           ivec2(-61076, -86629);
           mat4x3 _GLF_SWITCH_3_4v, _GLF_SWITCH_3_5v;
           mat4x2(-7.8, 2.3, 9019.4950, -9.8, 8.4, 4.9, 113.527, -893.551);
           false;
          }
         bool _GLF_SWITCH_3_6v[86], _GLF_SWITCH_3_7v;
         mat4(-4.3, 8694.4327, -585.537, 1.5, -21.94, 0.6, 770.890, -4921.5764, -2.1, 3.5, 1783.6842, -2059.6912, 25.71, 28.25, -332.360, -578.259);
         mat2x3 _GLF_SWITCH_3_8v;
         ivec3 _GLF_SWITCH_3_9v[66], _GLF_SWITCH_3_10v[26], _GLF_SWITCH_3_11v;
         if(_GLF_DEAD(false))
          return;
        }
       mat3x2 _GLF_SWITCH_3_12v[87];
       for(int _GLF_SWITCH_3_13v, _GLF_SWITCH_3_14v; true; uvec2(51017u, 181686u))
        {
         while(false)
          {
           if(_GLF_DEAD(false))
            return;
           _GLF_SWITCH_3_13v;
          }
         if(false)
          {
           mat4x2(-483.019, -2.8, -65.40, -627.052, -7.9, -6718.6813, 6.6, -89.30);
           mat4x2(-6.1, 61.97, 572.497, 85.47, -2.6, 0.9, 0.8, -4536.8453);
           mat2x3(-3.4, -59.16, 0.0, -2.4, 99.43, -2.3);
           ;
           bvec3(true, true, true);
           mat4x2(-3.9, -179.591, -8.8, 3.3, -431.144, -43.35, 8250.8515, -880.482);
          }
         mat3x4(-1.1, -8.2, 170.029, 2.7, -2.8, -8.3, 8285.8313, 7.3, 7.8, 796.283, 6.9, 7.8);
         (mat4x3(-271.346, -3815.9186, 21.95, 88.85, -2.3, 147.713, -798.632, 9.9, -6.9, 360.323, 248.555, -2.9) * mat2x4(-126.169));
        }
       min(ivec4(-4824, 92461, -27601, -99872), ivec4(-97271, -98502, 960, -53720));
       {
        vec4(-8786.7620, 5.6, -6.9, -66.15);
        do
         {
          vec3(5.1, -659.114, -888.003);
         }
        while(_GLF_WRAPPED_LOOP(false));
        ;
        bvec4(true, true, true, false);
        {
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
          }
         else
          {
           ;
          }
         mat4 _GLF_SWITCH_3_15v, _GLF_SWITCH_3_16v, _GLF_SWITCH_3_17v[96];
        }
       }
       mat2x4 _GLF_SWITCH_3_18v, _GLF_SWITCH_3_19v[53], _GLF_SWITCH_3_20v;
       if(true)
        {
        }
      }
     else
      {
       uvec2 _GLF_SWITCH_3_21v[39], _GLF_SWITCH_3_22v[53];
       do
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         int _GLF_SWITCH_3_23v[75], _GLF_SWITCH_3_24v, _GLF_SWITCH_3_25v;
         mat4 _GLF_SWITCH_3_26v, _GLF_SWITCH_3_27v, _GLF_SWITCH_3_28v;
         while((mat4x2(-2.4, 5.0, 4437.4319, 9180.9277, 737.632, 455.906, 67.26, -48.73) != mat4x2(9372.9203, -9016.2697, 842.660, 977.069, -62.89, 7.9, 95.06, -4.6)))
          {
           mat3x2 _GLF_SWITCH_3_29v[99], _GLF_SWITCH_3_30v;
           do
            {
             smoothstep(vec4(26.17, 5191.0613, -618.993, -51.33).a, 2.0, 42.28);
            }
           while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))));
           mat2x4 _GLF_SWITCH_3_31v, _GLF_SWITCH_3_32v;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
            }
           else
            {
             mat3x4(68.37);
            }
           bool _GLF_SWITCH_3_33v, _GLF_SWITCH_3_34v[92], _GLF_SWITCH_3_35v[67];
           uvec4(198849u, 57745u, 42883u, 191556u);
          }
         if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec3(false, false, false)), ! (! (bool(bvec3(false, false, false))))))))
          continue;
         {
          vec4(-6.7, -624.878, 5.6, 8.7);
          bvec3 _GLF_SWITCH_3_36v, _GLF_SWITCH_3_37v;
          if(_GLF_DEAD(false))
           break;
          if(_GLF_WRAPPED_IF_FALSE(false))
           {
           }
          else
           {
            vec4(39.32, -348.772, -4.3, 2.5);
           }
          vec4 _GLF_SWITCH_3_38v, _GLF_SWITCH_3_39v, _GLF_SWITCH_3_40v[22];
          bvec4((vec2(-8335.1469, 7.6) == vec2(-3.8, 8.9)), true, (uvec3(83669u, 124636u, 153185u) != uvec3(154382u, 74990u, 72966u)), (bvec2(true, false) == bvec2(true, false)));
          (-7.6 - mat4x2(3.4, -1757.3007, 7.8, 91.06, 32.55, 6363.8608, 420.131, 559.266));
          mat4x3 _GLF_SWITCH_3_41v;
         }
        }
       while(bool(-64465));
       if(_GLF_DEAD(false))
        return;
       vec2 _GLF_SWITCH_3_42v, _GLF_SWITCH_3_43v[96];
       uvec3 _GLF_SWITCH_3_44v;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
      }
     case 0:
     case 83:
     case 66:
     case 54:
     case 41:
     case 22:
     for(int _injected_loop_counter = _GLF_IDENTITY((1 ^ int(_GLF_ZERO(0.0, injectionSwitch.x))), ((1 ^ int(_GLF_ZERO(0.0, injectionSwitch.x)))) | ((1 ^ int(_GLF_ZERO(0.0, injectionSwitch.x))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != (int(_GLF_ZERO(0.0, injectionSwitch.x)) | 0)); _injected_loop_counter --)
      {
       return;
      }
     break;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     case 91:
     if(_GLF_DEAD(false))
      return;
     ivec3(-93065, 10132, 66185);
     default:
     1;
    }
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       return;
      }
     else
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          barrier();
         return;
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        return;
      }
     else
      {
      }
    }
   do
    {
     do
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(false))
        break;
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), _GLF_IDENTITY(! (! (_GLF_IDENTITY(! (false), bool(bvec4(! (false), false, false, true))))), ! (! (_GLF_IDENTITY(! (! (_GLF_IDENTITY(! (false), bool(bvec4(! (false), false, false, true))))), _GLF_IDENTITY((_GLF_IDENTITY(! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true))))), _GLF_IDENTITY(bool(bool(_GLF_IDENTITY(! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true))))), (! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true)))))) && true))), (_GLF_IDENTITY(bool(bool(_GLF_IDENTITY(! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true))))), (! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true)))))) && true))), (bool(bool(_GLF_IDENTITY(! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true))))), (! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true)))))) && true)))) && true)) && true))), _GLF_IDENTITY(bool(bvec4((_GLF_IDENTITY(! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true))))), _GLF_IDENTITY(bool(bool(_GLF_IDENTITY(! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true))))), (! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true)))))) && true))), (_GLF_IDENTITY(bool(bool(_GLF_IDENTITY(! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true))))), (! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true)))))) && true))), (bool(bool(_GLF_IDENTITY(! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true))))), (! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true)))))) && true)))) && true)) && true))), false, false, false)), false || (bool(bvec4((_GLF_IDENTITY(! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true))))), _GLF_IDENTITY(bool(bool(_GLF_IDENTITY(! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true))))), (! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true)))))) && true))), (_GLF_IDENTITY(bool(bool(_GLF_IDENTITY(! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true))))), (! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true)))))) && true))), (bool(bool(_GLF_IDENTITY(! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true))))), (! (! (_GLF_IDENTITY(! (false), bool(bvec4(! _GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), true && (_GLF_IDENTITY((false), ((false)) || false))))), false, false, true)))))) && true)))) && true)) && true))), false, false, false))))) || false)))))))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(false))
                  continue;
                 return;
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                    {
                     if(_GLF_DEAD(false))
                      return;
                     barrier();
                    }
                   break;
                  }
                }
              }
             barrier();
             if(_GLF_DEAD(false))
              break;
             do
              {
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                barrier();
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (injectionSwitch.x > injectionSwitch.y) && true)))));
            }
           if(_GLF_DEAD(false))
            break;
          }
        }
       else
        {
        }
       barrier();
       if(_GLF_DEAD(false))
        return;
      }
     while(_GLF_WRAPPED_LOOP(false));
     if(_GLF_DEAD(false))
      barrier();
    }
   while(_GLF_WRAPPED_LOOP(false));
   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
    }
   else
    {
     if(_GLF_DEAD(false))
      return;
     for(int _injected_loop_counter = (1 ^ 1); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
      {
       if(_GLF_IDENTITY(_GLF_DEAD(_GLF_IDENTITY(false, false || (_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, true && (false)))))))), _GLF_IDENTITY(bool(bvec4(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, _GLF_IDENTITY(false || (false), bool(_GLF_IDENTITY(bvec2(false || (false), true), bvec2(bvec3(bvec2(false || (false), true), true)))))), ! (! (_GLF_IDENTITY(false, false || (false)))))), _GLF_IDENTITY(true, (true) || false), true, false)), ! _GLF_IDENTITY((! (bool(bvec4(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, false || (false)), true && (_GLF_IDENTITY(false, false || (false))))), true, true, false)))), bool(bvec2((! (bool(bvec4(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))), true, true, false)))), false))))))
        {
         if(_GLF_DEAD(false))
          return;
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, ! (! (true)))))
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               barrier();
              }
             else
              {
              }
             if(_GLF_DEAD(false))
              return;
            }
           else
            {
            }
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          return;
        }
      }
    }
  }
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
    }
   else
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
    }
  }
 else
  {
   do
    {
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        {
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 ^ 0)); _injected_loop_counter --)
          {
           barrier();
          }
        }
      }
     else
      {
      }
     if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), true && (_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) / 1.0) > injectionSwitch.y))))))
      continue;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       switch(_GLF_SWITCH(0))
        {
         case 18:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         if(_GLF_DEAD(false))
          break;
         if(true)
          {
           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
            {
             mat3x4(7.0, -73.67, 70.56, 1.8, 260.989, -3.5, 64.83, 14.90, -347.692, -2549.8139, 4.4, 0.6);
            }
           vec2 _GLF_SWITCH_0_0v, _GLF_SWITCH_0_1v;
           ;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             do
              {
               barrier();
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           {
            for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _GLF_IDENTITY(_injected_loop_counter --, 0 ^ (_injected_loop_counter --)))
             {
              if(_GLF_DEAD(false))
               return;
             }
            uvec4(126288u, 192245u, 184737u, 174495u).rgr;
            if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_IDENTITY(bool(_GLF_IDENTITY(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, true), bvec3(bvec3(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, true))))), bool(bvec2(bool(_GLF_IDENTITY(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, true), bvec3(bvec3(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, true))))), true))))))
             {
             }
            else
             {
              if(_GLF_DEAD(false))
               break;
              if(_GLF_WRAPPED_IF_TRUE(true))
               {
                if(_GLF_DEAD(false))
                 barrier();
               }
              else
               {
               }
             }
            mat4x2 _GLF_SWITCH_0_2v, _GLF_SWITCH_0_3v, _GLF_SWITCH_0_4v;
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               barrier();
              continue;
             }
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(false))
               continue;
              if(_GLF_DEAD(false))
               barrier();
              barrier();
             }
            uint _GLF_SWITCH_0_5v;
           }
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_IDENTITY((_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (! ((_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))) && true)))
            break;
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(false))
            barrier();
           greaterThan(uvec3(121357u, 71729u, 164787u), uvec3(_GLF_IDENTITY(9822u, (_GLF_IDENTITY(9822u, max(9822u, 9822u))) | 0u), 19462u, 25794u));
           while(false)
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(false))
              continue;
             int(atan(12.54));
             uint _GLF_SWITCH_0_6v[18], _GLF_SWITCH_0_7v, _GLF_SWITCH_0_8v;
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                continue;
               if(_GLF_DEAD(false))
                barrier();
               continue;
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             true;
             do
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               if(_GLF_DEAD(false))
                return;
               barrier();
              }
             do
              {
               (+ mat3x2(4.9, -3.9, -7760.4574, 3.5, -23.98, 9.4));
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
             for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
              {
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 do
                  {
                   barrier();
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, false || (false))));
                }
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(false))
                return;
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               do
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   barrier();
                  }
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 _GLF_IDENTITY(bvec2(true, false), bvec2(bvec4(_GLF_IDENTITY(bvec2(true, false), bvec2(bvec3(bvec2(true, false), false))), true, false)));
                }
               else
                {
                }
              }
             else
              {
              }
            }
           if(_GLF_DEAD(false))
            break;
           if(bvec3(true, false, _GLF_IDENTITY(false, false || (false))).r)
            {
            }
           else
            {
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 | ((1 << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), int(0))))); _injected_loop_counter ++)
              {
               if(_GLF_DEAD(false))
                {
                 do
                  {
                   if(_GLF_DEAD(false))
                    return;
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                 return;
                }
              }
             if(_GLF_IDENTITY(_GLF_DEAD(false), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (_GLF_DEAD(false))))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
               barrier();
              }
             mat2x4(faceforward(-8281.2204, -121.740, vec3(-177.375, _GLF_IDENTITY(6236.4600, clamp(6236.4600, _GLF_IDENTITY(6236.4600, 0.0 + (6236.4600)), _GLF_IDENTITY(_GLF_IDENTITY(6236.4600, mix(float(_GLF_FUZZED(float(126484u))), float(6236.4600), bool(true))), (true ? _GLF_IDENTITY(6236.4600, mix(float(_GLF_FUZZED(float(126484u))), float(6236.4600), bool(true))) : _GLF_FUZZED(-95.27))))), -6.6)[2]));
             for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(6), _GLF_IDENTITY(_GLF_IDENTITY(int(6), 0 | (int(6))), int(ivec4(_GLF_IDENTITY(_GLF_IDENTITY(int(6), 0 | (int(6))), (true ? _GLF_IDENTITY(_GLF_IDENTITY(int(6), 0 | (int(6))), (_GLF_IDENTITY(int(6), 0 | (int(6)))) + 0) : _GLF_FUZZED(-72065))), 1, 0, 1))))) >> _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(6), _GLF_IDENTITY((int(6)) ^ (0 << _GLF_IDENTITY(int(1), int(1))), max((int(6)) ^ (0 << _GLF_IDENTITY(int(1), int(1))), (int(6)) ^ (0 << _GLF_IDENTITY(int(1), int(1)))))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY(0, (0) | 0)); _injected_loop_counter --)
              {
               mat3x2(mat2x3(-2.2, 67.41, -5811.0724, _GLF_IDENTITY(-7.1, (-7.1) - length(log(vec3(1.0, 1.0, 1.0)))), -2188.6551, _GLF_IDENTITY(55.97, (55.97) / 1.0)));
               if(_GLF_DEAD(false))
                continue;
              }
            }
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 >> _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(6), clamp(int(6), int(6), int(6)))))); _injected_loop_counter --)
              {
               return;
              }
            }
           do
            {
             if(_GLF_DEAD(false))
              return;
             if(_GLF_DEAD(false))
              return;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
            }
           while(_GLF_WRAPPED_LOOP(false));
           mat2(mat4x2(_GLF_IDENTITY(-695.554, float(mat4(-695.554, _GLF_IDENTITY(round(length(normalize(1.0))), mix(float(_GLF_FUZZED((-9.3 - -0.9))), float(_GLF_IDENTITY(round(length(normalize(1.0))), max(round(length(normalize(1.0))), round(length(normalize(1.0)))))), bool(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))), 0.0, 1.0, 1.0, 1.0, 0.0, _GLF_IDENTITY(_GLF_IDENTITY(round(length(normalize(1.0))), float(mat4x2(round(length(normalize(1.0))), 1.0, 1.0, 1.0, _GLF_IDENTITY(1.0, _GLF_IDENTITY(float(_GLF_IDENTITY(mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0), mat3x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0) + (mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0)))), float(mat2x4(_GLF_IDENTITY(float(_GLF_IDENTITY(mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0), mat3x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0) + (mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0)))), (false ? _GLF_FUZZED(-38.06) : float(_GLF_IDENTITY(mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0), mat3x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0) + (mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0)))))), 1.0, round(length(normalize(vec2(1.0, 1.0)))), 0.0, 1.0, 1.0, determinant(mat4(0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0)), 1.0)))), 1.0, 0.0, 1.0))), float(float(_GLF_IDENTITY(_GLF_IDENTITY(round(length(normalize(1.0))), float(mat4x2(round(length(normalize(1.0))), 1.0, 1.0, 1.0, _GLF_IDENTITY(1.0, _GLF_IDENTITY(float(_GLF_IDENTITY(mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0), mat3x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0) + (mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0)))), float(mat2x4(_GLF_IDENTITY(float(_GLF_IDENTITY(mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0), mat3x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0) + (mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0)))), (false ? _GLF_FUZZED(-38.06) : float(_GLF_IDENTITY(mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0), mat3x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0) + (mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0)))))), 1.0, round(length(normalize(vec2(1.0, 1.0)))), 0.0, 1.0, 1.0, determinant(mat4(0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0)), 1.0)))), 1.0, 0.0, 1.0))), (false ? _GLF_FUZZED(-9.3) : _GLF_IDENTITY(_GLF_IDENTITY(round(length(normalize(1.0))), float(mat4x2(round(length(normalize(1.0))), 1.0, 1.0, 1.0, _GLF_IDENTITY(1.0, _GLF_IDENTITY(float(_GLF_IDENTITY(mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0), mat3x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0) + (mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0)))), float(mat2x4(_GLF_IDENTITY(float(_GLF_IDENTITY(mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0), mat3x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0) + (mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0)))), (false ? _GLF_FUZZED(-38.06) : float(_GLF_IDENTITY(mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0), mat3x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0) + (mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0)))))), 1.0, round(length(normalize(vec2(1.0, 1.0)))), 0.0, 1.0, 1.0, determinant(mat4(0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0)), 1.0)))), 1.0, 0.0, 1.0))), max(_GLF_IDENTITY(round(length(normalize(1.0))), float(mat4x2(round(length(normalize(1.0))), 1.0, 1.0, 1.0, _GLF_IDENTITY(1.0, _GLF_IDENTITY(float(_GLF_IDENTITY(mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0), mat3x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0) + (mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0)))), float(mat2x4(_GLF_IDENTITY(float(_GLF_IDENTITY(mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0), mat3x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0) + (mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0)))), (false ? _GLF_FUZZED(-38.06) : float(_GLF_IDENTITY(mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0), mat3x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0) + (mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0)))))), 1.0, round(length(normalize(vec2(1.0, 1.0)))), 0.0, 1.0, 1.0, determinant(mat4(0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0)), 1.0)))), 1.0, 0.0, 1.0))), _GLF_IDENTITY(round(length(normalize(1.0))), float(mat4x2(round(length(normalize(1.0))), 1.0, 1.0, 1.0, _GLF_IDENTITY(1.0, _GLF_IDENTITY(float(_GLF_IDENTITY(mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0), mat3x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0) + (mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0)))), float(mat2x4(_GLF_IDENTITY(float(_GLF_IDENTITY(mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0), mat3x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0) + (mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0)))), (false ? _GLF_FUZZED(-38.06) : float(_GLF_IDENTITY(mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0), mat3x2(0.0, 0.0, 0.0, 0.0, 0.0, 0.0) + (mat3x2(1.0, 0.0, 1.0, 1.0, _GLF_ZERO(0.0, injectionSwitch.x), 1.0)))))), 1.0, round(length(normalize(vec2(1.0, 1.0)))), 0.0, 1.0, 1.0, determinant(mat4(0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0)), 1.0)))), 1.0, 0.0, 1.0)))))))))), 0.0, 0.0, round(length(normalize(_GLF_IDENTITY(vec3(1.0, 1.0, 1.0), sqrt(vec3(0.0, 0.0, 0.0)) + (_GLF_IDENTITY(vec3(1.0, 1.0, 1.0), (vec3(1.0, 1.0, 1.0)) * vec3(1.0, 1.0, 1.0))))))), sqrt(_GLF_IDENTITY(1.0, min(_GLF_IDENTITY(1.0, clamp(1.0, _GLF_IDENTITY(1.0, min(1.0, 1.0)), 1.0)), 1.0))), sqrt(0.0), 0.0, 1.0, exp(0.0)))), _GLF_IDENTITY(1.7, float(_GLF_IDENTITY(mat4(1.7, 1.0, determinant(mat2(0.0, 0.0, 0.0, 0.0)), 1.0, 0.0, 1.0, 1.0, _GLF_IDENTITY(1.0, mix(float(_GLF_FUZZED(6.7)), float(1.0), bool(true))), determinant(mat3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)), 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0), (true ? _GLF_IDENTITY(mat4(1.7, 1.0, determinant(mat2(0.0, 0.0, 0.0, 0.0)), 1.0, 0.0, 1.0, 1.0, 1.0, determinant(mat3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)), 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0), transpose(transpose(mat4(1.7, 1.0, determinant(mat2(0.0, 0.0, 0.0, 0.0)), 1.0, 0.0, 1.0, 1.0, 1.0, determinant(mat3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)), 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)))) : _GLF_FUZZED(mat4(74.37, 5575.1165, 9804.7185, 9.5, 32.92, -1868.2977, -1.4, -8.5, -43.69, 6677.0456, -281.772, -2628.5040, 9346.7605, 9.1, 0.4, -2681.1889)))))), 6.8, -4.1, -9852.3629, -9180.7612, 9.5, 4.3));
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             continue;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
            }
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              return;
            }
           mat3 _GLF_SWITCH_0_9v[77], _GLF_SWITCH_0_10v, _GLF_SWITCH_0_11v[59];
          }
         else
          {
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ((injectionSwitch.x > injectionSwitch.y)) && true))))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              {
               do
                {
                 return;
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
              barrier();
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(false))
              {
               do
                {
                 barrier();
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
              }
             continue;
            }
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, _GLF_IDENTITY(float(_GLF_IDENTITY(vec3(injectionSwitch.x, 1.0, 0.0), (true ? vec3(injectionSwitch.x, 1.0, 0.0) : _GLF_FUZZED((mat2x3(-8619.1546, 6667.6196, -0.2, 174.535, -1655.5791, -908.378) * injectionSwitch))))), min(_GLF_IDENTITY(float(_GLF_IDENTITY(vec3(injectionSwitch.x, 1.0, 0.0), (true ? vec3(injectionSwitch.x, 1.0, 0.0) : _GLF_FUZZED((mat2x3(-8619.1546, 6667.6196, -0.2, 174.535, -1655.5791, -908.378) * injectionSwitch))))), 0.0 + (float(_GLF_IDENTITY(vec3(injectionSwitch.x, 1.0, 0.0), (true ? vec3(injectionSwitch.x, 1.0, 0.0) : _GLF_FUZZED((mat2x3(-8619.1546, 6667.6196, -0.2, 174.535, -1655.5791, -908.378) * injectionSwitch))))))), float(_GLF_IDENTITY(vec3(injectionSwitch.x, 1.0, 0.0), (true ? vec3(injectionSwitch.x, 1.0, 0.0) : _GLF_FUZZED((mat2x3(-8619.1546, 6667.6196, -0.2, 174.535, -1655.5791, -908.378) * injectionSwitch)))))))) > injectionSwitch.y))))
                {
                }
               else
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
                    break;
                   do
                    {
                     barrier();
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                  }
                }
              }
             continue;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, max(_GLF_IDENTITY(injectionSwitch.y, 1.0 * (injectionSwitch.y)), _GLF_IDENTITY(injectionSwitch.y, max(injectionSwitch.y, _GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, injectionSwitch.y, injectionSwitch.y))))))))))
              continue;
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, bool(bvec2(false, true))), (injectionSwitch.x > injectionSwitch.y))))
              break;
             if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) + 0.0) > injectionSwitch.y))))
              barrier();
             uvec2(57327u, 6778u);
            }
           else
            {
            }
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(false))
            continue;
          }
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), (! (false)) || false)))))
                      barrier();
                     barrier();
                    }
                  }
                }
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
              }
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 >> _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), (int(2)) | (int(2)))))); _injected_loop_counter --)
              {
               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                {
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(_GLF_IDENTITY(false, false || (false)))) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    continue;
                  }
                 barrier();
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    {
                     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(6), int(6))) >> _GLF_IDENTITY(int(6), int(6))), (_injected_loop_counter < ((1 << _GLF_IDENTITY(int(6), int(6))) >> _GLF_IDENTITY(int(6), int(6)))) || false)); _injected_loop_counter ++)
                      {
                       barrier();
                      }
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      return;
                    }
                   return;
                  }
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                }
              }
             if(_GLF_DEAD(false))
              break;
            }
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          break;
         case 0:
         for(int _injected_loop_counter = int(_GLF_IDENTITY(_GLF_ZERO(0.0, injectionSwitch.x), mix(float(_GLF_FUZZED(-365.677)), float(_GLF_ZERO(0.0, injectionSwitch.x)), bool(true)))); _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
              break;
             barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, clamp(injectionSwitch, injectionSwitch, injectionSwitch)).x > injectionSwitch.y))))
            barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           for(int _injected_loop_counter = (((((1 << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), int(4))) << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), max(int(2), int(2))))) & 1); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
            {
             do
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
           break;
          }
         case 6:
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            continue;
           barrier();
          }
         if(_GLF_DEAD(false))
          break;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           else
            {
            }
           if(_GLF_DEAD(false))
            return;
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
            }
           else
            {
             if(_GLF_DEAD(false))
              continue;
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
              {
               for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > ((0 << _GLF_IDENTITY(int(6), int(6))) << _GLF_IDENTITY(int(4), int(4)))); _injected_loop_counter --)
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   return;
                  }
                }
              }
            }
          }
         if(_GLF_DEAD(false))
          break;
         case 84:
         if(_GLF_DEAD(false))
          continue;
         case 66:
         if(_GLF_DEAD(false))
          barrier();
         case 19:
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec3(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec4(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, false, true))), false, false)))))
          break;
         if(_GLF_DEAD(false))
          barrier();
         case 32:
         do
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                break;
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_DEAD(false))
                  continue;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                    {
                     barrier();
                    }
                  }
                }
               else
                {
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
               return;
              }
             if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(bvec4(false, false, true, false)))))
              {
              }
             else
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 return;
                }
               else
                {
                }
              }
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            return;
          }
         while(_GLF_WRAPPED_LOOP(false));
         case 53:
         case 93:
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
            return;
          }
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            break;
           continue;
          }
         return;
         for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(6), int(6))) >> _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            break;
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             barrier();
            }
          }
         break;
         if(_GLF_DEAD(false))
          continue;
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
          {
           if(_GLF_IDENTITY(_GLF_DEAD(false), _GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (_GLF_DEAD(false)), ! (! (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (_GLF_DEAD(false)), bool(bool(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (_GLF_DEAD(false))))))))))
            {
             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
              }
             else
              {
               return;
              }
            }
          }
         if(_GLF_DEAD(false))
          return;
         default:
         if(_GLF_DEAD(false))
          {
           do
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             barrier();
             if(_GLF_DEAD(false))
              continue;
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
          }
         1;
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          continue;
         barrier();
        }
       if(_GLF_DEAD(false))
        break;
       if(_GLF_DEAD(false))
        barrier();
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          return;
         continue;
        }
       do
        {
         return;
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
    }
   while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
  }
 uint next_virtual_gid = workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + _GLF_IDENTITY(1, 0 ^ (1))) % subgroup_size);
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_DEAD(false))
    return;
  }
 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
  {
   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
    }
   else
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
        }
       else
        {
         barrier();
        }
      }
    }
  }
 else
  {
  }
 if(_GLF_DEAD(false))
  return;
 do
  {
   switch(_GLF_SWITCH(0))
    {
     case 0:
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        continue;
       for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(6), int(6))) >> _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(6), (true ? _GLF_IDENTITY(int(6), ~ (~ (int(6)))) : _GLF_FUZZED(findLSB(subgroup_local_id))))))); _injected_loop_counter ++)
        {
         return;
        }
      }
     case 94:
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
        return;
       for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), int(2)))); _GLF_IDENTITY(_injected_loop_counter ++, (_injected_loop_counter ++) ^ 0))
        {
         barrier();
        }
      }
     case 99:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      break;
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         barrier();
        }
       else
        {
        }
       if(_GLF_DEAD(false))
        return;
      }
     case 36:
     if(_GLF_DEAD(false))
      barrier();
     case 57:
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        barrier();
      }
     else
      {
      }
     if(_GLF_DEAD(false))
      continue;
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(false, _GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (_GLF_IDENTITY(true, false || (true))), false || (! (_GLF_IDENTITY(_GLF_IDENTITY(true, false || (true)), bool(_GLF_IDENTITY(bvec2(_GLF_IDENTITY(true, false || (true)), true), bvec2(bvec2(_GLF_IDENTITY(bvec2(_GLF_IDENTITY(true, false || (true)), true), bvec2(bvec4(bvec2(_GLF_IDENTITY(true, false || (true)), true), true, true))))))))))))), true, true)))))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
          }
         break;
        }
       if(_GLF_DEAD(false))
        return;
       if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), false || (_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (! (_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, max(injectionSwitch, _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) ? _GLF_FUZZED(vec2(-5.8, -3.4)) : injectionSwitch)), mat2(1.0) * (_GLF_IDENTITY(injectionSwitch, (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) ? _GLF_FUZZED(vec2(-5.8, -3.4)) : injectionSwitch)))))).x > injectionSwitch.y)))))))))
        break;
       break;
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           break;
          }
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            continue;
          }
         else
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
            {
             do
              {
               return;
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
          }
         if(_GLF_IDENTITY(_GLF_DEAD(false), _GLF_IDENTITY(bool(bvec3(_GLF_DEAD(false), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))), ! (! (bool(bvec3(_GLF_DEAD(false), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))))
          {
           switch(_GLF_SWITCH(0))
            {
             case 9:
             ivec3(13683, -2124, 9398);
             case 0:
             if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, _GLF_IDENTITY(bool(_GLF_IDENTITY(bvec2(true, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bvec2(bvec2(bvec2(true, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))), (bool(_GLF_IDENTITY(bvec2(true, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bvec2(bvec2(bvec2(true, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))) || false))))
              {
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 return;
                }
               else
                {
                 if(_GLF_DEAD(false))
                  return;
                }
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                    {
                     if(_GLF_WRAPPED_IF_FALSE(false))
                      {
                      }
                     else
                      {
                       barrier();
                      }
                    }
                   barrier();
                  }
                }
               else
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                  {
                   do
                    {
                     return;
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                  }
                }
               if(_GLF_DEAD(false))
                {
                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter != 0, (_injected_loop_counter != 0) || false)); _injected_loop_counter --)
                  {
                   barrier();
                  }
                }
              }
             else
              {
               if(_GLF_DEAD(false))
                continue;
              }
             break;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             case 48:
             mat4x2(7.3, -579.734, -1339.3993, -4.1, 27.32, -871.882, 556.342, -2217.4261);
             default:
             if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, false, true)))))
              return;
             1;
            }
          }
        }
       else
        {
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
          break;
         if(_GLF_DEAD(false))
          break;
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           barrier();
          }
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        continue;
       if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec3(false, false, true)), true && (bool(bvec3(false, false, true))))), (injectionSwitch.x > injectionSwitch.y))))
        continue;
       barrier();
       if(_GLF_DEAD(false))
        continue;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      continue;
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
        break;
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY(int(_GLF_ONE(1.0, injectionSwitch.y)), (int(_GLF_ONE(1.0, injectionSwitch.y))) / (1 | 0))); _injected_loop_counter ++)
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         barrier();
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, mix(float(_GLF_FUZZED(-907.198)), float(_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) - 0.0)), bool(true))) > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        break;
       break;
      }
     if(_GLF_DEAD(false))
      continue;
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      barrier();
     case 6:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           return;
          }
         else
          {
          }
        }
       if(_GLF_DEAD(false))
        {
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 & 1)); _injected_loop_counter ++)
          {
           barrier();
          }
        }
       if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, (false) && true)))
        {
        }
       else
        {
         barrier();
        }
      }
     case 72:
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        break;
       continue;
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, ! (! (false))), bool(bvec3(false, true, true)))))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
          barrier();
         break;
         if(_GLF_DEAD(false))
          break;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(false))
        break;
       continue;
       if(_GLF_DEAD(false))
        break;
      }
     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       else
        {
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        break;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 barrier();
                }
               else
                {
                }
              }
             else
              {
              }
            }
           switch(_GLF_SWITCH(0))
            {
             case 1:
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               mat3x4(109.943, 3.1, 5.7, 4779.5229, 3122.8942, 90.73, -8.0, _GLF_IDENTITY(_GLF_IDENTITY(-3.9, min(-3.9, -3.9)), (_GLF_IDENTITY(-3.9, _GLF_IDENTITY(min(-3.9, -3.9), mix(float(_GLF_FUZZED(-5.5)), float(min(-3.9, -3.9)), bool(true))))) * 1.0), 241.828, 0.7, 3741.2030, 58.07);
               if(_GLF_DEAD(false))
                continue;
              }
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                return;
               for(int _injected_loop_counter = (1 | 1); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                {
                 barrier();
                }
              }
             case 0:
             case 55:
             if(_GLF_DEAD(false))
              barrier();
             case 93:
             case 64:
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), ! (! (! (false))))))))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 barrier();
                }
               else
                {
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
              }
             case 19:
             case 74:
             if(_GLF_IDENTITY(_GLF_DEAD(false), false || (_GLF_DEAD(false))))
              continue;
             case 10:
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                break;
               do
                {
                 barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             barrier();
             break;
             case 76:
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               mat4x2(-894.784);
               if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                return;
              }
             else
              {
              }
             case 69:
             vec3 _GLF_SWITCH_2_0v[19], _GLF_SWITCH_2_1v[7], _GLF_SWITCH_2_2v;
             default:
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               1;
               if(_GLF_DEAD(false))
                return;
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
              }
            }
          }
         break;
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
        }
      }
     else
      {
       switch(_GLF_SWITCH(0))
        {
         case 74:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, (false ? _GLF_FUZZED(6334.2037) : injectionSwitch.y))))))
          barrier();
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           do
            {
             for(             mat3(_GLF_IDENTITY(5.8, (true ? 5.8 : _GLF_FUZZED(5.7))), 1.0, -0.9, -6.7, 2560.0622, 78.27, 71.04, -21.60, -13.65);
 _GLF_IDENTITY(true, false || (true)); (abs(-549.760) - mat2x4(239.341, -9023.8608, _GLF_IDENTITY(-8272.5757, mix(float(_GLF_FUZZED(float(85793))), float(-8272.5757), bool(true))), 2059.0133, 2.2, -4.4, 6.9, 1.0)))
              {
               98951;
               mat2(-0.9, -940.529, 4.9, -13.99);
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(false))
                barrier();
               (ivec2(19416, 81610) * (ivec2(82110, -6313) | -49707));
               for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                {
                 ;
                }
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   (mat2x3(5878.2910, -29.47, -92.53, 402.992, -8.1, -1690.4495) * mat2(_GLF_IDENTITY(1822.1962, max(1822.1962, 1822.1962)), 6.8, 6.0, -6.4));
                  }
                 else
                  {
                  }
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                }
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 do
                  {
                   for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                    {
                     _GLF_IDENTITY((vec4(-829.342, -7187.0968, -3.1, -611.757) != vec4(-0.0, 20.81, -59.97, 3.1)), true && ((vec4(-829.342, -7187.0968, -3.1, -611.757) != vec4(-0.0, 20.81, -59.97, 3.1))));
                    }
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                }
               else
                {
                }
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
          }
         else
          {
          }
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
              {
               if(_GLF_DEAD(false))
                barrier();
              }
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               barrier();
              }
             else
              {
              }
            }
          }
         case 19:
         {
          ;
          int _GLF_SWITCH_2_0v[43], _GLF_SWITCH_2_1v, _GLF_SWITCH_2_2v[45];
          if(_GLF_DEAD(false))
           barrier();
          mat4x3(-8.2, 4.0, -8060.4705, 645.417, 260.504, -6730.0235, -5.8, 459.111, 2.3, -1175.7642, 115.469, -882.529);
          if(_GLF_DEAD(false))
           return;
          if(_GLF_WRAPPED_IF_TRUE(true))
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             return;
            uvec2(next_virtual_gid, next_virtual_gid);
           }
          else
           {
           }
         }
         case 0:
         case 47:
         case 5:
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            {
             switch(_GLF_SWITCH(((1 ^ 1) | 0)))
              {
               case 0:
               case 16:
               case 81:
               case 39:
               if(_GLF_DEAD(false))
                return;
               case 21:
               case 63:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               case 62:
               case 66:
               if(_GLF_DEAD(false))
                break;
               case 50:
               barrier();
               break;
               case 89:
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 vec4(9.2, -1055.6396, 7243.8655, -0.4);
                }
               else
                {
                }
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   barrier();
                  }
                 else
                  {
                  }
                }
               case 30:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 vec4(790.765, -1917.6649, 7862.2057, -6851.3426);
                }
               else
                {
                }
               default:
               1;
               if(_GLF_DEAD(false))
                continue;
              }
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              break;
             barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            break;
           return;
           if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
            break;
          }
         break;
         if(_GLF_DEAD(false))
          barrier();
         case 20:
         (mat3(8.6, 48.50, 3.4, 66.71, 2.7, -997.600, 3092.2251, -9376.5867, -6580.1359) * mat2x3(step(-8.0, -864.947), -2.7, 4810.8400, -2561.6647, -723.633, 0.0));
         case 93:
         mat4(-31.99, -6887.7688, 42.02, -2.1, -7279.0672, 2.8, -591.173, -9.8, 8541.8226, -444.688, 0.8, _GLF_IDENTITY(1594.0031, (true ? 1594.0031 : _GLF_FUZZED(-696.976))), -63.62, -6.6, -2553.2359, 8.4);
         default:
         1;
        }
      }
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      continue;
     if(_GLF_DEAD(false))
      {
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
        {
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (_GLF_IDENTITY(injectionSwitch, (injectionSwitch) * mat2(1.0)).x < injectionSwitch.y))))
          {
           barrier();
          }
         else
          {
          }
        }
      }
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          break;
         break;
        }
       if(_GLF_DEAD(false))
        continue;
       if(_GLF_DEAD(false))
        continue;
       atomicStore(buf[virtual_gid], uint(1), 4, 64, 4);
      }
     else
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        continue;
      }
     if(_GLF_DEAD(false))
      break;
     break;
     default:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       switch(_GLF_SWITCH(0))
        {
         case 40:
         ivec2 _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v, _GLF_SWITCH_3_2v[8];
         case 39:
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = (int(_GLF_ZERO(0.0, injectionSwitch.x)) >> _GLF_IDENTITY(int(8), int(8))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
            {
             return;
            }
          }
         do
          {
           mat3x4(55.78, -3.3, 287.888, -825.217, -62.22, -782.323, 13.48, 1.8, -0.4, -3.7, -2813.3193, 667.975);
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
         case 0:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         case 95:
         case 97:
         case 21:
         case 63:
         if(_GLF_DEAD(false))
          continue;
         case 83:
         case 79:
         case 12:
         case 36:
         if(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(false), ! (! (_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(false), bool(bvec3(_GLF_WRAPPED_IF_FALSE(false), false, true)))))))
          {
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
           return;
          }
         break;
         case 14:
         if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
          continue;
         bvec2(true, true);
         default:
         1;
        }
      }
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(7), int(7))) >> _GLF_IDENTITY(int(7), int(7)))); _injected_loop_counter ++)
        {
         1;
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           break;
          }
         return;
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            continue;
           continue;
          }
         do
          {
           barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              break;
             barrier();
            }
          }
         while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, bool(bvec3(false, true, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))));
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, true && (injectionSwitch.x > injectionSwitch.y))))))
      {
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
        {
         barrier();
        }
      }
    }
  }
 while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))));
 for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  {
   do
    {
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
      {
       switch(_GLF_SWITCH(0))
        {
         case 0:
         for(int _injected_loop_counter = (int(_GLF_ONE(1.0, injectionSwitch.y)) & 1); _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 << _GLF_IDENTITY(int(4), int(4)))); _injected_loop_counter --)
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                {
                 if(_GLF_IDENTITY(_GLF_DEAD(false), bool(bvec4(_GLF_DEAD(false), _GLF_IDENTITY(false, ! (! (false))), true, false))))
                  barrier();
                }
               if(_GLF_DEAD(false))
                barrier();
               barrier();
              }
             else
              {
              }
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY((1 | 1), ((1 | 1)) ^ 0)); _injected_loop_counter ++)
            {
             barrier();
            }
          }
         break;
         case 6:
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           ivec3(-86705, -23292, 92604);
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          return;
         default:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(_GLF_IDENTITY(int(1), (int(1)) * 1), _GLF_IDENTITY(int(1), max(int(1), int(1))))); _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
          {
           if(_GLF_DEAD(false))
            return;
          }
         1;
         if(_GLF_DEAD(false))
          barrier();
        }
      }
    }
   while(_GLF_WRAPPED_LOOP(false));
  }
 for(int _injected_loop_counter = ((0 ^ 0) | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 & 1)); _injected_loop_counter ++)
  {
   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             barrier();
            }
           else
            {
            }
          }
        }
       else
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, true && (_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec4(false, true, true, false)), ! (! (bool(bvec4(false, true, true, false))))))))))
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             return;
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
        }
       if(_GLF_DEAD(false))
        return;
       return;
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        return;
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
        {
         do
          {
           return;
          }
         while(_GLF_WRAPPED_LOOP(false));
         if(_GLF_DEAD(false))
          break;
        }
      }
     if(_GLF_DEAD(false))
      return;
    }
   else
    {
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        return;
      }
     else
      {
      }
    }
  }
 if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), _GLF_IDENTITY(bool(_GLF_IDENTITY(bool(_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ! (! ((injectionSwitch.x > injectionSwitch.y))))), bool(bvec3(bool(_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ! (! ((injectionSwitch.x > injectionSwitch.y))))), true, _GLF_IDENTITY(false, bool(bvec2(_GLF_IDENTITY(false, (false) || false), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))))))), bool(bvec4(bool(_GLF_IDENTITY(bool(_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ! (! ((_GLF_IDENTITY(injectionSwitch.x, 0.0 + (_GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, injectionSwitch.x)))) > injectionSwitch.y))))), bool(bvec3(bool(_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ! (! ((injectionSwitch.x > injectionSwitch.y))))), true, false)))), false, false, true))))), bool(bvec2(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, (_GLF_IDENTITY(injectionSwitch.x, min(injectionSwitch.x, injectionSwitch.x))) * abs(1.0)) > injectionSwitch.y)), true)))))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 else
  {
   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, ! (! (false))), bool(bvec4(_GLF_IDENTITY(false, ! (! (false))), true, false, false)))))
    barrier();
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
    }
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    return;
   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
    {
     if(_GLF_DEAD(false))
      return;
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
      return;
     barrier();
    }
   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ! (_GLF_IDENTITY(! ((injectionSwitch.x > injectionSwitch.y)), false || (! ((injectionSwitch.x > injectionSwitch.y)))))))))
          barrier();
         return;
        }
       barrier();
      }
    }
   else
    {
     if(_GLF_DEAD(false))
      return;
    }
   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(_GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (true), ! (! (_GLF_IDENTITY(! (true), ! (! (! (true))))))))), (injectionSwitch.x < _GLF_IDENTITY(injectionSwitch.y, (injectionSwitch.y) * 1.0)))))
    {
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
        {
         switch(_GLF_SWITCH((int(_GLF_ZERO(0.0, injectionSwitch.x)) | 0)))
          {
           case 88:
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
            }
           else
            {
            }
           do
            {
             uvec3(129060u, 54236u, 187316u);
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              {
               for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(3), _GLF_IDENTITY(int(3), int(ivec3(int(3), 0, 1))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(false))
                    continue;
                   barrier();
                  }
                 switch(_GLF_SWITCH(0))
                  {
                   case 92:
                   mat4 _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v;
                   case 88:
                   mat2 _GLF_SWITCH_2_2v, _GLF_SWITCH_2_3v[95];
                   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                    {
                     if(_GLF_DEAD(false))
                      {
                       do
                        {
                         barrier();
                        }
                       while(_GLF_WRAPPED_LOOP(false));
                      }
                    }
                   case 0:
                   case 16:
                   if(_GLF_WRAPPED_IF_TRUE(true))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                   else
                    {
                    }
                   case 84:
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      break;
                     if(_GLF_WRAPPED_IF_FALSE(false))
                      {
                      }
                     else
                      {
                       barrier();
                      }
                    }
                   case 40:
                   case 1:
                   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 ^ 0)); _injected_loop_counter ++)
                    {
                     if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (_GLF_IDENTITY(! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bool(bvec2(! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), false)))))))
                      barrier();
                    }
                   case 99:
                   case 96:
                   switch(_GLF_SWITCH((0 | 0)))
                    {
                     case 75:
                     while(true)
                      {
                       for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(5), int(5))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                        {
                         if(_GLF_DEAD(false))
                          break;
                         do
                          {
                           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                            {
                             mat4x3(7116.0210, 42.23, 9.0, 6.8, 2415.2947, -2895.8052, 3371.5740, -264.616, 5580.7859, -0.4, -9.1, -92.17);
                            }
                          }
                         while(_GLF_WRAPPED_LOOP(false));
                        }
                       if(_GLF_DEAD(false))
                        barrier();
                       (+ mat2x4(8.9, -13.45, -348.500, -34.02, _GLF_IDENTITY(-6.8, min(-6.8, -6.8)), -1186.9830, -530.116, 34.13));
                       vec2 _GLF_SWITCH_1_0v, _GLF_SWITCH_1_1v;
                       ;
                       if(_GLF_DEAD(false))
                        barrier();
                       float _GLF_SWITCH_1_2v, _GLF_SWITCH_1_3v[79];
                      }
                     if(_GLF_DEAD(false))
                      continue;
                     if(_GLF_WRAPPED_IF_TRUE(true))
                      {
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_WRAPPED_IF_TRUE(true))
                          {
                           barrier();
                          }
                         else
                          {
                          }
                        }
                      }
                     else
                      {
                      }
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_WRAPPED_IF_TRUE(true))
                        {
                         barrier();
                        }
                       else
                        {
                        }
                       if(_GLF_DEAD(false))
                        return;
                      }
                     if(_GLF_DEAD(false))
                      continue;
                     case 23:
                     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        break;
                       ;
                       if(_GLF_DEAD(false))
                        barrier();
                      }
                     case 0:
                     if(_GLF_DEAD(false))
                      continue;
                     case 34:
                     if(_GLF_DEAD(false))
                      continue;
                     case 45:
                     for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY(1, 0 ^ (1))); _injected_loop_counter ++)
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        return;
                      }
                     case 2:
                     case 20:
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      break;
                     case 80:
                     if(_GLF_DEAD(false))
                      return;
                     barrier();
                     break;
                     case 67:
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      {
                       if(_GLF_WRAPPED_IF_FALSE(false))
                        {
                        }
                       else
                        {
                         return;
                        }
                      }
                     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                      {
                       do
                        {
                         do
                          {
                           for(ivec2 _GLF_SWITCH_1_4v, _GLF_SWITCH_1_5v, _GLF_SWITCH_1_6v[82]; (mat3(-54.70, 3004.7768, -8.3, -0.3, -8341.3043, 66.61, 7.6, -17.85, 320.026) != mat3(50.56, -8.1, -6763.4161, 5950.6964, -68.27, _GLF_IDENTITY(316.671, (316.671) * 1.0), 1.5, 5.7, -3.1)); uvec3(58461u, 179826u, 182536u))
                            {
                             if(_GLF_DEAD(false))
                              continue;
                             do
                              {
                               ivec3(-6464, 98044, -57659);
                              }
                             while(_GLF_WRAPPED_LOOP(false));
                             lessThanEqual(_GLF_SWITCH_1_5v, (37463 - _GLF_SWITCH_1_5v));
                             if(_GLF_DEAD(false))
                              continue;
                             mat4x3 _GLF_SWITCH_1_7v, _GLF_SWITCH_1_8v;
                             do
                              {
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                {
                                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                                  {
                                   if(_GLF_DEAD(false))
                                    barrier();
                                  }
                                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                  continue;
                                 return;
                                }
                              }
                             while(_GLF_WRAPPED_LOOP(false));
                            }
                          }
                         while(_GLF_WRAPPED_LOOP(false));
                        }
                       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                      }
                     default:
                     1;
                     if(_GLF_DEAD(false))
                      return;
                    }
                   break;
                   case 7:
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_WRAPPED_IF_FALSE(false))
                      {
                      }
                     else
                      {
                       if(_GLF_DEAD(false))
                        break;
                       barrier();
                      }
                    }
                   uvec4 _GLF_SWITCH_2_4v, _GLF_SWITCH_2_5v[79], _GLF_SWITCH_2_6v;
                   default:
                   if(_GLF_DEAD(false))
                    {
                     do
                      {
                       barrier();
                      }
                     while(_GLF_WRAPPED_LOOP(false));
                    }
                   1;
                  }
                }
              }
             barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           else
            {
            }
           if(_GLF_DEAD(false))
            return;
           do
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false || (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
                  return;
                 if(_GLF_DEAD(false))
                  {
                   do
                    {
                     barrier();
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                  }
                 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                  {
                   barrier();
                  }
                 else
                  {
                  }
                }
               do
                {
                 for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                  {
                   return;
                  }
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           case 0:
           case 27:
           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
            continue;
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) && (_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), ! (! (_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))))
              {
               if(_GLF_DEAD(false))
                barrier();
               barrier();
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             return;
            }
           for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
            {
             if(_GLF_DEAD(false))
              {
               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                {
                 return;
                }
              }
            }
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           case 18:
           case 59:
           case 78:
           case 38:
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED(-5.7), _GLF_FUZZED(-8180.6252)), bvec2(false, false))), max(_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED(-5.7), _GLF_FUZZED(-8180.6252)), bvec2(false, false))), clamp(_GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED(-5.7), _GLF_FUZZED(-8180.6252)), bvec2(false, false))), _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED(-5.7), _GLF_FUZZED(-8180.6252)), bvec2(false, false))), (_GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED(-5.7), _GLF_FUZZED(-8180.6252)), bvec2(false, false)))) / vec2(1.0, 1.0)), _GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED(-5.7), _GLF_FUZZED(-8180.6252)), bvec2(false, false))))), _GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED(-5.7), _GLF_FUZZED(-8180.6252)), bvec2(false, false))), vec2(1.0, 1.0) * (_GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2(_GLF_FUZZED(-5.7), _GLF_FUZZED(-8180.6252)), bvec2(false, false))))))).y))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
            }
           else
            {
             switch(_GLF_SWITCH((31206 & 0)))
              {
               case 48:
               if(_GLF_DEAD(false))
                break;
               ;
               case 0:
               case 16:
               case 30:
               case 36:
               if(_GLF_DEAD(false))
                break;
               case 33:
               case 64:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
               case 87:
               case 13:
               case 26:
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 barrier();
                }
               break;
               case 54:
               mat3x4 _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v, _GLF_SWITCH_3_2v;
               case 98:
               mat4x3 _GLF_SWITCH_3_3v, _GLF_SWITCH_3_4v[21];
               default:
               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 | 1)); _injected_loop_counter ++)
                {
                 1;
                }
              }
            }
           case 99:
           if(_GLF_DEAD(false))
            continue;
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                    {
                     barrier();
                    }
                  }
                 else
                  {
                  }
                }
               return;
              }
            }
           atomicStore(buf[next_virtual_gid], uint(2), 4, _GLF_IDENTITY(64, max(64, 64)), 4);
           break;
           default:
           if(_GLF_DEAD(false))
            barrier();
           1;
           if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
            barrier();
          }
        }
      }
     else
      {
      }
    }
   else
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
    }
  }
}
