#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


struct _GLF_struct_58 {
 mat3 _f0;
 vec2 _f1;
 bvec4 _f2;
} ;

struct _GLF_struct_59 {
 mat4 _f0;
 bool _f1;
 _GLF_struct_58 _f2;
} ;

struct _GLF_struct_60 {
 int _injected_loop_counter;
 _GLF_struct_59 _f0;
} ;

struct _GLF_struct_55 {
 mat2x3 _f0;
 mat4x2 _f1;
 vec2 _f2;
} ;

struct _GLF_struct_54 {
 mat4x2 _f0;
 vec2 _f1;
 uvec2 _f2;
 int _f3;
 bvec2 _f4;
} ;

struct _GLF_struct_56 {
 mat3 _f0;
 _GLF_struct_54 _f1;
 uint _f2;
 _GLF_struct_55 _f3;
 bvec2 _f4;
} ;

struct _GLF_struct_57 {
 _GLF_struct_56 _f0;
 int _injected_loop_counter;
} ;

struct _GLF_struct_53 {
 uvec3 _f0;
 mat4 _GLF_SWITCH_2_24v;
 uvec4 _f1;
} ;

struct _GLF_struct_50 {
 uint _f0;
 vec4 _f1;
 bool _f2;
 uvec4 _f3;
 mat4 _f4;
 mat2x4 _f5;
 mat3x4 _f6;
} ;

struct _GLF_struct_51 {
 _GLF_struct_50 _f0;
 uvec4 _f1;
} ;

struct _GLF_struct_48 {
 uvec3 _f0;
 uvec3 _f1;
 bvec4 _f2;
 mat4x3 _f3;
 mat3 _f4;
 mat2 _f5;
} ;

struct _GLF_struct_47 {
 mat3x2 _f0;
 mat4x2 _f1;
 uvec3 _f2;
 vec2 _f3;
} ;

struct _GLF_struct_49 {
 _GLF_struct_47 _f0;
 _GLF_struct_48 _f1;
 ivec2 _f2;
 vec3 _f3;
 mat3x2 _f4;
 float _f5;
} ;

struct _GLF_struct_45 {
 mat2 _f0;
 bvec4 _f1;
 bvec3 _f2;
 vec4 _f3;
 uvec2 _f4;
 ivec4 _f5;
 float _f6;
} ;

struct _GLF_struct_44 {
 ivec4 _f0;
 ivec3 _f1;
 uvec4 _f2;
 mat4x2 _f3;
 uvec2 _f4;
} ;

struct _GLF_struct_43 {
 ivec2 _f0;
 uvec4 _f1;
} ;

struct _GLF_struct_42 {
 mat4 _f0;
 bvec4 _f1;
 ivec4 _f2;
 vec2 _f3;
} ;

struct _GLF_struct_41 {
 int _f0;
 mat3 _f1;
 mat3x4 _f2;
 bvec3 _f3;
} ;

struct _GLF_struct_46 {
 _GLF_struct_41 _f0;
 _GLF_struct_42 _f1;
 _GLF_struct_43 _f2;
 _GLF_struct_44 _f3;
 _GLF_struct_45 _f4;
 bvec3 _f5;
} ;

struct _GLF_struct_52 {
 _GLF_struct_46 _f0;
 uint subgroup_id;
 _GLF_struct_49 _f1;
 mat2x3 _f2;
 _GLF_struct_51 _f3;
} ;

struct _GLF_struct_40 {
 int _injected_loop_counter;
 uvec3 _f0;
} ;

struct _GLF_struct_38 {
 int _f0;
 mat3x4 _f1;
 mat3x2 _f2;
 uvec2 _f3;
 uvec3 _f4;
 ivec4 _f5;
} ;

struct _GLF_struct_36 {
 mat4x3 _f0;
 uvec3 _f1;
 mat4x3 _f2;
 int _f3;
 vec4 _f4;
} ;

struct _GLF_struct_35 {
 int _f0;
 vec3 _f1;
 float _f2;
} ;

struct _GLF_struct_34 {
 ivec2 _f0;
 bvec2 _f1;
 mat3 _f2;
 vec4 _f3;
 mat3 _f4;
 mat4x3 _f5;
 bvec2 _f6;
} ;

struct _GLF_struct_37 {
 _GLF_struct_34 _f0;
 _GLF_struct_35 _f1;
 _GLF_struct_36 _f2;
} ;

struct _GLF_struct_32 {
 uint _f0;
 mat3x4 _f1;
 bool _f2;
 mat4x3 _f3;
 uvec2 GLF_merged2_0_1_16_1_1_13next_virtual_gidnum_workgroup;
} ;

struct _GLF_struct_31 {
 uvec4 _f0;
 ivec4 _f1;
} ;

struct _GLF_struct_33 {
 uvec3 _f0;
 _GLF_struct_31 _f1;
 _GLF_struct_32 _f2;
} ;

struct _GLF_struct_39 {
 mat4x3 _f0;
 _GLF_struct_33 _f1;
 _GLF_struct_37 _f2;
 mat2x3 _f3;
 ivec4 _f4;
 _GLF_struct_38 _f5;
} ;

struct _GLF_struct_28 {
 bvec4 _f0;
 mat3x2 _f1;
 uint _f2;
} ;

struct _GLF_struct_27 {
 vec4 _f0;
 ivec3 _f1;
 bvec3 _f2;
 mat4x3 _f3;
 uvec4 _f4;
 mat3 _f5;
 mat2 _f6;
} ;

struct _GLF_struct_26 {
 bvec3 _f0;
 ivec3 _f1;
 bvec3 _f2;
 uvec2 _f3;
 mat3x4 _f4;
} ;

struct _GLF_struct_29 {
 _GLF_struct_26 _f0;
 uint _f1;
 _GLF_struct_27 _f2;
 bool _f3;
 _GLF_struct_28 _f4;
 ivec2 _f5;
} ;

struct _GLF_struct_24 {
 mat4x2 _f0;
 ivec2 _f1;
 mat3x4 _f2;
 mat2x3 _f3;
 mat3x2 _f4;
 mat3x4 _f5;
 ivec2 _f6;
} ;

struct _GLF_struct_25 {
 uvec3 _f0;
 _GLF_struct_24 _f1;
} ;

struct _GLF_struct_30 {
 _GLF_struct_25 _f0;
 _GLF_struct_29 _f1;
 uint subgroup_local_id;
} ;

struct _GLF_struct_21 {
 float _f0;
 vec2 _f1;
 mat2 _f2;
 uvec4 _f3;
 bvec2 _f4;
 float _f5;
} ;

struct _GLF_struct_20 {
 mat2x3 _f0;
 uvec4 _f1;
 uvec2 _f2;
} ;

struct _GLF_struct_22 {
 _GLF_struct_20 _f0;
 ivec4 _f1;
 _GLF_struct_21 _f2;
} ;

struct _GLF_struct_18 {
 vec4 _f0;
 mat4x3 _f1;
 mat2x4 _f2;
 uint _f3;
 uvec2 _f4;
 ivec2 _f5;
} ;

struct _GLF_struct_17 {
 ivec3 _GLF_SWITCH_1_27v;
 mat2x3 _f0;
 int _f1;
 bvec4 _f2;
} ;

struct _GLF_struct_19 {
 vec4 _f0;
 _GLF_struct_17 _f1;
 _GLF_struct_18 _f2;
} ;

struct _GLF_struct_15 {
 mat3x2 _f0;
 uint _f1;
 vec2 _f2;
 uvec4 _f3;
 mat4x2 _f4;
 vec2 _f5;
 vec2 _f6;
} ;

struct _GLF_struct_14 {
 bool _f0;
 mat4x3 _f1;
 mat3 _f2;
 vec2 _f3;
 bvec2 _f4;
 vec3 _f5;
} ;

struct _GLF_struct_13 {
 mat4x3 _f0;
} ;

struct _GLF_struct_16 {
 uvec3 _f0;
 _GLF_struct_13 _f1;
 mat4x2 _f2;
 _GLF_struct_14 _f3;
 mat3x4 _f4;
 uvec4 _f5;
 _GLF_struct_15 _f6;
} ;

struct _GLF_struct_11 {
 mat4x3 _f0;
 uvec2 _f1;
 uvec4 _f2;
 int _f3;
 mat3 _f4;
 mat2x3 _f5;
 ivec2 _f6;
} ;

struct _GLF_struct_10 {
 ivec2 _f0;
 bvec3 _f1;
 bool _f2;
 vec3 _f3;
 mat3 _f4;
 mat3x4 _f5;
 mat4 _f6;
} ;

struct _GLF_struct_9 {
 bvec2 _f0;
 uvec2 _f1;
 float _f2;
 ivec2 _f3;
} ;

struct _GLF_struct_12 {
 _GLF_struct_9 _f0;
 _GLF_struct_10 _f1;
 _GLF_struct_11 _f2;
 mat3x2 _f3;
 bool _f4;
} ;

struct _GLF_struct_23 {
 _GLF_struct_12 _f0;
 _GLF_struct_16 _f1;
 _GLF_struct_19 _f2;
 float _f3;
 mat3x2 _f4;
 _GLF_struct_22 _f5;
} ;

struct _GLF_struct_6 {
 uvec4 _f0;
 uvec4 _f1;
 uint _f2;
 ivec4 _f3;
} ;

struct _GLF_struct_5 {
 uvec4 _f0;
 mat3x2 _f1;
 mat2x3 _f2;
 uint read_2;
 int _f3;
 uint _f4;
 int _f5;
} ;

struct _GLF_struct_7 {
 ivec2 _f0;
 _GLF_struct_5 _f1;
 _GLF_struct_6 _f2;
 mat2x3 _f3;
} ;

struct _GLF_struct_3 {
 float _f0;
 bvec3 _f1;
 mat2x3 _f2;
 vec2 _f3;
 mat4x3 _f4;
 mat4x3 _f5;
 bvec2 _f6;
} ;

struct _GLF_struct_2 {
 uvec2 _f0;
 uvec2 _f1;
 mat4x2 _f2;
 vec4 _f3;
} ;

struct _GLF_struct_1 {
 float _f0;
 mat2 _f1;
 mat4x3 _f2;
 mat3 _f3;
 mat3x4 _f4;
 ivec3 _f5;
 bvec4 _f6;
} ;

struct _GLF_struct_0 {
 bvec3 _f0;
 mat4 _f1;
 bvec2 _f2;
} ;

struct _GLF_struct_4 {
 _GLF_struct_0 _f0;
 int _f1;
 _GLF_struct_1 _f2;
 _GLF_struct_2 _f3;
 mat4x3 _f4;
 _GLF_struct_3 _f5;
 int _f6;
} ;

struct _GLF_struct_8 {
 uint _f0;
 uvec4 _f1;
 ivec2 _f2;
 _GLF_struct_4 _f3;
 _GLF_struct_7 _f4;
 bool _f5;
} ;

layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, (true ? _GLF_IDENTITY(injectionSwitch, mat2(1.0) * (injectionSwitch)) : _GLF_FUZZED(vec2(-948.151, -6.7)))).x > injectionSwitch.y))))
  return;
 uvec2 GLF_merged2_0_1_11_1_1_12virtual_gidworkgroup_id;
 _GLF_struct_39 _GLF_struct_replacement_39;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
    }
   else
    {
     return;
    }
  }
 _GLF_struct_52 _GLF_struct_replacement_52 = _GLF_struct_52(_GLF_struct_46(_GLF_struct_41(1, mat3(1.0), mat3x4(1.0), bvec3(true)), _GLF_struct_42(mat4(1.0), bvec4(true), ivec4(1), vec2(1.0)), _GLF_struct_43(ivec2(1), uvec4(1u)), _GLF_struct_44(ivec4(1), ivec3(1), uvec4(1u), mat4x2(1.0), uvec2(1u)), _GLF_struct_45(mat2(1.0), bvec4(true), bvec3(true), vec4(1.0), uvec2(1u), ivec4(1), 1.0), bvec3(true)), gl_SubgroupID, _GLF_struct_49(_GLF_struct_47(mat3x2(1.0), mat4x2(1.0), uvec3(1u), vec2(1.0)), _GLF_struct_48(uvec3(1u), uvec3(1u), bvec4(true), mat4x3(1.0), mat3(1.0), mat2(1.0)), ivec2(1), vec3(1.0), mat3x2(1.0), 1.0), mat2x3(1.0), _GLF_struct_51(_GLF_struct_50(1u, vec4(1.0), true, uvec4(1u), mat4(1.0), mat2x4(1.0), mat3x4(1.0)), uvec4(1u)));
 uint subgroup_size = gl_SubgroupSize;
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    return;
   do
    {
     if(_GLF_DEAD(false))
      break;
     return;
    }
   while(_GLF_WRAPPED_LOOP(false));
  }
 _GLF_struct_30 _GLF_struct_replacement_30 = _GLF_struct_30(_GLF_struct_25(uvec3(1u), _GLF_struct_24(mat4x2(1.0), ivec2(1), mat3x4(1.0), mat2x3(1.0), mat3x2(_GLF_IDENTITY(_GLF_IDENTITY(1.0, clamp(1.0, 1.0, 1.0)), clamp(1.0, 1.0, _GLF_IDENTITY(1.0, min(_GLF_IDENTITY(1.0, (1.0) + 0.0), 1.0))))), mat3x4(1.0), ivec2(1))), _GLF_struct_29(_GLF_struct_26(bvec3(true), ivec3(1), bvec3(true), uvec2(1u), mat3x4(1.0)), 1u, _GLF_struct_27(vec4(1.0), ivec3(1), bvec3(true), mat4x3(1.0), uvec4(1u), mat3(1.0), mat2(1.0)), true, _GLF_struct_28(bvec4(true), mat3x2(1.0), 1u), ivec2(1)), gl_SubgroupInvocationID);
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 uint num_workgroup = gl_NumWorkGroups.x;
 if(_GLF_DEAD(false))
  return;
 _GLF_struct_replacement_39._f1._f2.GLF_merged2_0_1_16_1_1_13next_virtual_gidnum_workgroup.y = num_workgroup;
 uint workgroup_size = _GLF_IDENTITY(gl_WorkGroupSize.x, 0u | (gl_WorkGroupSize.x));
 uint workgroup_id = _GLF_IDENTITY(gl_WorkGroupID, uvec3(uvec3(gl_WorkGroupID))).x;
 GLF_merged2_0_1_11_1_1_12virtual_gidworkgroup_id.y = workgroup_id;
 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 & 1)); _injected_loop_counter ++)
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     if(_GLF_IDENTITY(_GLF_DEAD(false), ! (_GLF_IDENTITY(! (_GLF_DEAD(false)), ! (_GLF_IDENTITY(! (! (_GLF_DEAD(false))), true && (! (! (_GLF_DEAD(false))))))))))
      return;
     switch(_GLF_SWITCH(0))
      {
       case 69:
       {
        if(_GLF_DEAD(false))
         return;
        do
         {
          ;
         }
        while(_GLF_WRAPPED_LOOP(false));
        int _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v, _GLF_SWITCH_2_2v[7];
        if(_GLF_DEAD(false))
         continue;
        ivec3 _GLF_SWITCH_2_3v[61], _GLF_SWITCH_2_4v;
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         while((_GLF_IDENTITY(vec3(4338.2775, 3.4, -61.57) != vec3(-2.9, -312.642, 9.7), true && (_GLF_IDENTITY(vec3(4338.2775, 3.4, -61.57) != vec3(-2.9, -312.642, 9.7), (vec3(4338.2775, 3.4, -61.57) != vec3(-2.9, -312.642, 9.7)) || false)))))
          {
           mat2x4 _GLF_SWITCH_2_5v;
           if(_GLF_IDENTITY(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))), ! (! (_GLF_IDENTITY(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))), (_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false))))) && true)))))
            continue;
          }
         do
          {
           _GLF_SWITCH_2_4v;
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter > (1 ^ 1), true && (_injected_loop_counter > (1 ^ 1)))); _injected_loop_counter --)
          {
           true;
          }
         {
          mat2(-4742.1549, -1.3, -5.6, 782.386);
          outerProduct(vec2(-8285.9498, -5352.1584), vec3(4.3, 0.2, _GLF_IDENTITY(-7.8, _GLF_IDENTITY(float(_GLF_IDENTITY(vec4(-7.8, _GLF_ONE(1.0, injectionSwitch.y), 0.0, 1.0), vec4(mat2x3(_GLF_IDENTITY(vec4(-7.8, _GLF_ONE(1.0, injectionSwitch.y), 0.0, 1.0), max(vec4(-7.8, _GLF_ONE(1.0, injectionSwitch.y), 0.0, 1.0), vec4(-7.8, _GLF_ONE(1.0, injectionSwitch.y), 0.0, 1.0))), 0.0, round(length(normalize(1.0))))))), mix(float(_GLF_FUZZED(_GLF_IDENTITY(99.97, min(99.97, 99.97)))), float(float(_GLF_IDENTITY(vec4(-7.8, _GLF_ONE(_GLF_IDENTITY(1.0, (_GLF_IDENTITY(1.0, cos(0.0) * (1.0))) / abs(1.0)), injectionSwitch.y), 0.0, 1.0), vec4(mat2x3(_GLF_IDENTITY(vec4(-7.8, _GLF_ONE(1.0, injectionSwitch.y), 0.0, 1.0), max(_GLF_IDENTITY(vec4(-7.8, _GLF_ONE(1.0, injectionSwitch.y), 0.0, 1.0), mix(vec4((vec4(-7.8, _GLF_ONE(1.0, injectionSwitch.y), 0.0, 1.0))[0], (vec4(-7.8, _GLF_ONE(1.0, injectionSwitch.y), 0.0, 1.0))[1], (vec4(-7.8, _GLF_ONE(1.0, injectionSwitch.y), 0.0, 1.0))[2], _GLF_FUZZED(-9.5)), vec4(_GLF_FUZZED(-7.4), _GLF_FUZZED(0.9), _GLF_FUZZED(1673.8120), (vec4(-7.8, _GLF_ONE(1.0, injectionSwitch.y), 0.0, 1.0))[3]), bvec4(false, false, false, true))), vec4(-7.8, _GLF_ONE(1.0, injectionSwitch.y), 0.0, 1.0))), 0.0, round(length(normalize(1.0)))))))), bool(true))))));
         }
         bvec4(true, true, false, true);
         {
          switch(_GLF_SWITCH(0))
           {
            case 0:
            if(_GLF_WRAPPED_IF_TRUE(true))
             {
              vec2(-59.41, -30.43);
             }
            else
             {
             }
            if(_GLF_WRAPPED_IF_FALSE(false))
             {
             }
            else
             {
              ivec2(60016, 96159);
             }
            case 67:
            vec2 _GLF_SWITCH_2_6v, _GLF_SWITCH_2_7v[58], _GLF_SWITCH_2_8v[42];
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               return;
              if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) && (false)), (injectionSwitch.x > injectionSwitch.y))))
               {
                for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                 {
                  return;
                 }
               }
              return;
             }
            mat2x4 _GLF_SWITCH_2_9v, _GLF_SWITCH_2_10v;
            case 44:
            (_GLF_SWITCH_2_4v , mat3(13.59, 657.243, -861.808, -5.6, -279.778, -2351.4219, 12.02, _GLF_IDENTITY(-6.6, (false ? _GLF_FUZZED(-4358.1510) : _GLF_IDENTITY(-6.6, (-6.6) - 0.0))), 5073.8824));
            for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
             {
              ;
             }
            case 15:
            bvec3(false, true, false);
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               break;
              return;
             }
            bvec2(_GLF_IDENTITY(true, _GLF_IDENTITY(bool(bvec4(true, false, true, _GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec4(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, false, false))))), (_GLF_IDENTITY(bool(bvec4(true, _GLF_IDENTITY(false, _GLF_IDENTITY(bool(bool(false)), (bool(bool(false))) && true)), true, _GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec4(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, false, _GLF_IDENTITY(false, true && (false))))))), true && (_GLF_IDENTITY(bool(bvec4(true, _GLF_IDENTITY(false, _GLF_IDENTITY(bool(bool(false)), (bool(bool(false))) && true)), true, _GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec4(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, false, _GLF_IDENTITY(false, true && (false))))))), bool(_GLF_IDENTITY(bool(bool(bvec4(true, _GLF_IDENTITY(false, _GLF_IDENTITY(bool(bool(false)), (bool(bool(false))) && true)), true, _GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec4(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, false, _GLF_IDENTITY(false, true && (false)))))))), (bool(bool(bvec4(true, _GLF_IDENTITY(false, _GLF_IDENTITY(bool(bool(false)), (bool(bool(false))) && true)), true, _GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec4(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, false, _GLF_IDENTITY(false, true && (false))))))))) && true)))))) || false)), false);
            break;
            default:
            1;
           }
          if(_GLF_DEAD(false))
           break;
         }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         if(true)
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(false))
                return;
               switch(_GLF_SWITCH((0 >> _GLF_IDENTITY(int(5), _GLF_IDENTITY(int(5), clamp(int(5), int(5), int(5)))))))
                {
                 case 24:
                 if(_GLF_DEAD(false))
                  break;
                 vec4 _GLF_SWITCH_4_0v;
                 case 0:
                 case 11:
                 do
                  {
                   do
                    {
                     return;
                    }
                   while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, true && (false))));
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, false || (false))));
                 case 28:
                 case 10:
                 case 6:
                 if(_GLF_DEAD(false))
                  return;
                 break;
                 case 57:
                 mat2x4 _GLF_SWITCH_4_1v, _GLF_SWITCH_4_2v[45];
                 case 70:
                 false;
                 default:
                 1;
                }
              }
            }
           mat2x3 _GLF_SWITCH_2_11v[74], _GLF_SWITCH_2_12v;
          }
         mat2x4(-9367.8060, _GLF_IDENTITY(7.4, clamp(7.4, 7.4, 7.4)), -6.9, 1174.2399, 4.7, 5243.9294, -5.4, -219.044);
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
        }
        while((mat4(513.564, 3.8, -5.3, -2215.0649, -8.0, 700.541, -9.7, -3.1, 7.9, 107.609, -5.0, -1.4, -59.87, 2.6, 351.778, 136.545) == mat4(2377.7671, 0.5, -0.5, -8.3, -5.5, 3.7, -1573.4839, 8.8, 4.0, 67.29, _GLF_IDENTITY(-760.959, float(mat2x3(_GLF_IDENTITY(-760.959, determinant(mat2(1.0, 0.0, 0.0, 1.0)) * (-760.959)), 1.0, 0.0, 1.0, 0.0, 1.0))), 391.017, -3.6, 576.782, 9377.3167, -825.901)))
         {
          if(false)
           {
            if(_GLF_DEAD(false))
             return;
            if(_GLF_WRAPPED_IF_TRUE(true))
             {
              ;
             }
            else
             {
              if(_GLF_DEAD(false))
               continue;
             }
            uvec4(190068u, 195857u, 149133u, 184016u);
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             return;
            mat2 _GLF_SWITCH_2_13v[27];
            mat3 _GLF_SWITCH_2_14v, _GLF_SWITCH_2_15v;
            if(_GLF_DEAD(false))
             return;
            (mat3x4(42.77, -4.4, 5428.7635, 5.8, _GLF_IDENTITY(-2769.8764, mix(float(_GLF_FUZZED(840.833)), float(_GLF_IDENTITY(-2769.8764, float(mat3(-2769.8764, cos(0.0), 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0)))), bool(true))), 5.5, -3.6, 98.15, -6.5, -4.1, -9.6, 37.80) + (mat3x4(-308.855, -4424.1965, -8.2, -1.7, _GLF_IDENTITY(-91.63, (-91.63) * 1.0), 82.19, 7.4, -8659.1044, -4108.7056, -2756.0240, -543.667, 58.57) - mat3x4(-379.130, 6.1, -8.4, -9.0, -67.42, -9.8, 53.87, -39.66, 1.1, 655.488, 6.5, -8.6)));
            mat2x3(_GLF_IDENTITY(-3.7, (false ? _GLF_FUZZED(4309.7242) : -3.7)), -21.37, 6190.4438, 0.8, -4.0, 9.3);
            ivec4 _GLF_SWITCH_2_16v[70], _GLF_SWITCH_2_17v[87];
            if(_GLF_DEAD(false))
             continue;
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             break;
            uvec3 _GLF_SWITCH_2_18v, _GLF_SWITCH_2_19v[50], _GLF_SWITCH_2_20v[46];
            mat4x2(-324.665, -467.275, -72.57, -2909.2259, -7.8, 611.359, 685.339, 879.503);
           }
          mat2 _GLF_SWITCH_2_21v[59], _GLF_SWITCH_2_22v, _GLF_SWITCH_2_23v[58];
          if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           {
           }
          else
           {
            if(_GLF_WRAPPED_IF_TRUE(true))
             {
              if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), ! (! (! (false))))))))
               return;
              while(bvec4(false, true, true, true).s)
               {
                if(_GLF_DEAD(false))
                 break;
                if(_GLF_DEAD(false))
                 {
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   continue;
                  if(_GLF_DEAD(false))
                   return;
                  break;
                 }
                if(_GLF_DEAD(false))
                 break;
                if(_GLF_DEAD(false))
                 return;
                _GLF_struct_53 _GLF_struct_replacement_53;
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 return;
                ;
                (+ mat2x4(-2136.9770, 77.77, 63.32, 2.3, -11.01, 2.1, 6641.0602, 92.37));
                if(_GLF_DEAD(false))
                 {
                  if(_GLF_WRAPPED_IF_TRUE(true))
                   {
                    return;
                   }
                  else
                   {
                   }
                 }
                bvec4(false, true, true, true);
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 continue;
                if(_GLF_WRAPPED_IF_FALSE(false))
                 {
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   {
                    for(_GLF_struct_57 _GLF_struct_replacement_57 = _GLF_struct_57(_GLF_struct_56(mat3(1.0), _GLF_struct_54(mat4x2(1.0), vec2(1.0), uvec2(1u), 1, bvec2(true)), 1u, _GLF_struct_55(mat2x3(1.0), mat4x2(1.0), vec2(1.0)), bvec2(true)), 0); _GLF_WRAPPED_LOOP(_GLF_struct_replacement_57._injected_loop_counter < ((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), int(1)))); _GLF_struct_replacement_57._injected_loop_counter ++)
                     {
                      return;
                     }
                   }
                 }
                else
                 {
                  vec2(-5.2, 3.2);
                 }
                if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 {
                 }
                else
                 {
                  (-3201.1423 + (mat2x3(812.386, 9.1, -84.29, -9746.7090, 4.1, -6.3)));
                 }
                bool _GLF_SWITCH_2_25v;
                mat4x2 _GLF_SWITCH_2_26v[90], _GLF_SWITCH_2_27v, _GLF_SWITCH_2_28v;
               }
             }
            else
             {
             }
           }
         }
        for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
         {
          if(_GLF_DEAD(false))
           return;
          if((_GLF_struct_replacement_39._f1._f2.GLF_merged2_0_1_16_1_1_13next_virtual_gidnum_workgroup != (_GLF_struct_replacement_30.subgroup_local_id / GLF_merged2_0_1_11_1_1_12virtual_gidworkgroup_id)))
           {
            if(_GLF_DEAD(false))
             return;
            if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
             {
              do
               {
                mat4x3((mat3x2(-2.9, 7.7, -0.8, 326.094, 4315.1002, -2.8) * mat3(2.1, -4124.5579, -3.9, 2.6, -4.3, -17.43, -8.4, 7.3, _GLF_IDENTITY(8.1, mix(float(_GLF_FUZZED(89.73)), float(8.1), bool(true))))));
                if(_GLF_DEAD(false))
                 return;
               }
              while(_GLF_WRAPPED_LOOP(false));
             }
            else
             {
              if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
               return;
             }
            if(_GLF_DEAD(false))
             continue;
            if(_GLF_DEAD(false))
             {
              if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
               {
                if(_GLF_DEAD(false))
                 return;
               }
              else
               {
               }
              return;
             }
            uvec3(18516u, 184588u, 54496u);
            if(_GLF_WRAPPED_IF_TRUE(true))
             {
              if(_GLF_DEAD(false))
               return;
             }
            else
             {
             }
            while((_GLF_struct_replacement_52.subgroup_id == 9252u))
             {
              if(_GLF_DEAD(false))
               continue;
             }
            (-17344 ^ _GLF_IDENTITY(max(ivec4(-42946, ivec2(-597, -81392), _GLF_SWITCH_2_0v), _GLF_SWITCH_2_1v), ~ (~ (max(ivec4(-42946, ivec2(-597, -81392), _GLF_SWITCH_2_0v), _GLF_SWITCH_2_1v)))));
            uint _GLF_SWITCH_2_29v[76];
            if(_GLF_DEAD(false))
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               break;
              do
               {
                return;
               }
              while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) && true)));
             }
            if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
             {
              for(bool _GLF_SWITCH_2_30v; _GLF_SWITCH_2_30v; ivec2(-15958, -72161))
               {
                if(_GLF_WRAPPED_IF_FALSE(false))
                 {
                 }
                else
                 {
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   continue;
                  if(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(false), ! (! (_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(false), ! (! (_GLF_WRAPPED_IF_FALSE(false))))))))
                   {
                   }
                  else
                   {
                    ivec2(19857, -14153);
                   }
                 }
                if(_GLF_DEAD(false))
                 continue;
                _GLF_SWITCH_2_1v;
                -3992;
                ivec4(91741, 17876, 95686, -75809);
               }
             }
            else
             {
             }
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
              if(_GLF_WRAPPED_IF_FALSE(false))
               {
               }
              else
               {
                if(_GLF_DEAD(false))
                 return;
                return;
               }
             }
            if((-23823 >= (-- _GLF_SWITCH_2_0v)))
             {
              ivec2 _GLF_SWITCH_2_31v[74];
              if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
               }
              else
               {
                if(_GLF_DEAD(false))
                 return;
               }
              ;
              for(_GLF_struct_60 _GLF_struct_replacement_60 = _GLF_struct_60((0 ^ 1), _GLF_struct_59(mat4(1.0), true, _GLF_struct_58(mat3(1.0), vec2(1.0), bvec4(true)))); _GLF_WRAPPED_LOOP(_GLF_struct_replacement_60._injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _GLF_struct_replacement_60._injected_loop_counter --)
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 return;
                ((vec4(73.41, 83.20, 7.6, -1998.8268)[1] + mat3x4(7.2, 2.4, -35.35, -871.180, 0.0, -4970.5871, -67.89, 310.450, -907.786, _GLF_IDENTITY(-6.2, (true ? -6.2 : _GLF_FUZZED(898.820))), _GLF_IDENTITY(-4.9, clamp(_GLF_IDENTITY(-4.9, max(_GLF_IDENTITY(-4.9, (false ? _GLF_FUZZED(-7.8) : -4.9)), _GLF_IDENTITY(-4.9, mix(float(_GLF_FUZZED(-3380.4003)), float(-4.9), bool(true))))), _GLF_IDENTITY(-4.9, (true ? -4.9 : _GLF_FUZZED(-941.086))), -4.9)), -0.6)) - radians(48.26));
               }
              if(_GLF_DEAD(false))
               continue;
              if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
               {
               }
              else
               {
                vec2(4558.1607, 2714.2969);
               }
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               return;
              ivec4(-73648, -6812, -49890, 95021).brgg;
              mat3(-74.34, -5.3, 7633.3197, -31.77, 6.9, 7.3, 4.1, -369.410, -1.8);
              mat4x2 _GLF_SWITCH_2_32v;
              if(_GLF_DEAD(false))
               return;
              notEqual(uvec4(159097u, 4333u, 15953u, 160022u), uvec4(75858u, 145882u, 69863u, 162333u));
             }
           }
         }
        if(_GLF_DEAD(false))
         break;
        if((workgroup_size == packUnorm4x8(vec4(4.1, -46.05, -1482.9613, -6.9))))
         {
          if(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), (_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, mat2(1.0) * (injectionSwitch)).y))), (_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(_GLF_IDENTITY(false, ! (! (false))), (injectionSwitch.x > injectionSwitch.y)))) && true)) && true))
           {
           }
          else
           {
            switch(_GLF_SWITCH(int(_GLF_ZERO(_GLF_IDENTITY(0.0, float(mat4x2(0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0))), injectionSwitch.x))))
             {
              case 0:
              if(_GLF_WRAPPED_IF_FALSE(false))
               {
               }
              else
               {
                if(_GLF_DEAD(false))
                 return;
               }
              case 12:
              case 96:
              if(_GLF_DEAD(false))
               continue;
              case 13:
              for(mat3x4 _GLF_SWITCH_2_33v; (distance(_GLF_IDENTITY(injectionSwitch, mat2(1.0) * (injectionSwitch)), vec2(-2.8, -6830.9035)) == uintBitsToFloat(workgroup_size)); bvec2(true, true))
               {
                if(_GLF_DEAD(false))
                 continue;
                false;
                if(_GLF_DEAD(false))
                 continue;
                lessThan(uvec3(156564u, 141745u, 35527u), uvec3(17156u, 17646u, 141441u));
                ivec4(-63112, -68514, 79968, -25832);
                (false ? mat2x3(-9669.9772, -4.8, -176.747, 0.2, -4.5, -9255.6398) : ((2.6 - mat4x3(2890.1938, 777.747, -9.9, 19.47, -896.340, 5025.9130, 8.8, -75.04, -8.4, -35.74, -4.0, -7.1)) * mat2x4(-51.97, -93.84, 3259.3020, 3166.3445, 828.773, -846.562, -2.3, -5.6)));
                if(_GLF_DEAD(false))
                 break;
                lessThanEqual((ivec4(59271, -50571, 5018, -94003)), ivec4(73442, -87519, -32406, _GLF_IDENTITY(65678, 0 | (_GLF_IDENTITY(65678, ~ (~ (65678)))))));
                uvec4 _GLF_SWITCH_2_34v, _GLF_SWITCH_2_35v, _GLF_SWITCH_2_36v;
                if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                 break;
                ;
                if(_GLF_DEAD(false))
                 continue;
               }
              break;
              default:
              1;
             }
           }
          if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
           {
            if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))) && true)))
             {
              switch(_GLF_SWITCH(0))
               {
                case 0:
                case 52:
                case 78:
                case 28:
                case 56:
                case 76:
                if(_GLF_DEAD(false))
                 break;
                case 13:
                case 29:
                case 79:
                if(bvec4(true, false, false, true).y)
                 {
                  if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                   {
                    for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                     {
                      vec4(275.045, -4152.9995, 4542.7004, 2.8);
                      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                       return;
                     }
                   }
                  else
                   {
                   }
                  bvec3 _GLF_SWITCH_2_37v, _GLF_SWITCH_2_38v, _GLF_SWITCH_2_39v[87];
                  if(_GLF_WRAPPED_IF_TRUE(true))
                   {
                    isinf(vec4(-9006.4356, -3.0, -6.6, 3144.1195));
                   }
                  else
                   {
                   }
                  if(_GLF_DEAD(false))
                   break;
                  if(_GLF_DEAD(false))
                   {
                    do
                     {
                      if(_GLF_DEAD(false))
                       continue;
                      if(_GLF_WRAPPED_IF_FALSE(false))
                       {
                       }
                      else
                       {
                        if(_GLF_WRAPPED_IF_TRUE(true))
                         {
                          return;
                          if(_GLF_DEAD(false))
                           return;
                         }
                        else
                         {
                         }
                       }
                      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                       continue;
                     }
                    while(_GLF_WRAPPED_LOOP(false));
                    if(_GLF_DEAD(false))
                     continue;
                   }
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   return;
                  if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                   {
                    ivec3(-50438);
                   }
                  else
                   {
                   }
                  if(_GLF_DEAD(false))
                   return;
                  if(_GLF_DEAD(false))
                   return;
                  bvec3 _GLF_SWITCH_2_40v, _GLF_SWITCH_2_41v;
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   return;
                  for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 & 1)); _injected_loop_counter ++)
                   {
                    if(_GLF_DEAD(false))
                     return;
                   }
                 }
                else
                 {
                  if(_GLF_DEAD(false))
                   continue;
                  for(int _injected_loop_counter = (0 | 1); _GLF_WRAPPED_LOOP(_injected_loop_counter != (int(_GLF_ZERO(0.0, injectionSwitch.x)) | 0)); _injected_loop_counter --)
                   {
                    if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(false || (false), true && (false || (false))))))
                     {
                      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                       break;
                      do
                       {
                        if(_GLF_DEAD(false))
                         break;
                        return;
                       }
                      while(_GLF_WRAPPED_LOOP(false));
                     }
                   }
                  if(_GLF_DEAD(false))
                   return;
                 }
                break;
                case 60:
                mat2x4 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v;
                case 33:
                mat2x3 _GLF_SWITCH_4_2v;
                default:
                1;
               }
             }
            else
             {
             }
           }
          else
           {
           }
          mat3x2(mat3(_GLF_IDENTITY(-6.5, (true ? _GLF_IDENTITY(-6.5, mix(float(_GLF_FUZZED(4944.3173)), float(-6.5), bool(true))) : _GLF_FUZZED(((! true) ? -3493.7324 : -1.5)))), -6.8, 8.7, -641.117, -4.0, 4.2, -4800.6330, 4.5, _GLF_IDENTITY(-5804.2723, mix(float(_GLF_FUZZED(92.95)), float(_GLF_IDENTITY(-5804.2723, _GLF_IDENTITY(float(mat4x3(-5804.2723, determinant(mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0)), 1.0, 0.0, 1.0, 0.0, determinant(mat3(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)), 0.0, 0.0, 0.0, 1.0, 1.0)), float(mat2x3(float(mat4x3(-5804.2723, determinant(mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0)), 1.0, 0.0, 1.0, 0.0, determinant(mat3(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)), 0.0, 0.0, 0.0, 1.0, 1.0)), 0.0, 0.0, 0.0, 0.0, 0.0))))), bool(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))));
          mat4x2(mat4(-311.149, 2.5, -3.9, -549.656, 1.1, -373.559, 9.5, -4.1, -2100.6245, -3.9, 345.848, 38.43, -6.3, 2.6, -2.3, 9214.5936));
         }
        mat3x2 _GLF_SWITCH_2_42v[91];
       }
       case 0:
       case 84:
       if(_GLF_DEAD(false))
        return;
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
          {
           do
            {
             return;
             if(_GLF_DEAD(false))
              continue;
            }
           while(_GLF_IDENTITY(_GLF_WRAPPED_LOOP(false), _GLF_IDENTITY(bool(bvec4(_GLF_WRAPPED_LOOP(false), true, true, _GLF_IDENTITY(true, bool(bvec2(true, true))))), bool(bvec3(bool(bvec4(_GLF_WRAPPED_LOOP(false), true, true, _GLF_IDENTITY(true, bool(bvec2(true, true))))), true, false)))));
          }
        }
       else
        {
        }
       break;
       default:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        break;
       1;
      }
    }
  }
 uint workgroup_base = _GLF_IDENTITY(workgroup_size * GLF_merged2_0_1_11_1_1_12virtual_gidworkgroup_id.y, (workgroup_size * GLF_merged2_0_1_11_1_1_12virtual_gidworkgroup_id.y) / 1u);
 do
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), true && (_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bool(bvec3(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), true, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))))))
      {
       switch(_GLF_SWITCH(0))
        {
         case 90:
         (-1.3 - _GLF_IDENTITY(mat4(-18.02), transpose(transpose(_GLF_IDENTITY(mat4(-18.02), transpose(transpose(mat4(-18.02))))))));
         case 0:
         case 55:
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 << _GLF_IDENTITY(int(4), int(_GLF_IDENTITY(4, (4) * 1))))); _injected_loop_counter --)
            {
             switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
              {
               case 41:
               mat2 _GLF_SWITCH_3_0v;
               if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))) || false)))
                return;
               case 0:
               case 29:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               case 66:
               case 1:
               case 44:
               case 3:
               case 72:
               if(_GLF_DEAD(false))
                continue;
               case 70:
               do
                {
                 if(_GLF_DEAD(false))
                  continue;
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    break;
                   return;
                  }
                }
               while(_GLF_WRAPPED_LOOP(false));
               break;
               if(_GLF_DEAD(false))
                break;
               default:
               1;
              }
            }
          }
         else
          {
          }
         case 48:
         if(_GLF_IDENTITY(_GLF_WRAPPED_IF_FALSE(false), false || (_GLF_WRAPPED_IF_FALSE(false))))
          {
           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < _GLF_IDENTITY(1, clamp(1, 1, 1))); _injected_loop_counter ++)
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
            }
          }
         else
          {
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
              {
               return;
              }
            }
           return;
          }
         break;
         default:
         if(_GLF_DEAD(false))
          return;
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           1;
          }
         else
          {
          }
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(false))
            return;
          }
        }
       if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))
        return;
      }
    }
   else
    {
    }
  }
 while(_GLF_WRAPPED_LOOP(false));
 if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
  return;
 do
  {
   if(_GLF_DEAD(false))
    return;
  }
 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
 uint virtual_gid = workgroup_base + _GLF_IDENTITY(_GLF_struct_replacement_52.subgroup_id * subgroup_size, ~ (~ _GLF_IDENTITY(_GLF_IDENTITY((_GLF_struct_replacement_52.subgroup_id * subgroup_size), ((_GLF_struct_replacement_52.subgroup_id * subgroup_size)) | ((_GLF_struct_replacement_52.subgroup_id * subgroup_size))), clamp(_GLF_IDENTITY((_GLF_struct_replacement_52.subgroup_id * subgroup_size), ~ (_GLF_IDENTITY(~ (_GLF_IDENTITY((_GLF_IDENTITY(_GLF_struct_replacement_52.subgroup_id, 0u ^ (_GLF_IDENTITY(_GLF_struct_replacement_52.subgroup_id, min(_GLF_struct_replacement_52.subgroup_id, _GLF_struct_replacement_52.subgroup_id)))) * subgroup_size), (_GLF_IDENTITY((_GLF_struct_replacement_52.subgroup_id * subgroup_size), min(_GLF_IDENTITY((_GLF_struct_replacement_52.subgroup_id * subgroup_size), 0u + ((_GLF_struct_replacement_52.subgroup_id * subgroup_size))), (_GLF_struct_replacement_52.subgroup_id * subgroup_size)))) | ((_GLF_struct_replacement_52.subgroup_id * subgroup_size)))), uint(uvec2(_GLF_IDENTITY(~ (_GLF_IDENTITY(_GLF_IDENTITY((_GLF_struct_replacement_52.subgroup_id * _GLF_IDENTITY(subgroup_size, min(_GLF_IDENTITY(subgroup_size, (false ? _GLF_FUZZED(_GLF_struct_replacement_52.subgroup_id) : subgroup_size)), subgroup_size))), clamp((_GLF_struct_replacement_52.subgroup_id * _GLF_IDENTITY(subgroup_size, min(_GLF_IDENTITY(_GLF_IDENTITY(subgroup_size, (false ? _GLF_FUZZED(_GLF_struct_replacement_52.subgroup_id) : subgroup_size)), (_GLF_IDENTITY(subgroup_size, (false ? _GLF_FUZZED(_GLF_struct_replacement_52.subgroup_id) : subgroup_size))) / 1u), subgroup_size))), _GLF_IDENTITY((_GLF_struct_replacement_52.subgroup_id * _GLF_IDENTITY(subgroup_size, min(_GLF_IDENTITY(subgroup_size, (false ? _GLF_FUZZED(_GLF_struct_replacement_52.subgroup_id) : subgroup_size)), subgroup_size))), uint(uvec2((_GLF_struct_replacement_52.subgroup_id * _GLF_IDENTITY(subgroup_size, min(_GLF_IDENTITY(subgroup_size, (false ? _GLF_FUZZED(_GLF_struct_replacement_52.subgroup_id) : subgroup_size)), subgroup_size))), (0u << _GLF_IDENTITY(uint(4u), uint(4u)))))), (_GLF_struct_replacement_52.subgroup_id * _GLF_IDENTITY(subgroup_size, min(_GLF_IDENTITY(subgroup_size, (false ? _GLF_IDENTITY(_GLF_FUZZED(_GLF_struct_replacement_52.subgroup_id), uint(uvec3(_GLF_FUZZED(_GLF_struct_replacement_52.subgroup_id), 0u, ((1u << _GLF_IDENTITY(uint(3u), uint(3u))) >> _GLF_IDENTITY(uint(3u), uint(3u)))))) : subgroup_size)), subgroup_size))))), (_GLF_IDENTITY((_GLF_IDENTITY(_GLF_IDENTITY(_GLF_struct_replacement_52.subgroup_id, ~ (_GLF_IDENTITY(~ (_GLF_struct_replacement_52.subgroup_id), (_GLF_IDENTITY(~ (_GLF_struct_replacement_52.subgroup_id), (~ (_GLF_struct_replacement_52.subgroup_id)) * 1u)) >> 0u))) * subgroup_size, min(_GLF_struct_replacement_52.subgroup_id * subgroup_size, _GLF_IDENTITY(_GLF_struct_replacement_52.subgroup_id, (_GLF_struct_replacement_52.subgroup_id) ^ 0u) * subgroup_size))), min((_GLF_struct_replacement_52.subgroup_id * subgroup_size), (_GLF_struct_replacement_52.subgroup_id * subgroup_size)))) | ((_GLF_struct_replacement_52.subgroup_id * subgroup_size)))), (true ? ~ (_GLF_IDENTITY((_GLF_IDENTITY(_GLF_struct_replacement_52.subgroup_id * subgroup_size, 0u ^ (_GLF_struct_replacement_52.subgroup_id * subgroup_size))), (_GLF_IDENTITY((_GLF_struct_replacement_52.subgroup_id * _GLF_IDENTITY(subgroup_size, 0u ^ (subgroup_size))), min((_GLF_struct_replacement_52.subgroup_id * subgroup_size), _GLF_IDENTITY((_GLF_struct_replacement_52.subgroup_id * subgroup_size), max(_GLF_IDENTITY((_GLF_struct_replacement_52.subgroup_id * subgroup_size), clamp((_GLF_struct_replacement_52.subgroup_id * subgroup_size), (_GLF_struct_replacement_52.subgroup_id * subgroup_size), (_GLF_struct_replacement_52.subgroup_id * subgroup_size))), _GLF_IDENTITY((_GLF_struct_replacement_52.subgroup_id * subgroup_size), clamp((_GLF_struct_replacement_52.subgroup_id * subgroup_size), (_GLF_struct_replacement_52.subgroup_id * subgroup_size), (_GLF_struct_replacement_52.subgroup_id * subgroup_size)))))))) | ((_GLF_struct_replacement_52.subgroup_id * subgroup_size)))) : _GLF_FUZZED(_GLF_struct_replacement_30.subgroup_local_id))), 0u))))), (_GLF_struct_replacement_52.subgroup_id * subgroup_size), (_GLF_IDENTITY(_GLF_struct_replacement_52.subgroup_id, (false ? _GLF_FUZZED(56060u) : _GLF_IDENTITY(_GLF_struct_replacement_52.subgroup_id, (_GLF_struct_replacement_52.subgroup_id) / uint(_GLF_ONE(1.0, injectionSwitch.y))))) * subgroup_size))))) + _GLF_struct_replacement_30.subgroup_local_id;
 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
  }
 else
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     GLF_merged2_0_1_11_1_1_12virtual_gidworkgroup_id.x = virtual_gid;
    }
   else
    {
    }
  }
 uint next_virtual_gid = workgroup_base + _GLF_struct_replacement_52.subgroup_id * subgroup_size + ((_GLF_struct_replacement_30.subgroup_local_id + 1) % subgroup_size);
 do
  {
   if(_GLF_DEAD(false))
    {
     switch(_GLF_SWITCH(0))
      {
       case 0:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        break;
       case 15:
       case 61:
       case 99:
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(_GLF_IDENTITY(true, true && (_GLF_IDENTITY(true, false || (true)))), (injectionSwitch.x < injectionSwitch.y))))
        {
         if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(_GLF_IDENTITY(false, false || (false)), (_GLF_IDENTITY(_GLF_IDENTITY(false, false || (false)), ! (! (_GLF_IDENTITY(false, false || (_GLF_IDENTITY(false, false || (false)))))))) && true)))
          {
           if(_GLF_DEAD(false))
            return;
          }
         else
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
            return;
           if(_GLF_DEAD(false))
            return;
           return;
          }
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(false))
          return;
        }
       else
        {
        }
       break;
       case 35:
       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
        }
       else
        {
         mat2(-4508.5106, -4089.3668, -79.43, -3.2);
        }
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
          return;
        }
       case 1:
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 ^ 0)); _injected_loop_counter --)
        {
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
           if(_GLF_DEAD(false))
            continue;
          }
         else
          {
           mat2(-83.09, -18.15, 0.6, -248.977);
          }
        }
       default:
       1;
      }
     if(_GLF_DEAD(false))
      return;
    }
  }
 while(_GLF_WRAPPED_LOOP(false));
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
    }
   else
    {
     for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 << _GLF_IDENTITY(_GLF_IDENTITY(int(1), int(1)), clamp(_GLF_IDENTITY(int(1), int(1)), _GLF_IDENTITY(int(1), int(1)), _GLF_IDENTITY(int(1), int(1)))))); _injected_loop_counter --)
      {
       do
        {
         _GLF_struct_replacement_39._f1._f2.GLF_merged2_0_1_16_1_1_13next_virtual_gidnum_workgroup.x = next_virtual_gid;
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(false))
        break;
      }
    }
  }
 else
  {
  }
 for(int _injected_loop_counter = _GLF_IDENTITY(0, _GLF_IDENTITY((0), min((0), (0))) << 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_ONE(1.0, injectionSwitch.y), (_GLF_ONE(1.0, injectionSwitch.y)) / determinant(mat3(1.0, determinant(mat3(1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0)), 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0))), mix(float(_GLF_IDENTITY(_GLF_ONE(1.0, injectionSwitch.y), (_GLF_ONE(1.0, injectionSwitch.y)) / determinant(mat3(1.0, determinant(mat3(1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0)), 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0)))), float(_GLF_FUZZED(1641.6374)), bool(false))))); _injected_loop_counter ++)
  {
   if(_GLF_DEAD(false))
    continue;
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      return;
     break;
    }
   if(_GLF_DEAD(false))
    return;
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     do
      {
       atomicStore(buf[_GLF_struct_replacement_39._f1._f2.GLF_merged2_0_1_16_1_1_13next_virtual_gidnum_workgroup.x], _GLF_IDENTITY(uint(1), ~ (~ (uint(1)))), 4, _GLF_IDENTITY(64, (false ? _GLF_FUZZED(98229) : _GLF_IDENTITY(64, (64) + 0))), 4);
       if(_GLF_DEAD(false))
        continue;
      }
     while(_GLF_WRAPPED_LOOP(false));
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
    }
  }
 uint read_1 = atomicLoad(buf[GLF_merged2_0_1_11_1_1_12virtual_gidworkgroup_id.x], 4, 64, 0);
 _GLF_struct_8 _GLF_struct_replacement_8 = _GLF_struct_8(1u, uvec4(1u), ivec2(1), _GLF_struct_4(_GLF_struct_0(_GLF_IDENTITY(bvec3(true), bvec3(bvec4(bvec3(true), false))), mat4(1.0), bvec2(true)), 1, _GLF_struct_1(1.0, mat2(1.0), mat4x3(1.0), mat3(1.0), mat3x4(1.0), ivec3(1), bvec4(true)), _GLF_struct_2(uvec2(1u), uvec2(1u), mat4x2(1.0), vec4(1.0)), mat4x3(1.0), _GLF_struct_3(_GLF_IDENTITY(1.0, max(1.0, 1.0)), bvec3(true), mat2x3(1.0), vec2(1.0), mat4x3(1.0), mat4x3(1.0), bvec2(true)), 1), _GLF_struct_7(ivec2(_GLF_IDENTITY(1, 0 + (1))), _GLF_struct_5(uvec4(1u), mat3x2(1.0), mat2x3(1.0), atomicLoad(buf[GLF_merged2_0_1_11_1_1_12virtual_gidworkgroup_id.x], 4, 64, _GLF_IDENTITY(0, ~ (_GLF_IDENTITY(~ (0), (~ (0)) | 0)))), 1, 1u, 1), _GLF_struct_6(_GLF_IDENTITY(uvec4(1u), ~ (~ (uvec4(1u)))), uvec4(1u), _GLF_IDENTITY(1u, uint(_GLF_IDENTITY(uint(1u), (uint(1u)) | (uint(1u))))), ivec4(1)), mat2x3(1.0)), true);
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 if(_GLF_struct_replacement_30.subgroup_local_id + 1 < subgroup_size)
  {
   switch(_GLF_SWITCH(_GLF_IDENTITY((0 << _GLF_IDENTITY(int(4), int(4))), (0 >> _GLF_IDENTITY(int(2), int(2))) + ((0 << _GLF_IDENTITY(int(4), int(4)))))))
    {
     case 13:
     uint _GLF_SWITCH_0_0v, _GLF_SWITCH_0_1v, _GLF_SWITCH_0_2v;
     case 0:
     case 10:
     case 90:
     case 85:
     int i = 0;
     case 70:
     case 1:
     do
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        break;
       atomicStore(buf[_GLF_struct_replacement_39._f1._f2.GLF_merged2_0_1_16_1_1_13next_virtual_gidnum_workgroup.x], uint(read_1 == _GLF_struct_replacement_8._f4._f1.read_2) + 1, 4, 64, 4);
      }
     while(_GLF_WRAPPED_LOOP(false));
     if(_GLF_DEAD(false))
      return;
     break;
     default:
     1;
    }
  }
 else
  {
   switch(_GLF_SWITCH(0))
    {
     case 61:
     if(_GLF_DEAD(false))
      return;
     uvec4 _GLF_SWITCH_1_0v, _GLF_SWITCH_1_1v;
     case 76:
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 & 1)); _injected_loop_counter ++)
      {
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
        {
         for(int _injected_loop_counter = _GLF_IDENTITY(((0 | 0) | 0), min(_GLF_IDENTITY(((0 | 0) | 0), int(_GLF_IDENTITY(ivec4(((0 | 0) | 0), 0, (0 | 0), 1), (ivec4(((0 | 0) | 0), 0, (0 | 0), 1)) * ivec4(1, 1, 1, 1)))), ((0 | 0) | 0))); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
          {
           true;
          }
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     case 0:
     case 65:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        return;
       if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, false || (false))))
        {
        }
       else
        {
         return;
        }
      }
     atomicStore(buf[_GLF_IDENTITY(_GLF_IDENTITY(_GLF_struct_replacement_39._f1._f2.GLF_merged2_0_1_16_1_1_13next_virtual_gidnum_workgroup.x, uint(uvec4(_GLF_struct_replacement_39._f1._f2.GLF_merged2_0_1_16_1_1_13next_virtual_gidnum_workgroup.x, 1u, 1u, ((1u << _GLF_IDENTITY(uint(2u), uint(2u))) >> _GLF_IDENTITY(uint(2u), uint(2u)))))), (_GLF_IDENTITY(0u, ~ (~ (0u))) << _GLF_IDENTITY(uint(0u), uint(0u))) | (_GLF_struct_replacement_39._f1._f2.GLF_merged2_0_1_16_1_1_13next_virtual_gidnum_workgroup.x))], uint(read_1 == _GLF_struct_replacement_8._f4._f1.read_2) + 1, 4, 64, 4);
     break;
     if(_GLF_DEAD(false))
      return;
     case 52:
     do
      {
       if(_GLF_DEAD(false))
        return;
      }
     while(_GLF_WRAPPED_LOOP(false));
     for(_GLF_struct_40 _GLF_struct_replacement_40 = _GLF_struct_40(1, uvec3(1u)); _GLF_WRAPPED_LOOP(_GLF_struct_replacement_40._injected_loop_counter > 0); _GLF_struct_replacement_40._injected_loop_counter --)
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          break;
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           return;
          }
         else
          {
          }
        }
       if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, bool(bvec2(false, false)))) && true)))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
          break;
         if(_GLF_DEAD(false))
          continue;
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
          {
           for(int _injected_loop_counter = (1 ^ 1); _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter, (_GLF_IDENTITY(_injected_loop_counter, ~ (~ (_injected_loop_counter)))) | 0) != 1); _injected_loop_counter ++)
            {
             return;
             if(_GLF_DEAD(false))
              continue;
            }
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false || (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
            continue;
          }
        }
       if(_GLF_DEAD(false))
        continue;
      }
     if(_GLF_DEAD(false))
      return;
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (_GLF_IDENTITY(injectionSwitch.x < _GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(vec2(vec3(injectionSwitch, 0.0)), (vec2(vec3(injectionSwitch, 0.0))) - vec2(0.0, 0.0))).y, ! (! (injectionSwitch.x < injectionSwitch.y)))))))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         do
          {
           injectionSwitch;
          }
         while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) || false)));
        }
       do
        {
         do
          {
           do
            {
             for(             bvec2(false, false);
 false; (_GLF_SWITCH_1_0v - _GLF_SWITCH_1_0v))
              {
               mat3 _GLF_SWITCH_1_2v, _GLF_SWITCH_1_3v, _GLF_SWITCH_1_4v;
               if(_GLF_DEAD(false))
                break;
               ((false , -28.76) - mat3x4(4.3, -9.2, 3417.8946, -1.7, -30.79, 8.4, _GLF_IDENTITY(-425.813, (false ? _GLF_FUZZED(length((vec4(8.5, -0.7, 3.6, -720.769) * mat4(4.7, 632.228, 8.9, -1.3, -1.7, -851.345, 1135.8312, -9.5, 0.9, 8.4, -0.2, 6493.4378, -0.5, 6.1, -8.1, 4763.8733)))) : _GLF_IDENTITY(-425.813, (-425.813) * 1.0))), 61.18, 1944.9473, -958.929, -91.20, -20.69));
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
               mat4x3 _GLF_SWITCH_1_5v[59], _GLF_SWITCH_1_6v[53];
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(vec2(vec4(injectionSwitch, 1.0, 0.0)), (vec2(vec4(injectionSwitch, 1.0, 0.0))) * mat2(1.0))).x < injectionSwitch.y))))
                    {
                     mat3(-9.9, -800.219, 32.75, -797.227, -698.914, -8.7, -84.61, 281.075, -53.61);
                    }
                   else
                    {
                    }
                  }
                 else
                  {
                  }
                }
               else
                {
                }
              }
             {
              ivec2(-55116, 20460);
              if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, (false) || false), (injectionSwitch.x > injectionSwitch.y))))
               break;
              _GLF_struct_replacement_39._f1._f2.GLF_merged2_0_1_16_1_1_13next_virtual_gidnum_workgroup;
              uvec3(28982u, 67442u, 173763u);
              vec4(-608.458, 1355.8511, 3.1, -47.14);
             }
             do
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 switch(_GLF_SWITCH(0))
                  {
                   case 5:
                   findLSB(ivec4(53101, -88257, -54771, 72178)).tts;
                   case 66:
                   do
                    {
                     uintBitsToFloat(uvec3(159765u, 133546u, 194071u));
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                   case 0:
                   case 99:
                   case 72:
                   case 15:
                   case 44:
                   case 92:
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    break;
                   case 7:
                   case 58:
                   case 33:
                   case 39:
                   exp(_GLF_IDENTITY(vec4(690.875, 9.0, 602.144, -3.2), clamp(vec4(690.875, 9.0, 602.144, -3.2), vec4(690.875, 9.0, 602.144, -3.2), vec4(690.875, 9.0, 602.144, -3.2))));
                   break;
                   case 85:
                   ivec2 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v[73];
                   case 24:
                   ivec2 _GLF_SWITCH_4_2v;
                   default:
                   1;
                  }
                }
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), bool(bvec3(_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), false || ((injectionSwitch.x > injectionSwitch.y))), true, true))))));
             {
              mat3x2(-3238.1856, -127.394, -5.9, _GLF_IDENTITY(_GLF_IDENTITY(2671.8036, max(2671.8036, 2671.8036)), min(_GLF_IDENTITY(_GLF_IDENTITY(2671.8036, max(_GLF_IDENTITY(2671.8036, min(2671.8036, 2671.8036)), 2671.8036)), (true ? 2671.8036 : _GLF_FUZZED(69.09))), 2671.8036)), 9.8, 4.8);
             }
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               do
                {
                 for(uvec2 _GLF_SWITCH_1_7v[5], _GLF_SWITCH_1_8v; true; vec2(297.203, -71.61))
                  {
                   switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                    {
                     case 38:
                     if(_GLF_WRAPPED_IF_FALSE(false))
                      {
                      }
                     else
                      {
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          return;
                         return;
                        }
                      }
                     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                      {
                       1569.5944;
                      }
                     else
                      {
                      }
                     case 0:
                     case 16:
                     case 19:
                     case 2:
                     mat2x3 _GLF_SWITCH_1_9v, _GLF_SWITCH_1_10v, _GLF_SWITCH_1_11v[50];
                     case 79:
                     vec3(-6.0, 25.48, -532.044);
                     case 13:
                     case 11:
                     if(_GLF_DEAD(false))
                      continue;
                     do
                      {
                       mat4(16.22, -3.3, 1422.3559, 302.034, _GLF_IDENTITY(-0.9, clamp(-0.9, -0.9, _GLF_IDENTITY(-0.9, mix(float(_GLF_FUZZED(332.152)), float(-0.9), bool(true))))), _GLF_IDENTITY(1.5, float(_GLF_IDENTITY(vec4(_GLF_IDENTITY(1.5, max(1.5, 1.5)), 1.0, 1.0, 1.0), (true ? vec4(_GLF_IDENTITY(1.5, max(1.5, 1.5)), 1.0, 1.0, 1.0) : _GLF_FUZZED(vec4(9.6, -821.838, -6549.1292, 1.0)))))), -2.3, _GLF_IDENTITY(596.251, max(_GLF_IDENTITY(596.251, (596.251) / 1.0), 596.251)), _GLF_IDENTITY(-12.72, max(-12.72, -12.72)), 6.7, -35.30, 46.56, -798.014, 841.484, 71.72, 7.0);
                      }
                     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                     if(_GLF_DEAD(false))
                      return;
                     if(_GLF_WRAPPED_IF_FALSE(false))
                      {
                      }
                     else
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        {
                         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < _GLF_IDENTITY(injectionSwitch, clamp(_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)), injectionSwitch, injectionSwitch)).y))))
                          {
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            continue;
                           if(_GLF_DEAD(false))
                            continue;
                           return;
                          }
                         else
                          {
                          }
                        }
                      }
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      break;
                     case 57:
                     if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))
                      continue;
                     do
                      {
                       if(_GLF_DEAD(false))
                        return;
                      }
                     while(_GLF_WRAPPED_LOOP(false));
                     case 39:
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      continue;
                     do
                      {
                       if(_GLF_DEAD(false))
                        return;
                      }
                     while(_GLF_WRAPPED_LOOP(false));
                     case 9:
                     if(_GLF_WRAPPED_IF_TRUE(true))
                      {
                       (subgroup_size / workgroup_size);
                      }
                     else
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        break;
                      }
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_DEAD(false))
                        break;
                       break;
                      }
                     if(_GLF_DEAD(false))
                      break;
                     break;
                     default:
                     1;
                    }
                  }
                }
               while(_GLF_IDENTITY(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, false || (_GLF_IDENTITY(false, bool(bvec4(false, true, false, false)))))), (_GLF_IDENTITY(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, false || (_GLF_IDENTITY(false, bool(bvec4(false, true, false, false)))))), bool(bvec4(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, false || (_GLF_IDENTITY(false, bool(bvec4(false, true, false, false)))))), false, false, false)))) && true));
              }
             else
              {
              }
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(false))
              break;
             mat2x3(_GLF_IDENTITY(3.4, clamp(3.4, 3.4, 3.4)), 6.6, -9.1, _GLF_IDENTITY(-5.1, (true ? -5.1 : _GLF_FUZZED(-0.1))), -2.5, 8157.0604);
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               while(_GLF_IDENTITY(any(bvec4(false, false, true, true)), ! (_GLF_IDENTITY(! (_GLF_IDENTITY(any(bvec4(false, false, true, true)), ! (! (any(bvec4(false, false, true, true)))))), _GLF_IDENTITY(bool(bool(! (_GLF_IDENTITY(any(bvec4(false, false, true, true)), ! (! (any(bvec4(false, false, true, true)))))))), _GLF_IDENTITY((bool(bool(! (_GLF_IDENTITY(any(bvec4(false, false, true, true)), ! (! (any(bvec4(false, false, true, true))))))))), ((bool(bool(! (_GLF_IDENTITY(any(bvec4(false, false, true, true)), ! (! (any(bvec4(false, false, true, true)))))))))) || false) || false)))))
                {
                 switch(_GLF_SWITCH(0))
                  {
                   case 14:
                   mat3(-1.3, 61.86, 2.5, -5302.5004, _GLF_IDENTITY(7384.7953, max(7384.7953, 7384.7953)), 82.13, -62.21, 32.26, 3.7);
                   if(_GLF_DEAD(false))
                    break;
                   case 0:
                   case 51:
                   ivec4 _GLF_SWITCH_1_12v, _GLF_SWITCH_1_13v, _GLF_SWITCH_1_14v;
                   ;
                   if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, bool(bvec4(true, false, false, false)))))
                    {
                     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_GLF_IDENTITY(_injected_loop_counter, (_injected_loop_counter) - 0) < _GLF_IDENTITY(((1 << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(_GLF_IDENTITY(int(0), ~ (_GLF_IDENTITY(~ (int(0)), max(~ (int(0)), ~ (int(0)))))), _GLF_IDENTITY(int(0), (false ? _GLF_FUZZED(91639) : int(0))))), (_GLF_IDENTITY(((1 << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(_GLF_IDENTITY(int(0), (false ? _GLF_FUZZED(91639) : int(0))), (_GLF_IDENTITY(_GLF_IDENTITY(int(0), (false ? _GLF_FUZZED(91639) : int(0))), ~ (~ (_GLF_IDENTITY(int(0), (false ? _GLF_FUZZED(91639) : int(0))))))) | (_GLF_IDENTITY(int(0), (false ? _GLF_FUZZED(91639) : int(0))))))), (((_GLF_IDENTITY(1, clamp(1, 1, 1)) << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), _GLF_IDENTITY((false ? _GLF_FUZZED(91639) : int(0)), ((false ? _GLF_FUZZED(91639) : int(0))) | ((false ? _GLF_FUZZED(91639) : int(0)))))))) | (((1 << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), _GLF_IDENTITY((false ? _GLF_IDENTITY(_GLF_FUZZED(91639), _GLF_IDENTITY((false ? _GLF_FUZZED((_GLF_IDENTITY(42718, 0 + (_GLF_IDENTITY(42718, int(ivec3(42718, 0, 1))))) & 56434)) : _GLF_FUZZED(91639)), (_GLF_IDENTITY((false ? _GLF_FUZZED((_GLF_IDENTITY(42718, 0 + (_GLF_IDENTITY(42718, int(ivec3(42718, 0, 1))))) & 56434)) : _GLF_FUZZED(91639)), ((false ? _GLF_FUZZED((_GLF_IDENTITY(42718, 0 + (_GLF_IDENTITY(42718, int(ivec3(42718, 0, 1))))) & 56434)) : _GLF_FUZZED(91639))) | 0)) | ((false ? _GLF_FUZZED((_GLF_IDENTITY(42718, 0 + (_GLF_IDENTITY(42718, int(ivec3(42718, 0, 1))))) & 56434)) : _GLF_FUZZED(91639))))) : int(0)), ((false ? _GLF_IDENTITY(_GLF_FUZZED(91639), _GLF_IDENTITY((false ? _GLF_FUZZED((_GLF_IDENTITY(42718, 0 + (_GLF_IDENTITY(42718, int(ivec3(42718, 0, 1))))) & 56434)) : _GLF_FUZZED(91639)), (_GLF_IDENTITY((false ? _GLF_FUZZED((_GLF_IDENTITY(42718, 0 + (_GLF_IDENTITY(42718, int(ivec3(42718, 0, 1))))) & 56434)) : _GLF_FUZZED(91639)), ((false ? _GLF_FUZZED((_GLF_IDENTITY(42718, 0 + (_GLF_IDENTITY(42718, int(ivec3(42718, 0, 1))))) & 56434)) : _GLF_FUZZED(91639))) | 0)) | ((false ? _GLF_FUZZED((_GLF_IDENTITY(42718, 0 + (_GLF_IDENTITY(42718, int(ivec3(42718, 0, 1))))) & 56434)) : _GLF_FUZZED(91639))))) : int(0))) / 1))))))) >> 0)); _injected_loop_counter ++)
                      {
                       -52.39;
                      }
                    }
                   else
                    {
                     if(_GLF_DEAD(false))
                      return;
                    }
                   false;
                   case 58:
                   case 49:
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      continue;
                    }
                   else
                    {
                     mat3(float(next_virtual_gid));
                    }
                   case 55:
                   if(_GLF_DEAD(false))
                    continue;
                   mat4x3 _GLF_SWITCH_1_15v, _GLF_SWITCH_1_16v[29];
                   break;
                   case 99:
                   (mat3x4(8.3, -93.29, 0.7, -7317.3819, -161.275, -14.68, -86.74, -99.09, 6.0, 9.4, 268.095, 771.103) , mat4x2(4.2, -2040.1338, 702.256, 365.489, -5050.9360, 6.9, -3577.8596, 400.155));
                   case 88:
                   ;
                   if(_GLF_DEAD(false))
                    break;
                   default:
                   1;
                   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, _GLF_IDENTITY(bool(_GLF_IDENTITY(bool(injectionSwitch.x > injectionSwitch.y), ! (! (bool(injectionSwitch.x > injectionSwitch.y))))), bool(bool(bool(_GLF_IDENTITY(bool(injectionSwitch.x > injectionSwitch.y), ! (! (bool(injectionSwitch.x > injectionSwitch.y))))))))))), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || false)))
                    {
                     if(_GLF_DEAD(false))
                      continue;
                     break;
                    }
                  }
                }
              }
             else
              {
              }
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(false))
              break;
             bvec4(bvec2(true, false), false, true);
             bvec3 _GLF_SWITCH_1_17v, _GLF_SWITCH_1_18v;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
            }
           while(false);
          }
         while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_IDENTITY(bool(bvec3(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || false), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))), false || (bool(bvec3(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || false), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))))));
        }
       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
        {
         do
          {
           for(int _injected_loop_counter = (0 | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < ((_GLF_IDENTITY(1, (1) ^ 0) << _GLF_IDENTITY(int(3), int(3))) >> _GLF_IDENTITY(int(3), _GLF_IDENTITY(int(3), (int(3)) << 0)))); _injected_loop_counter ++)
            {
             for(mat4 _GLF_SWITCH_1_19v, _GLF_SWITCH_1_20v, _GLF_SWITCH_1_21v; true; mat2x3(9.6, 9389.6924, -8.6, -54.26, 444.532, 8647.6855))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
               if((mat3x2(-62.92, -597.170, 5.8, -7289.5651, -4405.9387, -6.0) == mat3x2(3.5, -6.5, -579.567, -4.5, -9.5, 5.9)))
                {
                 if(_GLF_IDENTITY(_GLF_DEAD(false), true && (_GLF_DEAD(false))))
                  break;
                }
               do
                {
                 mat2x4(2.6, -558.178, 94.69, 507.305, -43.41, -15.74, 41.95, -4.5);
                 mat3 _GLF_SWITCH_1_22v, _GLF_SWITCH_1_23v, _GLF_SWITCH_1_24v;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                 ivec3 _GLF_SWITCH_1_25v;
                 if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), (_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))) && true))
                  break;
                 do
                  {
                   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                    }
                   else
                    {
                     if(_GLF_DEAD(false))
                      break;
                     if(_GLF_DEAD(false))
                      return;
                     switch(_GLF_SWITCH(0))
                      {
                       case 3:
                       vec4 _GLF_SWITCH_2_0v;
                       case 0:
                       case 53:
                       case 69:
                       case 98:
                       case 9:
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        return;
                       case 76:
                       case 78:
                       case 64:
                       do
                        {
                         (+ mat4x3(-5.2, 7.3, 2854.0716, -90.12, 476.068, 2.5, -9.4, -6.2, -131.333, _GLF_IDENTITY(877.616, _GLF_IDENTITY(float(_GLF_IDENTITY(mat2x4(_GLF_IDENTITY(877.616, (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) ? 877.616 : _GLF_FUZZED(-811.258))), 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0), (false ? _GLF_FUZZED(mat2x4(1269.4925, 3.4, -958.938, -3.1, -54.76, 4684.3489, 11.56, 2.4)) : mat2x4(_GLF_IDENTITY(877.616, (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) ? 877.616 : _GLF_FUZZED(-811.258))), 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0)))), min(float(_GLF_IDENTITY(mat2x4(_GLF_IDENTITY(877.616, (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) ? 877.616 : _GLF_FUZZED(-811.258))), 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0), (false ? _GLF_FUZZED(mat2x4(1269.4925, 3.4, -958.938, -3.1, -54.76, 4684.3489, 11.56, 2.4)) : mat2x4(_GLF_IDENTITY(877.616, (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) ? 877.616 : _GLF_FUZZED(-811.258))), 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0)))), float(_GLF_IDENTITY(mat2x4(_GLF_IDENTITY(877.616, (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) ? 877.616 : _GLF_FUZZED(-811.258))), 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0), (false ? _GLF_FUZZED(mat2x4(1269.4925, 3.4, -958.938, -3.1, -54.76, 4684.3489, 11.56, 2.4)) : mat2x4(_GLF_IDENTITY(877.616, (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)) ? 877.616 : _GLF_FUZZED(-811.258))), 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0))))))), -3217.5656, 87.88));
                        }
                       while(_GLF_WRAPPED_LOOP(false));
                       break;
                       case 81:
                       do
                        {
                         isnan(-7292.0477);
                        }
                       while(_GLF_WRAPPED_LOOP(false));
                       default:
                       1;
                      }
                    }
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                 if(_GLF_DEAD(false))
                  break;
                }
               while(true);
               if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                return;
              }
            }
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
       if(false)
        {
         for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != (_GLF_IDENTITY((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), _GLF_IDENTITY(int(1), min(int(1), _GLF_IDENTITY(int(1), (int(1)) - 0)))), 0 ^ ((1 << _GLF_IDENTITY(_GLF_IDENTITY(int(1), 0 ^ (int(1))), int(_GLF_IDENTITY(1, ~ (~ (1)))))) >> _GLF_IDENTITY(int(_GLF_IDENTITY(1, clamp(_GLF_IDENTITY(1, (1) >> 0), _GLF_IDENTITY(1, (1) - 0), _GLF_IDENTITY(1, 0 ^ (1))))), _GLF_IDENTITY(int(1), min(int(1), _GLF_IDENTITY(int(1), (int(1)) - 0)))))))); _GLF_IDENTITY(_injected_loop_counter ++, ~ (~ (_injected_loop_counter ++))))
          {
           for(int _injected_loop_counter = _GLF_IDENTITY(0, (0) | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY(1, int(int(1)))); _injected_loop_counter ++)
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               mat3x4(-55.38, -48.38, 85.36, -3.1, 85.40, 720.423, 7.7, -9.8, -5.3, -6811.2772, -96.91, -554.857);
              }
            }
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           if(_GLF_DEAD(false))
            continue;
          }
         do
          {
           do
            {
             if(false)
              {
               if(_GLF_DEAD(false))
                continue;
              }
            }
           while(_GLF_IDENTITY(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || ((_GLF_IDENTITY(injectionSwitch, _GLF_IDENTITY(vec2(mat2(injectionSwitch, 1.0, log(1.0))), (vec2(mat2(injectionSwitch, 1.0, log(1.0)))) * mat2(1.0))).x > injectionSwitch.y))))), (_GLF_WRAPPED_LOOP(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), _GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || false) || ((_GLF_IDENTITY(injectionSwitch, mat2(1.0) * (injectionSwitch)).x > _GLF_IDENTITY(injectionSwitch.y, float(mat2x4(injectionSwitch.y, 0.0, abs(0.0), 0.0, _GLF_IDENTITY(0.0, (0.0) / 1.0), 1.0, 0.0, 0.0))))))))) && true));
          }
         while(_GLF_WRAPPED_LOOP(false));
         for(int _injected_loop_counter = (((0 >> _GLF_IDENTITY(int(2), int(2))) & -41380) << _GLF_IDENTITY(int(7), _GLF_IDENTITY(int(7), (int(7)) * 1))); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
          {
           while(false)
            {
            }
          }
         mix(-127.725, _GLF_IDENTITY(intBitsToFloat(63253), _GLF_IDENTITY((_GLF_IDENTITY(intBitsToFloat(63253), min(intBitsToFloat(63253), intBitsToFloat(63253)))), max((_GLF_IDENTITY(intBitsToFloat(63253), min(intBitsToFloat(63253), intBitsToFloat(63253)))), _GLF_IDENTITY((_GLF_IDENTITY(_GLF_IDENTITY(intBitsToFloat(63253), min(intBitsToFloat(63253), intBitsToFloat(63253))), max(_GLF_IDENTITY(intBitsToFloat(63253), min(intBitsToFloat(63253), intBitsToFloat(63253))), _GLF_IDENTITY(intBitsToFloat(63253), min(intBitsToFloat(63253), intBitsToFloat(63253)))))), clamp((_GLF_IDENTITY(_GLF_IDENTITY(intBitsToFloat(63253), min(intBitsToFloat(63253), intBitsToFloat(63253))), max(_GLF_IDENTITY(intBitsToFloat(63253), min(intBitsToFloat(63253), intBitsToFloat(63253))), _GLF_IDENTITY(intBitsToFloat(63253), min(intBitsToFloat(63253), intBitsToFloat(63253)))))), (_GLF_IDENTITY(_GLF_IDENTITY(intBitsToFloat(63253), min(intBitsToFloat(63253), intBitsToFloat(63253))), max(_GLF_IDENTITY(intBitsToFloat(63253), min(intBitsToFloat(63253), intBitsToFloat(63253))), _GLF_IDENTITY(intBitsToFloat(63253), min(intBitsToFloat(63253), intBitsToFloat(63253)))))), (_GLF_IDENTITY(_GLF_IDENTITY(intBitsToFloat(63253), min(intBitsToFloat(63253), intBitsToFloat(63253))), max(_GLF_IDENTITY(intBitsToFloat(63253), min(intBitsToFloat(63253), intBitsToFloat(63253))), _GLF_IDENTITY(intBitsToFloat(63253), min(intBitsToFloat(63253), intBitsToFloat(63253)))))))))) * 1.0), -4.0);
         bvec3(false, true, true);
        }
       else
        {
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
          }
         else
          {
           if(_GLF_DEAD(false))
            return;
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
              {
               ;
              }
            }
           else
            {
            }
          }
         do
          {
           mat4x2(2.7, -4.3, 1.2, -2100.0973, 0.7, 3252.3544, 5.5, -9483.8755);
          }
         while(_GLF_WRAPPED_LOOP(false));
         bvec3(_GLF_IDENTITY(false, bool(bvec2(false, true))), true, true);
         if(_GLF_IDENTITY(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))), ! (! (_GLF_IDENTITY(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))), (_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (_GLF_IDENTITY(injectionSwitch.x, clamp(injectionSwitch.x, injectionSwitch.x, injectionSwitch.x)) < injectionSwitch.y)))) && true)))))
          {
           switch(_GLF_SWITCH(0))
            {
             case 0:
             case 90:
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             if(_GLF_DEAD(false))
              {
               do
                {
                 return;
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             case 77:
             if(_GLF_DEAD(false))
              return;
             case 8:
             if(_GLF_DEAD(false))
              return;
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
               if(_GLF_DEAD(false))
                return;
              }
             else
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  return;
                 return;
                }
              }
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec3(false, true, true)), bool(bool(bool(bvec3(false, true, true))))))))
                {
                }
               else
                {
                 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, _GLF_IDENTITY((injectionSwitch.x < injectionSwitch.y), ! (! ((injectionSwitch.x < injectionSwitch.y)))))))
                  {
                   return;
                  }
                 else
                  {
                  }
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
              }
             break;
             if(_GLF_DEAD(false))
              return;
             case 50:
             ivec2 _GLF_SWITCH_2_0v;
             default:
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               1;
              }
             else
              {
              }
            }
          }
         else
          {
          }
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _GLF_IDENTITY(_injected_loop_counter --, 0 ^ (_injected_loop_counter --)))
            {
             length(clamp(vec3(6434.2691, 5.7, 6.2), _GLF_IDENTITY(vec3(-3.5, 8.1, 912.261), _GLF_IDENTITY((vec3(-3.5, 8.1, 912.261)), vec3(_GLF_IDENTITY(mat4x2((vec3(-3.5, 8.1, 912.261)), 1.0, 1.0, 0.0, 0.0, 0.0), mat2(1.0) * (mat4x2((vec3(-3.5, 8.1, 912.261)), 1.0, 1.0, 0.0, 0.0, 0.0))))) * mat3(1.0)), vec3(1.9, -78.64, 340.578)));
            }
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            return;
           do
            {
             return;
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
         mat2x4(-0.3);
        }
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(false))
          return;
        }
       else
        {
        }
       {
        if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
         return;
        vec2 _GLF_SWITCH_1_26v;
        _GLF_struct_23 _GLF_struct_replacement_23;
        if(_GLF_WRAPPED_IF_TRUE(true))
         {
          (bvec2(true, _GLF_IDENTITY(false, true && (false))) != bvec2(true, false));
         }
        else
         {
         }
        ;
        if(_GLF_DEAD(false))
         return;
        if(_GLF_DEAD(false))
         {
          for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), int(_GLF_IDENTITY(ivec4(int(2), 0, _GLF_IDENTITY(1, clamp(_GLF_IDENTITY(1, (_GLF_IDENTITY(1, (1) >> 0)) | 0), _GLF_IDENTITY(1, int(ivec3(1, 1, 1))), 1)), 0), max(ivec4(int(2), 0, _GLF_IDENTITY(1, clamp(_GLF_IDENTITY(1, (_GLF_IDENTITY(1, (1) >> 0)) | 0), _GLF_IDENTITY(1, int(ivec3(1, 1, 1))), 1)), 0), ivec4(int(2), 0, _GLF_IDENTITY(1, clamp(_GLF_IDENTITY(1, (_GLF_IDENTITY(1, (1) >> 0)) | 0), _GLF_IDENTITY(1, int(ivec3(1, 1, 1))), 1)), 0))))))) >> _GLF_IDENTITY(int(2), _GLF_IDENTITY(_GLF_IDENTITY(int(2), max(int(2), int(2))), max(_GLF_IDENTITY(int(2), max(int(2), int(2))), _GLF_IDENTITY(_GLF_IDENTITY(int(2), max(int(2), int(2))), (_GLF_IDENTITY(_GLF_IDENTITY(int(2), max(int(2), int(2))), min(_GLF_IDENTITY(int(2), max(int(2), int(2))), _GLF_IDENTITY(int(2), max(int(2), int(2)))))) ^ 0)))))); _injected_loop_counter ++)
           {
            if(_GLF_DEAD(false))
             return;
            return;
           }
         }
        do
         {
          if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           {
            if(_GLF_DEAD(false))
             {
              if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, (true) && true)))
               {
                for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                 {
                  return;
                 }
               }
              else
               {
               }
             }
           }
          else
           {
            do
             {
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 continue;
                return;
               }
             }
            while(_GLF_WRAPPED_LOOP(false));
            for(uvec4 _GLF_SWITCH_1_28v; (atomicCompSwap(next_virtual_gid, workgroup_size, workgroup_base) < 176986u); (_GLF_IDENTITY(324.598, mix(float(_GLF_IDENTITY(_GLF_IDENTITY(324.598, clamp(324.598, 324.598, 324.598)), max(324.598, 324.598))), float(_GLF_FUZZED(226.266)), bool(false))) - vec3(-8390.7285, -8.1, 2811.7943)))
             {
              clamp(bitCount(ivec2(-21925, -73195)), 71874, -67420);
              if(_GLF_IDENTITY(_GLF_DEAD(false), bool(bvec4(_GLF_DEAD(false), false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), true))))
               break;
              vec3 _GLF_SWITCH_1_29v, _GLF_SWITCH_1_30v;
              if(_GLF_WRAPPED_IF_TRUE(true))
               {
                mat4(183.848, 4079.2872, 8438.3950, -13.12, _GLF_IDENTITY(6375.5930, (6375.5930) / 1.0), 6.3, -7239.6392, 64.15, -287.910, 131.914, 0.8, 9.6, 4.1, -3.6, -59.47, 52.72);
               }
              else
               {
               }
              if(_GLF_DEAD(false))
               continue;
              do
               {
                do
                 {
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   return;
                  for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                   {
                    for(int _injected_loop_counter = (0 & -34388); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                     {
                      if(_GLF_WRAPPED_IF_FALSE(false))
                       {
                       }
                      else
                       {
                        if(_GLF_WRAPPED_IF_TRUE(true))
                         {
                          if(_GLF_WRAPPED_IF_TRUE(true))
                           {
                            do
                             {
                              do
                               {
                                lessThan((ivec4(_GLF_IDENTITY(630, min(630, _GLF_IDENTITY(630, (true ? 630 : _GLF_FUZZED(_GLF_IDENTITY(53403, (53403) / 1)))))), 82782, -88655, 85034) * ivec4(59200, -31096, 93617, -91402)), (ivec4(_GLF_IDENTITY(-61773, max(-61773, -61773)), 41832, -43048, 82602) / ivec4(ivec2(-64886, -96950), -79653, 81157)));
                               }
                              while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                             }
                            while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(_GLF_IDENTITY(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, true), _GLF_IDENTITY(bvec3(bvec3(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, true))), bvec3(bvec4(bvec3(bvec3(bvec3(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y)))), true, _GLF_IDENTITY(true, bool(_GLF_IDENTITY(bool(true), ! (! (bool(true))))))))), false))))))));
                           }
                          else
                           {
                           }
                         }
                        else
                         {
                         }
                       }
                     }
                   }
                  if(_GLF_DEAD(false))
                   break;
                 }
                while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), false || (! (false)))))));
               }
              while(_GLF_WRAPPED_LOOP(false));
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
                if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, ! (! (false)))))
                 {
                 }
                else
                 {
                  if(_GLF_WRAPPED_IF_TRUE(true))
                   {
                    return;
                   }
                  else
                   {
                   }
                 }
               }
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               continue;
              uvec4 _GLF_SWITCH_1_31v;
              do
               {
                ;
               }
              while(_GLF_WRAPPED_LOOP(false));
              do
               {
                -0.9;
                if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, (false) && true), ! (! (_GLF_IDENTITY(false, bool(bvec3(false, false, false))))))))
                 continue;
               }
              while(_GLF_WRAPPED_LOOP(false));
              if(_GLF_WRAPPED_IF_FALSE(false))
               {
               }
              else
               {
                mat4(-5.9, _GLF_IDENTITY(-5.2, _GLF_IDENTITY(mix(float(-5.2), float(_GLF_FUZZED(-2.6)), bool(false)), mix(float(mix(float(-5.2), float(_GLF_FUZZED(-2.6)), bool(false))), float(_GLF_FUZZED(-394.904)), bool(false)))), 5.8, 19.13, -4.0, 500.558, 7.7, -64.96, 8501.2719, -30.54, _GLF_IDENTITY(358.711, min(358.711, 358.711)), -7946.3482, 80.82, 3.9, -9.3, _GLF_IDENTITY(-4726.2097, min(_GLF_IDENTITY(-4726.2097, (-4726.2097) + 0.0), _GLF_IDENTITY(-4726.2097, (_GLF_IDENTITY(-4726.2097, max(-4726.2097, -4726.2097))) * 1.0))));
               }
             }
            if(_GLF_DEAD(false))
             return;
           }
         }
        while(_GLF_WRAPPED_LOOP(false));
       }
       {
        if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], injectionSwitch[1])).x > injectionSwitch.y))))
         {
         }
        else
         {
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           return;
          for(int _injected_loop_counter = ((0 & -68850) >> _GLF_IDENTITY(int(3), int(3))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
           {
            if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(_GLF_IDENTITY(false, ! (! (false))), false, true, true)))))
             return;
           }
         }
        if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         {
         }
        else
         {
          do
           {
            mat2(-9.1, _GLF_IDENTITY(-6.1, float(_GLF_IDENTITY(mat4x2(-6.1, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0), mat4x2(mat4(mat4x2(_GLF_IDENTITY(-6.1, min(-6.1, -6.1)), 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0)))))), -3279.0093, 1.9);
           }
          while(_GLF_WRAPPED_LOOP(false));
          if(_GLF_WRAPPED_IF_FALSE(false))
           {
           }
          else
           {
            do
             {
              if(_GLF_DEAD(false))
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 break;
                return;
               }
             }
            while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, false || (false))));
           }
         }
        while(false)
         {
          if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ((_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, bool(_GLF_IDENTITY(bvec3(injectionSwitch.x > injectionSwitch.y, _GLF_IDENTITY(false, true && (false)), false), bvec3(bvec4(bvec3(injectionSwitch.x > injectionSwitch.y, _GLF_IDENTITY(false, true && (false)), false), false))))))) && _GLF_TRUE(true, (_GLF_IDENTITY(injectionSwitch.x < injectionSwitch.y, bool(bvec4(_GLF_IDENTITY(injectionSwitch.x < injectionSwitch.y, ! (! (injectionSwitch.x < injectionSwitch.y))), true, true, false)))))))))
           continue;
          ivec4(43052, 46009, -60171, -21744);
          if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
           continue;
          if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             break;
            return;
           }
          mat3 _GLF_SWITCH_1_32v[2];
          if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, mix(float(_GLF_FUZZED(-6.2)), _GLF_IDENTITY(float(_GLF_IDENTITY(injectionSwitch.x, clamp(_GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, injectionSwitch.x)), _GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) / 1.0), injectionSwitch.x))), min(float(_GLF_IDENTITY(injectionSwitch.x, clamp(_GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, injectionSwitch.x)), _GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) / 1.0), injectionSwitch.x))), _GLF_IDENTITY(float(_GLF_IDENTITY(injectionSwitch.x, clamp(_GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, injectionSwitch.x)), _GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) / 1.0), injectionSwitch.x))), min(float(_GLF_IDENTITY(injectionSwitch.x, clamp(_GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, injectionSwitch.x)), _GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) / 1.0), injectionSwitch.x))), float(_GLF_IDENTITY(injectionSwitch.x, clamp(_GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, injectionSwitch.x)), _GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) / 1.0), injectionSwitch.x))))))), bool(true))) > injectionSwitch.y))))
           {
           }
          else
           {
            _GLF_IDENTITY(_GLF_struct_replacement_39._f1._f2.GLF_merged2_0_1_16_1_1_13next_virtual_gidnum_workgroup, ~ (~ (_GLF_struct_replacement_39._f1._f2.GLF_merged2_0_1_16_1_1_13next_virtual_gidnum_workgroup)));
           }
          do
           {
            _GLF_IDENTITY(bvec3(true, false, false), bvec3(_GLF_IDENTITY(bvec3(bvec3(true, false, false)), bvec3(bvec4(bvec3(bvec3(true, false, false)), false)))));
           }
          while(_GLF_WRAPPED_LOOP(false));
          ivec4 _GLF_SWITCH_1_33v;
          if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           {
           }
          else
           {
            injectionSwitch;
           }
         }
        do
         {
          do
           {
            for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
             {
              if(_GLF_WRAPPED_IF_TRUE(true))
               {
                while(_GLF_IDENTITY(true, bool(bool(true))))
                 {
                  switch(_GLF_SWITCH(0))
                   {
                    case 10:
                    mat3x4 _GLF_SWITCH_2_0v[23], _GLF_SWITCH_2_1v[14];
                    case 3:
                    for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                     {
                      greaterThanEqual((workgroup_id + uvec2(_GLF_IDENTITY(752u, 0u | (752u)), 182493u)), _GLF_IDENTITY(GLF_merged2_0_1_11_1_1_12virtual_gidworkgroup_id, uvec2(0u, _GLF_IDENTITY(0u, clamp(0u, 0u, _GLF_IDENTITY(0u, clamp(0u, 0u, 0u))))) | (GLF_merged2_0_1_11_1_1_12virtual_gidworkgroup_id)));
                     }
                    case 0:
                    for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > (1 ^ 1)); _injected_loop_counter --)
                     {
                      _GLF_IDENTITY(false, bool(bvec3(_GLF_IDENTITY(false, false || (false)), _GLF_IDENTITY(false, ! (! (false))), true)));
                     }
                    if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, (_GLF_IDENTITY(true, false || (true))) || false)))
                     {
                      for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                       {
                        (_GLF_SWITCH_1_1v);
                        if(_GLF_DEAD(false))
                         {
                          if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                           break;
                          return;
                         }
                       }
                     }
                    else
                     {
                      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                       continue;
                     }
                    case 23:
                    if(_GLF_DEAD(false))
                     break;
                    bool _GLF_SWITCH_1_34v, _GLF_SWITCH_1_35v, _GLF_SWITCH_1_36v;
                    vec4(822.542, 860.625, -310.435, 0.0);
                    uvec4 _GLF_SWITCH_1_37v[78];
                    break;
                    if(_GLF_DEAD(false))
                     break;
                    default:
                    if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                     {
                      if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(false, true, false, true)))))
                       return;
                      if(_GLF_DEAD(false))
                       return;
                      if(_GLF_DEAD(false))
                       return;
                     }
                    else
                     {
                     }
                    1;
                    if(_GLF_DEAD(false))
                     break;
                   }
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   return;
                 }
               }
              else
               {
               }
             }
           }
          while(_GLF_WRAPPED_LOOP(false));
         }
        while(_GLF_WRAPPED_LOOP(false));
        if(_GLF_WRAPPED_IF_TRUE(true))
         {
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           return;
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           return;
         }
        else
         {
          do
           {
            if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
             }
            else
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
                for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), int(4))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                 {
                  return;
                 }
               }
             }
           }
          while(_GLF_WRAPPED_LOOP(false));
         }
        uvec3 _GLF_SWITCH_1_38v, _GLF_SWITCH_1_39v[33];
        if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         {
          if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), true && (! (false)))))))
           {
            do
             {
              return;
             }
            while(_GLF_WRAPPED_LOOP(false));
           }
         }
        else
         {
          if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bool(false)), bool(bvec2(bool(bool(false)), false))))))
           return;
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           return;
         }
        do
         {
          if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, true && (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, ! (! (injectionSwitch.x > injectionSwitch.y)))))))))
           {
            if(_GLF_DEAD(false))
             break;
           }
          else
           {
            mat3x2(3216.6921);
           }
          if(_GLF_DEAD(false))
           return;
          vec4 _GLF_SWITCH_1_40v, _GLF_SWITCH_1_41v, _GLF_SWITCH_1_42v[93];
          if(_GLF_DEAD(false))
           continue;
          bvec4 _GLF_SWITCH_1_43v;
          ;
          if(_GLF_DEAD(false))
           break;
          mat4x3(48.45, 3.7, 3251.6879, 6.2, 6.9, 3.0, 9.8, _GLF_IDENTITY(_GLF_IDENTITY(3965.8037, clamp(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_IDENTITY(3965.8037, clamp(3965.8037, 3965.8037, 3965.8037)), min(_GLF_IDENTITY(3965.8037, clamp(3965.8037, 3965.8037, 3965.8037)), _GLF_IDENTITY(3965.8037, clamp(3965.8037, 3965.8037, 3965.8037)))), min(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_IDENTITY(3965.8037, clamp(3965.8037, 3965.8037, 3965.8037)), min(_GLF_IDENTITY(3965.8037, clamp(3965.8037, 3965.8037, 3965.8037)), _GLF_IDENTITY(3965.8037, clamp(3965.8037, 3965.8037, 3965.8037)))), (_GLF_IDENTITY(_GLF_IDENTITY(3965.8037, clamp(3965.8037, 3965.8037, 3965.8037)), min(_GLF_IDENTITY(3965.8037, clamp(3965.8037, 3965.8037, 3965.8037)), _GLF_IDENTITY(3965.8037, clamp(3965.8037, 3965.8037, 3965.8037))))) + 0.0), _GLF_IDENTITY(_GLF_IDENTITY(3965.8037, clamp(3965.8037, 3965.8037, 3965.8037)), min(_GLF_IDENTITY(3965.8037, clamp(3965.8037, 3965.8037, 3965.8037)), _GLF_IDENTITY(3965.8037, clamp(3965.8037, 3965.8037, 3965.8037)))))), _GLF_IDENTITY(3965.8037, clamp(3965.8037, _GLF_IDENTITY(3965.8037, mix(float(3965.8037), float(_GLF_FUZZED(9.0)), bool(false))), 3965.8037)), 3965.8037)), (_GLF_IDENTITY(3965.8037, clamp(_GLF_IDENTITY(3965.8037, clamp(3965.8037, 3965.8037, 3965.8037)), _GLF_IDENTITY(3965.8037, clamp(3965.8037, _GLF_IDENTITY(3965.8037, mix(float(3965.8037), float(_GLF_FUZZED(9.0)), bool(false))), 3965.8037)), 3965.8037))) + abs(0.0)), 97.24, -3606.5575, _GLF_IDENTITY(-5.5, min(-5.5, _GLF_IDENTITY(-5.5, min(-5.5, -5.5)))), 21.96);
         }
        while((vec4(-397.069, -7.5, 4642.4416, 2.3) != vec4(_GLF_IDENTITY(72.38, _GLF_IDENTITY((72.38) / sqrt(1.0), (true ? (72.38) / sqrt(1.0) : _GLF_FUZZED(uintBitsToFloat(read_1))))), 17.44, -7636.6806, -9.7)));
        if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         {
          if(_GLF_DEAD(false))
           return;
         }
        else
         {
          for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
           {
            if(_GLF_WRAPPED_IF_FALSE(false))
             {
             }
            else
             {
              if(false)
               {
                bvec3(false, true, false);
                if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                 return;
                if(_GLF_DEAD(false))
                 return;
                if(_GLF_DEAD(false))
                 continue;
                for(int _injected_loop_counter = (1 ^ 1); _GLF_WRAPPED_LOOP(_injected_loop_counter < (int(_GLF_ZERO(0.0, injectionSwitch.x)) | (0 ^ 1))); _injected_loop_counter ++)
                 {
                  ivec4(82636, -66332, 43064, 40041);
                 }
                if(_GLF_WRAPPED_IF_TRUE(true))
                 {
                  injectionSwitch;
                  if(_GLF_WRAPPED_IF_TRUE(true))
                   {
                    for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                     {
                      if(_GLF_DEAD(false))
                       return;
                     }
                    if(_GLF_DEAD(false))
                     break;
                   }
                  else
                   {
                    if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     break;
                   }
                 }
                else
                 {
                 }
                if(_GLF_WRAPPED_IF_FALSE(false))
                 {
                  if(_GLF_DEAD(false))
                   return;
                 }
                else
                 {
                  if(_GLF_DEAD(false))
                   return;
                  if(_GLF_DEAD(false))
                   {
                    if(_GLF_WRAPPED_IF_FALSE(false))
                     {
                     }
                    else
                     {
                      return;
                     }
                   }
                  if(_GLF_DEAD(false))
                   continue;
                 }
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 break;
                if(_GLF_DEAD(false))
                 {
                  if(_GLF_WRAPPED_IF_TRUE(true))
                   {
                    return;
                   }
                  else
                   {
                   }
                 }
                if(_GLF_DEAD(false))
                 {
                  if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   {
                   }
                  else
                   {
                    return;
                   }
                 }
                vec2 _GLF_SWITCH_1_44v, _GLF_SWITCH_1_45v, _GLF_SWITCH_1_46v;
                if(_GLF_DEAD(false))
                 {
                  for(int _injected_loop_counter = (1 ^ 0); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                   {
                    return;
                   }
                 }
                if(_GLF_DEAD(false))
                 return;
                mat3x2 _GLF_SWITCH_1_47v, _GLF_SWITCH_1_48v[90];
                ;
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 return;
                if(_GLF_WRAPPED_IF_FALSE(false))
                 {
                 }
                else
                 {
                  exp2(3.3);
                 }
               }
              if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
               break;
              if(_GLF_WRAPPED_IF_FALSE(false))
               {
               }
              else
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 {
                  if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                   {
                    return;
                   }
                  else
                   {
                   }
                 }
               }
             }
           }
         }
       }
       mat4x3(813.689, -6282.0488, -48.88, 486.200, _GLF_IDENTITY(-4.7, (false ? _GLF_FUZZED(-93.37) : -4.7)), 7.0, 5013.3886, -8091.7591, -6.8, 8946.1028, 448.199, -4.5);
       do
        {
         ;
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), false || (_GLF_IDENTITY(! (false), (! (false)) || false)))))))
        return;
      }
     else
      {
      }
     case 81:
     mat2x3 _GLF_SWITCH_1_49v, _GLF_SWITCH_1_50v[9];
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         return;
        }
       else
        {
        }
      }
     default:
     1;
    }
  }
 if(_GLF_DEAD(false))
  return;
}
