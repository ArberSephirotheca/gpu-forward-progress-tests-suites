#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer Checker {
 uint checker[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = gl_NumWorkGroups.x;
 uint workgroup_size = gl_WorkGroupSize.x;
 uint workgroup_id = gl_WorkGroupID.x;
 uint workgroup_base = workgroup_size * workgroup_id;
 uint virtual_gid = workgroup_base + subgroup_id * subgroup_size + subgroup_local_id;
 uint next_virtual_gid = workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size);
 uint read = atomicLoad(buf[virtual_gid], 4, 64, 0);
 atomicStore(buf[next_virtual_gid], uint(1), 4, 64, 4);
 if(subgroup_local_id + 1 < subgroup_size)
  {
   switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
    {
     case 18:
     for(     notEqual(uvec2(164986u, 46285u), uvec2(164530u, 36777u));
 false; mat3(mat2(5.8, 21.82, 1.9, 5.9)))
      {
       (ivec3(-9381, -39279, -93717) / ivec3(37603, -71518, 23574));
       {
        if((mix(uvec3(2383u, 178358u, 17104u), uvec3(42823u, 106534u, 134371u), bvec3(true, false, false)) != uvec3(109461u, 142857u, 172807u)))
         {
          ivec2(96607, -67953);
          ;
          outerProduct(normalize(vec4(-3076.4942, -341.905, 9166.3068, 29.75)), (-712.211 + injectionSwitch));
         }
        vec4 _GLF_SWITCH_0_0v;
        89054;
        bvec3 _GLF_SWITCH_0_1v;
       }
      }
     case 48:
     while((false || true))
      {
       ivec4 _GLF_SWITCH_0_2v[66], _GLF_SWITCH_0_3v[80];
       {
        ivec3(-55416, 69991, 5902);
        mat2 _GLF_SWITCH_0_4v[30], _GLF_SWITCH_0_5v, _GLF_SWITCH_0_6v;
        if(true)
         {
          uvec3(33165u, 17700u, 113927u);
         }
       }
       if(((ivec3(2167, 11394, -82775) + ivec3(-59562, -17853, -64797)) == ivec3(-92352, 89697, 89557)))
        {
         switch(_GLF_SWITCH(0))
          {
           case 85:
           ;
           case 96:
           ((true ? (mat3x2(45.62, 89.20, 48.60, 5433.9223, 453.042, 3.9) * mat2x3(-836.283, -7.9, -5190.4162, 5.1, -89.38, -901.298)) : mat2(-8.0, -0.1, 6.1, 20.13)) , bvec2(true, false));
           case 0:
           case 26:
           case 44:
           ;
           bvec2 _GLF_SWITCH_0_7v, _GLF_SWITCH_0_8v, _GLF_SWITCH_0_9v[10];
           mat2(-5.8);
           case 48:
           case 90:
           uvec3 _GLF_SWITCH_0_10v, _GLF_SWITCH_0_11v, _GLF_SWITCH_0_12v;
           case 69:
           case 62:
           case 49:
           case 42:
           case 1:
           vec2(-0.6, -16.57);
           break;
           case 31:
           (mat3x2(1.7, -15.06, 96.21, -8188.2008, 883.208, -8.8) / 5.5);
           default:
           1;
          }
        }
       abs(vec4(-962.859, 7.7, -1711.9742, 20.50));
       vec4(-797.946, 7.8, 2.1, 52.89);
      }
     case 0:
     atomicStore(checker[virtual_gid], read, 4, 64, 4);
     case 43:
     case 57:
     subgroupAll(false);
     break;
     case 58:
     mat3x4 _GLF_SWITCH_0_13v[4], _GLF_SWITCH_0_14v[43], _GLF_SWITCH_0_15v;
     case 64:
     while(true)
      {
       ivec3(-73637, 13444, 9607);
       float _GLF_SWITCH_0_16v, _GLF_SWITCH_0_17v[81];
      }
     default:
     1;
    }
  }
 else
  {
   switch(_GLF_SWITCH(0))
    {
     case 28:
     bvec4(false, false, true, true);
     case 0:
     case 71:
     case 37:
     case 9:
     case 61:
     case 63:
     case 68:
     atomicStore(buf[virtual_gid], read, 4, 64, 4);
     case 95:
     case 46:
     subgroupAll(true);
     break;
     default:
     1;
    }
  }
}
