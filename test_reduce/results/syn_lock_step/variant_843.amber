#!amber

SET ENGINE_DATA fence_timeout_ms 10000

SHADER compute test GLSL
#version 460

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if((false))
  return;
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 if((false))
  {
   if((false))
    return;
   return;
  }
 if((! (! ((false)))))
  return;
 if((false))
  return;
 uint num_workgroup = gl_NumWorkGroups.x;
 if((((injectionSwitch.x > injectionSwitch.y))))
  {
   if((false))
    return;
   return;
  }
 if((false))
  {
   if(((((! (false || (((! (! (! (((false) && true))))))))))) && true))
    {
     if((bool(bvec2((((injectionSwitch.x > injectionSwitch.y))), false))))
      return;
     return;
    }
   return;
  }
 uint workgroup_size = (max(gl_WorkGroupSize.x, gl_WorkGroupSize.x));
 if((false))
  {
   if((false))
    return;
   return;
  }
 uint workgroup_id = gl_WorkGroupID.x;
 if(((((! (((! (((injectionSwitch.x > injectionSwitch.y) || false))) && true)))))))
  return;
 if((false))
  return;
 if((false))
  {
   if((false))
    return;
   return;
  }
 if((false))
  {
   if(((! ((bool(bvec3(! (false), true, true)))))))
    return;
   return;
  }
 if((false))
  {
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   return;
   if((false))
    return;
  }
 if((((((true ? injectionSwitch.x : (normalize(796.099)))) > injectionSwitch.y))))
  return;
 if((false))
  {
   if((false))
    return;
   return;
  }
 if(((bool(bvec3((false || ((((clamp(injectionSwitch, injectionSwitch, (clamp((clamp(injectionSwitch, injectionSwitch, injectionSwitch)), injectionSwitch, injectionSwitch)))).x > injectionSwitch.y)))), true, ((injectionSwitch.x < injectionSwitch.y)))))))
  return;
 uint workgroup_base = ((((clamp((((true ? uint(uvec4(uint((injectionSwitch.x)), 1u, 0u, 0u)) : (num_workgroup)))), uint((injectionSwitch.x)), uint((injectionSwitch.x))))) | ((((min(uint(uvec2((((uint((injectionSwitch.x))) << 0u)), 0u)), ((((((uint(uvec2((((uint(((1.0 * (injectionSwitch.x))))) << 0u)), 0u))) - 0u)) + 0u)) | (((((uint((max(uvec2((((uint(uvec2((uint((injectionSwitch.x))) << 0u, 1u))))), 0u), uvec2((((uint(uvec2((uint((injectionSwitch.x))) << 0u, 1u))))), 0u))))) - 0u)) + 0u))))))) | 0u)) ^ (((workgroup_size) >> 0u) * workgroup_id));
 uint virtual_gid = (((0u << (uint(((((injectionSwitch.x > injectionSwitch.y)) ? (subgroup_size) : 0u))))) | ((~ (~ (~ (~ (workgroup_base + ((subgroup_id) | (0u ^ 0u)) * subgroup_size + (0u ^ (subgroup_local_id))))))))));
 uint next_virtual_gid = (1u * (((true ? workgroup_base + ((uint(uvec4((uint(uint(0u))), (((~ (~ (0u))) ^ 0u)), 0u, 0u))) ^ (subgroup_id)) * subgroup_size + (~ (((~ ((((((~ (uint(uvec3(((((0u + (~ (((subgroup_local_id)) / 1u))))) | (((((0u + (~ (subgroup_local_id))))) ^ 0u))), 1u, (1u ^ 1u)))))) + (uint((((injectionSwitch.x) - 0.0))) | 0u)) + 1) % (min(subgroup_size, (((max(((((max(((bool((bvec2(bvec3(bvec2((true && (false)), false), true))))) ? (clamp((workgroup_base), (workgroup_base), (workgroup_base))) : subgroup_size), ((bool((bvec2(bvec3(bvec2((((true) && true) && (false)), false), true))))) ? (clamp((workgroup_base), (workgroup_base), (workgroup_base))) : subgroup_size)))) | 0u) >> (0u ^ (0u))), ((((max(((((bool((bvec2(bvec3(bvec2((true && (false)), false), true)))))) && true) ? (clamp((workgroup_base), (workgroup_base), (workgroup_base))) : subgroup_size), ((bool((bvec2(bvec3(bvec2(((! (! (true && (false))))), false), true))))) ? (clamp((workgroup_base), (workgroup_base), (workgroup_base))) : subgroup_size)))) | 0u) >> (0u ^ (0u))))))))))))) * 1u)) : (virtual_gid)))));
 if((false))
  return;
 buf[virtual_gid] = 1;
 if((false))
  return;
 if((((! ((bool(bool((! (! (! (true && (((injectionSwitch.x > injectionSwitch.y)))))))))))))))
  {
   if((true && (((((false || (((false || (injectionSwitch.x < injectionSwitch.y)))))) && (! (((! (! ((((! (((((true && (((false))))) && ((injectionSwitch.x < (float(vec4((max((((vec2((clamp((mix(float((6.0)), float(injectionSwitch[0]), bool(true))), injectionSwitch[0], injectionSwitch[0])), injectionSwitch[1]))) + vec2((clamp(0.0, 0.0, 0.0)), 0.0)).y, ((injectionSwitch.y) / exp(0.0)))), sin(0.0), exp(0.0), 1.0))))))))) || false) && true)))))))) && ((true && ((true))) || (((min(injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y)))))))
    return;
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   return;
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   if((false))
    return;
  }
 buf[next_virtual_gid] = (0 | (((((injectionSwitch.x < injectionSwitch.y)) ? 2 : (- 24865)))));
 if((((((! ((true && (! ((false)))))) || false)) || false)))
  {
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   return;
  }
 if((false))
  return;
 if((false))
  {
   if((false))
    return;
   if((false))
    return;
   if((false))
    {
     if((false))
      return;
     if((((injectionSwitch.x > injectionSwitch.y))))
      {
       if((((injectionSwitch.x > injectionSwitch.y))))
        return;
       if((false))
        return;
       return;
      }
     return;
    }
   return;
  }
 if((false))
  return;
 if((false))
  return;
}

END

BUFFER tester DATA_TYPE uint32 SIZE 8388096 FILL 0
BUFFER expected DATA_TYPE uint32 SIZE 8388096 FILL 2
BUFFER injection DATA_TYPE vec2<float> DATA
 0.0 1.0
END

PIPELINE compute test_pipe
  ATTACH test
  BIND BUFFER tester AS storage DESCRIPTOR_SET 0 BINDING 0 
  BIND BUFFER injection AS uniform DESCRIPTOR_SET 0 BINDING 1 

END

RUN test_pipe 65532 1 1
EXPECT tester EQ_BUFFER expected
