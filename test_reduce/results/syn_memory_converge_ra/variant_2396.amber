#!amber

DEVICE_FEATURE SubgroupSizeControl.subgroupSizeControl

SET ENGINE_DATA fence_timeout_ms 10000

SHADER compute test GLSL
#version 460

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_maximal_reconvergence : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer WriteVal {
 uint write_val;
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = (uvec3(gl_NumWorkGroups[0], gl_NumWorkGroups[((((min((((1)) | ((~ ((0 | (~ ((1)))))))) - (0 >> (int(2))), (1) - (0 >> (int(2)))))) ^ 0))], (0u ^ (uint((min(uint((((gl_NumWorkGroups[(min((1 * (2)), 2))]) | 0u))), uint((((gl_NumWorkGroups[(min((1 * (2)), 2))]) | 0u)))))))))).x;
 uint workgroup_size = gl_WorkGroupSize.x;
 uint workgroup_id = (uint((float(mat4((min((clamp((clamp((min((min((injectionSwitch.x), (injectionSwitch.x))), (injectionSwitch.x))), (injectionSwitch.x), (injectionSwitch.x))), (injectionSwitch.x), (injectionSwitch.x))), (injectionSwitch.x))), exp(0.0), sin(0.0), 0.0, 1.0, 1.0, abs(1.0), exp(0.0), 1.0, 1.0, log(1.0), sqrt(1.0), 1.0, 1.0, 0.0, 1.0)))) ^ (gl_WorkGroupID.x));
 uint workgroup_base = ((workgroup_size * workgroup_id) >> (0u ^ (uint(uint(0u)))));
 uint subgroup_base = subgroup_id * (max(subgroup_size, (max((uint(uvec3(subgroup_size, (0u | ((clamp(1u, 1u, 1u)))), 1u))), subgroup_size))));
 uint virtual_gid = (max((((((((~ (~ (((0u) - 0u)))) << (uint(1u)))) | (max((((~ (~ ((0u ^ ((min(((((0u) - 0u)) << 0u), ((0u) - 0u)))))))) << (uint(1u)))), (((~ (~ ((0u ^ ((min(((((0u) - 0u)) << 0u), ((0u) - 0u)))))))) << (uint(1u)))))))) | (((~ (~ (((0u) - 0u)))) << (uint(1u))))) ^ ((((((~ (~ (uint(((uvec4(min(((clamp(min(uint(uvec3(((((min(workgroup_base, workgroup_base)) + subgroup_base)) << 0u), 1u, 0u)), uint(uvec3(((((min(workgroup_base, workgroup_base)) + subgroup_base)) << 0u), 1u, 0u))), min(uint(uvec3(((((min(workgroup_base, workgroup_base)) + subgroup_base)) << 0u), 1u, 0u)), uint(uvec3(((((min(workgroup_base, workgroup_base)) + subgroup_base)) << 0u), 1u, 0u))), min(uint(uvec3(((((min(workgroup_base, workgroup_base)) + subgroup_base)) << 0u), 1u, 0u)), uint(uvec3(((((min(workgroup_base, workgroup_base)) + subgroup_base)) << 0u), 1u, 0u)))))), uint(uvec3(((((min(workgroup_base, workgroup_base)) + subgroup_base)) << 0u), 1u, 0u))), ((1u << ((clamp(uint(2u), uint(2u), uint(2u))))) >> (uint(2u))), 1u, 0u)) >> (uvec4(0u, 0u, 0u, 0u) >> (uvec4(5u)))))))))))) >> 0u)), workgroup_base + subgroup_base)) + subgroup_local_id;
 atomicStore(write_val, uint((uint(uvec4(virtual_gid, uint((((clamp((clamp((((true ? injectionSwitch : (vec2(3.0, (((((bool((bvec3(bvec4(bvec3((! (! (injectionSwitch.x > injectionSwitch.y))), ((injectionSwitch.x > injectionSwitch.y)), false), true))))))) ? (- 5274.7122) : - 71.04))))) * mat2(1.0))), (((vec2(mat3x2((max(true ? (true ? injectionSwitch : (vec2(3.0, - 71.04))) : (((injectionSwitch)) * mat2(1.0)), true ? (true ? injectionSwitch : (vec2(3.0, (min(- 71.04, - 71.04))))) : (((injectionSwitch)) * mat2(1.0)))), 0.0, 1.0, 0.0, 1.0))))), (((true ? injectionSwitch : (vec2(3.0, - 71.04)))) * mat2(1.0)))), (min((vec2(mat3x2((clamp((true ? injectionSwitch : (vec2(3.0, - 71.04))), ((true ? (true ? injectionSwitch : (vec2(3.0, - 71.04))) : ((((((clamp(injectionSwitch, injectionSwitch, injectionSwitch))) / vec2((injectionSwitch.y), (injectionSwitch.y))))) * mat2(1.0)))), (true ? injectionSwitch : (vec2(3.0, - 71.04))))), 0.0, 0.0, 0.0, 0.0))), (min((clamp((true ? injectionSwitch : (vec2(3.0, - 71.04))), ((true ? (true ? injectionSwitch : (vec2(3.0, - 71.04))) : (((vec2(0.0, 0.0) + ((injectionSwitch)))) * mat2(1.0)))), (true ? injectionSwitch : (vec2(3.0, - 71.04))))), ((mat2(1.0) * (min((vec2(mat3((clamp((true ? injectionSwitch : (vec2(3.0, - 71.04))), ((true ? (true ? injectionSwitch : (vec2(3.0, - 71.04))) : ((vec2(((mat4(((injectionSwitch)), 0.0, 0.0, 0.0, exp(0.0), 1.0, 0.0, sqrt(1.0), 0.0, 1.0, 0.0, 0.0, 1.0, (injectionSwitch.y), 0.0)) * mat4(1.0)))) * mat2(1.0)))), (true ? injectionSwitch : (vec2(3.0, - 71.04))))), 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0))), (clamp((true ? injectionSwitch : (vec2(3.0, - 71.04))), ((true ? (true ? injectionSwitch : (vec2(3.0, - 71.04))) : (((injectionSwitch)) * mat2(1.0)))), (true ? injectionSwitch : (vec2(((3.0) / (injectionSwitch.y)), - 71.04))))))))))))), (mix(vec2(((clamp((true ? injectionSwitch : (vec2(3.0, (mix(float(- 71.04), float((- 528.742)), bool(false)))))), (clamp(((true ? (true ? injectionSwitch : ((max(vec2(3.0, - 71.04), vec2(3.0, - 71.04))))) : (((injectionSwitch)) * mat2(1.0)))), ((true ? (true ? injectionSwitch : (vec2(3.0, - 71.04))) : ((mix(vec2((((injectionSwitch)) * mat2(1.0))[0], (1875.6925)), vec2((- 28.35), (((injectionSwitch)) * mat2(1.0))[1]), bvec2(false, true)))))), ((true ? (((true) || ((injectionSwitch.x > injectionSwitch.y))) ? injectionSwitch : ((mix(vec2((vec2(3.0, - 71.04))[0], (vec2(3.0, - 71.04))[1]), vec2((- 2146.6242), (944.595)), bvec2(false, false))))) : (((injectionSwitch)) * mat2(1.0)))))), (true ? injectionSwitch : (vec2(3.0, - 71.04))))))[0], ((clamp((true ? injectionSwitch : (vec2(3.0, - 71.04))), (mix(vec2((- 4.0), (float(((mat3((((((true ? (true ? injectionSwitch : ((clamp(vec2(3.0, - 71.04), vec2(3.0, - 71.04), (max(vec2(3.0, - 71.04), vec2(3.0, - 71.04))))))) : (clamp((((((((injectionSwitch) * mat2(1.0)) - vec2(0.0, 0.0))))) * mat2(1.0)), (((injectionSwitch)) * mat2(1.0)), (((injectionSwitch)) * mat2(1.0))))) * mat2(1.0)))))[1], 1.0, (injectionSwitch.x), 1.0, 0.0, 0.0, sqrt(0.0), determinant(mat2(0.0, 1.0, 0.0, 0.0)), 1.0)) / mat3(1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0))))), vec2(((min(float(mat4x2((((true ? (true ? injectionSwitch : (vec2(1.0, 1.0) * ((vec2(3.0, - 71.04))))) : (((injectionSwitch)) * mat2(1.0)))))[0], 0.0, sqrt(1.0), (((max(1.0, 1.0))) * 1.0), 1.0, 0.0, round(length(normalize(vec3(1.0, 1.0, 1.0)))), 0.0)), float(mat4x2((((true ? (((false ? (injectionSwitch) : (min(true ? injectionSwitch : (vec2(3.0, - 71.04)), true ? injectionSwitch : (vec2(3.0, - 71.04))))))) : (((injectionSwitch)) * mat2(1.0)))))[0], 0.0, sqrt(1.0), 1.0, 1.0, 0.0, round(length(normalize((mix(vec3((1.2), (vec3(1.0, 1.0, 1.0))[1], (- 4.2)), vec3((vec3(1.0, 1.0, 1.0))[0], (clamp(((- 2154.9434 - 4.0)), ((- 2154.9434 - 4.0)), ((- 2154.9434 - 4.0)))), (float(mat3((vec3(1.0, 1.0, 1.0))[2], (injectionSwitch.x), 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0)))), bvec3((! (! (true))), false, true)))))), (max(0.0, 0.0))))))), (- 8.2)), bvec2(true, false))), ((vec2(vec4(true ? injectionSwitch : (vec2(3.0, - 71.04)), 0.0, 1.0)))))))[1]), vec2(((true ? 400.018 : - 8.1)), ((- 3.7 / 446.252))), bvec2(false, (bool(bvec2(((injectionSwitch.x > (clamp(injectionSwitch, injectionSwitch, (vec2(injectionSwitch[0], injectionSwitch[1])))).y)), false))))))))).x)), 0u, 1u)))), (((max((((0 ^ (min(((((clamp(int(ivec2((4), 0)), int(ivec2((4), 0)), int(ivec2((4), 0)))))) ^ 0), ((((((clamp(int(ivec2((4), 0)), int(ivec2((4), 0)), int(ivec2((4), 0)))))) ^ 0)) ^ 0)))))) | (((0 ^ (4)))), (((0 ^ (4)))) | (((0 ^ (4))))))) - (((0 | (((0) + 0)))) | (0))), (max((clamp(64, ((64) + 0), 64)), 64)), (clamp(4, 4, (clamp(4, 4, (0 ^ ((0 ^ (4)))))))));
 uint read_val = (((uint(((~ (~ (uvec2(uvec3(uvec2(uint((injectionSwitch.x)), 1u), 1u)))))))) ^ (((((((! (! (bool(bvec3((bool((bvec3(bvec3(bvec3(bool(bvec2((! (! (((! (! ((! (! (bool(bvec2(true, false)))))))))))), false)), false, false)))))), (false || (true)), ((((injectionSwitch.x) * 1.0) < injectionSwitch.y))))))))) ? atomicLoad(write_val, 4, (~ (~ (64))), (int(((ivec3((max(2, 2)), 1, 1)) + ivec3(0, 0, 0))))) : (subgroup_local_id)))))) / 1u);
 buf[virtual_gid] = (((0u | (uint(subgroupAllEqual(((read_val) | (read_val))))))) + 0u);
}

END

BUFFER tester DATA_TYPE uint32 SIZE 8388096 FILL 0
BUFFER expected DATA_TYPE uint32 SIZE 8388096 FILL 2
BUFFER injection DATA_TYPE vec2<float> DATA
 0.0 1.0
END

PIPELINE compute test_pipe
  ATTACH test
  BIND BUFFER tester AS storage DESCRIPTOR_SET 0 BINDING 0 
  BIND BUFFER injection AS uniform DESCRIPTOR_SET 0 BINDING 1 

  SUBGROUP test
	  VARYING_SIZE on
  END
END

RUN test_pipe 65532 1 1
EXPECT tester EQ_BUFFER expected
