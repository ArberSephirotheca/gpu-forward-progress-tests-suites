#!amber

SET ENGINE_DATA fence_timeout_ms 10000

SHADER compute test GLSL
#version 460

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 uint subgroup_id = gl_SubgroupID;
 if((((injectionSwitch.x > injectionSwitch.y))))
  return;
 if((((injectionSwitch.x > (clamp(injectionSwitch.y, injectionSwitch.y, (mix(float((524.817)), float(injectionSwitch.y), bool(true)))))))))
  return;
 if((false))
  {
   if((false))
    {
     if((false))
      return;
     if((false))
      return;
     if((((injectionSwitch.x > injectionSwitch.y))))
      {
       if((((false) || false)))
        return;
       return;
      }
     if((false))
      return;
     return;
    }
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   if(((true && (false))))
    return;
   if(((((vec2(injectionSwitch[0], injectionSwitch[1])).x > injectionSwitch.y))))
    {
     if((false))
      return;
     if((false))
      return;
     return;
    }
   if((false))
    return;
   if(((((! (((! (((bool((bvec2(bvec4(bvec2(((injectionSwitch.x < injectionSwitch.y)) && (injectionSwitch.x > injectionSwitch.y), ((injectionSwitch.x > injectionSwitch.y))), false, true)))))))) && ((injectionSwitch.x < ((((injectionSwitch.x < injectionSwitch.y)) ? injectionSwitch.y : (determinant(mat2(2217.0115, 385.764, - 66.75, 54.70))))))))))))))
    return;
   if((false))
    {
     if((false))
      return;
     return;
    }
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   return;
  }
 if((((injectionSwitch.x > injectionSwitch.y))))
  return;
 uint subgroup_size = gl_SubgroupSize;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = (((((min((uvec3(uvec3(gl_NumWorkGroups))).x, (min((clamp((((min((uvec3(uvec3(gl_NumWorkGroups))), (uvec3(uvec3(gl_NumWorkGroups)))))) - ((uvec3(0u, 0u, 0u)) | (uvec3(0u, 0u, 0u)))), (min((uvec3(uvec3(gl_NumWorkGroups))), (uvec3(uvec3(gl_NumWorkGroups))))), (min((uvec3(uvec3(gl_NumWorkGroups))), (uvec3(uvec3(gl_NumWorkGroups))))))).x, (((uvec3(uvec3(gl_NumWorkGroups))) / uvec3(1u, 1u, 1u))).x)))))) * 1u) ^ 0u);
 if((false))
  return;
 if((false))
  {
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   return;
  }
 if((false))
  return;
 if(((! (! (false)))))
  {
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   if((false))
    return;
   if((false))
    {
     if((((injectionSwitch.x > injectionSwitch.y))))
      return;
     if(((bool(((bvec3(bvec3(bvec3(bvec4((bvec3(bvec3(bvec3(false, true, ((injectionSwitch.x > injectionSwitch.y)))))), true))))))))))
      {
       if((((injectionSwitch.x > injectionSwitch.y))))
        return;
       return;
      }
     if((((((false ? (746.239) : (((0.0 + ((float((transpose(transpose(mat4x2((clamp(float(mat4((injectionSwitch.x), 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, determinant(mat4(1.0, 0.0, sqrt(0.0), 0.0, length(vec2(0.0, 0.0)), 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, (clamp(0.0, (clamp(0.0, ((0.0) + sin(0.0)), (clamp(0.0, 0.0, 0.0)))), 0.0)), 0.0, 1.0)), 0.0, (injectionSwitch.x), 0.0, 0.0, 1.0, ((min(injectionSwitch, injectionSwitch)).y), (dot(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 1.0))))), float(mat4((injectionSwitch.x), 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, determinant(mat4(1.0, 0.0, sqrt(0.0), 0.0, length(vec2(0.0, 0.0)), 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0)), 0.0, (injectionSwitch.x), 0.0, 0.0, (mix(float((5.5)), float(1.0), bool(true))), (float((max(float((injectionSwitch.y)), float((injectionSwitch.y)))))), ((false ? (vec4(0.4, - 5478.5609, 40.46, - 44.38).r) : (dot(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 1.0))))))), float(mat4((injectionSwitch.x), (float(mat3x2(1.0, 1.0, abs(0.0), 1.0, (clamp(((1.0) + 0.0), 1.0, 1.0)), 0.0))), 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, determinant(mat4(1.0, 0.0, sqrt(0.0), 0.0, length(vec2(0.0, 0.0)), (min(1.0, (clamp((max(1.0, 1.0)), 1.0, 1.0)))), 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0)), 0.0, (injectionSwitch.x), 0.0, 0.0, 1.0, (injectionSwitch.y), (dot(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 1.0))))))), (float((mat2(mat2x4(mat2(((determinant(mat4(1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0))) - 0.0), 1.0, 1.0, (dot((((((vec2(mat2x3(vec2((((max(round(length(normalize(vec3(1.0, 1.0, 1.0)))), round(length(normalize(vec3(1.0, 1.0, 1.0))))))) - 0.0), 0.0), 0.0, 1.0, 1.0, 0.0)))) / vec2(1.0, 1.0))) - vec2(0.0, 0.0)), vec2(1.0, 0.0))))))))), 1.0, 1.0, length(0.0), 1.0, 0.0, 0.0))))))))) / 1.0))) > injectionSwitch.y))))
      {
       if((false))
        return;
       if((false))
        return;
       if((false))
        return;
       if((false))
        return;
       if((((injectionSwitch.x > injectionSwitch.y))))
        return;
       return;
      }
     return;
    }
   if((false))
    return;
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   if((false))
    return;
   return;
   if((false))
    return;
   if((false))
    return;
  }
 uint workgroup_size = gl_WorkGroupSize.x;
 if((false))
  return;
 if((false))
  return;
 if((((injectionSwitch.x > injectionSwitch.y))))
  return;
 if((((injectionSwitch.x > injectionSwitch.y))))
  return;
 if((false))
  return;
 if((false))
  return;
 uint workgroup_id = (((min(gl_WorkGroupID, gl_WorkGroupID)) / uvec3(1u, 1u, 1u))).x;
 if((false))
  return;
 if((bool(bvec4((((injectionSwitch.x > injectionSwitch.y))), true, ((injectionSwitch.x > injectionSwitch.y)), true))))
  {
   if((false))
    return;
   return;
  }
 if((bool((bvec2(bvec3((bvec2(bvec4(bvec2((false), true), false, false))), true))))))
  return;
 if(((((false || (injectionSwitch.x > injectionSwitch.y))))))
  return;
 if((false))
  return;
 uint workgroup_base = workgroup_size * workgroup_id;
 if(((! (! (false)))))
  {
   if((false))
    return;
   if((false))
    return;
   if((false))
    return;
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   if((false))
    return;
   return;
  }
 if((false))
  return;
 if(((true && (false))))
  {
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   return;
  }
 if((false))
  return;
 if((false))
  {
   if((false))
    {
     if((false))
      return;
     if((((injectionSwitch.x > injectionSwitch.y))))
      return;
     if(((bool(bvec2(false, true)))))
      return;
     if((false))
      return;
     return;
    }
   if((! (((! ((false))) || ((false) || false)))))
    return;
   if((false))
    {
     if((false))
      {
       if((false))
        return;
       return;
      }
     if((false))
      {
       if((((injectionSwitch.x > injectionSwitch.y))))
        return;
       return;
      }
     if((false))
      return;
     if((false))
      return;
     return;
     if((false))
      return;
     if((false))
      {
       if((((false)) || false))
        return;
       if((((injectionSwitch.x > injectionSwitch.y))))
        return;
       return;
      }
    }
   return;
   if((false))
    return;
   if((false))
    return;
  }
 if((false))
  return;
 if((false))
  {
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   return;
   if((false))
    return;
  }
 if((false))
  return;
 if((false))
  {
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   return;
  }
 if((false))
  return;
 if((false))
  {
   if(((bool(bvec4(((injectionSwitch.x > injectionSwitch.y)), false, false, true)))))
    return;
   return;
  }
 uint virtual_gid = workgroup_base + subgroup_id * subgroup_size + subgroup_local_id;
 if(((bool(bvec2((false || (false)), true)))))
  {
   if((((injectionSwitch.x > ((clamp(vec2(mat3x4(injectionSwitch, 1.0, 1.0, 0.0, 1.0, sqrt(0.0), 1.0, 0.0, 1.0, sqrt(0.0), 1.0)), vec2(mat3x4(injectionSwitch, 1.0, 1.0, 0.0, 1.0, sqrt(0.0), 1.0, 0.0, 1.0, sqrt(0.0), 1.0)), vec2(mat3x4(injectionSwitch, 1.0, 1.0, 0.0, 1.0, sqrt((min((1.0 * (0.0)), 0.0))), 1.0, 0.0, 1.0, sqrt(0.0), 1.0))))).y))))
    return;
   if((true && ((((((false) || false))) || false))))
    {
     if((! ((bool(bvec3((bool(bvec3(! ((false)), false, false))), ((injectionSwitch.x < injectionSwitch.y)), true))))))
      return;
     return;
    }
   if((false))
    return;
   return;
  }
 uint next_virtual_gid = workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + ((1) - 0)) % subgroup_size);
 if((((injectionSwitch.x > injectionSwitch.y))))
  return;
 buf[virtual_gid] = 1;
 if((((injectionSwitch.x > injectionSwitch.y))))
  return;
 if((false))
  {
   if((((! (! ((injectionSwitch.x > injectionSwitch.y)))))))
    return;
   if((((injectionSwitch.x > injectionSwitch.y))))
    {
     if((false))
      return;
     return;
    }
   if((false))
    {
     if((false))
      {
       if((((injectionSwitch.x > injectionSwitch.y))))
        return;
       if((((injectionSwitch.x > (float(mat3x2(((injectionSwitch) * mat2((injectionSwitch.y))).y, (dot(vec4(0.0, 0.0, 1.0, 0.0), vec4(0.0, 0.0, 1.0, 0.0))), (injectionSwitch.x), 0.0, 1.0, 0.0)))))))
        return;
       if((false))
        return;
       if((false))
        return;
       return;
      }
     if((false))
      {
       if((false))
        return;
       return;
      }
     if((false))
      return;
     if(((((injectionSwitch.x > injectionSwitch.y)) || (((injectionSwitch.x > injectionSwitch.y))))))
      return;
     return;
     if((false))
      return;
     if((false))
      return;
    }
   if((false))
    return;
   return;
  }
 if(((! (! ((bool(bvec4((bool(bvec4(! ((bool(bvec2((bool(bvec3(((((((((bool((bvec3(bvec3((bvec3(bvec3(bvec3(((((max(injectionSwitch.x, injectionSwitch.x)) < (clamp(injectionSwitch, injectionSwitch, ((clamp(vec2(1.0, 1.0), (clamp(vec2(1.0, 1.0), vec2(1.0, 1.0), vec2(1.0, 1.0))), vec2(1.0, 1.0))) * ((vec2(vec4(injectionSwitch, 0.0, 0.0))))))).y)) && ((! (! ((! (! ((! (false || ((! ((false || ((false || (((! (! (! (! (! (false)))))))))))))))))))))))), false, true)))))))))) || false)) && true))) && true), true, true))), (bool(bvec3((bool(bvec4(false, true, ((injectionSwitch.x < injectionSwitch.y)), true))), false, false))))))), true, true, ((false) || false)))), true, ((injectionSwitch.x > (((((((true ? mat2(((false ? (0.4) : 1.0))) * (injectionSwitch) : (injectionSwitch))))) * vec2(1.0, 1.0))) + log(vec2(1.0, 1.0))).y)), ((! (! (bool(bool(false))))))))))))))
  {
   if((false))
    return;
   if((false))
    return;
   if((false))
    return;
   return;
  }
 if(subgroup_local_id + 1 < subgroup_size)
  {
   if((false || ((! (! ((((injectionSwitch.x > injectionSwitch.y)))))))))
    {
     if((false))
      {
       if((((injectionSwitch.x > injectionSwitch.y))))
        return;
       return;
      }
     if((((injectionSwitch.x > injectionSwitch.y))))
      return;
     return;
    }
   if((false))
    {
     if((((injectionSwitch.x > (min(injectionSwitch, injectionSwitch)).y))))
      return;
     return;
    }
   if((false))
    return;
   if((((bool((bool(bvec3(bool((injectionSwitch.x > injectionSwitch.y)), true, (! ((bool(bvec4(! (false), true, true, false)))))))))))))
    {
     if((false))
      return;
     return;
     if((false))
      return;
     if((((bool(bvec2(bool(bvec3((false || (false)), true, true)), true))))))
      return;
    }
   int i = 0;
   if((false))
    {
     if(((bool(bool(false)))))
      return;
     if((false))
      return;
     if((((false) && true)))
      {
       if((((injectionSwitch.x > injectionSwitch.y))))
        return;
       return;
      }
     if((((injectionSwitch.x > injectionSwitch.y))))
      return;
     if((false))
      return;
     return;
    }
   buf[next_virtual_gid] = (~ (~ (2)));
  }
 else
  {
   if((false))
    return;
   if((false))
    {
     if((false))
      return;
     return;
    }
   buf[next_virtual_gid] = 2;
   if((false))
    return;
   if((false))
    return;
   if((false))
    return;
  }
 if((false))
  {
   if((false))
    {
     if((false))
      return;
     return;
    }
   if((false))
    {
     if((false))
      return;
     return;
    }
   if((false))
    return;
   return;
  }
 if((false))
  return;
 if(((! (! (((injectionSwitch.x > injectionSwitch.y)))))))
  return;
 if((((((injectionSwitch) * mat2(1.0)).x > injectionSwitch.y))))
  {
   if((false))
    return;
   if((false))
    return;
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   if((false))
    return;
   return;
   if((false))
    return;
  }
}

END

BUFFER tester DATA_TYPE uint32 SIZE 8388096 FILL 0
BUFFER expected DATA_TYPE uint32 SIZE 8388096 FILL 2
BUFFER injection DATA_TYPE vec2<float> DATA
 0.0 1.0
END

PIPELINE compute test_pipe
  ATTACH test
  BIND BUFFER tester AS storage DESCRIPTOR_SET 0 BINDING 0 
  BIND BUFFER injection AS uniform DESCRIPTOR_SET 0 BINDING 1 

END

RUN test_pipe 65532 1 1
EXPECT tester EQ_BUFFER expected
