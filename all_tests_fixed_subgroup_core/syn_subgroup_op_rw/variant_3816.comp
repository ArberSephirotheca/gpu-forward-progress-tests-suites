#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer Checker {
 uint checker[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false || (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(false))
      return;
     return;
    }
   if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, (false) || false))))))
    {
     if(_GLF_DEAD(false))
      barrier();
     return;
    }
   return;
   if(_GLF_DEAD(false))
    barrier();
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(false))
    {
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
      {
       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
        }
       else
        {
         return;
         if(_GLF_DEAD(false))
          barrier();
         do
          {
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
      }
    }
   if(_GLF_DEAD(false))
    return;
   barrier();
  }
 if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ((injectionSwitch.x > injectionSwitch.y)) || false))))
  return;
 uint subgroup_id = gl_SubgroupID;
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     barrier();
    }
   else
    {
    }
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), bool(bvec2(_GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ((injectionSwitch.x > injectionSwitch.y)) || false), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))) || false)))))
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     return;
    }
  }
uint subgroup_size = 16;
 if(_GLF_DEAD(false))
  barrier();
 do
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, min(injectionSwitch.y, injectionSwitch.y))))))
    return;
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        barrier();
       break;
      }
    }
   else
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), bool(bvec3(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), true, true))))
      {
       if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), bool(bvec2(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), true)))))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, true && _GLF_IDENTITY((_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, bool(bvec4(injectionSwitch.x > injectionSwitch.y, true, true, false))), bool(bvec4(_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, bool(bvec4(injectionSwitch.x > injectionSwitch.y, true, true, false))), true, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), false)))), ((_GLF_IDENTITY(_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, bool(bvec4(injectionSwitch.x > injectionSwitch.y, true, true, false))), bool(bvec4(_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, bool(bvec4(injectionSwitch.x > injectionSwitch.y, true, true, false))), true, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), false))))) && true))))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           else
            {
            }
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              return;
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           continue;
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              {
               do
                {
                 barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
            }
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           barrier();
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              continue;
             barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
              }
             else
              {
               return;
              }
            }
           for(int _injected_loop_counter = (1 & 1); _GLF_WRAPPED_LOOP(_injected_loop_counter > (1 ^ int(_GLF_ONE(1.0, injectionSwitch.y)))); _injected_loop_counter --)
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    return;
                   barrier();
                  }
                }
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 return;
                }
               else
                {
                }
              }
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 barrier();
                }
               else
                {
                }
              }
             barrier();
            }
           if(_GLF_DEAD(false))
            return;
          }
         else
          {
           if(_GLF_DEAD(false))
            barrier();
          }
        }
       else
        {
         if(_GLF_DEAD(false))
          break;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          break;
         break;
         if(_GLF_DEAD(false))
          barrier();
        }
      }
    }
   if(_GLF_DEAD(false))
    {
     do
      {
       return;
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
  }
 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
 if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || _GLF_IDENTITY(false, (false) && true))))
  barrier();
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   return;
  }
 uint subgroup_local_id = gl_SubgroupInvocationID;
 if(_GLF_DEAD(false))
  return;
 uint num_workgroup = _GLF_IDENTITY(gl_NumWorkGroups.x, max(gl_NumWorkGroups.x, gl_NumWorkGroups.x));
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     do
      {
       if(_GLF_DEAD(false))
        {
         do
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             barrier();
            }
          }
         while(_GLF_WRAPPED_LOOP(false));
         if(_GLF_DEAD(false))
          return;
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
            }
          }
         else
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
         if(_GLF_DEAD(false))
          barrier();
        }
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
   return;
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    barrier();
   return;
  }
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 uint workgroup_size = gl_WorkGroupSize.x;
 if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ! (_GLF_IDENTITY(! ((injectionSwitch.x > injectionSwitch.y)), (! ((injectionSwitch.x > injectionSwitch.y))) && true))))))
        barrier();
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
        {
         barrier();
        }
      }
    }
   else
    {
    }
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     return;
    }
   else
    {
    }
  }
 uint workgroup_id = gl_WorkGroupID.x;
 if(_GLF_DEAD(false))
  barrier();
 uint workgroup_base = workgroup_size * workgroup_id;
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
    {
     if(_GLF_DEAD(false))
      {
       switch(_GLF_SWITCH(0))
        {
         case 10:
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         do
          {
           max(vec2(4139.9777, 36.55), 91.78);
           for(           vec4(4172.9218, 6.5, 433.958, 2910.4294);
 (ivec4(-30257, 59101, -9913, -83143) != min(ivec4(-62075, 75832, -78122, 39357), -14177)); mat4x2(mat2x4(-1822.1962, -6.8, 6.0, 6.4, 45.33, 32.78, 9.3, 29.71)))
            {
             mat3 _GLF_SWITCH_3_0v;
             do
              {
               ;
               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
             uint _GLF_SWITCH_3_1v;
             mat3x2 _GLF_SWITCH_3_2v[29], _GLF_SWITCH_3_3v[6];
             uvec4(22944u, 100102u, 114415u, 194336u);
             do
              {
               vec3(4.1, 37.04, 0.4);
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, false)))))
              {
               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), int(0)))); _injected_loop_counter ++)
                {
                 barrier();
                }
              }
             mat4x3(-8.2, -4.0, 8060.4705, 645.417, 260.504, 6730.0235, -5.8, -459.111, -2.3, -1175.7642, -115.469, 882.529);
             do
              {
               uvec2(_GLF_SWITCH_3_1v, _GLF_SWITCH_3_1v);
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           mat3(6.9, 7487.1945, -8.6, 48.50, -3.4, -66.71, 2.7, -997.600, 3092.2251);
           mat2x4(-94.57, -7.5, -5664.2801, -6.8, _GLF_IDENTITY(-494.714, float(mat3(-494.714, 0.0, 0.0, 1.0, 1.0, tan(0.0), 1.0, 1.0, 0.0))), 127.269, -1.9, -81.08);
           vec3(4.9, -5.6, -6.6);
           mat3x2(mat3(4310.0939, -9.9, (- -8442.0232), 6720.2875, -339.888, -2266.4446, 9159.4003, -6.2, dot(2.3, 8.4)));
           bvec3(true, not(bvec2(true, true)));
          }
         while((mat3x4(-6.4, -2777.8320, -80.10, -0.9, -6.7, -2560.0622, -78.27, -71.04, 21.60, -13.65, -17.75, 6.8) != (mat3x4(49.76, 4.3, 723.934, -8.9, 2.3, 6088.8272, -75.78, 0.5, -1330.2234, -26.91, -0.6, -330.693) + 0.9)));
         case 0:
         if(_GLF_DEAD(false))
          barrier();
         case 29:
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_IDENTITY(bool(bvec3(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, vec2(vec3(injectionSwitch, sqrt(0.0)))).x > injectionSwitch.y)), true, false)), (bool(bvec3(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, vec2(vec3(injectionSwitch, sqrt(0.0)))).x > injectionSwitch.y)), true, false))) || false)))))))
          {
           if(_GLF_DEAD(false))
            return;
           for(int _injected_loop_counter = (0 ^ 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
            {
             return;
            }
          }
         case 61:
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(true && (false), bool(bvec4(true && (false), false, true, true))))))
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 do
                  {
                   barrier();
                   if(_GLF_DEAD(false))
                    return;
                   if(_GLF_DEAD(false))
                    barrier();
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                }
              }
            }
          }
         return;
         break;
         case 13:
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           while(false)
            {
             vec4(847.795, 2.9, 3122.8942, _GLF_IDENTITY(90.73, max(90.73, _GLF_IDENTITY(90.73, mix(float(90.73), float(_GLF_FUZZED(4416.4176)), bool(false))))));
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
              barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
         else
          {
          }
         default:
         do
          {
           _GLF_IDENTITY(1, clamp(1, _GLF_IDENTITY(1, (1) | (1)), _GLF_IDENTITY(1, (1) << 0)));
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
            }
           else
            {
             barrier();
            }
          }
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
    }
  }
 uint virtual_gid = workgroup_base + subgroup_id * subgroup_size + subgroup_local_id;
 do
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_DEAD(false))
      {
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 << _GLF_IDENTITY(int(2), _GLF_IDENTITY(_GLF_IDENTITY(int(2), (int(2)) | (int(2))), clamp(_GLF_IDENTITY(_GLF_IDENTITY(int(2), (int(2)) | (int(2))), (_GLF_IDENTITY(int(2), (int(2)) | (int(2)))) | (_GLF_IDENTITY(int(2), (int(2)) | (int(2))))), _GLF_IDENTITY(int(2), (int(2)) | (int(2))), _GLF_IDENTITY(_GLF_IDENTITY(int(2), (int(2)) | (int(2))), 0 ^ (_GLF_IDENTITY(int(2), (int(2)) | (int(2)))))))))); _injected_loop_counter --)
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
            break;
           continue;
          }
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_IDENTITY(bool(bvec2(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false)), (bool(bvec2(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false))) && true))))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))
              barrier();
             do
              {
               if(_GLF_DEAD(false))
                barrier();
              }
             while(_GLF_WRAPPED_LOOP(false));
             break;
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               return;
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             barrier();
            }
           barrier();
          }
         else
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, false || (false)), (injectionSwitch.x > injectionSwitch.y))))
            return;
          }
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_DEAD(false))
        return;
       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
        }
       else
        {
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = (0 | 1); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
            {
             return;
            }
          }
        }
      }
    }
   else
    {
    }
  }
 while(_GLF_WRAPPED_LOOP(false));
 if(_GLF_DEAD(false))
  barrier();
 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(false))
      break;
     switch(_GLF_SWITCH(_GLF_IDENTITY(0, (0) / 1)))
      {
       case 20:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        continue;
       if(_GLF_DEAD(false))
        continue;
       {
        if(_GLF_DEAD(false))
         {
          for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
           {
            barrier();
           }
         }
        if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         {
         }
        else
         {
          ;
          for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
           {
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
              if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
               }
              else
               {
                barrier();
               }
             }
           }
          if(_GLF_DEAD(false))
           barrier();
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           return;
         }
        if(_GLF_DEAD(false))
         barrier();
        mat2x3 _GLF_SWITCH_0_0v, _GLF_SWITCH_0_1v;
        bvec4 _GLF_SWITCH_0_2v[89];
        vec3 _GLF_SWITCH_0_3v;
        if(_GLF_DEAD(false))
         continue;
        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         barrier();
        if(_GLF_DEAD(false))
         continue;
        if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, ! (! (false)))) || false)))
         barrier();
        ;
        do
         {
          if(_GLF_DEAD(false))
           barrier();
         }
        while(_GLF_WRAPPED_LOOP(false));
        bvec2(false, true);
        ivec2 _GLF_SWITCH_0_4v, _GLF_SWITCH_0_5v;
        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
         barrier();
        if(_GLF_DEAD(false))
         continue;
        if(_GLF_DEAD(false))
         {
          if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           {
           }
          else
           {
            barrier();
           }
         }
        if(_GLF_DEAD(false))
         barrier();
       }
       case 0:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        continue;
       if(_GLF_DEAD(false))
        continue;
       case 22:
       case 27:
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           return;
          }
         else
          {
          }
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         continue;
        }
       case 45:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, (_GLF_IDENTITY(injectionSwitch.y, mix(float(_GLF_FUZZED(-9.8)), float(injectionSwitch.y), bool(true)))) - 0.0)))))
        {
         if(_GLF_DEAD(false))
          barrier();
         continue;
        }
       case 86:
       case 36:
       if(_GLF_DEAD(false))
        barrier();
       case 17:
       case 42:
       if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, false || (false))))
        {
        }
       else
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              {
               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                {
                 barrier();
                }
              }
             break;
            }
           barrier();
          }
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_DEAD(false))
        continue;
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         if(_GLF_DEAD(false))
          return;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, _GLF_IDENTITY(bool(bvec3(injectionSwitch.x > injectionSwitch.y, false, false)), (bool(bvec3(injectionSwitch.x > injectionSwitch.y, false, false))) && true))))))
        barrier();
       case 4:
       do
        {
         barrier();
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        break;
       if(_GLF_DEAD(false))
        barrier();
       break;
       if(_GLF_DEAD(false))
        break;
       default:
       if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         continue;
        }
       1;
       if(_GLF_DEAD(false))
        continue;
       if(_GLF_DEAD(false))
        continue;
       if(_GLF_DEAD(false))
        barrier();
      }
     do
      {
       if(_GLF_DEAD(false))
        continue;
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            return;
          }
         else
          {
          }
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
          {
           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
            {
             return;
            }
          }
        }
       if(_GLF_DEAD(false))
        {
         for(int _injected_loop_counter = (1 ^ 0); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             barrier();
            }
           else
            {
            }
          }
        }
      }
     while(_GLF_WRAPPED_LOOP(false));
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         barrier();
        }
      }
    }
   if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, false || (_GLF_IDENTITY(false, false || (false))))))
    {
    }
   else
    {
     if(_GLF_DEAD(false))
      barrier();
    }
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_DEAD(false))
    break;
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, (false) && true)))), (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, 1.0 * (_GLF_IDENTITY(injectionSwitch.y, (false ? _GLF_FUZZED(-509.344) : injectionSwitch.y))))))))
            barrier();
           return;
          }
         if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
          barrier();
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           return;
          }
        }
      }
     else
      {
      }
    }
   else
    {
    }
   if(_GLF_DEAD(false))
    barrier();
   do
    {
     if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(_GLF_IDENTITY(false, _GLF_FALSE(_GLF_IDENTITY(false, (false) || false), (injectionSwitch.x > injectionSwitch.y)) || (_GLF_IDENTITY(false, _GLF_IDENTITY((false) && true, bool(_GLF_IDENTITY(bvec3((false) && true, false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))), _GLF_IDENTITY(bvec3(bvec4(bvec3((false) && true, false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))), false)), bvec3(bvec4(bvec3(bvec4(bvec3((false) && true, false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))), false)), false))))))))), (injectionSwitch.x > injectionSwitch.y)), true && (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
      barrier();
    }
   while(_GLF_WRAPPED_LOOP(false));
   return;
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   if(_GLF_DEAD(false))
    {
     do
      {
       return;
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
  }
 else
  {
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    return;
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       for(int _injected_loop_counter = (1 | 1); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
        {
         if(_GLF_DEAD(false))
          return;
        }
       return;
      }
    }
   if(_GLF_DEAD(false))
    return;
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 << _GLF_IDENTITY(int(2), int(2)))); _injected_loop_counter --)
    {
     return;
    }
  }
 uint next_virtual_gid = _GLF_IDENTITY(_GLF_IDENTITY(workgroup_base + subgroup_id * subgroup_size, 0u ^ (workgroup_base + subgroup_id * subgroup_size)) + ((subgroup_local_id + 1) % subgroup_size), (0u << _GLF_IDENTITY(uint(7u), uint(7u))) ^ (_GLF_IDENTITY(workgroup_base + subgroup_id * subgroup_size, 0u ^ (workgroup_base + subgroup_id * subgroup_size)) + ((subgroup_local_id + 1) % subgroup_size)));
 if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
  return;
 uint read = atomicLoad(buf[virtual_gid], 4, 64, _GLF_IDENTITY(0, ~ (~ (_GLF_IDENTITY(0, _GLF_IDENTITY((0) - 0, (_GLF_IDENTITY((0) - 0, (false ? _GLF_FUZZED(-12444) : (0) - 0))) | ((0) - 0)))))));
 do
  {
   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
    {
     if(_GLF_DEAD(false))
      return;
    }
   else
    {
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(false))
      continue;
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(5), int(5))) >> _GLF_IDENTITY(int(5), int(5)))); _injected_loop_counter ++)
      {
       return;
      }
     if(_GLF_DEAD(false))
      barrier();
    }
   switch(_GLF_SWITCH(0))
    {
     case 0:
     case 4:
     if(_GLF_DEAD(false))
      barrier();
     case 65:
     if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)).y))))
        {
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            return;
          }
         else
          {
          }
         continue;
        }
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(false))
          {
           do
            {
             return;
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY(1, (1) >> 0)); _injected_loop_counter ++)
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  {
                   do
                    {
                     if(_GLF_DEAD(false))
                      {
                       for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(ivec2(int(4), 0)), clamp(int(ivec2(int(4), 0)), int(ivec2(int(4), 0)), int(ivec2(int(4), 0))))))) >> _GLF_IDENTITY(int(4), int(4))); _GLF_WRAPPED_LOOP(_injected_loop_counter != (-70317 & 0)); _injected_loop_counter --)
                        {
                         barrier();
                        }
                      }
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                   break;
                  }
                 do
                  {
                   return;
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                }
              }
             if(_GLF_DEAD(false))
              barrier();
             barrier();
            }
          }
        }
       else
        {
        }
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
        {
         barrier();
        }
      }
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
          }
         continue;
        }
       if(_GLF_DEAD(false))
        continue;
       break;
      }
     case 51:
     if(_GLF_DEAD(false))
      break;
     case 89:
     case 46:
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      continue;
     if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), _GLF_IDENTITY(bool(bool(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), (_GLF_IDENTITY(bool(bool(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, ! (! (false))), (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, vec2(mat4x2(_GLF_IDENTITY(injectionSwitch, mix(vec2((injectionSwitch)[0], (injectionSwitch)[_GLF_IDENTITY(1, int(ivec2(1, 0)))]), vec2(_GLF_FUZZED((5.0 + -8740.1669)), _GLF_FUZZED(-374.951)), bvec2(false, false))), 1.0, _GLF_ONE(1.0, injectionSwitch.y), 1.0, 0.0, abs(1.0), 0.0))).y))))), false || (bool(bool(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))) || false)))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        continue;
       continue;
       if(_GLF_DEAD(false))
        break;
      }
     case 68:
     case 87:
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           barrier();
          }
        }
      }
     else
      {
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec2(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true)))))
        barrier();
       continue;
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       do
        {
         barrier();
        }
       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
      }
     if(_GLF_DEAD(false))
      {
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
        {
         barrier();
        }
      }
     case 35:
     case 63:
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(false))
      break;
     atomicStore(buf[next_virtual_gid], uint(1), 4, 64, 4);
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(false, true, false, false)))))
        barrier();
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             return;
            }
           else
            {
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, _GLF_IDENTITY(injectionSwitch.y, clamp(injectionSwitch.y, injectionSwitch.y, injectionSwitch.y)), injectionSwitch.y))))))
          break;
        }
       else
        {
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch.y, mix(float(_GLF_FUZZED(0.4)), float(injectionSwitch.y), bool(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))))))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               barrier();
              }
             else
              {
              }
            }
           barrier();
          }
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           do
            {
             do
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                 return;
                 if(_GLF_DEAD(false))
                  continue;
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             barrier();
            }
          }
         barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
            barrier();
           continue;
          }
        }
       if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (false))))
        {
         do
          {
           barrier();
          }
         while(_GLF_WRAPPED_LOOP(false));
         if(_GLF_DEAD(false))
          barrier();
        }
      }
     break;
     default:
     if(_GLF_DEAD(false))
      break;
     _GLF_IDENTITY(1, (1) ^ _GLF_IDENTITY(0, (0) >> 0));
     if(_GLF_DEAD(false))
      break;
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         barrier();
        }
       else
        {
        }
      }
     do
      {
       if(_GLF_DEAD(false))
        barrier();
      }
     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       continue;
      }
     return;
    }
   if(_GLF_DEAD(false))
    barrier();
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
    {
     if(_GLF_DEAD(false))
      barrier();
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      continue;
     barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
    }
   if(_GLF_DEAD(false))
    barrier();
  }
 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
 if(_GLF_IDENTITY(subgroup_local_id, 1u * (subgroup_local_id)) + 1 < subgroup_size)
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         barrier();
        }
       return;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
        {
         return;
        }
      }
     barrier();
    }
   do
    {
     for(int _injected_loop_counter = (1 & int(_GLF_ONE(1.0, injectionSwitch.y))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
      {
       if(_GLF_DEAD(false))
        return;
      }
     atomicStore(checker[virtual_gid], _GLF_IDENTITY(read, (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) ? _GLF_FUZZED(read) : read)), 4, 64, 4);
     if(_GLF_DEAD(false))
      break;
    }
   while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, true && (_GLF_IDENTITY(false, bool(bvec2(false, true)))))));
   if(_GLF_DEAD(false))
    {
     switch(_GLF_SWITCH(0))
      {
       case 0:
       case 38:
       case 44:
       case 84:
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           barrier();
          }
        }
       case 81:
       case 2:
       if(_GLF_DEAD(false))
        barrier();
       case 74:
       if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
        {
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
          {
           return;
          }
        }
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
        }
       else
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       case 73:
       case 98:
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         switch(_GLF_SWITCH((1 ^ 1)))
          {
           case 16:
           float _GLF_SWITCH_2_0v[6];
           if(_GLF_DEAD(false))
            {
             do
              {
               barrier();
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
            }
           case 58:
           uvec3(58831u, 183729u, 16626u);
           case 0:
           case 62:
           if(_GLF_DEAD(false))
            return;
           case 47:
           if(_GLF_DEAD(false))
            barrier();
           case 60:
           case 91:
           case 77:
           if(_GLF_DEAD(false))
            barrier();
           case 89:
           if(_GLF_DEAD(false))
            {
             do
              {
               barrier();
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
           case 29:
           if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (false))))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              return;
            }
           return;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 << _GLF_IDENTITY(int(2), int(2)))); _injected_loop_counter --)
              {
               do
                {
                 return;
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
            }
           break;
           default:
           do
            {
             1;
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
          }
        }
       else
        {
        }
       break;
       default:
       1;
      }
    }
   if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bool(false)), true && (bool(bool(false)))))))
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        barrier();
       return;
      }
     else
      {
      }
    }
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(false))
      barrier();
     switch(_GLF_SWITCH(0))
      {
       case 0:
       if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, (false) || false)))
        {
        }
       else
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! _GLF_IDENTITY((_GLF_IDENTITY(! _GLF_IDENTITY((false), ((false)) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), (! (false)) || false)), _GLF_IDENTITY(((_GLF_IDENTITY(! (false), (! (false)) || false))), (((_GLF_IDENTITY(! (false), (! (false)) || false)))) && true) || false))))
          {
           if(_GLF_DEAD(false))
            {
             switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
              {
               case 1:
               do
                {
                 if(false)
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   ivec2 _GLF_SWITCH_3_0v;
                  }
                 else
                  {
                   (mat4(-4651.9110, -6.4, 8.9, -6419.6853, -831.332, 6.8, -141.143, 2810.5563, 6972.4386, -50.04, 1.9, -831.427, 907.659, 9.1, 664.987, -6220.5790) * (mat2x4(-965.356, -6.5, 257.833, -8669.0693, 789.663, -2961.6844, 0.4, -8905.2830)));
                  }
                }
               while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) && true)));
               case 0:
               case 8:
               case 14:
               case 24:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 if(_GLF_DEAD(false))
                  return;
                 switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                  {
                   case 61:
                   {
                    if(_GLF_DEAD(false))
                     return;
                    mat4x2 _GLF_SWITCH_1_0v, _GLF_SWITCH_1_1v, _GLF_SWITCH_1_2v;
                    ivec4 _GLF_SWITCH_1_3v, _GLF_SWITCH_1_4v[20], _GLF_SWITCH_1_5v[4];
                    do
                     {
                      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                       {
                        if(_GLF_DEAD(false))
                         barrier();
                        if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_IDENTITY(_GLF_DEAD(false), bool(bool(_GLF_DEAD(false))))))))
                         barrier();
                        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                         return;
                        return;
                       }
                     }
                    while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                    if(_GLF_WRAPPED_IF_FALSE(false))
                     {
                     }
                    else
                     {
                      if(_GLF_WRAPPED_IF_TRUE(true))
                       {
                        while(false)
                         {
                          switch(_GLF_SWITCH((0 ^ 0)))
                           {
                            case 0:
                            case 1:
                            if(_GLF_DEAD(false))
                             {
                              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                               continue;
                              barrier();
                             }
                            case 72:
                            case 28:
                            case 49:
                            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                             barrier();
                            case 15:
                            case 83:
                            case 55:
                            if(_GLF_DEAD(false))
                             {
                              switch(_GLF_SWITCH(0))
                               {
                                case 0:
                                case 91:
                                case 11:
                                case 20:
                                case 81:
                                case 34:
                                if(_GLF_DEAD(false))
                                 {
                                  if(_GLF_DEAD(false))
                                   barrier();
                                  continue;
                                 }
                                case 45:
                                if(_GLF_DEAD(false))
                                 return;
                                case 87:
                                case 80:
                                case 59:
                                barrier();
                                break;
                                default:
                                1;
                               }
                             }
                            if(_GLF_DEAD(false))
                             continue;
                            break;
                            if(_GLF_DEAD(false))
                             return;
                            if(_GLF_DEAD(false))
                             barrier();
                            default:
                            1;
                           }
                         }
                       }
                      else
                       {
                       }
                      for(int _injected_loop_counter = (1 & 1); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                       {
                        if(_GLF_DEAD(false))
                         barrier();
                       }
                      do
                       {
                        if(_GLF_DEAD(false))
                         break;
                        if(_GLF_WRAPPED_IF_FALSE(false))
                         {
                         }
                        else
                         {
                          if(_GLF_WRAPPED_IF_TRUE(true))
                           {
                            if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                             {
                              for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(1), _GLF_IDENTITY(int(1), (int(1)) | 0))) >> _GLF_IDENTITY(int(1), _GLF_IDENTITY(int(1), int(ivec3(int(1), int(_GLF_ONE(1.0, injectionSwitch.y)), 1))))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                               {
                                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                 barrier();
                                return;
                               }
                             }
                           }
                          else
                           {
                           }
                         }
                       }
                      while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                      for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), int(2))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                       {
                        if(_GLF_DEAD(false))
                         barrier();
                       }
                     }
                    if(false)
                     {
                     }
                    if(_GLF_WRAPPED_IF_FALSE(false))
                     {
                     }
                    else
                     {
                      if(_GLF_DEAD(false))
                       barrier();
                      for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _GLF_IDENTITY(_injected_loop_counter --, 0 | (_injected_loop_counter --)))
                       {
                        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                         barrier();
                        for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                         {
                          if(_GLF_DEAD(false))
                           {
                            if(_GLF_WRAPPED_IF_TRUE(true))
                             {
                              do
                               {
                                barrier();
                               }
                              while(_GLF_WRAPPED_LOOP(false));
                             }
                            else
                             {
                             }
                           }
                         }
                        while((bvec4(false, false, false, false) == bvec4(true, false, false, false)))
                         {
                          switch(_GLF_SWITCH(0))
                           {
                            case 48:
                            -45393;
                            case 0:
                            case 64:
                            case 18:
                            if(_GLF_DEAD(false))
                             barrier();
                            for(int _injected_loop_counter = (1 ^ ((1 << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), int(2)))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                             {
                              for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                               {
                                bvec4(false, false, true, true);
                                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                 {
                                  for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < _GLF_IDENTITY(1, (1) / 1)); _injected_loop_counter ++)
                                   {
                                    barrier();
                                   }
                                 }
                               }
                             }
                            if(_GLF_DEAD(false))
                             {
                              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                               barrier();
                              break;
                             }
                            if(_GLF_DEAD(false))
                             barrier();
                            case 10:
                            float _GLF_SWITCH_1_6v, _GLF_SWITCH_1_7v;
                            mat4(8.9, -918.128, -2.3, 6300.0367, -548.596, 35.93, -7.1, 61.31, 7604.7393, 8.7, -724.662, 7005.2847, -6213.7071, 9.0, -659.096, -1391.2501);
                            mat3(334.982, -9.8, 957.793, 30.65, -80.70, -2.3, 799.239, 880.051, 8.1);
                            case 93:
                            case 69:
                            case 87:
                            (mat2(-7.5, 2.1, 5292.7155, -0.6) * (+ mat4x2(-617.895, 41.21, -2.7, 566.023, -3.9, -3364.2186, -2709.4476, 7145.9425)));
                            if(_GLF_DEAD(false))
                             barrier();
                            break;
                            case 55:
                            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                             barrier();
                            do
                             {
                              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                               barrier();
                             }
                            while(_GLF_WRAPPED_LOOP(false));
                            vec2(534.135, 3.5);
                            if(_GLF_DEAD(false))
                             barrier();
                            default:
                            1;
                           }
                         }
                        if(_GLF_DEAD(false))
                         continue;
                        if(_GLF_DEAD(false))
                         {
                          if(_GLF_WRAPPED_IF_FALSE(false))
                           {
                            if(_GLF_DEAD(false))
                             {
                              for(int _injected_loop_counter = (0 | _GLF_IDENTITY(1, clamp(1, 1, 1))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                               {
                                return;
                               }
                             }
                            if(_GLF_DEAD(false))
                             barrier();
                           }
                          else
                           {
                            if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                             {
                             }
                            else
                             {
                              barrier();
                             }
                           }
                         }
                        if(_GLF_DEAD(false))
                         barrier();
                        if(_GLF_DEAD(false))
                         {
                          if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                           {
                            barrier();
                           }
                          else
                           {
                           }
                         }
                        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                         {
                          if(_GLF_DEAD(false))
                           barrier();
                          if(_GLF_DEAD(false))
                           barrier();
                          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                           {
                            if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, mix(float(_GLF_FUZZED(-45.31)), float(injectionSwitch.x), bool(true))) > injectionSwitch.y))))
                             return;
                            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                             break;
                            barrier();
                           }
                          if(_GLF_DEAD(false))
                           barrier();
                          continue;
                         }
                       }
                     }
                    for(int _injected_loop_counter = ((0 << _GLF_IDENTITY(int(3), int(3))) | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                     {
                      if(_GLF_DEAD(false))
                       {
                        if(_GLF_WRAPPED_IF_FALSE(false))
                         {
                         }
                        else
                         {
                          barrier();
                         }
                       }
                      if(_GLF_DEAD(false))
                       {
                        if(_GLF_DEAD(false))
                         {
                          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                           return;
                          return;
                         }
                        do
                         {
                          barrier();
                         }
                        while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                       }
                     }
                   }
                   case 96:
                   if(_GLF_DEAD(false))
                    return;
                   subgroup_local_id;
                   case 0:
                   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 ^ int(_GLF_ZERO(0.0, injectionSwitch.x)))); _injected_loop_counter --)
                    {
                     if(_GLF_WRAPPED_IF_FALSE(false))
                      {
                       if(_GLF_DEAD(false))
                        barrier();
                      }
                     else
                      {
                       if(_GLF_WRAPPED_IF_TRUE(true))
                        {
                         if(_GLF_DEAD(false))
                          barrier();
                         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, ! (! (false))), (_GLF_IDENTITY(false, ! (! (false)))) || false)))
                          return;
                        }
                       else
                        {
                        }
                      }
                    }
                   for(int _injected_loop_counter = (1 | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY(0, (0) | (-94745 & 0))); _injected_loop_counter --)
                    {
                     if(_GLF_WRAPPED_IF_FALSE(false))
                      {
                       if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, _GLF_IDENTITY(float(mat3x4(_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) + 0.0), 1.0, log(1.0), 0.0, 0.0, sqrt(1.0), 0.0, 0.0, _GLF_ONE(1.0, injectionSwitch.y), 0.0, _GLF_ZERO(0.0, injectionSwitch.x), 0.0)), max(float(mat3x4(_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) + 0.0), 1.0, log(1.0), 0.0, 0.0, sqrt(1.0), 0.0, 0.0, _GLF_ONE(1.0, injectionSwitch.y), 0.0, _GLF_ZERO(0.0, injectionSwitch.x), 0.0)), float(mat3x4(_GLF_IDENTITY(injectionSwitch.x, (injectionSwitch.x) + 0.0), 1.0, log(1.0), 0.0, 0.0, sqrt(1.0), 0.0, 0.0, _GLF_ONE(1.0, injectionSwitch.y), 0.0, _GLF_ZERO(0.0, injectionSwitch.x), 0.0))))) > injectionSwitch.y)) || (false))))
                        {
                         if(_GLF_WRAPPED_IF_TRUE(true))
                          {
                           if(_GLF_WRAPPED_IF_FALSE(false))
                            {
                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              {
                               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                                {
                                 barrier();
                                }
                               else
                                {
                                }
                              }
                            }
                           else
                            {
                             for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                              {
                               switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                                {
                                 case 93:
                                 (bitfieldReverse(uvec2(104632u, 28052u)) != uvec2(66840u, 91855u));
                                 case 0:
                                 case 54:
                                 case 50:
                                 if(_GLF_DEAD(false))
                                  barrier();
                                 case 16:
                                 if(_GLF_DEAD(false))
                                  {
                                   if(_GLF_WRAPPED_IF_TRUE(true))
                                    {
                                     barrier();
                                    }
                                   else
                                    {
                                    }
                                  }
                                 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                  {
                                  }
                                 else
                                  {
                                   if(_GLF_DEAD(false))
                                    barrier();
                                   return;
                                  }
                                 break;
                                 case 88:
                                 if(_GLF_WRAPPED_IF_FALSE(false))
                                  {
                                  }
                                 else
                                  {
                                   ;
                                  }
                                 if(_GLF_DEAD(false))
                                  barrier();
                                 case 35:
                                 ;
                                 default:
                                 if(_GLF_DEAD(_GLF_IDENTITY(false, false || (_GLF_IDENTITY(false, true && (false))))))
                                  barrier();
                                 1;
                                }
                              }
                            }
                          }
                         else
                          {
                          }
                        }
                      }
                     else
                      {
                       if(_GLF_DEAD(false))
                        barrier();
                       if(_GLF_DEAD(false))
                        {
                         do
                          {
                           if(_GLF_WRAPPED_IF_TRUE(true))
                            {
                             barrier();
                            }
                           else
                            {
                             if(_GLF_DEAD(false))
                              barrier();
                            }
                          }
                         while(_GLF_WRAPPED_LOOP(false));
                        }
                       switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                        {
                         case 0:
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          barrier();
                         if(_GLF_DEAD(false))
                          barrier();
                         case 7:
                         case 98:
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          barrier();
                         if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, bool(bool(_GLF_IDENTITY(injectionSwitch.x > injectionSwitch.y, (injectionSwitch.x > injectionSwitch.y) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))))))))
                          {
                           if(_GLF_WRAPPED_IF_TRUE(true))
                            {
                             return;
                            }
                           else
                            {
                            }
                           if(_GLF_DEAD(false))
                            barrier();
                           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                            barrier();
                          }
                         if(_GLF_DEAD(false))
                          barrier();
                         if(_GLF_WRAPPED_IF_TRUE(true))
                          {
                           return;
                          }
                         else
                          {
                          }
                         break;
                         case 63:
                         do
                          {
                           for(                           ivec4(30314, -64879, -51267, 89523);
 true; mat2x4(-40.63, 4000.1804, 45.43, 405.907, -1.4, -2.5, -61.62, 6.9))
                            {
                             if(_GLF_DEAD(false))
                              break;
                             if(_GLF_DEAD(false))
                              {
                               if(_GLF_WRAPPED_IF_TRUE(true))
                                {
                                 barrier();
                                }
                               else
                                {
                                }
                              }
                             if(_GLF_DEAD(false))
                              {
                               if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, bool(bvec3(false, false, false))))))))
                                continue;
                               break;
                              }
                             if(_GLF_DEAD(false))
                              {
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                barrier();
                               barrier();
                              }
                            }
                           {
                            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                             continue;
                            if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, false || (false)))))))
                             barrier();
                            for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                             {
                              if(_GLF_DEAD(false))
                               barrier();
                              mod((- _GLF_IDENTITY(-4.9, clamp(-4.9, _GLF_IDENTITY(-4.9, max(-4.9, -4.9)), -4.9))), -7760.4574);
                             }
                            if(_GLF_DEAD(false))
                             {
                              if(_GLF_DEAD(false))
                               break;
                              barrier();
                             }
                            ;
                           }
                           if(_GLF_DEAD(false))
                            return;
                           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                            {
                             if(_GLF_DEAD(false))
                              barrier();
                            }
                           else
                            {
                            }
                           isinf(mod(vec3(-4.5, 7.7, 9173.0000), vec3(-1259.2372, -88.28, 2.2)));
                           ;
                           if(_GLF_DEAD(false))
                            {
                             switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                              {
                               case 0:
                               if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, min(injectionSwitch, _GLF_IDENTITY(injectionSwitch, clamp(injectionSwitch, injectionSwitch, injectionSwitch)))).x > injectionSwitch.y))))
                                continue;
                               for(int _injected_loop_counter = (_GLF_IDENTITY((1 << _GLF_IDENTITY(int(0), int(0))), 1 * ((1 << _GLF_IDENTITY(int(0), int(0))))) >> _GLF_IDENTITY(int(0), int(0))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                                {
                                 barrier();
                                }
                               break;
                               if(_GLF_DEAD(false))
                                continue;
                               case 60:
                               mat4x2(-0.7, 8.1, 81.33, 68.38, 6189.7292, 5.5, 70.93, -0.4);
                               if(_GLF_DEAD(false))
                                {
                                 do
                                  {
                                   do
                                    {
                                     return;
                                    }
                                   while(_GLF_WRAPPED_LOOP(false));
                                  }
                                 while(_GLF_WRAPPED_LOOP(false));
                                }
                               case 78:
                               mat4x2(-3.9, -3413.0434, 661.376, -17.85, -320.026, -14.40, 56.90, 1967.6341);
                               default:
                               1;
                              }
                            }
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            {
                             if(_GLF_DEAD(false))
                              continue;
                             continue;
                            }
                           if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, _GLF_IDENTITY(true && (true), (_GLF_IDENTITY(true && (true), bool(bvec2(true && (true), true)))) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))))
                            {
                             if(_GLF_DEAD(false))
                              barrier();
                             mat4x2(-121.740, 9569.5161, -737.596, -3.6, 60.06, 6.6, -827.893, -1.9);
                             if(_GLF_DEAD(false))
                              {
                               do
                                {
                                 if(_GLF_WRAPPED_IF_FALSE(false))
                                  {
                                  }
                                 else
                                  {
                                   return;
                                  }
                                }
                               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                              }
                             if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                              barrier();
                            }
                           else
                            {
                            }
                           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, true && _GLF_IDENTITY((_GLF_IDENTITY(false, (false) && true)), true && ((_GLF_IDENTITY(false, (false) && true))))), _GLF_IDENTITY(! (! (false)), bool(bvec3(_GLF_IDENTITY(! (! (false)), ! (! (! (! (false))))), true, true))))))
                            barrier();
                           ;
                           if(_GLF_DEAD(false))
                            {
                             do
                              {
                               return;
                              }
                             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                            }
                           mat4 _GLF_SWITCH_0_0v, _GLF_SWITCH_0_1v, _GLF_SWITCH_0_2v;
                           if(_GLF_DEAD(false))
                            barrier();
                           if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bool(false)), ! (! (bool(bool(false))))))))
                            barrier();
                           do
                            {
                             if(_GLF_WRAPPED_IF_TRUE(true))
                              {
                               if(_GLF_DEAD(false))
                                barrier();
                              }
                             else
                              {
                              }
                             if(_GLF_DEAD(false))
                              break;
                             if(_GLF_DEAD(false))
                              {
                               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                                {
                                 barrier();
                                }
                               else
                                {
                                }
                              }
                             switch(_GLF_SWITCH(0))
                              {
                               case 39:
                               ivec3 _GLF_SWITCH_1_0v, _GLF_SWITCH_1_1v, _GLF_SWITCH_1_2v;
                               case 13:
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                barrier();
                               mat3 _GLF_SWITCH_1_3v, _GLF_SWITCH_1_4v;
                               case 0:
                               mat4x2 _GLF_SWITCH_0_3v, _GLF_SWITCH_0_4v[29], _GLF_SWITCH_0_5v;
                               if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bool(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
                                barrier();
                               if(_GLF_WRAPPED_IF_FALSE(false))
                                {
                                }
                               else
                                {
                                 (floatBitsToUint((-7.2 - vec3(122.467, -9.5, 1107.2437))) & next_virtual_gid);
                                }
                               case 47:
                               if(_GLF_DEAD(false))
                                continue;
                               case 53:
                               bool _GLF_SWITCH_0_6v[41], _GLF_SWITCH_0_7v;
                               case 11:
                               if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(false, false, true, false)))))
                                {
                                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                  barrier();
                                 break;
                                }
                               mat4x2 _GLF_SWITCH_0_8v[66], _GLF_SWITCH_0_9v, _GLF_SWITCH_0_10v;
                               if(_GLF_DEAD(false))
                                barrier();
                               if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(_GLF_IDENTITY(false, (false) || false), true, false)))))
                                {
                                 if(_GLF_WRAPPED_IF_FALSE(false))
                                  {
                                  }
                                 else
                                  {
                                   barrier();
                                  }
                                }
                               injectionSwitch;
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                return;
                               case 98:
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                barrier();
                               if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, bool(bvec4(true, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, false)))))
                                {
                                 if(_GLF_DEAD(false))
                                  {
                                   switch(_GLF_SWITCH(0))
                                    {
                                     case 0:
                                     case 23:
                                     case 76:
                                     case 84:
                                     do
                                      {
                                       if(_GLF_DEAD(false))
                                        break;
                                       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                                        {
                                         barrier();
                                        }
                                      }
                                     while(_GLF_WRAPPED_LOOP(false));
                                     break;
                                     case 40:
                                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                      {
                                       do
                                        {
                                         barrier();
                                        }
                                       while(_GLF_WRAPPED_LOOP(false));
                                      }
                                     uint _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v[4];
                                     default:
                                     1;
                                     if(_GLF_DEAD(false))
                                      barrier();
                                    }
                                  }
                                }
                               else
                                {
                                }
                               case 74:
                               if(_GLF_DEAD(false))
                                return;
                               mat4x3 _GLF_SWITCH_0_11v, _GLF_SWITCH_0_12v;
                               if(_GLF_DEAD(false))
                                {
                                 if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch.x, float(vec4(_GLF_IDENTITY(injectionSwitch.x, min(_GLF_IDENTITY(injectionSwitch.x, max(injectionSwitch.x, injectionSwitch.x)), injectionSwitch.x)), 0.0, 0.0, 0.0))) > injectionSwitch.y))))
                                  {
                                   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                                    {
                                     barrier();
                                    }
                                   else
                                    {
                                    }
                                  }
                                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                  return;
                                 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                  {
                                  }
                                 else
                                  {
                                   if(_GLF_DEAD(false))
                                    {
                                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                      barrier();
                                     barrier();
                                    }
                                  }
                                 if(_GLF_DEAD(false))
                                  barrier();
                                 barrier();
                                }
                               if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, true && (true))))
                                {
                                 6.8;
                                }
                               else
                                {
                                }
                               case 99:
                               if(_GLF_DEAD(false))
                                barrier();
                               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                                {
                                 if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, false, false)))))
                                  barrier();
                                }
                               else
                                {
                                }
                               if(_GLF_DEAD(false))
                                {
                                 if(_GLF_DEAD(false))
                                  continue;
                                 break;
                                }
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                {
                                 if(_GLF_DEAD(_GLF_FALSE(false, _GLF_IDENTITY((injectionSwitch.x > injectionSwitch.y), ((injectionSwitch.x > injectionSwitch.y)) || false))))
                                  return;
                                 do
                                  {
                                   barrier();
                                  }
                                 while(_GLF_WRAPPED_LOOP(false));
                                }
                               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                                {
                                 if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && true))
                                  barrier();
                                }
                               else
                                {
                                }
                               case 57:
                               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                {
                                }
                               else
                                {
                                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                                  {
                                   if(_GLF_DEAD(false))
                                    barrier();
                                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                    {
                                     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                                      {
                                       return;
                                      }
                                    }
                                  }
                                }
                               case 63:
                               case 19:
                               ivec4(87519, 66844, 13921, -43898);
                               if(_GLF_DEAD(false))
                                return;
                               break;
                               case 15:
                               if(_GLF_DEAD(false))
                                barrier();
                               ivec4((+ 74397));
                               case 92:
                               if(_GLF_DEAD(false))
                                continue;
                               if(_GLF_DEAD(false))
                                barrier();
                               equal(vec4(-79.39, -6882.9326, 1.0, 308.975), vec4(7.1, -9.2, 4.0, -101.478));
                               default:
                               if(_GLF_WRAPPED_IF_TRUE(true))
                                {
                                 if(_GLF_DEAD(false))
                                  {
                                   if(_GLF_WRAPPED_IF_FALSE(false))
                                    {
                                    }
                                   else
                                    {
                                     barrier();
                                    }
                                  }
                                }
                               else
                                {
                                }
                               1;
                               if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), ! (! (! (false))))))))
                                barrier();
                              }
                             if(_GLF_DEAD(false))
                              barrier();
                             if(_GLF_DEAD(false))
                              barrier();
                             if(_GLF_DEAD(false))
                              continue;
                            }
                           while(bool((-71614 >> -20316)));
                           if(_GLF_IDENTITY(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), _GLF_IDENTITY(bool(bool(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))), ! (_GLF_IDENTITY(! (bool(bool(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))), ! (! (! (bool(bool(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))))))))
                            {
                             if(_GLF_WRAPPED_IF_TRUE(true))
                              {
                               barrier();
                              }
                             else
                              {
                              }
                            }
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            barrier();
                           if(_GLF_WRAPPED_IF_TRUE(true))
                            {
                             bvec4(false, false, true, false);
                            }
                           else
                            {
                            }
                           if(_GLF_DEAD(false))
                            break;
                          }
                         while(bool(36174));
                         default:
                         1;
                         if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                          return;
                         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 ^ 0) & 1)); _injected_loop_counter ++)
                          {
                           if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, (false) || false)) || false)))
                            barrier();
                          }
                         if(_GLF_WRAPPED_IF_FALSE(false))
                          {
                          }
                         else
                          {
                           if(_GLF_DEAD(false))
                            {
                             if(_GLF_WRAPPED_IF_TRUE(true))
                              {
                               barrier();
                              }
                             else
                              {
                              }
                            }
                          }
                        }
                       do
                        {
                         if(_GLF_DEAD(false))
                          return;
                        }
                       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                        {
                         if(_GLF_DEAD(_GLF_FALSE(_GLF_IDENTITY(false, ! (! (false))), (injectionSwitch.x > injectionSwitch.y))))
                          barrier();
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          {
                           if(_GLF_DEAD(false))
                            barrier();
                           return;
                          }
                        }
                       else
                        {
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_WRAPPED_IF_FALSE(false))
                            {
                            }
                           else
                            {
                             barrier();
                            }
                          }
                         if(_GLF_DEAD(false))
                          barrier();
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            barrier();
                           return;
                          }
                        }
                      }
                    }
                   if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, true && (false))) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))
                    return;
                   break;
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                      {
                       if(_GLF_DEAD(false))
                        return;
                       barrier();
                      }
                     else
                      {
                      }
                    }
                   for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), int(0))); _GLF_WRAPPED_LOOP(_injected_loop_counter != ((0 ^ 0) & -67771)); _injected_loop_counter --)
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      return;
                    }
                   if(_GLF_DEAD(false))
                    return;
                   default:
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_DEAD(false))
                    return;
                   1;
                  }
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    return;
                  }
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                    {
                     return;
                    }
                   else
                    {
                    }
                  }
                 if(_GLF_DEAD(_GLF_FALSE(false, (_GLF_IDENTITY(injectionSwitch, (true ? injectionSwitch : _GLF_FUZZED(vec2(-722.505, 8.0)))).x > injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(false))
                    return;
                   barrier();
                  }
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   return;
                  }
                }
               else
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   return;
                  }
                }
               if(_GLF_DEAD(false))
                barrier();
               case 86:
               case 98:
               do
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                    }
                   else
                    {
                     return;
                    }
                  }
                }
               while(_GLF_WRAPPED_LOOP(false));
               break;
               case 69:
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 (8561.8211 - mat2x4(0.3, 53.19, -8240.1531, -7.1, 8.2, -3.5, -8.0, -2.6));
                 mat3x2 _GLF_SWITCH_3_1v[74], _GLF_SWITCH_3_2v, _GLF_SWITCH_3_3v;
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      {
                      }
                     else
                      {
                       barrier();
                      }
                    }
                  }
                 else
                  {
                  }
                 vec4 _GLF_SWITCH_3_4v[60], _GLF_SWITCH_3_5v[75];
                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 >> _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(6), (int(6)) | (int(6)))))); _injected_loop_counter --)
                  {
                   ;
                  }
                 mat3 _GLF_SWITCH_3_6v[23];
                 mat4x2(5.0, -130.462, 2168.7380, -2053.8739, 9325.0531, -4.7, 6.3, 846.718);
                 bvec4(true, false, false, false);
                 if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                  barrier();
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_WRAPPED_IF_TRUE(true))
                    {
                     barrier();
                    }
                   else
                    {
                    }
                  }
                 ivec2(-50541, -52608);
                 mat4x3 _GLF_SWITCH_3_7v, _GLF_SWITCH_3_8v[84];
                }
               else
                {
                }
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   barrier();
                  }
                }
               case 43:
               vec4 _GLF_SWITCH_3_9v;
               default:
               1;
              }
            }
           barrier();
          }
        }
       break;
       default:
       1;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     do
      {
       for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
        {
         if(_GLF_DEAD(false))
          barrier();
        }
      }
     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(false))
            barrier();
           return;
          }
        }
      }
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
        {
         do
          {
           return;
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
        }
       do
        {
         return;
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           barrier();
          }
         else
          {
          }
        }
      }
     else
      {
      }
    }
   if(_GLF_DEAD(false))
    barrier();
   do
    {
     subgroupAll(_GLF_IDENTITY(false, ! (! (false))));
    }
   while(_GLF_WRAPPED_LOOP(false));
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
    {
     do
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
        continue;
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
              barrier();
             if(_GLF_DEAD(false))
              return;
            }
           else
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_DEAD(false))
                barrier();
              }
             else
              {
              }
             return;
            }
          }
         else
          {
          }
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               barrier();
              }
             return;
            }
          }
         else
          {
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
        }
      }
     while(_GLF_WRAPPED_LOOP(false));
     if(_GLF_DEAD(false))
      barrier();
    }
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (_GLF_IDENTITY(! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))), (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))) && _GLF_IDENTITY(true, (true) && true))))))
        {
         do
          {
           barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
         while(_GLF_WRAPPED_LOOP(false));
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(false))
          barrier();
        }
      }
     else
      {
      }
    }
   else
    {
    }
   do
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       return;
      }
    }
   while(_GLF_WRAPPED_LOOP(false));
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
        {
         barrier();
        }
      }
    }
  }
 else
  {
   do
    {
     switch(_GLF_SWITCH(0))
      {
       case 13:
       mat3x4 _GLF_SWITCH_3_0v[10], _GLF_SWITCH_3_1v[75], _GLF_SWITCH_3_2v[14];
       case 0:
       case 85:
       case 31:
       case 21:
       atomicStore(buf[virtual_gid], read, 4, 64, 4);
       break;
       case 23:
       if(true)
        {
         do
          {
           if(true)
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
             bvec2(true, true).ss;
             uvec2 _GLF_SWITCH_3_3v;
             if(_GLF_DEAD(false))
              barrier();
             atanh(vec4(7.0, -60.09, -4945.7422, 2303.0700));
             (ivec4(-25657, -24333, -17569, 90682) , (mat4x2(6.7, 398.666, -335.030, 8.5, 415.755, -9.2, 8.2, 966.894) - mat4x2(-28.95, 1.2, 1.6, 3.2, 524.994, -46.83, 667.098, -73.57)));
             uvec4 _GLF_SWITCH_3_4v;
             mat3(-83.59, 97.31, -3.0, 7.0, -9.2, -1.8, 58.92, 1.4, -31.16);
            }
           else
            {
             if(_GLF_DEAD(false))
              barrier();
             ;
             uvec3 _GLF_SWITCH_3_5v, _GLF_SWITCH_3_6v, _GLF_SWITCH_3_7v[16];
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             isnan(vec4(-7.8, 427.754, -5.5, 24.98));
             ivec2(ivec3(31792, -12336, -73961));
             (vec3(-8833.3235, 2.2, 1.1) , equal(injectionSwitch, injectionSwitch));
             mat2(injectionSwitch, vec2(-6.3, 1611.0489));
             ivec4 _GLF_SWITCH_3_8v, _GLF_SWITCH_3_9v, _GLF_SWITCH_3_10v;
            }
          }
         while(_GLF_WRAPPED_LOOP(false));
         ivec4 _GLF_SWITCH_3_11v;
         do
          {
           mat4x3(mat2(-8919.8561, -6.8, -3490.8618, 0.5));
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             do
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               barrier();
              }
            }
           clamp(uvec3(113338u, 124073u, 75306u), uvec3(86918u, 68339u, 190403u), uvec3(163593u, 107156u, 153509u));
           ivec2(ivec4(-69115, 73996, -13598, -95000));
           mat2 _GLF_SWITCH_3_12v, _GLF_SWITCH_3_13v, _GLF_SWITCH_3_14v[48];
           (ivec4(76917, 6977, _GLF_IDENTITY(84679, (_GLF_IDENTITY(84679, int(int(84679)))) << (0 << _GLF_IDENTITY(int(6), int(6)))), -2223) | floatBitsToInt(3.2));
           if(_GLF_DEAD(false))
            barrier();
          }
         while((_GLF_SWITCH_3_11v == ivec4(36372, ivec3(16823, 60329, 48908))));
         if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
          barrier();
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           -73527;
          }
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           ;
          }
         if(_GLF_DEAD(false))
          barrier();
         vec2(0.9, 497.243);
         mat2x3 _GLF_SWITCH_3_15v[45];
         for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(7), _GLF_IDENTITY(int(7), (_GLF_IDENTITY(int(7), (int(7)) ^ 0)) - 0))); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
          {
           for(bvec4 _GLF_SWITCH_3_16v[27], _GLF_SWITCH_3_17v[13], _GLF_SWITCH_3_18v; true; vec3(-3.0))
            {
             mat4x2(-508.787, -32.80, 5.7, -235.977, -1.3, 267.069, -14.23, -66.44);
             ;
             mat4 _GLF_SWITCH_3_19v, _GLF_SWITCH_3_20v, _GLF_SWITCH_3_21v;
            }
          }
        }
       default:
       1;
      }
    }
   while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(false))
      return;
    }
   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
    }
   else
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       else
        {
         if(_GLF_DEAD(false))
          return;
         for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 & 1)); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
              return;
             if(_GLF_DEAD(false))
              return;
             barrier();
            }
          }
        }
       return;
      }
    }
   subgroupAll(true);
   if(_GLF_DEAD(false))
    {
     for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(4), int(4))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
      {
       barrier();
      }
    }
   if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
    {
     switch(_GLF_SWITCH(0))
      {
       case 36:
       while((uvec3(96839u, 10627u, 93471u) != uvec3(96208u, 81398u, 79083u)))
        {
         for(         mat3(-16.63, -2.0, _GLF_IDENTITY(2.4, (2.4) + 0.0), 6.0, -1.0, -8.0, -1670.5871, -2.6, 4.6);
 true; mat3x4(-136.399, -5.4, -4.0, 213.930, -3.7, 541.636, 0.7, -0.0, 433.706, -534.902, -692.711, 6.8))
          {
           mat4 _GLF_SWITCH_3_0v;
           bvec4 _GLF_SWITCH_3_1v[68], _GLF_SWITCH_3_2v;
           do
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > _GLF_IDENTITY(injectionSwitch, min(_GLF_IDENTITY(injectionSwitch, max(injectionSwitch, _GLF_IDENTITY(injectionSwitch, min(injectionSwitch, injectionSwitch)))), injectionSwitch)).y))))
              barrier();
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           do
            {
             ;
            }
           while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (false))));
          }
         do
          {
           5745.8736;
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
         {
          mat4x3 _GLF_SWITCH_3_3v;
          uvec3(124775u, 36893u, 54235u);
          mat3 _GLF_SWITCH_3_4v;
          bvec2 _GLF_SWITCH_3_5v, _GLF_SWITCH_3_6v, _GLF_SWITCH_3_7v;
          uvec3 _GLF_SWITCH_3_8v, _GLF_SWITCH_3_9v;
          vec2 _GLF_SWITCH_3_10v, _GLF_SWITCH_3_11v[47], _GLF_SWITCH_3_12v[22];
          if(_GLF_DEAD(false))
           barrier();
         }
         if(_GLF_DEAD(false))
          barrier();
        }
       case 0:
       if(_GLF_DEAD(false))
        {
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
          {
           do
            {
             barrier();
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
        }
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           do
            {
             barrier();
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
          }
        }
       else
        {
        }
       break;
       if(_GLF_DEAD(false))
        {
         for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), int(1))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
          {
           barrier();
          }
        }
       default:
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (0 | 1)); _injected_loop_counter ++)
        {
         do
          {
           1;
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
      }
    }
   if(_GLF_DEAD(false))
    return;
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   return;
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(false))
      {
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
        {
         barrier();
        }
      }
     do
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(false))
            {
             do
              {
               barrier();
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
          }
         if(_GLF_DEAD(false))
          barrier();
         return;
        }
       return;
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     barrier();
    }
   return;
   if(_GLF_DEAD(false))
    return;
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         barrier();
        }
       else
        {
        }
      }
     return;
    }
   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
    {
     if(_GLF_DEAD(false))
      {
       for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(5), int(5))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
        {
         barrier();
        }
      }
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          barrier();
         return;
        }
      }
     else
      {
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
    }
   else
    {
    }
   if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_IDENTITY(bool(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))), (bool(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))) || false))))
    {
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
      {
       return;
      }
     else
      {
      }
     if(_GLF_DEAD(false))
      barrier();
    }
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), (int(2)) | 0))); _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), int(4)))); _injected_loop_counter ++)
      {
       if(_GLF_DEAD(false))
        barrier();
      }
     for(int _injected_loop_counter = _GLF_IDENTITY(0, 0 ^ (0)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
      {
       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
        return;
      }
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
       if(_GLF_DEAD(false))
        return;
       do
        {
         if(_GLF_DEAD(false))
          {
           do
            {
             if(_GLF_IDENTITY(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && true)) && true), false || (_GLF_DEAD(false))))
              return;
            }
           while(_GLF_WRAPPED_LOOP(false));
           barrier();
          }
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
     else
      {
       barrier();
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), _GLF_IDENTITY(int(1), 0 ^ (int(1)))))); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                continue;
               return;
              }
             if(_GLF_IDENTITY(_GLF_DEAD(false), (_GLF_DEAD(false)) && true))
              barrier();
             barrier();
             do
              {
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                    {
                     return;
                    }
                  }
                 if(_GLF_DEAD(false))
                  barrier();
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
           if(_GLF_DEAD(false))
            break;
          }
        }
       else
        {
        }
       if(_GLF_DEAD(false))
        barrier();
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
    }
   else
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, false || (_GLF_IDENTITY(true, (true) || false)))))
        {
         barrier();
        }
       else
        {
        }
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if(_GLF_IDENTITY(_GLF_DEAD(false), ! (! (_GLF_DEAD(false)))))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       return;
      }
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, _GLF_IDENTITY(injectionSwitch, vec2(injectionSwitch[0], _GLF_IDENTITY(injectionSwitch[1], clamp(injectionSwitch[1], injectionSwitch[1], injectionSwitch[1])))).y))); _injected_loop_counter ++)
    {
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        barrier();
       break;
      }
    }
   do
    {
     for(int _injected_loop_counter = (0 ^ 1); _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 | (0 | 0))); _injected_loop_counter --)
      {
       do
        {
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_IDENTITY(bool(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false, false)), true && (bool(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false, false)))))))
          {
           for(int _injected_loop_counter = (int(_GLF_ZERO(0.0, injectionSwitch.x)) << _GLF_IDENTITY(int(5), _GLF_IDENTITY(int(5), (false ? _GLF_FUZZED(-38912) : int(5))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(false))
            barrier();
           return;
          }
        }
       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
      }
    }
   while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, bool(bvec4(false, false, true, false)))));
   if(_GLF_DEAD(false))
    {
     do
      {
       return;
       if(_GLF_DEAD(false))
        barrier();
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
      }
     return;
    }
  }
}
