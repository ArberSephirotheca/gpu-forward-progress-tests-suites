#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if(_GLF_DEAD(false))
  return;
 uint subgroup_id = gl_SubgroupID;
 do
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       return;
      }
     else
      {
       if(_GLF_DEAD(false))
        return;
      }
    }
  }
 while(_GLF_WRAPPED_LOOP(false));
 if(_GLF_DEAD(false))
  return;
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     switch(_GLF_SWITCH((0 & 78829)))
      {
       case 47:
       mat3 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v;
       case 88:
       {
        vec4 _GLF_SWITCH_5_2v[41], _GLF_SWITCH_5_3v;
        if(_GLF_DEAD(false))
         return;
        mat2x3(-26.84, 0.9, 8.0, 0.7, -1805.5324, -7.8);
        uvec4 _GLF_SWITCH_5_4v, _GLF_SWITCH_5_5v;
        for(uvec2 _GLF_SWITCH_5_6v, _GLF_SWITCH_5_7v[92]; true; 16893u)
         {
          (ivec2(-6096, 24213) , (false ? ivec3(83996, -95982, 37238) : ivec3(21611)));
          bvec3(false, true, true);
          uvec3 _GLF_SWITCH_5_8v;
         }
        while((mat3x4(7641.9985, -9644.9083, -62.41, -3.2, -91.83, 1530.4922, 99.16, -2.8, -2656.4126, -7.4, -901.594, 80.74) == (mat3x4(0.3, 3761.4180, -64.34, -42.87, -740.005, -559.416, -3.3, 970.028, 151.095, -6.0, 0.4, -745.407) + mat3x4(8869.3768, -2285.4689, -2.1, 6.4, -499.676, -368.397, -43.21, 4.5, -5.8, 1323.5525, -779.055, -9411.5045))))
         {
          injectionSwitch;
          vec4 _GLF_SWITCH_5_9v[57], _GLF_SWITCH_5_10v;
         }
        (mat2x3(-4.4, 36.14, -3925.5703, 458.109, 954.540, -8695.4440) * mat2(1.5, 59.23, 6760.8468, -37.09));
        if(_GLF_DEAD(false))
         return;
        false;
       }
       case 0:
       if(_GLF_DEAD(false))
        return;
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > ((0 >> _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(7), int(7)))); _injected_loop_counter --)
        {
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           do
            {
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 return;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                }
               else
                {
                }
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
          }
        }
       case 22:
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
            {
             barrier();
            }
          }
         return;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        return;
       break;
       default:
       1;
      }
    }
   else
    {
    }
  }
uint subgroup_size = 16;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  {
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
    {
     if(_GLF_DEAD(false))
      return;
     return;
     if(_GLF_DEAD(false))
      break;
    }
  }
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   do
    {
     switch(_GLF_SWITCH(0))
      {
       case 56:
       uvec3 _GLF_SWITCH_4_0v;
       case 91:
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         bvec2(true, true)[0];
        }
       case 0:
       case 43:
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            continue;
           barrier();
          }
         barrier();
        }
       break;
       case 42:
       mat4x2(0.8, 1.4, 5.5, 5.4, -607.313, -4.0, 0.4, 9.7);
       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
        {
         if(_GLF_DEAD(false))
          return;
         continue;
        }
       default:
       1;
      }
    }
   while(_GLF_WRAPPED_LOOP(false));
  }
 else
  {
  }
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 else
  {
   if(_GLF_DEAD(false))
    return;
  }
 if(_GLF_DEAD(false))
  return;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
  return;
 uint num_workgroup = gl_NumWorkGroups.x;
 uint workgroup_size = gl_WorkGroupSize.x;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   do
    {
     if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
      break;
     return;
    }
   while(_GLF_WRAPPED_LOOP(false));
  }
 uint workgroup_id = gl_WorkGroupID.x;
 uint workgroup_base = workgroup_size * workgroup_id;
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 else
  {
  }
 if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, false)))))
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     barrier();
    }
  }
 if(_GLF_DEAD(false))
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     barrier();
     if(_GLF_DEAD(false))
      return;
    }
   else
    {
    }
  }
 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
  {
   if(_GLF_DEAD(false))
    {
     do
      {
       switch(_GLF_SWITCH(0))
        {
         case 21:
         true;
         case 78:
         while(((true ? mat3x4(-2884.2301, -31.03, -2.0, -3502.2156, -2.5, 712.832, 656.128, 94.46, -6030.5702, -3.6, 1.3, -5.4) : mat3x4(85.59, 2573.7313, -5.4, -7.8, -9.2, -2498.2267, -82.73, -431.897, 5.3, -5.3, -7.0, -395.172)) == mat3x4(7.5, -5.5, -570.517, 414.251, -90.31, -1.0, 893.485, -427.422, -308.946, 838.846, 7.1, 4.1)))
          {
           if(_GLF_DEAD(false))
            return;
           while(false)
            {
             vec3(-293.185, -4820.4941, -7.0);
             do
              {
               mat4x2(-5.4, -254.819, 1.7, 48.67, -9.5, -4.2, 822.465, 713.264);
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
             packHalf2x16(vec2(1464.2832, -315.505));
             if(_GLF_DEAD(false))
              return;
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                 switch(_GLF_SWITCH(0))
                  {
                   case 0:
                   case 35:
                   case 16:
                   if(_GLF_DEAD(false))
                    break;
                   case 5:
                   case 2:
                   if(_GLF_DEAD(false))
                    return;
                   do
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      return;
                     if(_GLF_DEAD(false))
                      continue;
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                   case 52:
                   case 77:
                   case 17:
                   case 81:
                   continue;
                   break;
                   case 24:
                   mat3x4(3.1, 16.57, -5097.5773, -3.0, 9.7, -1.2, -339.480, 0.4, 87.44, 0.5, 5.9, -1200.4116);
                   default:
                   do
                    {
                     if(_GLF_DEAD(false))
                      break;
                     1;
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                  }
                }
              }
             else
              {
               switch(_GLF_SWITCH((0 >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), 0 ^ (int(0)))))))
                {
                 case 0:
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   for(                   (uvec4(37376u, 71862u, 110734u, 159641u) ^ workgroup_id);
 false; bvec2(true, false))
                    {
                     if(_GLF_WRAPPED_IF_TRUE(true))
                      {
                       bitCount(workgroup_base);
                      }
                     else
                      {
                      }
                     if(_GLF_DEAD(false))
                      break;
                     mat3x4 _GLF_SWITCH_2_0v[41];
                     mat3x4 _GLF_SWITCH_2_1v, _GLF_SWITCH_2_2v;
                     true;
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      return;
                     ivec4 _GLF_SWITCH_2_3v, _GLF_SWITCH_2_4v[45];
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        break;
                       if(_GLF_DEAD(false))
                        return;
                       break;
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        continue;
                      }
                     if(_GLF_WRAPPED_IF_FALSE(false))
                      {
                      }
                     else
                      {
                       if(_GLF_DEAD(false))
                        continue;
                       ivec4(-76651, 87128, -62953, -95432);
                      }
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      break;
                     (true ? bvec2(true, false) : bvec2(true, false));
                    }
                  }
                 else
                  {
                  }
                 if(_GLF_DEAD(false))
                  continue;
                 break;
                 case 41:
                 asinh(vec2(-52.83, -3.2));
                 if(_GLF_DEAD(false))
                  break;
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      {
                      }
                     else
                      {
                       return;
                      }
                    }
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_WRAPPED_IF_FALSE(false))
                      {
                      }
                     else
                      {
                       barrier();
                      }
                    }
                   break;
                  }
                 case 24:
                 vec4 _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v, _GLF_SWITCH_3_2v;
                 default:
                 1;
                }
              }
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                break;
               do
                {
                 barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(false))
              continue;
            }
           mat3(-19.61, 286.347, -99.59, 4183.4866, -41.64, -711.310, -885.353, 21.38, -2366.1812);
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(false))
            continue;
           ivec3 _GLF_SWITCH_2_5v[42];
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           do
            {
             while((vec4(776.492, 16.89, 7.7, -4.9) == vec4(-1.8, 20.46, 582.107, 2.0)))
              {
               round(vec2(-810.212, 23.22));
               greaterThanEqual(uvec4(33727u, 192554u, 12449u, 24102u), uvec4(7850u, 173554u, 4364u, 255u));
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(false))
                barrier();
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
            }
           float _GLF_SWITCH_2_6v;
           if(_GLF_DEAD(false))
            return;
           if((transpose(mat4(799.665, 8.4, -9443.6137, -9520.3508, -9.1, -4676.8068, -9.7, 4.2, -53.26, -438.757, 31.85, 2.9, 4913.4527, 970.146, -6276.4398, 3895.5197)) != (mat4(-3.9, -734.799, -1.3, -257.383, 4.2, 9.9, -0.7, -1.8, 4.6, -859.807, 7.3, -58.05, -4.4, -240.603, -8166.5535, 362.158) - atanh(4339.9807))))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 barrier();
                }
               else
                {
                }
              }
             mat4x2 _GLF_SWITCH_2_7v, _GLF_SWITCH_2_8v, _GLF_SWITCH_2_9v[22];
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
             {
              for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
               {
                uvec3(74598u, 39065u, 120660u);
               }
              ;
              if(_GLF_WRAPPED_IF_FALSE(false))
               {
               }
              else
               {
                if(_GLF_DEAD(false))
                 {
                  if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   {
                   }
                  else
                   {
                    return;
                   }
                 }
               }
              if(_GLF_WRAPPED_IF_TRUE(true))
               {
                bvec3(true, true, false);
               }
              else
               {
                if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                 {
                  if(_GLF_DEAD(false))
                   {
                    if(_GLF_WRAPPED_IF_TRUE(true))
                     {
                      return;
                     }
                    else
                     {
                     }
                   }
                 }
                else
                 {
                 }
               }
              do
               {
                if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                 {
                  if(_GLF_DEAD(false))
                   continue;
                  return;
                 }
                if(_GLF_DEAD(false))
                 continue;
               }
              while(_GLF_WRAPPED_LOOP(false));
              (ivec3(-14897, 64817, -5315) | ivec3(-34774, 72053, 22151));
              if(_GLF_DEAD(false))
               return;
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               continue;
              mat3(2.6, -86.00, -5.3, 563.819, -403.940, 1.8, -5.8, 5.6, -6319.1901);
              ivec4(37920, -47106, -46967, 69026)[1];
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               {
                if(_GLF_DEAD(false))
                 break;
                break;
               }
              float _GLF_SWITCH_2_10v, _GLF_SWITCH_2_11v;
              do
               {
                subgroup_id;
               }
              while(_GLF_WRAPPED_LOOP(false));
             }
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    break;
                   do
                    {
                     barrier();
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                   if(_GLF_DEAD(false))
                    return;
                  }
                 if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                  continue;
                }
               do
                {
                 if(_GLF_DEAD(false))
                  return;
                 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != (((0 ^ 1) << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), int(1)))); _injected_loop_counter ++)
                  {
                   return;
                  }
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                continue;
               return;
               if(_GLF_DEAD(false))
                return;
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
               if(_GLF_DEAD(false))
                return;
              }
             else
              {
               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (1 | 0)); _injected_loop_counter ++)
                {
                 ivec2(80939, -69752);
                }
               if(_GLF_DEAD(false))
                break;
              }
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               switch(_GLF_SWITCH(0))
                {
                 case 0:
                 case 75:
                 case 26:
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                 case 81:
                 case 3:
                 if(_GLF_DEAD(false))
                  return;
                 case 82:
                 case 30:
                 case 76:
                 case 67:
                 case 69:
                 ivec3(71706, -52579, 5631);
                 break;
                 case 61:
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   (uvec4(14532u, 13733u, 176245u, 108838u) << uvec4(113396u, 70594u, 134653u, 182147u));
                  }
                 if(_GLF_DEAD(false))
                  continue;
                 case 57:
                 do
                  {
                   (mat3x2(575.770, 6112.5382, -94.81, -49.57, -1.8, 53.72) * vec3(5.0, -6.7, -1253.2720));
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                 default:
                 1;
                }
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
               do
                {
                 switch(_GLF_SWITCH((1 ^ 1)))
                  {
                   case 53:
                   if(_GLF_DEAD(false))
                    continue;
                   mat4x3(mat2x3(727.379, 83.58, -51.26, 83.41, -864.318, -3.6));
                   case 0:
                   case 86:
                   case 98:
                   case 91:
                   case 84:
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     do
                      {
                       return;
                      }
                     while(_GLF_WRAPPED_LOOP(false));
                     if(_GLF_DEAD(false))
                      continue;
                    }
                   break;
                   case 16:
                   bool _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v[74], _GLF_SWITCH_5_2v;
                   case 17:
                   do
                    {
                     bvec2(false, false);
                    }
                   while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) || false)));
                   default:
                   1;
                  }
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
              }
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              break;
             uint _GLF_SWITCH_2_12v;
             if(_GLF_DEAD(false))
              continue;
             do
              {
               for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                {
                 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                  {
                   ivec4(5649, 13509, -60122, -91897);
                  }
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_DEAD(false))
              continue;
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY((1 | 1), ~ (~ ((1 | 1))))); _injected_loop_counter ++)
              {
               ;
              }
            }
           if(_GLF_DEAD(false))
            barrier();
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 ^ 0)); _injected_loop_counter --)
            {
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               do
                {
                 mat3(-976.144, 8.0, 530.051, 9597.4159, -52.16, -6.6, -1633.5885, -38.60, 2.3);
                 if(_GLF_DEAD(false))
                  break;
                }
               while(false);
              }
             else
              {
              }
            }
           if((bitCount(49408u) != 18568))
            {
             if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true, false)))))
              break;
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               switch(_GLF_SWITCH((-34631 & 0)))
                {
                 case 0:
                 if(_GLF_DEAD(false))
                  break;
                 if(_GLF_DEAD(false))
                  continue;
                 case 73:
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                 if(_GLF_DEAD(false))
                  return;
                 case 10:
                 case 5:
                 case 25:
                 if(_GLF_DEAD(false))
                  return;
                 case 32:
                 ivec3(-53128, 2882, -7968);
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                 break;
                 case 89:
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                 uint _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v, _GLF_SWITCH_3_2v;
                 default:
                 1;
                }
              }
             else
              {
              }
             min(uvec2(32929u, 138528u), uvec2(1986u, 1169u));
             if(_GLF_DEAD(false))
              break;
             if(false)
              {
               (uvec2(126335u, 94337u) + 100817u);
               vec3 _GLF_SWITCH_2_13v[78], _GLF_SWITCH_2_14v;
               do
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                 if(_GLF_DEAD(false))
                  continue;
                 ;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(false))
                return;
               mat3(57.24, -701.246, -82.64, -9.8, -7.1, 2.9, 3470.2427, -960.362, -96.92);
               do
                {
                 atomicXor(subgroup_id, subgroup_size);
                }
               while(_GLF_WRAPPED_LOOP(false));
               mat4x2(1745.4691, 282.478, -162.490, -578.642, 6543.5975, 731.205, -1.6, 512.423);
               if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, ! (! (false)))))
                {
                }
               else
                {
                 if(_GLF_DEAD(false))
                  return;
                }
               max(ivec2(-76128, 97219), bitfieldInsert(ivec2(98881, 63429), ivec2(79849, 35805), -74231, 40135));
               if(_GLF_DEAD(false))
                return;
               int _GLF_SWITCH_2_15v[74];
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(2), int(2))); _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), int(0)))); _injected_loop_counter ++)
                {
                 if(_GLF_DEAD(false))
                  return;
                 _GLF_SWITCH_2_14v;
                }
               if(_GLF_DEAD(false))
                continue;
               if(_GLF_DEAD(false))
                continue;
              }
             else
              {
               do
                {
                 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                  }
                 else
                  {
                   mix((vec3(-2.4, 1820.7916, -6810.4603) != vec3(935.333, 6637.2783, 903.563)), true, (1378 != int(44.87)));
                  }
                }
               while(_GLF_WRAPPED_LOOP(false));
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                   if(_GLF_DEAD(false))
                    continue;
                  }
                 else
                  {
                   uvec2(27961u, 18804u);
                  }
                }
               if(_GLF_DEAD(false))
                continue;
               if(_GLF_DEAD(false))
                return;
               uint _GLF_SWITCH_2_16v, _GLF_SWITCH_2_17v, _GLF_SWITCH_2_18v;
               mat2x3 _GLF_SWITCH_2_19v, _GLF_SWITCH_2_20v;
              }
             uvec4(165923u, 69959u, 60245u, 90909u);
             if(_GLF_DEAD(false))
              continue;
             (mat3(-742.178, 0.6, 3226.0242, 4.5, -3036.5047, -516.035, -152.707, -4720.8250, 4.6) * mat4x3(9351.8253, -852.347, -77.40, -6160.2359, -5141.5067, 391.999, 780.104, 9750.5970, 876.910, -53.71, -0.8, 9260.4888));
             false;
            }
           if(_GLF_DEAD(false))
            return;
           for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (int(4)) << 0))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (int(4)) - 0)))); _injected_loop_counter ++)
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
              }
             if(_GLF_DEAD(false))
              break;
            }
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               if(_GLF_DEAD(false))
                return;
              }
             else
              {
              }
             break;
             if(_GLF_DEAD(false))
              barrier();
            }
          }
         if(_GLF_DEAD(false))
          barrier();
         case 0:
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, ! (! (false)))) || false)))
                continue;
               barrier();
              }
             break;
            }
           for(int _injected_loop_counter = (1 ^ 0); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
            {
             return;
             if(_GLF_DEAD(false))
              break;
            }
           if(_GLF_DEAD(false))
            continue;
          }
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
            break;
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
             return;
            }
          }
         else
          {
           do
            {
             return;
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
         case 18:
         case 63:
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               do
                {
                 return;
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             else
              {
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
            }
          }
         else
          {
           if(_GLF_DEAD(false))
            continue;
          }
         case 12:
         if(_GLF_DEAD(false))
          barrier();
         break;
         case 24:
         if(false)
          {
           bool _GLF_SWITCH_2_21v, _GLF_SWITCH_2_22v;
           while(_GLF_SWITCH_2_21v)
            {
             while(_GLF_SWITCH_2_22v)
              {
               vec4(7.1, 2107.2832, -647.450, -8408.1357);
               ivec4 _GLF_SWITCH_2_23v, _GLF_SWITCH_2_24v[55], _GLF_SWITCH_2_25v;
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_DEAD(false))
                continue;
              }
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               do
                {
                 while((num_workgroup < workgroup_base))
                  {
                   int _GLF_SWITCH_2_26v[56], _GLF_SWITCH_2_27v;
                   mat3 _GLF_SWITCH_2_28v, _GLF_SWITCH_2_29v, _GLF_SWITCH_2_30v;
                   bvec2 _GLF_SWITCH_2_31v;
                   for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(3), int(3))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      break;
                     if(_GLF_WRAPPED_IF_TRUE(true))
                      {
                       for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(3), int(3))) >> _GLF_IDENTITY(int(3), int(3)))); _injected_loop_counter ++)
                        {
                         bitCount(uvec2(98953u, 53879u));
                        }
                      }
                     else
                      {
                      }
                    }
                   do
                    {
                     uvec3(188452u, 193795u, 192639u);
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                   mat4 _GLF_SWITCH_2_32v;
                  }
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
              }
             ivec4 _GLF_SWITCH_2_33v, _GLF_SWITCH_2_34v[36], _GLF_SWITCH_2_35v;
             do
              {
               vec3(8.5, -450.667, 7646.2320);
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
             bool _GLF_SWITCH_2_36v, _GLF_SWITCH_2_37v, _GLF_SWITCH_2_38v[65];
            }
          }
         if(_GLF_DEAD(false))
          break;
         case 53:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bool(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
          return;
         ;
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            break;
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             return;
            }
           else
            {
             if(_GLF_DEAD(false))
              continue;
            }
          }
         default:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            continue;
           1;
          }
         else
          {
           if(_GLF_DEAD(false))
            return;
          }
        }
      }
     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
     if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec4(_GLF_IDENTITY(false, ! (! (false))), false, false, true)))))
      barrier();
     if(_GLF_DEAD(false))
      continue;
    }
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 uint virtual_gid = workgroup_base + subgroup_id * subgroup_size + subgroup_local_id;
 if(_GLF_DEAD(false))
  return;
 uint next_virtual_gid = workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size);
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
    {
     return;
    }
  }
 for(int _injected_loop_counter = (0 | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
      }
     else
      {
       do
        {
         atomicStore(buf[next_virtual_gid], uint(1), 4, 64, 4);
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
    }
   else
    {
    }
   if(_GLF_DEAD(false))
    break;
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(false))
      break;
     continue;
    }
  }
 uint read_1 = atomicLoad(buf[virtual_gid], 4, 64, 0);
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   if(_GLF_DEAD(false))
    {
     do
      {
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), 1 * (int(0))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
              {
               return;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
              }
            }
           else
            {
            }
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          continue;
        }
      }
     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
     do
      {
       for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > (-25305 & 0)); _injected_loop_counter --)
        {
         return;
        }
       if(_GLF_DEAD(false))
        continue;
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
  }
 else
  {
  }
 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
  }
 else
  {
   do
    {
     if(_GLF_DEAD(false))
      return;
    }
   while(_GLF_WRAPPED_LOOP(false));
   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
    }
   else
    {
     if(_GLF_DEAD(false))
      {
       do
        {
         return;
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
    }
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(false))
    {
     for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(6), int(6))) >> _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
      {
       return;
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
          return;
        }
       if(_GLF_DEAD(false))
        continue;
      }
    }
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 uint read_2 = atomicLoad(buf[virtual_gid], 4, 64, 0);
 for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), clamp(int(0), int(0), int(0))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != (int(_GLF_ZERO(0.0, injectionSwitch.x)) & ivec4(-35035, -64089, 43557, -90486).a)); _injected_loop_counter --)
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      continue;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      break;
     return;
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 do
  {
   do
    {
     if(subgroup_local_id + 1 < subgroup_size)
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         do
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
              {
               atomicStore(buf[next_virtual_gid], uint(read_1 == read_2) + 1, 4, 64, 4);
              }
             if(_GLF_DEAD(false))
              break;
            }
           else
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(false))
                continue;
               for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 << _GLF_IDENTITY(int(5), int(5)))); _injected_loop_counter --)
                {
                 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                  {
                   if(_GLF_WRAPPED_IF_TRUE(true))
                    {
                     return;
                    }
                   else
                    {
                    }
                  }
                 else
                  {
                  }
                }
               if(_GLF_DEAD(false))
                break;
              }
            }
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
         if(_GLF_DEAD(false))
          break;
        }
       else
        {
         if(_GLF_DEAD(false))
          return;
        }
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 | 1)); _injected_loop_counter ++)
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
          {
           subgroupAll(false);
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
            }
           else
            {
             return;
             if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
              return;
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          break;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
            }
           else
            {
             if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, false, true)))))
              return;
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_DEAD(false))
                barrier();
              }
             else
              {
              }
            }
          }
         else
          {
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            return;
           return;
          }
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           do
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 barrier();
                }
               else
                {
                }
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          break;
        }
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
             if(_GLF_DEAD(false))
              return;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
            }
           else
            {
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_IDENTITY(bool(bvec2(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false)), bool(bvec4(bool(bvec2(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false)), true, false, false))))))
                return;
               if(_GLF_DEAD(false))
                continue;
              }
            }
           barrier();
          }
        }
       else
        {
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          break;
         break;
        }
      }
     else
      {
       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
        }
       else
        {
         do
          {
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(false))
            return;
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (_GLF_IDENTITY(0, ~ (~ (0))) & -4205)); _injected_loop_counter --)
            {
             atomicStore(buf[next_virtual_gid], uint(read_1 == read_2) + 1, 4, 64, 4);
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              continue;
             continue;
            }
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
       if(_GLF_DEAD(false))
        break;
       if(_GLF_DEAD(false))
        break;
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          break;
         break;
        }
       if(_GLF_DEAD(false))
        return;
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           do
            {
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
              {
               do
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
              }
             switch(_GLF_SWITCH(0))
              {
               case 71:
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                  {
                   if(_GLF_WRAPPED_IF_TRUE(true))
                    {
                     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                      {
                       while(true)
                        {
                         if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, true && (false))))
                          {
                          }
                         else
                          {
                           if(_GLF_DEAD(false))
                            continue;
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            {
                             if(_GLF_DEAD(false))
                              continue;
                             if(_GLF_DEAD(false))
                              return;
                             barrier();
                            }
                          }
                         do
                          {
                           if(_GLF_DEAD(false))
                            {
                             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              {
                              }
                             else
                              {
                               if(_GLF_WRAPPED_IF_TRUE(true))
                                {
                                 if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, bool(bvec3(true, true, false)))))
                                  {
                                   return;
                                  }
                                 else
                                  {
                                  }
                                }
                               else
                                {
                                }
                              }
                            }
                          }
                         while(_GLF_WRAPPED_LOOP(false));
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            break;
                           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < _GLF_IDENTITY(1, clamp(1, 1, _GLF_IDENTITY(1, (false ? _GLF_FUZZED(_injected_loop_counter) : 1))))); _injected_loop_counter ++)
                            {
                             return;
                            }
                           do
                            {
                             if(_GLF_DEAD(false))
                              barrier();
                            }
                           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            break;
                          }
                         bvec4 _GLF_SWITCH_0_0v[47], _GLF_SWITCH_0_1v;
                         vec4 _GLF_SWITCH_0_2v, _GLF_SWITCH_0_3v, _GLF_SWITCH_0_4v;
                         (true ? (mat4(-3397.1043, -14.83, 734.598, 6.9, -7287.8530, -490.840, 4.1, -2.8, 4123.5577, -9.6, 78.45, -19.84, -4475.8741, 9.9, -3.2, 113.206) - mat4(-37.24, 20.74, -4308.9059, 6412.4522, 3.2, -2.8, -702.206, 26.23, 77.63, -9149.4093, -4040.8360, 1.1, 37.89, 88.40, -1893.6772, 8995.8047)) : (mat4(497.376, -7216.3707, -3.3, 53.71, 8153.2315, -4.0, -2.1, -4572.9924, 955.957, 137.851, 2.7, 249.001, -644.782, -3.5, 1.3, -9.9) + mat4(-3.7, -390.889, 99.73, -6.9, -6.6, -2.0, -796.847, -1334.1800, 2.2, 54.56, -1.4, -2368.5618, 4.2, 52.57, 2847.2779, 10.62)));
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          return;
                         if(_GLF_DEAD(false))
                          barrier();
                         vec3 _GLF_SWITCH_0_5v, _GLF_SWITCH_0_6v;
                         mat3((mat4x2(-9526.2149, 530.317, 6.1, 876.435, -14.83, 4.1, 6473.5695, -913.015) + 4110.9104));
                         vec2 _GLF_SWITCH_0_7v, _GLF_SWITCH_0_8v;
                         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          {
                          }
                         else
                          {
                           asinh(_GLF_SWITCH_0_7v);
                          }
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_DEAD(false))
                            continue;
                           if(_GLF_DEAD(false))
                            {
                             if(_GLF_WRAPPED_IF_FALSE(false))
                              {
                              }
                             else
                              {
                               barrier();
                               if(_GLF_DEAD(false))
                                break;
                              }
                            }
                           continue;
                          }
                         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true && (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
                          continue;
                         if(_GLF_DEAD(false))
                          continue;
                         mat3(-1844.5700, 1943.0506, -4128.0292, 8.3, -138.051, -6.6, -93.79, 9.1, 3090.8583);
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          barrier();
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          {
                           if(_GLF_DEAD(false))
                            break;
                           do
                            {
                             return;
                            }
                           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                           if(_GLF_DEAD(false))
                            break;
                          }
                         do
                          {
                           if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))) || false)))
                            {
                             switch(_GLF_SWITCH(0))
                              {
                               case 2:
                               exp(vec3(83.98, 50.71, -1.7));
                               if(_GLF_DEAD(false))
                                break;
                               case 0:
                               case 63:
                               case 57:
                               case 56:
                               case 21:
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                continue;
                               if(_GLF_DEAD(false))
                                {
                                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                  break;
                                 return;
                                }
                               case 50:
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                continue;
                               case 27:
                               case 42:
                               case 5:
                               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                {
                                }
                               else
                                {
                                 for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(7), _GLF_IDENTITY(int(7), 0 ^ (int(7))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                                  {
                                   if(true)
                                    {
                                     uvec4(108077u, 134191u, 138047u, 34387u);
                                     if(_GLF_WRAPPED_IF_FALSE(false))
                                      {
                                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                        break;
                                       if(_GLF_WRAPPED_IF_TRUE(true))
                                        {
                                         if(_GLF_DEAD(false))
                                          continue;
                                         if(_GLF_DEAD(false))
                                          barrier();
                                        }
                                       else
                                        {
                                        }
                                      }
                                     else
                                      {
                                       do
                                        {
                                         if(_GLF_WRAPPED_IF_TRUE(true))
                                          {
                                           bvec4((bvec2(false, true) != bvec2(true, true)), bvec3(false, true, true));
                                          }
                                         else
                                          {
                                          }
                                        }
                                       while(_GLF_WRAPPED_LOOP(false));
                                       if(_GLF_DEAD(false))
                                        return;
                                      }
                                     if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
                                      {
                                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                        continue;
                                       do
                                        {
                                         return;
                                        }
                                       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                                      }
                                     if(_GLF_DEAD(false))
                                      {
                                       if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec3(false, true, true), bvec3(bvec4(bvec3(false, true, true), false)))))))
                                        {
                                         if(_GLF_DEAD(false))
                                          continue;
                                         break;
                                        }
                                       break;
                                      }
                                     if(_GLF_DEAD(false))
                                      continue;
                                     mat2x3(639.376, -3.5, -864.323, -539.141, -1.9, 6.8);
                                    }
                                  }
                                 if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, ! (! (false)))) || false)))
                                  break;
                                }
                               break;
                               case 65:
                               if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                                break;
                               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                                {
                                 ;
                                }
                               else
                                {
                                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                  return;
                                }
                               default:
                               if(_GLF_DEAD(false))
                                continue;
                               if(_GLF_WRAPPED_IF_FALSE(false))
                                {
                                }
                               else
                                {
                                 if(_GLF_WRAPPED_IF_FALSE(false))
                                  {
                                  }
                                 else
                                  {
                                   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                                    {
                                     1;
                                    }
                                  }
                                }
                              }
                            }
                           else
                            {
                            }
                          }
                         while(_GLF_WRAPPED_LOOP(false));
                         if(_GLF_DEAD(false))
                          break;
                         if(_GLF_DEAD(false))
                          barrier();
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_WRAPPED_IF_FALSE(false))
                            {
                            }
                           else
                            {
                             return;
                            }
                          }
                         if(_GLF_DEAD(false))
                          {
                           for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                            {
                             barrier();
                            }
                          }
                        }
                      }
                     if(_GLF_DEAD(false))
                      continue;
                    }
                   else
                    {
                    }
                  }
                 else
                  {
                  }
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    continue;
                   break;
                  }
                }
               else
                {
                }
               if(_GLF_DEAD(false))
                continue;
               do
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(false))
                    continue;
                   if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, false || (true))))
                    {
                     return;
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      continue;
                    }
                   else
                    {
                    }
                  }
                }
               while(_GLF_WRAPPED_LOOP(false));
               case 58:
               do
                {
                 if(_GLF_DEAD(false))
                  break;
                 do
                  {
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      continue;
                     if(_GLF_WRAPPED_IF_TRUE(true))
                      {
                       if(_GLF_DEAD(false))
                        {
                         do
                          {
                           return;
                          }
                         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                        }
                      }
                     else
                      {
                      }
                     if(_GLF_DEAD(false))
                      barrier();
                     continue;
                    }
                   if(_GLF_DEAD(false))
                    continue;
                   if(_GLF_DEAD(false))
                    break;
                   if(true)
                    {
                     do
                      {
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_WRAPPED_IF_TRUE(true))
                          {
                           if(_GLF_WRAPPED_IF_TRUE(true))
                            {
                             switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                              {
                               case 95:
                               mat3x2(injectionSwitch, injectionSwitch, tanh(vec2(83.81, 2.7)));
                               case 0:
                               case 11:
                               case 6:
                               return;
                               break;
                               case 53:
                               mat3x4(5306.9801, 7.9, 80.66, -0.3, -1.8, 6.9, 0.5, -6.9, 8180.2089, -599.472, 3922.0435, -595.108);
                               default:
                               1;
                              }
                            }
                           else
                            {
                             if(_GLF_DEAD(false))
                              {
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                {
                                 if(_GLF_WRAPPED_IF_FALSE(false))
                                  {
                                  }
                                 else
                                  {
                                   return;
                                  }
                                }
                               break;
                              }
                            }
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            break;
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            continue;
                          }
                         else
                          {
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            continue;
                           if(_GLF_DEAD(false))
                            return;
                          }
                        }
                      }
                     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                     if(_GLF_DEAD(false))
                      break;
                     if(_GLF_DEAD(false))
                      {
                       for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), (int(2)) << int(_GLF_ZERO(0.0, injectionSwitch.x))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                        {
                         do
                          {
                           return;
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            barrier();
                          }
                         while(_GLF_WRAPPED_LOOP(false));
                        }
                      }
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_DEAD(false))
                        return;
                       break;
                      }
                     if(_GLF_DEAD(false))
                      continue;
                     for(int _injected_loop_counter = (0 | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < _GLF_IDENTITY(1, (_GLF_IDENTITY(1, max(1, 1))) + 0)); _injected_loop_counter ++)
                      {
                       if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        {
                        }
                       else
                        {
                         uvec4(184607u, 1357u, 135194u, 79063u);
                        }
                      }
                     if(_GLF_WRAPPED_IF_TRUE(true))
                      {
                       do
                        {
                         bitfieldInsert(uvec3(187125u, 61382u, 171814u), (uvec3(24032u, 151609u, 95941u) << num_workgroup), 86234, 50260);
                        }
                       while(_GLF_WRAPPED_LOOP(false));
                      }
                     else
                      {
                      }
                     if(_GLF_DEAD(false))
                      break;
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          {
                          }
                         else
                          {
                           return;
                          }
                        }
                       return;
                       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                        break;
                      }
                     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                      {
                       do
                        {
                         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < ((0 ^ 1) & 1)); _injected_loop_counter ++)
                          {
                           if(_GLF_WRAPPED_IF_FALSE(false))
                            {
                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              continue;
                            }
                           else
                            {
                             do
                              {
                               switch(_GLF_SWITCH(0))
                                {
                                 case 70:
                                 ;
                                 if(_GLF_DEAD(false))
                                  continue;
                                 case 37:
                                 if(_GLF_WRAPPED_IF_FALSE(false))
                                  {
                                  }
                                 else
                                  {
                                   bvec4(true);
                                  }
                                 case 0:
                                 case 25:
                                 case 78:
                                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                                  {
                                   for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                                    {
                                     if(_GLF_DEAD(false))
                                      continue;
                                     switch(_GLF_SWITCH((-90865 & 0)))
                                      {
                                       case 47:
                                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                        {
                                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                          continue;
                                         return;
                                        }
                                       if(_GLF_DEAD(false))
                                        {
                                         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true && (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))))
                                          break;
                                         if(_GLF_DEAD(false))
                                          {
                                           if(_GLF_DEAD(false))
                                            {
                                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                              continue;
                                             if(_GLF_DEAD(false))
                                              break;
                                             break;
                                            }
                                           continue;
                                          }
                                         if(_GLF_DEAD(false))
                                          break;
                                         if(_GLF_DEAD(false))
                                          continue;
                                         if(_GLF_DEAD(false))
                                          {
                                           if(_GLF_WRAPPED_IF_FALSE(false))
                                            {
                                            }
                                           else
                                            {
                                             return;
                                            }
                                          }
                                         barrier();
                                         do
                                          {
                                           if(_GLF_DEAD(false))
                                            break;
                                           if(_GLF_DEAD(false))
                                            return;
                                          }
                                         while(_GLF_WRAPPED_LOOP(false));
                                        }
                                       if(_GLF_DEAD(false))
                                        break;
                                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                        break;
                                       mat4x2 _GLF_SWITCH_1_0v, _GLF_SWITCH_1_1v[81];
                                       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                                        {
                                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                          return;
                                         switch(_GLF_SWITCH(0))
                                          {
                                           case 0:
                                           if(_GLF_DEAD(false))
                                            return;
                                           case 60:
                                           case 62:
                                           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 << _GLF_IDENTITY(int(3), int(3)))); _injected_loop_counter --)
                                            {
                                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                              return;
                                             if(_GLF_DEAD(false))
                                              {
                                               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                                                {
                                                 barrier();
                                                 do
                                                  {
                                                   if(_GLF_DEAD(false))
                                                    {
                                                     for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                                                      {
                                                       return;
                                                      }
                                                    }
                                                  }
                                                 while(_GLF_WRAPPED_LOOP(false));
                                                 if(_GLF_DEAD(false))
                                                  break;
                                                }
                                               else
                                                {
                                                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                                  {
                                                   if(_GLF_DEAD(false))
                                                    return;
                                                   break;
                                                  }
                                                }
                                              }
                                            }
                                           break;
                                           default:
                                           1;
                                          }
                                        }
                                       if(_GLF_DEAD(false))
                                        continue;
                                       do
                                        {
                                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                          barrier();
                                         if(_GLF_DEAD(false))
                                          break;
                                         if(_GLF_DEAD(false))
                                          {
                                           if(_GLF_WRAPPED_IF_TRUE(true))
                                            {
                                             return;
                                            }
                                           else
                                            {
                                            }
                                          }
                                         if(_GLF_DEAD(false))
                                          return;
                                         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, bool(bvec2(false, true))))))))
                                          return;
                                         if(_GLF_DEAD(false))
                                          continue;
                                         if(_GLF_DEAD(false))
                                          break;
                                        }
                                       while(_GLF_WRAPPED_LOOP(false));
                                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                        break;
                                       case 0:
                                       case 17:
                                       if(_GLF_DEAD(false))
                                        {
                                         if(_GLF_WRAPPED_IF_FALSE(false))
                                          {
                                          }
                                         else
                                          {
                                           return;
                                          }
                                        }
                                       if(_GLF_DEAD(false))
                                        return;
                                       case 98:
                                       case 73:
                                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                        break;
                                       case 56:
                                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                        {
                                         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                                          {
                                           return;
                                          }
                                        }
                                       if(_GLF_DEAD(false))
                                        break;
                                       case 57:
                                       case 49:
                                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                        {
                                         if(_GLF_WRAPPED_IF_TRUE(true))
                                          {
                                           if(_GLF_WRAPPED_IF_FALSE(false))
                                            {
                                            }
                                           else
                                            {
                                             return;
                                            }
                                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                            return;
                                          }
                                         else
                                          {
                                          }
                                         if(_GLF_DEAD(false))
                                          barrier();
                                        }
                                       if(_GLF_DEAD(false))
                                        continue;
                                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                        break;
                                       case 39:
                                       if(_GLF_DEAD(false))
                                        {
                                         do
                                          {
                                           barrier();
                                          }
                                         while(_GLF_WRAPPED_LOOP(false));
                                         if(_GLF_DEAD(false))
                                          break;
                                         if(_GLF_DEAD(false))
                                          continue;
                                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                          return;
                                        }
                                       if(_GLF_DEAD(false))
                                        return;
                                       if(_GLF_DEAD(false))
                                        break;
                                       case 23:
                                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                        {
                                         if(_GLF_DEAD(false))
                                          break;
                                         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                                          {
                                           if(_GLF_WRAPPED_IF_FALSE(false))
                                            {
                                            }
                                           else
                                            {
                                             if(_GLF_DEAD(false))
                                              return;
                                             if(_GLF_DEAD(false))
                                              return;
                                            }
                                           if(_GLF_DEAD(false))
                                            break;
                                          }
                                         if(_GLF_DEAD(false))
                                          break;
                                         break;
                                         if(_GLF_DEAD(false))
                                          break;
                                        }
                                       do
                                        {
                                         if(_GLF_WRAPPED_IF_FALSE(false))
                                          {
                                           if(_GLF_DEAD(false))
                                            break;
                                           if(_GLF_DEAD(false))
                                            {
                                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                              return;
                                             break;
                                            }
                                           if(_GLF_DEAD(false))
                                            break;
                                           if(_GLF_DEAD(false))
                                            {
                                             if(_GLF_WRAPPED_IF_TRUE(true))
                                              {
                                               if(_GLF_DEAD(false))
                                                return;
                                              }
                                             else
                                              {
                                              }
                                             barrier();
                                            }
                                          }
                                         else
                                          {
                                           if(_GLF_DEAD(false))
                                            break;
                                           if(_GLF_DEAD(false))
                                            continue;
                                           do
                                            {
                                             ivec4(17417, 41636, ivec2(72378, -32241));
                                            }
                                           while(_GLF_WRAPPED_LOOP(false));
                                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                            return;
                                          }
                                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                          continue;
                                         if(_GLF_DEAD(false))
                                          continue;
                                        }
                                       while(_GLF_WRAPPED_LOOP(false));
                                       if(_GLF_DEAD(false))
                                        break;
                                       break;
                                       if(_GLF_DEAD(false))
                                        continue;
                                       case 91:
                                       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                                        {
                                         mix((vec2(-28.04, -751.341) * -55.60), injectionSwitch, bvec2(true, true));
                                         if(_GLF_DEAD(false))
                                          continue;
                                         if(_GLF_WRAPPED_IF_FALSE(false))
                                          {
                                          }
                                         else
                                          {
                                           if(_GLF_DEAD(false))
                                            barrier();
                                          }
                                        }
                                       else
                                        {
                                        }
                                       default:
                                       if(_GLF_WRAPPED_IF_FALSE(false))
                                        {
                                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                          break;
                                        }
                                       else
                                        {
                                         do
                                          {
                                           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                                            {
                                             1;
                                            }
                                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                            break;
                                          }
                                         while(_GLF_WRAPPED_LOOP(false));
                                         if(_GLF_DEAD(false))
                                          continue;
                                         if(_GLF_DEAD(false))
                                          continue;
                                        }
                                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                        break;
                                       if(_GLF_DEAD(false))
                                        continue;
                                      }
                                    }
                                  }
                                 break;
                                 case 52:
                                 ;
                                 case 66:
                                 do
                                  {
                                   (uvec4(5484u, 123291u, 168646u, 150730u) >> uvec4(91775u, 155579u, 149046u, 185744u));
                                  }
                                 while(_GLF_WRAPPED_LOOP(false));
                                 default:
                                 1;
                                }
                              }
                             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                            }
                          }
                        }
                       while(_GLF_WRAPPED_LOOP(false));
                      }
                     while(false)
                      {
                       ;
                       bvec3 _GLF_SWITCH_0_9v, _GLF_SWITCH_0_10v, _GLF_SWITCH_0_11v;
                       mat4x3 _GLF_SWITCH_0_12v, _GLF_SWITCH_0_13v, _GLF_SWITCH_0_14v[96];
                       if(_GLF_DEAD(false))
                        break;
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        break;
                       for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(6), int(6))) >> _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter != (-89728 & 0)); _injected_loop_counter --)
                        {
                         switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                          {
                           case 19:
                           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                            break;
                           vec4 _GLF_SWITCH_3_0v[53], _GLF_SWITCH_3_1v;
                           case 60:
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            return;
                           if(_GLF_DEAD(false))
                            return;
                           ivec2(-35935, 90330).t;
                           case 0:
                           case 54:
                           do
                            {
                             if(_GLF_DEAD(false))
                              {
                               if(_GLF_DEAD(false))
                                continue;
                               barrier();
                               if(_GLF_DEAD(false))
                                break;
                              }
                            }
                           while(_GLF_WRAPPED_LOOP(false));
                           case 17:
                           case 7:
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            {
                             if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bool(false), false || (bool(false)))))))
                              return;
                             continue;
                            }
                           if(_GLF_DEAD(false))
                            {
                             if(_GLF_DEAD(false))
                              break;
                             switch(_GLF_SWITCH(0))
                              {
                               case 0:
                               case 50:
                               case 87:
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                break;
                               case 97:
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                continue;
                               case 67:
                               case 42:
                               case 31:
                               case 25:
                               if(_GLF_WRAPPED_IF_FALSE(false))
                                {
                                }
                               else
                                {
                                 do
                                  {
                                   if(_GLF_DEAD(false))
                                    {
                                     if(_GLF_DEAD(false))
                                      break;
                                     if(_GLF_DEAD(false))
                                      {
                                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                        barrier();
                                       return;
                                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                        break;
                                      }
                                     continue;
                                    }
                                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                    {
                                     do
                                      {
                                       barrier();
                                      }
                                     while(_GLF_WRAPPED_LOOP(false));
                                    }
                                   if(_GLF_DEAD(false))
                                    continue;
                                   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                                    {
                                     return;
                                    }
                                   else
                                    {
                                    }
                                   do
                                    {
                                     switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                                      {
                                       case 0:
                                       case 87:
                                       case 44:
                                       case 15:
                                       case 76:
                                       case 75:
                                       case 99:
                                       case 89:
                                       if(_GLF_DEAD(false))
                                        continue;
                                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                        barrier();
                                       case 14:
                                       case 57:
                                       if(_GLF_DEAD(false))
                                        return;
                                       break;
                                       case 45:
                                       _injected_loop_counter;
                                       default:
                                       1;
                                      }
                                    }
                                   while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                                   if(_GLF_DEAD(false))
                                    break;
                                  }
                                 while(_GLF_WRAPPED_LOOP(false));
                                }
                               break;
                               if(_GLF_DEAD(false))
                                break;
                               case 43:
                               if(_GLF_DEAD(false))
                                continue;
                               ;
                               case 14:
                               mat2x3(634.443, 1.7, -5.2, 585.318, -880.400, -14.62);
                               if(_GLF_DEAD(false))
                                break;
                               default:
                               do
                                {
                                 switch(_GLF_SWITCH(0))
                                  {
                                   case 91:
                                   mat3x4(-2.0, 1.1, -7.2, -9.6, 2.9, -600.853, 10.63, -387.556, -7560.0168, 9.9, -0.2, -2043.3921);
                                   if(_GLF_DEAD(false))
                                    {
                                     if(_GLF_DEAD(false))
                                      return;
                                     barrier();
                                    }
                                   case 32:
                                   _injected_loop_counter;
                                   case 0:
                                   case 5:
                                   1;
                                   break;
                                   if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                                    return;
                                   case 6:
                                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                    continue;
                                   ivec2 _GLF_SWITCH_5_0v;
                                   default:
                                   1;
                                  }
                                }
                               while(_GLF_WRAPPED_LOOP(false));
                              }
                            }
                           break;
                           default:
                           1;
                           if(_GLF_DEAD(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, (false) && true)) || false)))
                            return;
                           if(_GLF_DEAD(false))
                            return;
                          }
                         if(_GLF_DEAD(false))
                          return;
                        }
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, ! (! (false)))))
                          {
                           if(_GLF_DEAD(false))
                            return;
                          }
                         else
                          {
                           return;
                          }
                        }
                       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                        {
                         do
                          {
                           switch(_GLF_SWITCH((0 >> _GLF_IDENTITY(int(6), int(6)))))
                            {
                             case 0:
                             case 66:
                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              return;
                             case 45:
                             case 63:
                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              {
                               if(_GLF_WRAPPED_IF_TRUE(true))
                                {
                                 barrier();
                                }
                               else
                                {
                                }
                              }
                             if(_GLF_WRAPPED_IF_FALSE(false))
                              {
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                return;
                              }
                             else
                              {
                               if(_GLF_DEAD(false))
                                break;
                               (bvec4(true, true, true, true));
                              }
                             break;
                             default:
                             1;
                            }
                          }
                         while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || false)));
                         if(_GLF_DEAD(false))
                          return;
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          continue;
                        }
                       else
                        {
                         if(_GLF_DEAD(false))
                          return;
                        }
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            {
                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              continue;
                             return;
                            }
                           break;
                          }
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          continue;
                         break;
                         if(_GLF_DEAD(false))
                          continue;
                         if(_GLF_DEAD(false))
                          break;
                        }
                       do
                        {
                         if(_GLF_DEAD(false))
                          return;
                        }
                       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_WRAPPED_IF_TRUE(true))
                          {
                           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                            barrier();
                           do
                            {
                             return;
                            }
                           while(_GLF_WRAPPED_LOOP(false));
                           if(_GLF_DEAD(false))
                            continue;
                          }
                         else
                          {
                          }
                         do
                          {
                           if(_GLF_DEAD(false))
                            {
                             do
                              {
                               return;
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                break;
                              }
                             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                            }
                          }
                         while(_GLF_WRAPPED_LOOP(false));
                        }
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        {
                         if(_GLF_DEAD(false))
                          return;
                         barrier();
                        }
                       mat4x2(-7.0, -1.7, 576.366, 8.8, 57.91, 493.704, 254.782, -15.05);
                       ivec3 _GLF_SWITCH_0_15v;
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        break;
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        break;
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
                          continue;
                         barrier();
                        }
                       if(_GLF_WRAPPED_IF_TRUE(true))
                        {
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_DEAD(false))
                            continue;
                           break;
                          }
                         if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                          {
                           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                            continue;
                           continue;
                          }
                         if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, ! (_GLF_IDENTITY(! (true), bool(bool(! (true))))))))
                          {
                           do
                            {
                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              return;
                             if(_GLF_DEAD(false))
                              {
                               if(_GLF_WRAPPED_IF_FALSE(false))
                                {
                                }
                               else
                                {
                                 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                  {
                                  }
                                 else
                                  {
                                   barrier();
                                  }
                                 if(_GLF_DEAD(false))
                                  break;
                                }
                               if(_GLF_DEAD(false))
                                continue;
                              }
                             for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), (_GLF_IDENTITY(int(4), ~ (~ (int(4))))) | (int(4)))))); _injected_loop_counter ++)
                              {
                               if(_GLF_DEAD(false))
                                {
                                 if(_GLF_WRAPPED_IF_TRUE(true))
                                  {
                                   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 << _GLF_IDENTITY(int(2), int(2)))); _injected_loop_counter --)
                                    {
                                     return;
                                    }
                                  }
                                 else
                                  {
                                  }
                                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                  break;
                                }
                              }
                             if(_GLF_DEAD(false))
                              {
                               if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                                break;
                               break;
                              }
                             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                              {
                               ivec3(-97361, -31623, 14900);
                              }
                             if(_GLF_DEAD(false))
                              return;
                            }
                           while(_GLF_WRAPPED_LOOP(false));
                           if(_GLF_DEAD(false))
                            {
                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              break;
                             break;
                            }
                          }
                         else
                          {
                          }
                        }
                       else
                        {
                         if(_GLF_WRAPPED_IF_TRUE(true))
                          {
                           switch(_GLF_SWITCH(0))
                            {
                             case 0:
                             case 78:
                             case 62:
                             case 20:
                             case 26:
                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              {
                               if(_GLF_WRAPPED_IF_FALSE(false))
                                {
                                }
                               else
                                {
                                 if(_GLF_DEAD(false))
                                  continue;
                                 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                                  {
                                   if(_GLF_WRAPPED_IF_TRUE(true))
                                    {
                                     if(_GLF_DEAD(false))
                                      barrier();
                                     return;
                                    }
                                   else
                                    {
                                     if(_GLF_DEAD(false))
                                      continue;
                                    }
                                  }
                                }
                              }
                             break;
                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              continue;
                             case 21:
                             uvec3(158302u, 141228u, 195428u);
                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              {
                               if(_GLF_WRAPPED_IF_TRUE(true))
                                {
                                 barrier();
                                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                  continue;
                                }
                               else
                                {
                                }
                              }
                             if(_GLF_DEAD(false))
                              return;
                             default:
                             1;
                            }
                          }
                         else
                          {
                          }
                        }
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(false))
                          return;
                         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 >> _GLF_IDENTITY(int(4), int(4)))); _injected_loop_counter --)
                          {
                           return;
                          }
                         if(_GLF_DEAD(false))
                          barrier();
                        }
                      }
                     if(_GLF_DEAD(false))
                      break;
                     if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                      break;
                     if(_GLF_DEAD(false))
                      continue;
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      return;
                     mat2x4 _GLF_SWITCH_0_16v, _GLF_SWITCH_0_17v;
                     mat4x3 _GLF_SWITCH_0_18v;
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_DEAD(false))
                        return;
                       break;
                      }
                     ivec2(-26209, 22933);
                    }
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                 if(_GLF_DEAD(false))
                  continue;
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(false))
                return;
               for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(false))
                    continue;
                   return;
                  }
                }
               case 0:
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                 subgroupAll(true);
                }
               else
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   if(_GLF_DEAD(false))
                    {
                     for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                      {
                       barrier();
                      }
                     if(_GLF_DEAD(false))
                      break;
                    }
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    continue;
                   return;
                  }
                 else
                  {
                  }
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                }
               if(_GLF_DEAD(false))
                continue;
               if(_GLF_DEAD(false))
                return;
               case 64:
               if(_GLF_DEAD(false))
                break;
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > _GLF_IDENTITY(0, ~ (~ (0)))); _injected_loop_counter --)
                  {
                   if(_GLF_WRAPPED_IF_TRUE(true))
                    {
                     if(_GLF_DEAD(false))
                      {
                       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                        {
                         return;
                         if(_GLF_DEAD(false))
                          break;
                        }
                      }
                     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        return;
                       if(_GLF_DEAD(false))
                        {
                         do
                          {
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            return;
                           return;
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            continue;
                          }
                         while(_GLF_WRAPPED_LOOP(false));
                         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                          {
                           if(_GLF_DEAD(false))
                            {
                             for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), int(2))); _GLF_WRAPPED_LOOP(_injected_loop_counter > ((0 << _GLF_IDENTITY(int(6), int(6))) | 0)); _injected_loop_counter --)
                              {
                               if(_GLF_DEAD(false))
                                break;
                               return;
                              }
                            }
                          }
                         if(_GLF_DEAD(false))
                          continue;
                        }
                      }
                     else
                      {
                      }
                     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 >> _GLF_IDENTITY(int(4), _GLF_IDENTITY(int(4), max(int(4), int(4)))))); _injected_loop_counter --)
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        return;
                      }
                    }
                   else
                    {
                     if(_GLF_DEAD(false))
                      return;
                    }
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    continue;
                  }
                }
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
               break;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    return;
                  }
                }
               default:
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  break;
                 if(_GLF_DEAD(false))
                  break;
                 do
                  {
                   barrier();
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                }
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 1;
                }
              }
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(false))
                  break;
                 continue;
                }
               continue;
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
          }
         else
          {
          }
        }
       else
        {
        }
      }
    }
   while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
  }
 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
}
