#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 uint subgroup_id = gl_SubgroupID;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
  barrier();
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     barrier();
    }
   else
    {
    }
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        return;
      }
     return;
    }
   return;
  }
 if(_GLF_DEAD(false))
  {
   for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(6), int(6))) >> _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
    {
     return;
    }
  }
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      return;
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       barrier();
      }
     else
      {
      }
    }
  }
 do
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) && true)));
uint subgroup_size = 16;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   switch(_GLF_SWITCH(0))
    {
     case 84:
     if(bvec2(false, true).st[1])
      {
       bvec3(bvec2(false, true), true);
       {
        while(true)
         {
          vec4(-1.7, 4.1, -5898.2993, 8.2);
         }
        mat4x2(236.285);
        if((mat2x4(57.69, -2973.2693, -3.9, 8.9, -9924.4288, 162.562, 4.0, -6.3) == mat2x4(-1.5, 7.5, -41.53, -15.72, 9121.1835, 8563.9865, 89.01, -45.42)))
         {
          ;
          uvec3(68540u, 128533u, 176915u);
          mat2x4 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v[99], _GLF_SWITCH_4_2v;
         }
       }
      }
     else
      {
       while((mat2(-200.302, -7526.4535, -9.6, -49.79) != mat2(mat3x4(41.41, -5223.7812, 28.58, 6038.1132, -97.71, 5.6, 558.729, 4303.6007, 809.061, 97.22, 2256.3299, -5.5))))
        {
         bvec4 _GLF_SWITCH_4_3v, _GLF_SWITCH_4_4v[18], _GLF_SWITCH_4_5v;
         mat4x3 _GLF_SWITCH_4_6v[98];
         while((subgroup_id > uint(625.440)))
          {
           false;
           ;
          }
        }
       mat3x2(-8643.7391, -4430.2097, 850.766, -31.78, -7.2, -4938.8567);
       {
        if(false)
         {
          mat2x3 _GLF_SWITCH_4_7v[53], _GLF_SWITCH_4_8v[93], _GLF_SWITCH_4_9v[52];
          (5.4 > -7573.2796);
          bool _GLF_SWITCH_4_10v, _GLF_SWITCH_4_11v[31], _GLF_SWITCH_4_12v[47];
          mat4 _GLF_SWITCH_4_13v, _GLF_SWITCH_4_14v;
          ;
          ivec3(-57355, -43213, -73182);
          ;
          bvec4 _GLF_SWITCH_4_15v, _GLF_SWITCH_4_16v;
         }
        else
         {
          greaterThan(sign(injectionSwitch), unpackSnorm2x16(subgroup_id));
          bool _GLF_SWITCH_4_17v;
          ;
          vec3 _GLF_SWITCH_4_18v, _GLF_SWITCH_4_19v[13], _GLF_SWITCH_4_20v;
          ceil(vec2(9.6, 85.96));
          mat2x3 _GLF_SWITCH_4_21v, _GLF_SWITCH_4_22v[90], _GLF_SWITCH_4_23v[96];
          ivec3 _GLF_SWITCH_4_24v;
         }
        for(        mat4x3(0.0, 1.0, -157.329, -4.0, -765.485, -26.24, -9.9, -0.7, 9.4, 25.13, -966.682, -506.659);
 notEqual(bvec3(true, true, false), bvec3(true, false, false)).y; mat4x2(3.1, -6542.2710, -7611.9154, -191.281, 561.738, 832.787, 3289.7131, 85.44))
         {
          uvec4(143520u, 116425u, 150001u, 112684u);
          greaterThan(mix(vec3(3.7, 1.1, 514.588), vec3(896.854, 4792.8633, -302.487), bvec3(false, true, true)), vec3(-9131.6181, 8324.5423, 3.6));
          injectionSwitch;
          mat2x4 _GLF_SWITCH_4_25v;
         }
        ivec3 _GLF_SWITCH_4_26v[77], _GLF_SWITCH_4_27v;
        for(        mat2x4(mat2x3(-96.79, -6.6, 7316.5666, -4.5, 206.812, -2.4));
 false; mat3x4(-7.5, 7.8, -9.8, -2.1, -1.7, -15.27, -37.84, 3.7, -8.9, 6098.6747, 440.124, 8.6))
         {
          vec2 _GLF_SWITCH_4_28v, _GLF_SWITCH_4_29v;
          ;
          uvec2(168765u, 39658u);
         }
        (subgroup_size != subgroup_id);
        mat3x2 _GLF_SWITCH_4_30v;
       }
       (mat4x3(54.10, 4.7, -1.9, -3.5, -5.0, 2936.4117, 451.089, 490.907, 228.385, -5.1, -19.55, -6.6) / -90.19);
       ;
       if((false != true))
        {
         {
          bvec2(false, true);
          1.7;
          ((uvec2(72595u, 81503u)) | uvec2(89411u, 186087u));
          ivec2 _GLF_SWITCH_4_31v[63], _GLF_SWITCH_4_32v, _GLF_SWITCH_4_33v;
          ivec2 _GLF_SWITCH_4_34v[2];
         }
        }
       else
        {
         mat4x2 _GLF_SWITCH_4_35v[71], _GLF_SWITCH_4_36v;
        }
      }
     case 85:
     if((mat3x2(8.7, -770.030, 0.8, -7.2, -2.8, -634.396) != mat3x2(-2.5, -967.709, -99.42, -8339.3267, -1.6, -6603.5201)))
      {
       if(((++ subgroup_id) != (subgroup_id ++)))
        {
         {
          ;
         }
         ;
         uvec3(10477u, 188937u, 25078u);
         for(mat3x2 _GLF_SWITCH_4_37v, _GLF_SWITCH_4_38v; false; (-8953 % ivec4(-53370, 42961, 64621, 42705)))
          {
          }
         ((ivec4(75812, 22406, 1584, 55138) % 10676) / ivec4(41369, -50824, 93075, 50246));
        }
       else
        {
        }
       uvec4(147196u, 78629u, 119621u, 14241u);
       do
        {
         if((mat2x4(20.31) != mat2x4(-1.0, 917.972, 8968.4069, -1.7, 85.79, 174.370, -5.7, 9.9)))
          {
          }
         else
          {
           mat4x3(-2.2, 237.834, -3184.8463, -8929.1305, 305.489, -1736.0464, -6.6, -831.657, 0.6, 407.629, 3.3, 48.91);
           mat3x4(3.5, -45.97, -7.7, 9303.8083, -4.3, 71.47, 1.7, 3242.1384, -9370.1546, -7184.9051, 36.57, 2.8);
           ivec2(-71897, -92160);
          }
         vec4 _GLF_SWITCH_4_39v;
         for(         vec2(-29.91, 105.556)[1];
 false; mat3(8.3, 0.7, 3.4, 643.870, 1.7, -3.9, -943.421, 58.38, 2.3))
          {
           atomicXor(subgroup_id, subgroup_id);
           uvec4 _GLF_SWITCH_4_40v, _GLF_SWITCH_4_41v, _GLF_SWITCH_4_42v[43];
           ivec2(-5200, 19762);
           mix(_GLF_SWITCH_4_40v, uvec4(81671u, 188184u, 138901u, 68486u), bvec4(true, true, false, false));
           ;
           mat3x4 _GLF_SWITCH_4_43v, _GLF_SWITCH_4_44v;
           ;
           bvec3 _GLF_SWITCH_4_45v, _GLF_SWITCH_4_46v, _GLF_SWITCH_4_47v;
           uint _GLF_SWITCH_4_48v, _GLF_SWITCH_4_49v, _GLF_SWITCH_4_50v;
          }
         mat3x4 _GLF_SWITCH_4_51v, _GLF_SWITCH_4_52v[46], _GLF_SWITCH_4_53v;
         uvec4 _GLF_SWITCH_4_54v, _GLF_SWITCH_4_55v;
         mat4x3 _GLF_SWITCH_4_56v, _GLF_SWITCH_4_57v[93], _GLF_SWITCH_4_58v[66];
         while(true)
          {
           ivec2(-14853, 53901);
           bvec4 _GLF_SWITCH_4_59v, _GLF_SWITCH_4_60v, _GLF_SWITCH_4_61v;
           mat2x3(1801.6232, -32.23, -66.26, 2.4, 0.7, 1766.7502);
           false;
           ;
           abs(-99404);
           mat2x3 _GLF_SWITCH_4_62v, _GLF_SWITCH_4_63v[32], _GLF_SWITCH_4_64v;
           ivec3 _GLF_SWITCH_4_65v;
           (false ? 2578.2089 : -6.4);
          }
         if(any(bvec2(false, false)))
          {
           mat4x2 _GLF_SWITCH_4_66v[29], _GLF_SWITCH_4_67v, _GLF_SWITCH_4_68v[95];
           vec3(-4.5, -3.8, 7.5);
           mat2x3 _GLF_SWITCH_4_69v, _GLF_SWITCH_4_70v, _GLF_SWITCH_4_71v;
           mat2x3 _GLF_SWITCH_4_72v;
           (mat4x3(1.8, 5.9, 7.9, 3.4, 4234.7217, 57.24, 30.09, 792.129, 39.37, -45.82, 67.41, -47.54) - tan(9017.2500));
           mat3x4 _GLF_SWITCH_4_73v, _GLF_SWITCH_4_74v;
           _GLF_SWITCH_4_53v;
           true;
          }
         else
          {
           mat2x3(73.09, -1.6, 2.0, 5479.8920, -7.4, -7.2);
           uvec3(195782u, 112379u, 54364u);
          }
         3.5;
        }
       while((ivec3(-94548, -33890, -66858) == ivec3(-80384, 74553, 65356)));
      }
     else
      {
       (mat3x4(mat2x3(616.774, 26.15, 5.4, -1.9, 0.1, 14.68)) , (mat2x3(5433.0464, -5801.3662, -625.611, -88.68, -2614.8514, 3971.9735) - mat2x3(0.3, -503.471, -4263.6537, -25.63, 6445.1988, -1.1)));
       if((-11592 != -22954))
        {
         ;
         for(uvec4 _GLF_SWITCH_4_75v, _GLF_SWITCH_4_76v, _GLF_SWITCH_4_77v; false; min(ivec4(-98221, 73801, -41789, -73291), bitfieldReverse(ivec4(-19114, 41970, -73399, -51244))))
          {
           mat3x4(-32.48, 343.910, 81.04, -61.34, -3.4, -7124.1004, 4144.8320, -9931.7327, -1219.3329, 3229.4046, -6.1, -4.7);
           uint _GLF_SWITCH_4_78v, _GLF_SWITCH_4_79v[64];
           mat3x4(-1031.7957, 2032.9572, -29.20, 6.2, -0.5, 5696.1580, 81.67, 49.33, 6.8, 7.4, -6.7, 8.8);
          }
         ivec4 _GLF_SWITCH_4_80v, _GLF_SWITCH_4_81v;
         outerProduct(vec4(8.1, 540.436, 27.82, 66.37), vec2(-10.93, -2797.7913));
         float _GLF_SWITCH_4_82v, _GLF_SWITCH_4_83v;
         dot(vec3(335.988, 4.8, -474.582), log(fract(vec3(-2.2, 33.61, -450.579))));
         if(false)
          {
           mat2x4 _GLF_SWITCH_4_84v, _GLF_SWITCH_4_85v[38];
           mat3x2(6.4, 5.1, 9.4, 601.861, -110.874, 9.1);
           70764;
           vec4(8228.6137, 7.7, -41.13, 341.496);
           mat3 _GLF_SWITCH_4_86v[57];
           uvec2(uvec4(85729u, 54544u, 150592u, 166601u));
           mat3x4 _GLF_SWITCH_4_87v, _GLF_SWITCH_4_88v, _GLF_SWITCH_4_89v;
           ;
          }
         (packHalf2x16(injectionSwitch) < 90775u);
        }
       else
        {
         while((mat2x3(9.2, -404.127, 2579.0350, -6.0, -529.060, 394.990) == mat2x3(68.84, 28.73, 2.7, 830.463, -8432.4184, 3.0)))
          {
          }
         vec3 _GLF_SWITCH_4_90v, _GLF_SWITCH_4_91v;
         inverse(mat4(-1.2, -963.669, -4.6, -4481.7210, -4.4, -541.587, 4291.3875, -3539.0063, -60.14, -3.8, -2184.9071, -2.1, 800.705, -4.3, -8932.1055, 501.217));
         while((60928u == subgroup_size))
          {
           (uvec3(68945u, 109581u, 71658u));
           mat3x2 _GLF_SWITCH_4_92v, _GLF_SWITCH_4_93v, _GLF_SWITCH_4_94v;
           float _GLF_SWITCH_4_95v;
          }
         bvec2(true, false);
         bvec4 _GLF_SWITCH_4_96v, _GLF_SWITCH_4_97v;
         {
          mat4(length(_GLF_SWITCH_4_90v));
          mat4 _GLF_SWITCH_4_98v;
          dot(vec4(-4877.0014, -70.31, -9.2, 7048.4251), vec4(6.0, 467.631, -8.2, -8.8));
          ;
          mat4x3(5.0, 8.7, 6.8, -707.205, 140.968, 570.086, 44.73, 5.8, 0.1, 0.6, 214.001, -601.543);
          ;
          vec3(4.0, -7720.5810, -32.13);
          bitfieldExtract((subgroup_size + uvec4(17369u, 46049u, 171673u, 52881u)), -42171, 72408);
         }
        }
       ivec4(-5976, -89552, -58656, 61105).yxww;
       (subgroup_id | uvec3(subgroup_size));
      }
     case 0:
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(false))
      return;
     case 21:
     do
      {
       return;
      }
     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
     case 52:
     case 56:
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         return;
        }
       else
        {
        }
      }
     break;
     default:
     1;
    }
  }
 if(_GLF_DEAD(false))
  barrier();
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = gl_NumWorkGroups.x;
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
    return;
  }
 else
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       do
        {
         if(_GLF_DEAD(false))
          barrier();
         return;
        }
       while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (false) || false)));
      }
     return;
    }
   if(_GLF_DEAD(false))
    return;
  }
 uint workgroup_size = gl_WorkGroupSize.x;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    {
     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
      {
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           return;
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          return;
        }
       else
        {
         if(_GLF_DEAD(false))
          return;
        }
      }
    }
   if(_GLF_DEAD(false))
    {
     do
      {
       if(_GLF_DEAD(false))
        barrier();
      }
     while(_GLF_WRAPPED_LOOP(false));
     return;
    }
   if(_GLF_DEAD(false))
    return;
   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
    {
     barrier();
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  return;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      return;
     if(_GLF_DEAD(false))
      return;
     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
      }
     else
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(false))
        barrier();
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       do
        {
         return;
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
     do
      {
       barrier();
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     barrier();
    }
   else
    {
     if(_GLF_DEAD(false))
      barrier();
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          barrier();
         return;
        }
      }
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 if(_GLF_DEAD(false))
  barrier();
 uint workgroup_id = gl_WorkGroupID.x;
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    return;
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
    {
     do
      {
       if(_GLF_DEAD(false))
        return;
       return;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           return;
          }
        }
       if(_GLF_DEAD(false))
        break;
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        return;
      }
     if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bool(false)), false || (bool(bool(false)))))))
      barrier();
     if(_GLF_WRAPPED_IF_TRUE(true))
      {
       barrier();
      }
     else
      {
      }
    }
  }
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    barrier();
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))
          return;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          continue;
         break;
        }
       return;
       if(_GLF_DEAD(false))
        continue;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
    }
   else
    {
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
    }
   else
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       barrier();
      }
    }
   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          return;
         return;
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          return;
        }
       else
        {
        }
      }
    }
  }
 uint workgroup_base = workgroup_size * workgroup_id;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(false))
    barrier();
   return;
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    return;
   barrier();
  }
 if(_GLF_DEAD(false))
  {
   do
    {
     switch(_GLF_SWITCH((75246 & 0)))
      {
       case 91:
       106.938;
       case 64:
       if(_GLF_DEAD(false))
        return;
       {
        switch(_GLF_SWITCH(0))
         {
          case 72:
          if(mix(true, (bvec2(true, false) == bvec2(true, false)), false))
           {
            mat3x4 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v;
            (9.7 + (mat4(20.45, -56.13, -8235.7789, -56.30, 126.606, -934.284, -8.2, 986.834, 2.1, 9.4, -752.350, -0.0, 7.8, -7.3, -9.2, -156.289) + mat4(mat3x2(-80.76, -7.8, -6534.9870, 2269.8310, -2.1, -3490.7179))));
            false;
            ;
           }
          case 0:
          case 70:
          case 60:
          do
           {
            do
             {
              if(_GLF_DEAD(false))
               break;
              while((true || all(bvec3(true, true, false))))
               {
                uvec4(196680u, 197364u, 2898u, 100773u);
                while((num_workgroup < (+ workgroup_base)))
                 {
                 }
                if(_GLF_DEAD(false))
                 barrier();
                uvec2 _GLF_SWITCH_3_0v[45];
               }
             }
            while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           }
          while(_GLF_WRAPPED_LOOP(false));
          if(_GLF_DEAD(false))
           barrier();
          if(_GLF_DEAD(false))
           return;
          case 27:
          mat4x3 _GLF_SWITCH_3_1v[32];
          case 95:
          case 39:
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           return;
          do
           {
            if(_GLF_DEAD(false))
             barrier();
            mat4x2 _GLF_SWITCH_3_2v[53];
           }
          while(any(bvec4(false, true, true, false)));
          bvec4 _GLF_SWITCH_3_3v[79];
          {
           bvec3(true, false, false);
           mat4x3 _GLF_SWITCH_3_4v, _GLF_SWITCH_3_5v;
          }
          if(_GLF_DEAD(false))
           return;
          case 68:
          if(_GLF_WRAPPED_IF_FALSE(false))
           {
           }
          else
           {
            refract(vec3(-4271.8542, -4.0, 518.262), vec3(-5505.8372, -2580.1382, 3.1), -1559.1867);
           }
          if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
           {
            if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, true)))))
             barrier();
            return;
           }
          case 44:
          for(          exp(63.87);
 (2.5 > 6.3); mat2x3(-9.1, -445.856, 8.6, -139.409, -5.3, 4.2))
           {
            for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
             {
              injectionSwitch.t;
             }
            mat2x3 _GLF_SWITCH_3_6v;
            if(true)
             {
              for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(1), _GLF_IDENTITY(int(1), 0 ^ (int(1))))) >> _GLF_IDENTITY(int(1), _GLF_IDENTITY(int(1), (_GLF_IDENTITY(int(1), min(int(1), int(1)))) | int(_GLF_ZERO(0.0, injectionSwitch.x))))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
               {
                if(_GLF_WRAPPED_IF_TRUE(true))
                 {
                  injectionSwitch;
                 }
                else
                 {
                 }
                if(_GLF_DEAD(false))
                 barrier();
               }
              if(_GLF_DEAD(false))
               continue;
              mat4(0.2, -721.647, -8333.4708, 9140.8548, 16.57, 5.0, 3793.9733, -9360.8560, -9607.0550, 1411.4570, 852.881, 842.927, 7.1, -9.5, 7043.1009, 4.3);
             }
            (-7.7 + -541.311);
            mat2x3 _GLF_SWITCH_3_7v;
            if(_GLF_DEAD(false))
             break;
            if(_GLF_DEAD(false))
             barrier();
           }
          while(false)
           {
            if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
             }
            else
             {
              bvec4(false, true, false, false);
             }
            if(_GLF_WRAPPED_IF_TRUE(true))
             {
              mat3(6204.6519, 4.7, -2.7, -33.73, 0.9, 6.7, 1.5, 9.2, -11.34)[0];
             }
            else
             {
              if(_GLF_DEAD(false))
               continue;
             }
            if(_GLF_DEAD(false))
             barrier();
            if(_GLF_DEAD(false))
             break;
            bvec3(false, true, true);
            if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               continue;
              break;
             }
            if(_GLF_DEAD(false))
             barrier();
            ;
            do
             {
              switch(_GLF_SWITCH(0))
               {
                case 5:
                max(tan(vec3(76.45, 0.7, 42.29)), vec3(5.0, -83.71, 6.3));
                case 72:
                mat2(351.965, -4.1, 53.15, -11.69);
                case 0:
                case 55:
                case 19:
                case 84:
                case 20:
                case 53:
                case 87:
                for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                 {
                  (bvec4(true, false, true, false));
                  if(_GLF_DEAD(false))
                   barrier();
                 }
                break;
                case 9:
                sign(ivec4(92237, 33009, 26210, 12015));
                case 85:
                bvec4 _GLF_SWITCH_4_0v[40];
                default:
                1;
               }
             }
            while(_GLF_WRAPPED_LOOP(false));
            if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             continue;
            uvec3 _GLF_SWITCH_3_8v;
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             bvec3 _GLF_SWITCH_3_9v[13];
             _GLF_SWITCH_3_8v;
             if(_GLF_DEAD(false))
              break;
             lessThan((ivec3(17113, 7943, -19446) - max(ivec3(-28264, 57956, -50731), ivec3(-30781, 79585, -96507))), (ivec3(-38303, 82246, 33509) % ivec3(-60908, -81029, 71235)));
             if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), (_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))) && true)))
              {
               do
                {
                 switch(_GLF_SWITCH(0))
                  {
                   case 0:
                   if(_GLF_DEAD(false))
                    return;
                   case 63:
                   case 73:
                   case 37:
                   if(_GLF_DEAD(false))
                    barrier();
                   case 32:
                   case 94:
                   case 57:
                   mat3x4(-2.2, 0.7, -77.65, -9.3, 1.4, -5.1, 0.9, 463.102, -340.303, 31.02, -415.643, -410.992);
                   case 93:
                   if(_GLF_DEAD(false))
                    barrier();
                   break;
                   case 72:
                   inverse(mat3(50.33, -214.175, 733.403, 8.6, 6357.0496, -8.1, -94.60, 954.879, -2574.4043));
                   default:
                   1;
                  }
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             else
              {
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
            }
           }
          for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
           {
            if(_GLF_DEAD(false))
             return;
            if(_GLF_DEAD(false))
             continue;
            if(_GLF_DEAD(false))
             barrier();
            (- mat4x2(-3.6, 9.8, 7075.3471, -9.2, 94.02, 1.6, 5.9, -1.8));
           }
          if(_GLF_DEAD(false))
           return;
          if(_GLF_DEAD(false))
           return;
          if(_GLF_DEAD(false))
           barrier();
          break;
          case 61:
          uint _GLF_SWITCH_4_2v, _GLF_SWITCH_4_3v[93];
          default:
          1;
         }
       }
       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (_GLF_IDENTITY(false, (false) && true)), ! (! (! (_GLF_IDENTITY(false, (false) && true)))))))))
        return;
       case 0:
       case 6:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           return;
          }
         else
          {
          }
        }
       case 42:
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         return;
        }
       do
        {
         if(_GLF_DEAD(false))
          return;
        }
       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
       case 61:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       case 39:
       case 23:
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           do
            {
             return;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
        }
       case 37:
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           return;
          }
         else
          {
          }
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_DEAD(false))
        barrier();
       case 4:
       case 70:
       return;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       break;
       case 1:
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        return;
       if(true)
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           injectionSwitch;
          }
         else
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         equal(bvec4(true, bvec3(false, false, true)), bvec4(false, false, false, false));
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(false))
          {
           do
            {
             return;
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
          }
         if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
          }
         mat4x2(-2638.8356, -3.5, -6.7, -0.6, -4.2, 4.6, -1953.3565, -64.61);
         for(         bvec4(false, true, true, true);
 false; (+ mat2x4(-7.7, -228.763, 1615.2240, -66.86, -2950.7691, 518.270, 4074.5278, -3813.5113)))
          {
           if(_GLF_DEAD(false))
            return;
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
            {
             subgroup_local_id;
            }
           if(_GLF_DEAD(false))
            barrier();
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
            {
             mat2x3 _GLF_SWITCH_3_10v, _GLF_SWITCH_3_11v, _GLF_SWITCH_3_12v;
            }
           uvec2 _GLF_SWITCH_3_13v, _GLF_SWITCH_3_14v[68], _GLF_SWITCH_3_15v[30];
          }
        }
       else
        {
        }
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         barrier();
        }
       default:
       1;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
      }
    }
   while(_GLF_WRAPPED_LOOP(false));
   if(_GLF_DEAD(false))
    return;
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  barrier();
 uint virtual_gid = workgroup_base + subgroup_id * subgroup_size + subgroup_local_id;
 uint next_virtual_gid = workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size);
 atomicStore(buf[next_virtual_gid], uint(1), 4, 64, 4);
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
    barrier();
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
      }
     else
      {
       return;
      }
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   return;
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
      {
       switch(_GLF_SWITCH(0))
        {
         case 80:
         bvec2 _GLF_SWITCH_4_0v;
         case 59:
         for(vec4 _GLF_SWITCH_4_1v; true; mat3x4(-2.4, -795.540, -56.16, -3.4, -549.320, 6.6, 300.118, 5422.1137, 574.950, -56.93, -11.27, 290.425))
          {
           ;
           ;
           ivec2(-46189, -12838);
           do
            {
             bvec3 _GLF_SWITCH_4_2v[68];
             mat2x3 _GLF_SWITCH_4_3v[72], _GLF_SWITCH_4_4v[85], _GLF_SWITCH_4_5v;
             injectionSwitch;
             mat3(-0.9, -7.5, 40.60, -9.1, -90.66, 60.73, 3.9, -306.968, -4469.9351);
             mat4 _GLF_SWITCH_4_6v, _GLF_SWITCH_4_7v, _GLF_SWITCH_4_8v;
            }
           while(true);
          }
         case 0:
         barrier();
         break;
         case 19:
         ivec2(11364, -84339);
         case 83:
         do
          {
           {
            (++ subgroup_local_id);
            bvec3 _GLF_SWITCH_4_9v, _GLF_SWITCH_4_10v[69];
           }
           mat4(3979.7404, -8322.9929, 7789.6737, -8.9, 967.255, -4047.4999, -793.258, -45.49, 4390.4431, -603.593, 338.086, 9.7, -44.14, 0.9, -9003.3715, -2.4);
           mat3x4 _GLF_SWITCH_4_11v, _GLF_SWITCH_4_12v[16];
          }
         while(false);
         default:
         1;
        }
      }
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     if(_GLF_DEAD(false))
      barrier();
     return;
    }
   else
    {
    }
   if(_GLF_DEAD(false))
    return;
  }
 uint read_1 = atomicLoad(buf[virtual_gid], 4, 64, 0);
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
    barrier();
   barrier();
  }
 uint read_2 = atomicLoad(buf[virtual_gid], 4, 64, 0);
 if(_GLF_WRAPPED_IF_FALSE(false))
  {
  }
 else
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
     do
      {
       switch(_GLF_SWITCH(0))
        {
         case 0:
         if(_GLF_DEAD(false))
          barrier();
         case 77:
         case 16:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              return;
            }
           return;
          }
         break;
         case 52:
         while(false)
          {
           sinh(vec4(97.24, -9.3, -0.4, 8490.8096));
           uvec3(51048u, 14999u, 5816u);
           subgroup_size;
          }
         default:
         1;
        }
      }
     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
    }
   else
    {
     if(_GLF_DEAD(false))
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         return;
        }
      }
     for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), int(4))); _GLF_WRAPPED_LOOP(_injected_loop_counter > ((0 ^ 0) >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), int(ivec4(int(0), 0, 1, (0 >> _GLF_IDENTITY(int(8), int(8))))))))); _injected_loop_counter --)
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           return;
          }
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           switch(_GLF_SWITCH(((0 >> _GLF_IDENTITY(int(4), int(4))) & -29357)))
            {
             case 0:
             case 94:
             case 36:
             case 62:
             case 22:
             case 72:
             barrier();
             break;
             case 52:
             mat2x4((- mat2(-9792.2048, 516.224, -7.4, -4.6)));
             case 80:
             ;
             default:
             1;
            }
          }
         else
          {
          }
        }
      }
     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
      {
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 << _GLF_IDENTITY(int(6), int(6)))); _injected_loop_counter --)
            {
             return;
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 return;
                }
               else
                {
                }
              }
            }
           else
            {
            }
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(false))
          return;
         barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
        }
      }
     if(subgroup_local_id + 1 < subgroup_size)
      {
       do
        {
         if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, (true) || false)))
          {
           atomicStore(buf[next_virtual_gid], uint(read_1 == read_2) + 1, 4, 64, 4);
          }
         else
          {
          }
        }
       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        return;
       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
        {
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          break;
         if(_GLF_DEAD(_GLF_IDENTITY(false, ! (_GLF_IDENTITY(! (false), true && (! (false)))))))
          {
           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
            {
             return;
             if(_GLF_DEAD(false))
              barrier();
            }
          }
        }
       subgroupAll(false);
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
        return;
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           return;
          }
        }
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       if(_GLF_DEAD(false))
        barrier();
      }
     else
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         do
          {
           return;
          }
         while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, (_GLF_IDENTITY(false, (false) || false)) && _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))));
        }
       switch(_GLF_SWITCH(0))
        {
         case 34:
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           do
            {
             switch(_GLF_SWITCH(0))
              {
               case 0:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 return;
                }
               case 94:
               case 38:
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 return;
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               break;
               case 97:
               if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                return;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                  barrier();
                 return;
                }
               if(_GLF_DEAD(false))
                return;
               float _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               default:
               1;
               if(_GLF_DEAD(false))
                return;
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(false, _GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)) || (false))));
           do
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
            }
           while(_GLF_WRAPPED_LOOP(false));
           if(_GLF_DEAD(false))
            return;
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               return;
              }
             else
              {
              }
            }
           barrier();
          }
         bvec3(false, false, false);
         case 0:
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
          {
           switch(_GLF_SWITCH(0))
            {
             case 87:
             mat4x3(-5506.0939, 7.3, 1.3, 884.563, -49.35, -6.9, 9196.2366, 9029.5642, 5350.5985, -3751.0870, -9.1, 8.4);
             case 0:
             case 35:
             case 57:
             case 16:
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
              {
               if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                }
               else
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                }
              }
             case 46:
             case 9:
             case 96:
             case 24:
             case 75:
             if(_GLF_DEAD(false))
              barrier();
             break;
             case 58:
             mat3x2(-117.011, 640.615, -235.804, 3.9, -6304.4131, 60.30);
             case 94:
             mat3x4 _GLF_SWITCH_4_0v[22], _GLF_SWITCH_4_1v;
             default:
             1;
            }
          }
         if(_GLF_DEAD(false))
          {
           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
            {
             barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
         if(_GLF_DEAD(false))
          {
           do
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             return;
             if(_GLF_DEAD(false))
              barrier();
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), int(2))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                {
                 barrier();
                }
              }
             return;
            }
           barrier();
          }
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(false))
          {
           switch(_GLF_SWITCH(0))
            {
             case 80:
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(false))
              return;
             mat3x2 _GLF_SWITCH_1_0v, _GLF_SWITCH_1_1v, _GLF_SWITCH_1_2v[18];
             case 0:
             case 43:
             case 29:
             case 93:
             if(_GLF_DEAD(false))
              {
               do
                {
                 barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             case 82:
             case 32:
             case 27:
             if(_GLF_DEAD(false))
              barrier();
             case 17:
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               return;
              }
             case 21:
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               do
                {
                 barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             if(_GLF_DEAD(false))
              return;
             case 64:
             if(_GLF_DEAD(false))
              return;
             for(int _injected_loop_counter = (0 | (1 & 1)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
              {
               if(_GLF_DEAD(false))
                barrier();
               switch(_GLF_SWITCH(0))
                {
                 case 57:
                 float _GLF_SWITCH_1_0v, _GLF_SWITCH_1_1v;
                 case 54:
                 uint _GLF_SWITCH_1_2v, _GLF_SWITCH_1_3v, _GLF_SWITCH_1_4v;
                 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(false))
                    {
                     switch(_GLF_SWITCH(0))
                      {
                       case 0:
                       if(_GLF_WRAPPED_IF_TRUE(true))
                        {
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                            return;
                           if(_GLF_DEAD(false))
                            barrier();
                           if(_GLF_DEAD(false))
                            {
                             if(_GLF_DEAD(false))
                              barrier();
                             break;
                            }
                           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            {
                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              barrier();
                            }
                           else
                            {
                             barrier();
                            }
                           if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                            barrier();
                          }
                         if(_GLF_DEAD(false))
                          break;
                        }
                       else
                        {
                        }
                       barrier();
                       break;
                       default:
                       1;
                      }
                    }
                  }
                 else
                  {
                  }
                 case 0:
                 if(_GLF_DEAD(false))
                  break;
                 case 69:
                 case 51:
                 case 33:
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 case 18:
                 case 75:
                 if(_GLF_DEAD(false))
                  break;
                 case 37:
                 if(_GLF_DEAD(false))
                  continue;
                 case 88:
                 case 53:
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 if(_GLF_WRAPPED_IF_TRUE(true))
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    return;
                  }
                 else
                  {
                  }
                 case 8:
                 switch(_GLF_SWITCH((0 << _GLF_IDENTITY(int(3), int(3)))))
                  {
                   case 33:
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      break;
                     return;
                    }
                   mat3x4 _GLF_SWITCH_0_0v[31], _GLF_SWITCH_0_1v;
                   case 91:
                   if(_GLF_DEAD(false))
                    break;
                   mat4x2(-8.5, -236.255, 788.945, 9.0, -7554.6265, -7.6, 9264.9281, 11.15);
                   case 0:
                   if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                    {
                     if(_GLF_DEAD(false))
                      break;
                     break;
                    }
                   if(_GLF_DEAD(false))
                    barrier();
                   case 30:
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_DEAD(false))
                        barrier();
                       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec4(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false, true, true)))))
                        break;
                       continue;
                      }
                     return;
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_WRAPPED_IF_FALSE(false))
                        {
                        }
                       else
                        {
                         return;
                        }
                      }
                     if(_GLF_DEAD(false))
                      return;
                    }
                   if(_GLF_DEAD(false))
                    continue;
                   case 39:
                   if(_GLF_DEAD(false))
                    continue;
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     for(int _injected_loop_counter = (0 | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                      {
                       return;
                       if(_GLF_DEAD(false))
                        barrier();
                      }
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        return;
                       break;
                      }
                     if(_GLF_DEAD(false))
                      continue;
                    }
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    continue;
                   if(_GLF_DEAD(false))
                    return;
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    continue;
                   if(_GLF_DEAD(false))
                    {
                     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < (_GLF_IDENTITY((0 >> _GLF_IDENTITY(int(3), int(3))), ((0 >> _GLF_IDENTITY(int(3), int(3)))) - 0) | 1)); _injected_loop_counter ++)
                      {
                       return;
                      }
                    }
                   case 94:
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                      {
                       case 19:
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        break;
                       float _GLF_SWITCH_3_0v, _GLF_SWITCH_3_1v;
                       case 35:
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(false))
                          barrier();
                         break;
                        }
                       mat3x2 _GLF_SWITCH_3_2v[40], _GLF_SWITCH_3_3v, _GLF_SWITCH_3_4v;
                       if(_GLF_DEAD(false))
                        {
                         switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                          {
                           case 0:
                           if(_GLF_DEAD(false))
                            barrier();
                           return;
                           break;
                           default:
                           1;
                          }
                        }
                       case 0:
                       case 64:
                       case 22:
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(false))
                          continue;
                         break;
                        }
                       case 91:
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          break;
                         barrier();
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          barrier();
                        }
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        barrier();
                       case 3:
                       return;
                       if(_GLF_DEAD(false))
                        barrier();
                       break;
                       case 11:
                       isinf(injectionSwitch);
                       case 61:
                       if(_GLF_DEAD(false))
                        break;
                       injectionSwitch;
                       default:
                       1;
                      }
                    }
                   case 19:
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      continue;
                     barrier();
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                   case 58:
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_DEAD(false))
                    break;
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     continue;
                    }
                   barrier();
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     break;
                    }
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    break;
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    continue;
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_WRAPPED_IF_TRUE(true))
                      {
                       if(_GLF_DEAD(false))
                        barrier();
                       barrier();
                      }
                     else
                      {
                       if(_GLF_DEAD(false))
                        break;
                      }
                    }
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    return;
                   do
                    {
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_WRAPPED_IF_FALSE(false))
                        {
                        }
                       else
                        {
                         barrier();
                        }
                      }
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                   break;
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bvec2(false, true), bvec2(bvec2(bvec2(false, true))))))))
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        continue;
                       if(_GLF_DEAD(false))
                        barrier();
                       barrier();
                      }
                     if(_GLF_DEAD(false))
                      continue;
                     return;
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      continue;
                    }
                   if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                    {
                     if(_GLF_DEAD(false))
                      break;
                     barrier();
                    }
                   case 59:
                   mat4 _GLF_SWITCH_0_2v, _GLF_SWITCH_0_3v[83], _GLF_SWITCH_0_4v[35];
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    return;
                   case 4:
                   if(_GLF_DEAD(false))
                    return;
                   if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, (false) && true))))))
                    continue;
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                     continue;
                    }
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                     if(_GLF_DEAD(false))
                      continue;
                     if(_GLF_DEAD(false))
                      continue;
                     return;
                    }
                   if(_GLF_DEAD(false))
                    barrier();
                   if(_GLF_DEAD(false))
                    continue;
                   if(_GLF_DEAD(false))
                    barrier();
                   for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                    {
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_DEAD(false))
                        continue;
                       return;
                       if(_GLF_DEAD(false))
                        barrier();
                      }
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                     bvec4((ivec3(45968, 41902, 34821) == ivec3(73627, -30850, -49142)), greaterThan((uvec2(11278u, 164441u) - uvec2(60584u, 22932u)), uvec2(146462u, 57383u)), false);
                    }
                   default:
                   if(_GLF_DEAD(false))
                    {
                     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 >> _GLF_IDENTITY(int(1), _GLF_IDENTITY(int(1), ~ (~ (int(1))))))); _injected_loop_counter --)
                      {
                       return;
                      }
                    }
                   1;
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     if(_GLF_DEAD(false))
                      return;
                     break;
                    }
                  }
                 break;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                 case 62:
                 _GLF_SWITCH_1_1v;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                 default:
                 1;
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(false))
                  return;
                }
              }
             break;
             case 67:
             false;
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(1), int(1))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                }
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 return;
                }
              }
             do
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, true)))))
                  return;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                 barrier();
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
             default:
             if(_GLF_DEAD(false))
              return;
             1;
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(false))
              return;
             if(_GLF_DEAD(false))
              barrier();
             barrier();
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                return;
               barrier();
              }
            }
          }
         if(_GLF_DEAD(false))
          barrier();
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
          {
           switch(_GLF_SWITCH(0))
            {
             case 0:
             if(_GLF_DEAD(false))
              barrier();
             case 55:
             if(_GLF_DEAD(false))
              return;
             case 77:
             case 11:
             case 15:
             if(_GLF_DEAD(false))
              barrier();
             atomicStore(buf[next_virtual_gid], uint(read_1 == read_2) + 1, 4, 64, 4);
             break;
             case 74:
             mix(ivec4(94932, -62547, -5076, -60041), ivec4(-74702, 50242, -81473, 5569), bvec4(true, false, false, false));
             case 60:
             (_injected_loop_counter / _injected_loop_counter);
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
              {
               if(_GLF_DEAD(false))
                return;
               break;
              }
             default:
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(false))
              barrier();
             1;
             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
              }
             else
              {
               do
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 if(_GLF_DEAD(false))
                  return;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_DEAD(false))
              return;
            }
          }
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           barrier();
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           return;
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 return;
                }
              }
            }
           else
            {
             if(_GLF_DEAD(false))
              barrier();
            }
           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
            {
             return;
            }
          }
         case 42:
         if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(_GLF_IDENTITY(false, ! (! (false))), false)))))
          {
           if(_GLF_DEAD(false))
            return;
           barrier();
          }
         if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
          return;
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            return;
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             if(_GLF_DEAD(false))
              {
               switch(_GLF_SWITCH(0))
                {
                 case 0:
                 case 57:
                 if(_GLF_DEAD(false))
                  {
                   switch(_GLF_SWITCH(0))
                    {
                     case 23:
                     mat3x2 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v[17];
                     case 0:
                     case 42:
                     if(_GLF_DEAD(false))
                      barrier();
                     if(_GLF_DEAD(false))
                      return;
                     case 5:
                     case 8:
                     return;
                     break;
                     case 70:
                     ;
                     case 40:
                     ivec3 _GLF_SWITCH_4_2v;
                     default:
                     1;
                    }
                  }
                 case 59:
                 case 90:
                 case 8:
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                      return;
                     if(_GLF_DEAD(false))
                      barrier();
                     return;
                    }
                   if(_GLF_DEAD(false))
                    barrier();
                  }
                 return;
                 break;
                 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      return;
                     return;
                    }
                  }
                 case 10:
                 if(_GLF_DEAD(false))
                  barrier();
                 ivec4 _GLF_SWITCH_2_0v, _GLF_SWITCH_2_1v;
                 case 1:
                 mat2x3 _GLF_SWITCH_2_2v[46];
                 default:
                 1;
                }
               if(_GLF_DEAD(false))
                barrier();
              }
            }
           else
            {
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           barrier();
          }
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           if(_GLF_DEAD(false))
            return;
          }
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true)))
              return;
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
              {
               do
                {
                 barrier();
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
             if(_GLF_DEAD(false))
              barrier();
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(false))
                return;
              }
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           subgroupAll(true);
          }
         else
          {
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
            }
           else
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               barrier();
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    return;
                   if(_GLF_DEAD(false))
                    return;
                   return;
                   if(_GLF_DEAD(false))
                    return;
                  }
                 barrier();
                 if(_GLF_DEAD(false))
                  barrier();
                }
              }
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              barrier();
             for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
              {
               return;
              }
            }
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             do
              {
               switch(_GLF_SWITCH((0 >> _GLF_IDENTITY(int(6), int(6)))))
                {
                 case 3:
                 mat4(673.983, -4686.9755, 3.0, 7.8, 9222.9808, 203.251, -586.635, -0.7, -2.8, 398.353, 726.038, -171.391, 0.2, 50.47, 1541.3427, 295.546);
                 case 0:
                 do
                  {
                   return;
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                 if(_GLF_DEAD(false))
                  barrier();
                 break;
                 default:
                 1;
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
           if(_GLF_DEAD(false))
            {
             switch(_GLF_SWITCH(0))
              {
               case 72:
               mat4 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v;
               case 0:
               case 97:
               for(int _injected_loop_counter = (((1 & 1) << _GLF_IDENTITY(int(7), int(7))) >> _GLF_IDENTITY(int(7), int(7))); _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 << _GLF_IDENTITY(int(7), int(7)))); _injected_loop_counter --)
                {
                 barrier();
                }
               if(_GLF_DEAD(false))
                barrier();
               break;
               case 77:
               ;
               case 57:
               _GLF_SWITCH_4_0v;
               default:
               1;
              }
            }
           if(_GLF_DEAD(false))
            barrier();
           return;
          }
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           else
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                {
                 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                  {
                   return;
                  }
                }
               barrier();
              }
            }
          }
         else
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              barrier();
             return;
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
         for(int _injected_loop_counter = (((((1 << _GLF_IDENTITY(int(3), int(3))) >> _GLF_IDENTITY(int(3), int(3))) & 1) << _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(6), min(int(6), int(6))))) >> _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
          {
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            return;
          }
         if(_GLF_DEAD(false))
          {
           switch(_GLF_SWITCH(0))
            {
             case 0:
             if(_GLF_DEAD(false))
              barrier();
             case 48:
             case 94:
             return;
             break;
             default:
             1;
            }
          }
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 >> _GLF_IDENTITY(int(3), int(3)))); _injected_loop_counter --)
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(false))
              barrier();
             continue;
            }
           if(_GLF_DEAD(false))
            {
             do
              {
               return;
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_DEAD(false))
              continue;
            }
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
              {
               return;
              }
            }
           if(_GLF_DEAD(false))
            barrier();
          }
         break;
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             do
              {
               return;
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              return;
             barrier();
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              return;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             return;
            }
           return;
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
            {
             if(_GLF_DEAD(false))
              break;
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_DEAD(false))
                continue;
               barrier();
              }
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
            {
             if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
              }
             else
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
              }
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               if(_GLF_DEAD(false))
                barrier();
               for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(1), _GLF_IDENTITY(int(1), ~ (~ (int(1)))))) >> _GLF_IDENTITY(int(1), int(1))); _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 | 0)); _injected_loop_counter --)
                {
                 if(_GLF_DEAD(false))
                  return;
                }
               if(_GLF_DEAD(false))
                barrier();
               return;
              }
             if(_GLF_DEAD(_GLF_IDENTITY(false, bool(_GLF_IDENTITY(bool(false), bool(bvec3(bool(false), false, true)))))))
              barrier();
            }
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (int(_GLF_ZERO(0.0, injectionSwitch.x)) << _GLF_IDENTITY(int(2), int(2)))); _injected_loop_counter --)
            {
             barrier();
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(false))
              return;
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    barrier();
                   break;
                  }
                 barrier();
                }
               break;
               if(_GLF_DEAD(false))
                barrier();
              }
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              return;
             return;
            }
           do
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    return;
                  }
                 barrier();
                }
               return;
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
          }
         default:
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           return;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
          }
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            barrier();
          }
         if(_GLF_DEAD(false))
          barrier();
         if(_GLF_DEAD(false))
          {
           do
            {
             if(_GLF_DEAD(false))
              return;
            }
           while(_GLF_WRAPPED_LOOP(false));
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           return;
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            return;
           barrier();
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             do
              {
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 do
                  {
                   if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                    return;
                   barrier();
                  }
                 while(_GLF_WRAPPED_LOOP(false));
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_IDENTITY(bool(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), false)), ! (! (bool(bvec3(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), false))))))))
              {
              }
             else
              {
               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 ^ 0) | 1)); _injected_loop_counter ++)
                {
                 if(_GLF_DEAD(false))
                  return;
                }
               return;
              }
            }
           if(_GLF_DEAD(false))
            return;
           barrier();
          }
         1;
         do
          {
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, true)))))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               break;
              }
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               barrier();
              }
             else
              {
              }
            }
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 barrier();
                }
              }
             if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
              barrier();
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(false))
              break;
             return;
             if(_GLF_DEAD(false))
              barrier();
            }
           if(_GLF_DEAD(false))
            continue;
          }
         while(_GLF_WRAPPED_LOOP(false));
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
          return;
         if(_GLF_DEAD(false))
          barrier();
        }
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
          }
         else
          {
           return;
          }
        }
       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), _GLF_IDENTITY(int(1), (_GLF_IDENTITY(int(1), (false ? _GLF_FUZZED(-83724) : int(1)))) << 0)))); _injected_loop_counter ++)
        {
         switch(_GLF_SWITCH(0))
          {
           case 52:
           subgroup_size;
           case 0:
           case 54:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           case 71:
           case 70:
           case 7:
           if(_GLF_DEAD(false))
            barrier();
           break;
           default:
           1;
          }
        }
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(false))
        return;
       do
        {
         if(_GLF_DEAD(false))
          break;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            barrier();
           return;
          }
        }
       while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
       if(_GLF_DEAD(false))
        {
         do
          {
           return;
           if(_GLF_DEAD(false))
            barrier();
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_DEAD(false))
          return;
         barrier();
        }
       if(_GLF_DEAD(false))
        barrier();
      }
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
          return;
         barrier();
        }
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
        }
       else
        {
         do
          {
           return;
          }
         while(_GLF_WRAPPED_LOOP(false));
        }
       if(_GLF_DEAD(false))
        return;
      }
     if(_GLF_DEAD(false))
      return;
     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
      {
       if(_GLF_WRAPPED_IF_FALSE(false))
        {
         if(_GLF_DEAD(false))
          barrier();
        }
       else
        {
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          barrier();
         if(_GLF_DEAD(false))
          return;
        }
       if(_GLF_DEAD(false))
        barrier();
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          continue;
         barrier();
        }
      }
     if(_GLF_DEAD(false))
      {
       switch(_GLF_SWITCH(0))
        {
         case 0:
         case 14:
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          {
           if(_GLF_DEAD(false))
            barrier();
           return;
          }
         case 84:
         case 40:
         case 87:
         case 46:
         case 35:
         case 39:
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
          {
           barrier();
          }
         case 27:
         case 33:
         if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
          return;
         break;
         default:
         1;
        }
      }
    }
  }
 if(_GLF_DEAD(false))
  {
   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
    {
     return;
    }
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(false))
    return;
   switch(_GLF_SWITCH(0))
    {
     case 0:
     if(_GLF_DEAD(false))
      return;
     case 48:
     case 61:
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true && (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
        return;
       if(_GLF_DEAD(false))
        barrier();
      }
     else
      {
      }
     if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
      barrier();
     if(_GLF_DEAD(false))
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(false))
        return;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          return;
         do
          {
           barrier();
          }
         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
        }
       return;
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        return;
      }
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
     case 77:
     return;
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(false))
      barrier();
     case 50:
     if(_GLF_DEAD(false))
      barrier();
     do
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     while(_GLF_WRAPPED_LOOP(false));
     if(_GLF_DEAD(false))
      return;
     break;
     case 7:
     mat2(mat2x3(-15.49, 882.963, 2.1, 1.0, -2449.4485, 9378.7721));
     if(_GLF_DEAD(false))
      return;
     default:
     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
      {
       switch(_GLF_SWITCH(0))
        {
         case 81:
         if(false)
          {
           int _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v[25], _GLF_SWITCH_4_2v;
           while((float(-31777) != -766.550))
            {
            }
           mat2x3(mat4x3(0.9, 78.39, 838.925, 2705.1426, -5940.2929, -737.944, 784.157, 7.1, -0.2, 31.58, -2470.2582, -8.8));
           mat4x3 _GLF_SWITCH_4_3v, _GLF_SWITCH_4_4v;
           if(true)
            {
             float _GLF_SWITCH_4_5v, _GLF_SWITCH_4_6v;
             ivec4 _GLF_SWITCH_4_7v[86], _GLF_SWITCH_4_8v;
            }
           bvec4 _GLF_SWITCH_4_9v;
           for(bool _GLF_SWITCH_4_10v; (mat4x2(8.2, -95.56, 65.93, 1285.3838, 1.0, 1.1, 395.373, -5.6) != mat4x2(-4.7, -6587.7852, -139.906, -9.2, -93.54, 77.28, -5.3, -2567.4277)); vec4(78.31, -786.129, 354.965, 1551.6742))
            {
             uint _GLF_SWITCH_4_11v, _GLF_SWITCH_4_12v[39];
             mat3x4(4196.7116, -3118.8322, 35.19, 1154.6198, 98.33, -85.72, 33.45, 62.77, -434.967, 2.0, -8775.0171, 5.6);
             ivec4(-8196, 53101, 29768, -93395);
            }
           ;
           ivec4 _GLF_SWITCH_4_13v;
          }
         case 0:
         case 98:
         case 35:
         case 95:
         if(_GLF_DEAD(false))
          return;
         break;
         case 44:
         int _GLF_SWITCH_4_14v[10], _GLF_SWITCH_4_15v, _GLF_SWITCH_4_16v;
         case 62:
         mat2x4 _GLF_SWITCH_4_17v[92];
         default:
         1;
        }
      }
     else
      {
      }
     1;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      barrier();
    }
  }
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  barrier();
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_WRAPPED_IF_FALSE(false))
      {
      }
     else
      {
       return;
      }
    }
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
     switch(_GLF_SWITCH(0))
      {
       case 0:
       case 37:
       case 16:
       case 85:
       case 9:
       case 89:
       case 61:
       if(_GLF_DEAD(false))
        return;
       break;
       case 70:
       bvec2 _GLF_SWITCH_4_0v[44];
       default:
       1;
      }
    }
   else
    {
     switch(_GLF_SWITCH(0))
      {
       case 0:
       case 37:
       case 47:
       case 11:
       case 71:
       case 3:
       if(_GLF_DEAD(false))
        barrier();
       case 32:
       case 66:
       case 78:
       barrier();
       break;
       case 12:
       not(bvec2(true, true));
       default:
       1;
      }
    }
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    barrier();
   return;
  }
}
