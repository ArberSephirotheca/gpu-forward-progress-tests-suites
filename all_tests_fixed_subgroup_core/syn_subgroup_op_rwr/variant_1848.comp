#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


struct _GLF_struct_15 {
 mat2x4 _f0;
} ;

struct _GLF_struct_14 {
 mat3 _f0;
 vec4 _f1;
 uvec4 _f2;
 mat3 _f3;
} ;

struct _GLF_struct_13 {
 mat3x4 _f0;
} ;

struct _GLF_struct_16 {
 _GLF_struct_13 _f0;
 mat3x4 _f1;
 _GLF_struct_14 _f2;
 _GLF_struct_15 _f3;
} ;

struct _GLF_struct_11 {
 mat4 _f0;
} ;

struct _GLF_struct_10 {
 bvec2 _f0;
 uint read_1;
 vec2 _f1;
 mat4 _f2;
 vec3 _f3;
 mat2x3 _f4;
} ;

struct _GLF_struct_12 {
 _GLF_struct_10 _f0;
 uvec2 _f1;
 _GLF_struct_11 _f2;
} ;

struct _GLF_struct_9 {
 bvec4 _f0;
} ;

struct _GLF_struct_17 {
 float _f0;
 bvec4 _f1;
 _GLF_struct_9 _f2;
 mat2x3 _f3;
 mat4 _f4;
 _GLF_struct_12 _f5;
 _GLF_struct_16 _f6;
} ;

struct _GLF_struct_6 {
 vec4 _f0;
 mat2x3 _f1;
 mat2 _f2;
 vec2 _f3;
 mat3x2 _f4;
 mat4x3 _f5;
} ;

struct _GLF_struct_7 {
 _GLF_struct_6 _f0;
 int _f1;
} ;

struct _GLF_struct_8 {
 uint virtual_gid;
 _GLF_struct_7 _f0;
} ;

struct _GLF_struct_3 {
 float _f0;
 ivec3 _f1;
 float _f2;
 uvec4 _f3;
 mat3x2 _f4;
} ;

struct _GLF_struct_2 {
 mat4x2 _f0;
 mat2x4 _f1;
 vec4 _f2;
 mat2 _f3;
 mat3 _f4;
} ;

struct _GLF_struct_4 {
 _GLF_struct_2 _f0;
 _GLF_struct_3 _f1;
} ;

struct _GLF_struct_0 {
 uint _f0;
 mat4x3 _f1;
 bvec2 _f2;
 uvec2 _f3;
} ;

struct _GLF_struct_1 {
 _GLF_struct_0 _f0;
 uint num_workgroup;
} ;

struct _GLF_struct_5 {
 bvec2 _f0;
 _GLF_struct_1 _f1;
 mat3x2 _f2;
 _GLF_struct_4 _f3;
} ;

layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      return;
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       switch(_GLF_SWITCH(_GLF_IDENTITY(0, (0) << 0)))
        {
         case 0:
         case 46:
         case 2:
         case 98:
         case 86:
         do
          {
           if(_GLF_DEAD(false))
            continue;
           if(_GLF_DEAD(false))
            break;
           return;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
          }
         while(_GLF_WRAPPED_LOOP(false));
         break;
         case 96:
         mat2x4(-432.246, 394.676, -41.68, -8.5, 71.92, 7.0, -568.188, 2990.2006);
         case 95:
         (bvec2(false, true) , bvec2(true, false));
         default:
         1;
        }
      }
     if(_GLF_DEAD(false))
      return;
     do
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          {
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 return;
                }
               else
                {
                }
              }
            }
           return;
          }
         return;
        }
      }
     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
     return;
    }
  }
 else
  {
   if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(_GLF_IDENTITY(bvec2(false, true), bvec2(bvec4(bvec2(false, true), false, false)))), bool(bvec2(bool(_GLF_IDENTITY(bvec2(false, true), bvec2(bvec4(bvec2(false, true), false, false)))), false))))))
    return;
  }
 if(_GLF_DEAD(false))
  return;
 uint subgroup_id = gl_SubgroupID;
 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
  {
   switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
    {
     case 0:
     case 46:
     case 25:
     case 93:
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
      {
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        break;
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           barrier();
           if(_GLF_DEAD(false))
            continue;
          }
         else
          {
           if(_GLF_DEAD(false))
            break;
          }
        }
       if(_GLF_DEAD(false))
        break;
      }
     break;
     case 64:
     if(true)
      {
       uvec3(uvec2(52515u, 24815u), 77787u);
      }
     default:
     1;
    }
  }
 else
  {
  }
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  {
   for(int _injected_loop_counter = _GLF_IDENTITY(1, (1) | (1)); _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
    {
     return;
    }
   if(_GLF_DEAD(false))
    return;
  }
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     return;
    }
   else
    {
    }
  }
uint subgroup_size = 16;
 if(_GLF_DEAD(false))
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
      {
       do
        {
         return;
        }
       while(_GLF_WRAPPED_LOOP(false));
      }
     return;
    }
   return;
   if(_GLF_DEAD(false))
    {
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(0), int(0))) >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), ~ (~ (int(0))))))); _injected_loop_counter ++)
      {
       return;
      }
    }
  }
 if(_GLF_DEAD(false))
  return;
 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
  {
   if(_GLF_WRAPPED_IF_TRUE(true))
    {
     switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
      {
       case 65:
       mat3x4 _GLF_SWITCH_3_0v;
       case 0:
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          break;
         break;
        }
       if(_GLF_DEAD(false))
        break;
       case 14:
       if(_GLF_DEAD(false))
        return;
       case 25:
       if(_GLF_DEAD(false))
        {
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(false))
          continue;
         if(_GLF_WRAPPED_IF_FALSE(false))
          {
          }
         else
          {
           return;
          }
        }
       case 88:
       case 23:
       case 95:
       if(_GLF_DEAD(false))
        break;
       if(_GLF_DEAD(false))
        break;
       if(_GLF_DEAD(false))
        {
         switch(_GLF_SWITCH(0))
          {
           case 24:
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           bvec3 _GLF_SWITCH_4_0v[84], _GLF_SWITCH_4_1v;
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
           case 11:
           if(_GLF_DEAD(false))
            continue;
           ivec4 _GLF_SWITCH_4_2v[24];
           case 0:
           case 26:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              return;
             continue;
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_DEAD(false))
                barrier();
              }
             else
              {
              }
             return;
            }
           case 31:
           case 17:
           if(_GLF_DEAD(false))
            break;
           case 48:
           case 25:
           case 86:
           case 72:
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
            }
           else
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             do
              {
               return;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 switch(_GLF_SWITCH((0 << _GLF_IDENTITY(int(2), int(2)))))
                  {
                   case 44:
                   (mat2(8292.5526, 1992.6972, 724.546, 9.6) * mat3x2(-9.9, 673.157, 2.6, 652.742, -9169.4981, -1849.1899));
                   case 0:
                   case 23:
                   do
                    {
                     return;
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                   case 93:
                   case 31:
                   case 47:
                   case 24:
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    continue;
                   break;
                   case 41:
                   _injected_loop_counter;
                   case 15:
                   ;
                   default:
                   1;
                  }
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
            }
           if(_GLF_DEAD(false))
            continue;
           break;
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(false))
            break;
           if(_GLF_DEAD(false))
            break;
           case 9:
           (mat4(-9.2, 298.598, 10.01, 8.8, -8.2, 1501.9910, -686.863, -85.97, 3.5, -497.206, 8.2, -6469.6898, -743.167, -7.2, 328.394, 1.8) + vec2(-6.9, -1751.6246)[1]);
           case 27:
           subgroup_id;
           default:
           if(_GLF_DEAD(false))
            return;
           1;
          }
         if(_GLF_DEAD(false))
          continue;
         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 & 1) | 0)); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              break;
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               barrier();
              }
             else
              {
              }
            }
          }
         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
          return;
        }
       if(_GLF_DEAD(false))
        continue;
       if(_GLF_DEAD(false))
        barrier();
       break;
       case 13:
       do
        {
         mat4x2(-74.09, 6.9, 607.063, 8.9, 140.362, -4388.5217, -9200.8965, 17.16);
        }
       while(_GLF_WRAPPED_LOOP(false));
       if(_GLF_DEAD(false))
        continue;
       case 79:
       vec4 _GLF_SWITCH_3_1v;
       default:
       1;
      }
    }
   else
    {
     if(_GLF_DEAD(false))
      return;
    }
  }
 do
  {
   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
    {
     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
      {
       switch(_GLF_SWITCH(0))
        {
         case 2:
         if(true)
          {
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(false))
                return;
               subgroup_size;
               bvec2 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v, _GLF_SWITCH_4_2v;
               ;
               mat4x2 _GLF_SWITCH_4_3v, _GLF_SWITCH_4_4v[90], _GLF_SWITCH_4_5v;
               for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(2), int(2))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                {
                 findLSB(ivec4(-99476, -21668, -64396, -23978));
                }
               (injectionSwitch / 4.7);
               bool _GLF_SWITCH_4_6v, _GLF_SWITCH_4_7v[27], _GLF_SWITCH_4_8v;
              }
            }
           else
            {
            }
           while(true)
            {
             do
              {
               ;
              }
             while(_GLF_WRAPPED_LOOP(false));
             mat2 _GLF_SWITCH_4_9v, _GLF_SWITCH_4_10v, _GLF_SWITCH_4_11v[57];
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
              {
               mat3x2(-9048.3607, -8340.7448, 1.0, 8.1, 4.5, -9211.7152);
              }
             vec2 _GLF_SWITCH_4_12v, _GLF_SWITCH_4_13v;
             bitfieldReverse(uvec3(18737u, 31774u, 50432u));
             if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec2(false, false)))))
              {
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 return;
                }
               else
                {
                }
              }
            }
           if(_GLF_DEAD(false))
            break;
           if(false)
            {
             vec3 _GLF_SWITCH_4_14v;
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
               if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), ! (! (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)))))))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                 return;
                }
              }
             else
              {
               if(_GLF_DEAD(false))
                return;
               ivec2(58614, -98513);
              }
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               mat2x3(-27.93, 7182.4030, 2.7, -4.9, 1660.9975, -8.9);
              }
             else
              {
              }
             vec2 _GLF_SWITCH_4_15v, _GLF_SWITCH_4_16v, _GLF_SWITCH_4_17v;
             ((mat2x4(5013.5837, 229.006, -4.4, -2367.0471, -9.8, -35.57, -7917.4102, -828.612) + mat2x4(7.8, -36.30, 3.7, -8.9, 42.73, -6.3, -8621.3603, 2.1)) - mat2x4(43.10, 923.152, 9.6, -1886.7237, -8.0, -2968.7477, 4915.5347, -0.3));
             subgroup_size;
             for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(6), max(int(6), int(6))))) >> _GLF_IDENTITY(int(6), int(6))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
              {
               (mat4x3(94.99, 9.3, -35.62, 38.17, 71.40, -53.60, 9426.3024, -5817.4539, 55.56, 89.60, -7.1, 29.48) - mat4x3(mat3x4(2.6, 3370.6113, -744.605, 57.63, 2.5, 3383.6962, 5.9, -4.1, 11.53, -9.2, 8475.5022, -164.884)));
              }
             do
              {
               switch(_GLF_SWITCH(0))
                {
                 case 0:
                 case 80:
                 case 79:
                 case 63:
                 case 83:
                 case 26:
                 case 9:
                 case 48:
                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                  {
                   lessThan(atan(vec4(-4714.9267, -1.2, 2957.9685, -366.447)), vec4(23.58, 85.79, -9.5, 97.47));
                  }
                 break;
                 case 50:
                 uvec3(131110u, 108391u, 162924u);
                 case 17:
                 int _GLF_SWITCH_5_0v;
                 default:
                 1;
                }
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
             mat2(-10.35, -4.4, 3.7, -3.5);
            }
           else
            {
             false;
             mat4x3(mat4(-7.2, -6927.4603, 2.7, -25.58, -7.1, 5.7, -670.711, -6549.9640, 64.45, 384.165, 6.8, 1414.1591, -5.5, 9.6, 3492.9397, 574.567));
             do
              {
               ;
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_DEAD(false))
              barrier();
             mat4(mat3(-673.699, -1.5, 4.1, -23.73, 396.807, 34.81, -460.116, 680.124, -3693.9642));
             if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, bool(bvec4(true, true, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)), true)))))
              {
               (true ? bvec3(true, true, false) : bvec3(false, true, true));
              }
             else
              {
              }
             do
              {
               mat3x2(-1099.1370, 2753.4042, -94.55, -0.2, -2340.8221, 4.7);
              }
             while(_GLF_WRAPPED_LOOP(false));
             if(_GLF_DEAD(false))
              break;
             (isnan(vec4(73.08, -2725.5207, 4.3, -15.64)));
            }
           vec3 _GLF_SWITCH_4_18v;
           if((mat4x3(-8.4, -4060.6893, 608.158, 82.09, 4.2, -3.2, 825.348, 9.3, -5.0, 661.310, 6.8, 551.829) != mat4x3(7131.0686, -7.9, 6.8, 3.4, -521.179, -95.58, -8.3, 0.0, -3.6, -457.373, 4213.2178, -5293.0651)))
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             ivec3(14501, -48909, -3736);
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(2), int(2))) >> _GLF_IDENTITY(int(2), _GLF_IDENTITY(int(2), (false ? _GLF_FUZZED(-49676) : int(2)))))); _injected_loop_counter ++)
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 do
                  {
                   barrier();
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || false)));
                }
              }
             mat3 _GLF_SWITCH_4_19v[20], _GLF_SWITCH_4_20v;
             float _GLF_SWITCH_4_21v[70];
            }
           mat2x3(-5277.7741, 3.5, 7.1, -2646.2971, 1.1, 2.1);
           uint _GLF_SWITCH_4_22v;
          }
         else
          {
          }
         case 15:
         mat2x3 _GLF_SWITCH_4_23v, _GLF_SWITCH_4_24v, _GLF_SWITCH_4_25v;
         case 0:
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_DEAD(false))
              continue;
             if(_GLF_DEAD(false))
              continue;
             return;
             if(_GLF_DEAD(false))
              continue;
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           return;
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false || (_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), bool(bvec2(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), false)))))))
            {
             switch(_GLF_SWITCH(0))
              {
               case 28:
               -464.857;
               case 0:
               if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                return;
               case 5:
               case 23:
               case 12:
               if(_GLF_DEAD(false))
                continue;
               case 73:
               case 4:
               return;
               case 24:
               case 90:
               case 51:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                barrier();
               break;
               case 65:
               78695;
               case 27:
               do
                {
                 ivec3(-56234, 24032, -1896).yyzy;
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
               default:
               1;
              }
            }
          }
         else
          {
          }
         break;
         case 27:
         for(float _GLF_SWITCH_4_26v, _GLF_SWITCH_4_27v[72]; false; ((bvec3(true, false, false).p ? ivec3(-89959, -57203, -75579) : (ivec3(40757, -47842, -82211) >> -5684)) / (- 35855)))
          {
           do
            {
             if(_GLF_DEAD(false))
              {
               if(_GLF_DEAD(false))
                barrier();
               return;
              }
            }
           while(_GLF_WRAPPED_LOOP(false));
           uvec2(uvec3(33585u, 186199u, 46795u));
           if(_GLF_DEAD(false))
            continue;
           if(false)
            {
             (ivec4(69712, 33286, 17685, -52124) + ivec4(91291, 91615, -68116, -38227));
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              break;
             mat3x4 _GLF_SWITCH_4_28v;
             36685;
             mat4x3 _GLF_SWITCH_4_29v;
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
              break;
             uvec3(190407u, 123182u, 154525u);
             mat4x2(5864.6674, -626.208, -711.584, -9315.4141, 78.69, 9.6, -1.7, 0.2);
            }
           {
            mat3 _GLF_SWITCH_4_30v, _GLF_SWITCH_4_31v;
            if(_GLF_DEAD(false))
             continue;
            if(_GLF_WRAPPED_IF_FALSE(false))
             {
             }
            else
             {
              ;
             }
            uvec3(64796u, 161393u, 117881u);
            if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
             {
              bvec3(true, bvec2(false, false));
             }
            else
             {
             }
            ;
            if(_GLF_DEAD(false))
             continue;
            uvec3 _GLF_SWITCH_4_32v, _GLF_SWITCH_4_33v;
            if(_GLF_DEAD(false))
             continue;
            mat4x2(mat4(-5.5, -6.5, -2.9, 60.38, 732.027, -8.7, 4.8, 10.78, -841.452, -6400.2174, 5332.1423, -609.903, -6544.7137, 280.974, 183.197, 1.2));
            if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
             {
             }
            else
             {
              163090u;
             }
           }
           bvec3(bvec2(false, true), bvec3(false, true, true)[2]);
           for(uvec3 _GLF_SWITCH_4_34v, _GLF_SWITCH_4_35v[4], _GLF_SWITCH_4_36v; true; matrixCompMult(mat4x3(-70.51, -185.585, 1760.7229, 5998.7926, -338.976, 2.7, 4.8, -86.68, 3.6, 9.2, -9454.2960, -767.169), mat4x3(-77.94, 8.5, -39.76, -2687.5694, -234.894, -570.758, -96.07, 2.3, -6031.1511, 26.66, 55.80, -94.86)))
            {
             mat2x4 _GLF_SWITCH_4_37v, _GLF_SWITCH_4_38v, _GLF_SWITCH_4_39v[68];
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               vec2(-6.8, 0.2);
              }
            }
           {
            if(_GLF_DEAD(false))
             break;
            if(_GLF_DEAD(false))
             break;
            for(int _injected_loop_counter = (0 | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
             {
              ;
             }
            (vec3(83.81, -8.1, 7.5) + vec3(9.3, 6.9, 524.654));
            if(_GLF_WRAPPED_IF_TRUE(true))
             {
              uvec2(131310u, 148128u);
             }
            else
             {
             }
            if(_GLF_DEAD(false))
             break;
            findLSB(130400u);
            if(_GLF_DEAD(false))
             barrier();
            int _GLF_SWITCH_4_40v, _GLF_SWITCH_4_41v, _GLF_SWITCH_4_42v;
            for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (-71268 & 0)); _injected_loop_counter --)
             {
              inverse(outerProduct(vec3(9.9, 2.2, -7.1), vec3(-991.306, -0.1, -650.862)));
             }
            int _GLF_SWITCH_4_43v[61];
            mat2x4(-4476.9031, -571.560, 53.58, -6032.8117, 4.3, -356.087, 8444.2229, -77.34);
           }
          }
         default:
         if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, bool(bvec3(false, false, _GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y)))))))
          {
          }
         else
          {
           1;
           if(_GLF_DEAD(false))
            continue;
          }
        }
      }
    }
   else
    {
     if(_GLF_DEAD(false))
      return;
    }
  }
 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
  {
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    {
    }
   else
    {
     return;
    }
  }
 uint subgroup_local_id = gl_SubgroupInvocationID;
 do
  {
   if(_GLF_DEAD(false))
    {
     switch(_GLF_SWITCH(0))
      {
       case 96:
       vec3(-57.57, 0.1, 1350.8806);
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true)))
          continue;
         return;
        }
       case 0:
       case 80:
       if(_GLF_DEAD(false))
        break;
       case 69:
       if(_GLF_DEAD(false))
        {
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            barrier();
          }
         else
          {
          }
         barrier();
        }
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         return;
        }
       else
        {
        }
       break;
       default:
       if(_GLF_WRAPPED_IF_TRUE(true))
        {
         1;
        }
       else
        {
        }
       if(_GLF_DEAD(false))
        barrier();
      }
    }
  }
 while(_GLF_WRAPPED_LOOP(false));
 _GLF_struct_5 _GLF_struct_replacement_5 = _GLF_struct_5(bvec2(true), _GLF_struct_1(_GLF_struct_0(1u, mat4x3(1.0), bvec2(true), uvec2(1u)), gl_NumWorkGroups.x), mat3x2(1.0), _GLF_struct_4(_GLF_struct_2(mat4x2(1.0), mat2x4(1.0), vec4(1.0), mat2(1.0), mat3(1.0)), _GLF_struct_3(1.0, ivec3(1), 1.0, uvec4(1u), mat3x2(1.0))));
 do
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      {
       for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(5), int(5))) >> _GLF_IDENTITY(int(5), int(5))); _GLF_WRAPPED_LOOP(_injected_loop_counter != _GLF_IDENTITY(0, clamp(0, 0, 0))); _injected_loop_counter --)
        {
         return;
        }
      }
     barrier();
    }
  }
 while(_GLF_WRAPPED_LOOP(false));
 uint workgroup_size = gl_WorkGroupSize.x;
 do
  {
   if(_GLF_DEAD(false))
    break;
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      continue;
     if(_GLF_DEAD(false))
      break;
     return;
    }
  }
 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
 uint workgroup_id = gl_WorkGroupID.x;
 uint workgroup_base = workgroup_size * workgroup_id;
 _GLF_struct_8 _GLF_struct_replacement_8 = _GLF_struct_8(workgroup_base + subgroup_id * subgroup_size + subgroup_local_id, _GLF_struct_7(_GLF_struct_6(vec4(1.0), mat2x3(1.0), mat2(1.0), vec2(1.0), mat3x2(1.0), mat4x3(1.0)), 1));
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   if(_GLF_WRAPPED_IF_FALSE(false))
    {
    }
   else
    {
     if(_GLF_DEAD(false))
      return;
    }
   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
    return;
   for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(6), int(6))) >> _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(6), max(int(6), int(6)))))); _injected_loop_counter ++)
    {
     if(_GLF_DEAD(false))
      break;
     if(_GLF_DEAD(false))
      return;
    }
  }
 else
  {
  }
 if(_GLF_DEAD(false))
  barrier();
 uint next_virtual_gid = workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size);
 _GLF_struct_17 _GLF_struct_replacement_17 = _GLF_struct_17(1.0, bvec4(true), _GLF_struct_9(bvec4(true)), mat2x3(1.0), mat4(1.0), _GLF_struct_12(_GLF_struct_10(bvec2(true), atomicLoad(buf[_GLF_struct_replacement_8.virtual_gid], 4, 64, 0), vec2(1.0), mat4(1.0), vec3(1.0), mat2x3(1.0)), uvec2(1u), _GLF_struct_11(mat4(1.0))), _GLF_struct_16(_GLF_struct_13(mat3x4(1.0)), mat3x4(1.0), _GLF_struct_14(mat3(1.0), vec4(1.0), uvec4(1u), mat3(1.0)), _GLF_struct_15(mat2x4(1.0))));
 if(_GLF_DEAD(false))
  return;
 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
  {
   atomicStore(buf[next_virtual_gid], uint(_GLF_struct_replacement_17._f5._f0.read_1 + 1), 4, 64, 4);
  }
 else
  {
   if(_GLF_DEAD(false))
    return;
  }
 if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
  return;
 for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
  {
   if(_GLF_DEAD(false))
    {
     if(_GLF_DEAD(false))
      barrier();
     continue;
    }
   if(_GLF_DEAD(false))
    {
     do
      {
       return;
      }
     while(_GLF_WRAPPED_LOOP(false));
    }
  }
 uint read_2 = atomicLoad(buf[_GLF_struct_replacement_8.virtual_gid], 4, 64, 0);
 if(_GLF_WRAPPED_IF_TRUE(true))
  {
   if(subgroup_local_id + 1 < subgroup_size)
    {
     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != (1 | 1)); _injected_loop_counter ++)
      {
       switch(_GLF_SWITCH(0))
        {
         case 16:
         {
          ivec2 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v[38], _GLF_SWITCH_5_2v;
          bool _GLF_SWITCH_5_3v[80], _GLF_SWITCH_5_4v[29];
         }
         case 84:
         {
          vec3 _GLF_SWITCH_5_5v, _GLF_SWITCH_5_6v[87], _GLF_SWITCH_5_7v[33];
          mat3x4 _GLF_SWITCH_5_8v, _GLF_SWITCH_5_9v;
          for(int _GLF_SWITCH_5_10v[64]; (-49302 >= 5752); (vec3(83.83, 160.883, 849.622) * vec3(-309.405, 7.5, 37.67)))
           {
            if(_GLF_WRAPPED_IF_TRUE(true))
             {
              bvec3(true, false, false);
             }
            else
             {
             }
            473.532;
            while(true)
             {
              int _GLF_SWITCH_5_11v, _GLF_SWITCH_5_12v;
             }
           }
          if(false)
           {
            for(int _injected_loop_counter = (0 >> _GLF_IDENTITY(int(1), int(1))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
             {
              while((min(uvec2(80284u, 199782u), uvec2(1088u, 115587u)) != uvec2(107668u, 46174u)))
               {
                mat3x4(round(-63.68), 18.91, -1405.9595, reflect(47.66, 6919.6108), -7.3, 4204.3110, 62.56, log2(-5.0), 9138.0655, -4389.4259, 588.158, 1.9);
                vec2(-37.46, -3988.4804);
                mat3x2 _GLF_SWITCH_5_13v, _GLF_SWITCH_5_14v;
                bvec3 _GLF_SWITCH_5_15v;
                uint _GLF_SWITCH_5_16v[27], _GLF_SWITCH_5_17v, _GLF_SWITCH_5_18v;
                ivec4 _GLF_SWITCH_5_19v;
                mat4x3 _GLF_SWITCH_5_20v, _GLF_SWITCH_5_21v;
               }
             }
            mat4x3 _GLF_SWITCH_5_22v[43];
            uint _GLF_SWITCH_5_23v;
            44541;
            (uvec2(125409u, 172747u) << uvec2(137696u, 194783u));
            ;
           }
          {
           while((next_virtual_gid < subgroup_id))
            {
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               ;
              }
             else
              {
              }
             -31226;
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
              {
               bvec3(false);
              }
             mat3x2 _GLF_SWITCH_5_24v;
             mat2x4(3084.7825, -67.31, -9.3, -9201.7362, -9897.5717, -8218.6781, -8.2, 7912.4597);
             inverse(mat2(-26.73, -6804.3601, 25.81, -7.0));
            }
           mat4 _GLF_SWITCH_5_25v, _GLF_SWITCH_5_26v, _GLF_SWITCH_5_27v;
           vec3 _GLF_SWITCH_5_28v;
           do
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               (subgroup_id);
              }
             else
              {
              }
             ;
             true;
             uvec4(26636u, 49287u, 7420u, 141148u);
             do
              {
               outerProduct(vec4(9450.7251, 797.215, 3.1, -5602.4842), _GLF_SWITCH_5_28v);
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
            }
           while((faceforward(2.5, 51.02, -6.6) >= 11.76));
           {
            mat2(-143.069, 6.0, 2.3, -219.758);
            (greaterThan(ivec3(74349, -23208, 37979), ivec3(15051, 93177, -21357)) == lessThan(ivec3(5842, -24622, 22317), ivec3(-25562, -61178, 99475)));
            bvec2 _GLF_SWITCH_5_29v, _GLF_SWITCH_5_30v[84];
            ;
            clamp((workgroup_size | uvec4(59020u, 157340u, 191859u, 21053u)), clamp(uvec4(128933u, 41498u, 26864u, 39732u), workgroup_size, workgroup_base), uvec4(49766u, 163325u, 156970u, 83629u));
           }
           uint _GLF_SWITCH_5_31v;
           {
            vec2 _GLF_SWITCH_5_32v, _GLF_SWITCH_5_33v[12], _GLF_SWITCH_5_34v;
           }
           mat2x4(9533.3832, 3.3, 22.70, -3.9, -92.44, -3.4, -2.8, -7310.5748);
           if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
            {
             mat3(-9.2, 780.190, 563.036, -2.3, -3.9, -62.37, -77.00, 9328.5483, -12.59);
            }
           else
            {
            }
          }
          _GLF_SWITCH_5_8v;
         }
         case 0:
         case 9:
         case 30:
         case 85:
         case 44:
         switch(_GLF_SWITCH(0))
          {
           case 89:
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) && true)))
            return;
           if(_GLF_DEAD(false))
            return;
           mat2x3 _GLF_SWITCH_0_0v[30];
           if(_GLF_DEAD(false))
            return;
           case 0:
           case 79:
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           if(_GLF_DEAD(false))
            return;
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
            {
             if(_GLF_DEAD(false))
              break;
             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
              {
               if(_GLF_DEAD(false))
                continue;
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  continue;
                 continue;
                }
               if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, (false) && true))))))
                continue;
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(false))
                    break;
                   return;
                  }
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    barrier();
                   break;
                  }
                }
               else
                {
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_DEAD(false))
                  continue;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                 break;
                }
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  continue;
                 continue;
                }
               if(_GLF_DEAD(false))
                break;
               atomicStore(buf[next_virtual_gid], uint(_GLF_struct_replacement_17._f5._f0.read_1 + 1 == read_2) + 1, 4, 64, 4);
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(false))
                break;
               if(_GLF_DEAD(false))
                return;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
              }
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             do
              {
               if(_GLF_DEAD(false))
                return;
              }
             while(_GLF_WRAPPED_LOOP(false));
             return;
            }
           case 28:
           case 39:
           if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), true && (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))))
            return;
           case 94:
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               return;
              }
             else
              {
              }
            }
           do
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           while(_GLF_WRAPPED_LOOP(false));
           if(_GLF_DEAD(false))
            return;
           if(_GLF_DEAD(false))
            {
             switch(_GLF_SWITCH(0))
              {
               case 16:
               mat4 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v;
               case 85:
               mat2 _GLF_SWITCH_5_2v, _GLF_SWITCH_5_3v, _GLF_SWITCH_5_4v[99];
               case 0:
               case 80:
               case 83:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               case 35:
               case 56:
               case 43:
               if(_GLF_DEAD(false))
                return;
               case 33:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                return;
               case 9:
               case 26:
               case 22:
               for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                {
                 return;
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  break;
                }
               break;
               case 54:
               (-99519 / 40184);
               case 20:
               bvec2 _GLF_SWITCH_5_5v;
               default:
               1;
              }
            }
           do
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 return;
                }
              }
             subgroupAll(false);
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
            {
             if(_GLF_DEAD(false))
              return;
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                {
                 if(_GLF_DEAD(false))
                  return;
                }
               return;
              }
             else
              {
               do
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
              }
            }
           break;
           case 76:
           if(_GLF_DEAD(false))
            barrier();
           if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bvec3(false, true, false)))))
            {
             if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
              {
               return;
              }
             else
              {
              }
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           do
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             if(_GLF_DEAD(false))
              {
               do
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    {
                     for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                      {
                       return;
                      }
                    }
                   break;
                  }
                 return;
                }
               while(_GLF_WRAPPED_LOOP(false));
              }
            }
           while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
           if(true)
            {
             bvec2 _GLF_SWITCH_0_1v, _GLF_SWITCH_0_2v[37];
             uint _GLF_SWITCH_0_3v, _GLF_SWITCH_0_4v[58];
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              {
               for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                 if(_GLF_DEAD(false))
                  break;
                }
               return;
              }
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               mat4(-4029.3614, 53.30, 250.532, -33.15, -529.724, 7989.7547, -4850.7385, -3.3, -9983.5028, 90.05, 8553.8809, 4.5, 7271.4030, 7.8, -3.5, 3.2);
              }
             bool _GLF_SWITCH_0_5v, _GLF_SWITCH_0_6v[66];
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             {
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               return;
              if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
               {
                if(_GLF_DEAD(false))
                 {
                  if(_GLF_DEAD(false))
                   return;
                  for(int _injected_loop_counter = (0 ^ 0); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                   {
                    return;
                   }
                 }
               }
              else
               {
               }
              if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
               barrier();
              if(false)
               {
                ivec4(98857, 47554, 46569, -30058);
                if(_GLF_DEAD(false))
                 return;
                if(_GLF_WRAPPED_IF_FALSE(false))
                 {
                 }
                else
                 {
                  ;
                  if(_GLF_DEAD(false))
                   return;
                  if(_GLF_WRAPPED_IF_FALSE(_GLF_IDENTITY(false, ! (! (false)))))
                   {
                   }
                  else
                   {
                    do
                     {
                      if(_GLF_DEAD(false))
                       {
                        if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                         {
                          return;
                         }
                        else
                         {
                         }
                       }
                      if(_GLF_DEAD(false))
                       continue;
                     }
                    while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                   }
                 }
                if(_GLF_WRAPPED_IF_TRUE(true))
                 {
                  if(_GLF_DEAD(false))
                   barrier();
                 }
                else
                 {
                 }
                do
                 {
                  if(_GLF_DEAD(_GLF_IDENTITY(false, bool(bool(false)))))
                   {
                    if(_GLF_DEAD(false))
                     return;
                    for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter > int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                     {
                      return;
                     }
                   }
                 }
                while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                ;
                if(_GLF_DEAD(false))
                 {
                  if(_GLF_WRAPPED_IF_FALSE(false))
                   {
                   }
                  else
                   {
                    return;
                   }
                  do
                   {
                    if(_GLF_DEAD(false))
                     return;
                   }
                  while(_GLF_WRAPPED_LOOP(false));
                 }
                if(_GLF_DEAD(false))
                 {
                  if(_GLF_DEAD(false))
                   return;
                  return;
                 }
               }
              else
               {
                if(_GLF_DEAD(false))
                 {
                  if(_GLF_WRAPPED_IF_TRUE(true))
                   {
                    return;
                   }
                  else
                   {
                    if(_GLF_DEAD(false))
                     return;
                   }
                 }
               }
              if(_GLF_DEAD(false))
               return;
              if(_GLF_DEAD(false))
               return;
              if(_GLF_WRAPPED_IF_FALSE(false))
               {
               }
              else
               {
                for(                vec2(-5.6, length(cos(vec4(37.88, -1.6, -3256.9424, -36.88))));
 true; outerProduct(atan(vec3(93.99, 14.83, -10.34), vec3(-937.041, 16.75, 6263.5039)), vec3(9.1, 9297.5305, 872.098)))
                 {
                  if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                   break;
                  switch(_GLF_SWITCH((0 >> _GLF_IDENTITY(int(5), int(5)))))
                   {
                    case 13:
                    mat2 _GLF_SWITCH_2_0v[28];
                    if(_GLF_DEAD(false))
                     break;
                    if(_GLF_DEAD(false))
                     {
                      do
                       {
                        if(_GLF_DEAD(false))
                         return;
                        if(_GLF_DEAD(false))
                         barrier();
                        if(_GLF_DEAD(false))
                         break;
                       }
                      while(_GLF_WRAPPED_LOOP(false));
                      if(_GLF_DEAD(false))
                       {
                        if(_GLF_DEAD(false))
                         barrier();
                        continue;
                       }
                      if(_GLF_DEAD(false))
                       continue;
                      break;
                     }
                    if(_GLF_DEAD(false))
                     return;
                    case 0:
                    if(_GLF_DEAD(false))
                     {
                      do
                       {
                        return;
                       }
                      while(_GLF_WRAPPED_LOOP(false));
                     }
                    vec2 _GLF_SWITCH_0_7v;
                    case 5:
                    case 43:
                    if(_GLF_DEAD(false))
                     break;
                    for(int _injected_loop_counter = (0 << _GLF_IDENTITY(int(0), int(0))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                     {
                      if(_GLF_WRAPPED_IF_FALSE(false))
                       {
                       }
                      else
                       {
                        if(_GLF_DEAD(false))
                         return;
                       }
                      do
                       {
                        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                         continue;
                        mat4x2(-517.015, 146.738, 1616.7887, -3235.4350, 385.352, 2.7, 51.12, 8194.2806);
                       }
                      while(_GLF_WRAPPED_LOOP(false));
                     }
                    if(_GLF_DEAD(false))
                     break;
                    do
                     {
                      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                       continue;
                      if(_GLF_DEAD(false))
                       break;
                      (uvec3(82695u, 59466u, 191253u) - uvec3(45301u, 160572u, 143359u));
                     }
                    while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                    case 38:
                    if(_GLF_DEAD(false))
                     {
                      if(_GLF_WRAPPED_IF_FALSE(false))
                       {
                       }
                      else
                       {
                        return;
                       }
                     }
                    case 62:
                    if(_GLF_DEAD(false))
                     continue;
                    ivec3(84290, -31022, -99737);
                    case 95:
                    if(_GLF_DEAD(false))
                     continue;
                    if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     barrier();
                    if(_GLF_DEAD(false))
                     {
                      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                       continue;
                      continue;
                     }
                    case 34:
                    if(_GLF_DEAD(false))
                     continue;
                    65045;
                    vec4 _GLF_SWITCH_0_8v, _GLF_SWITCH_0_9v;
                    if(_GLF_DEAD(_GLF_IDENTITY(_GLF_IDENTITY(false, true && (false)), false || (_GLF_IDENTITY(false, true && (false))))))
                     break;
                    if(_GLF_DEAD(false))
                     {
                      do
                       {
                        return;
                       }
                      while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                     }
                    if(_GLF_WRAPPED_IF_TRUE(true))
                     {
                      if(_GLF_WRAPPED_IF_FALSE(false))
                       {
                       }
                      else
                       {
                        (bvec3(true, false, true) , bitCount(uvec4(41460u, 160162u, 42918u, 46194u)));
                       }
                      if(_GLF_DEAD(false))
                       break;
                      if(_GLF_DEAD(false))
                       {
                        if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                         continue;
                        break;
                       }
                      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                       {
                        for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (int(_GLF_ZERO(0.0, injectionSwitch.x)) & 35012)); _injected_loop_counter --)
                         {
                          barrier();
                         }
                       }
                      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                       continue;
                     }
                    else
                     {
                     }
                    break;
                    case 67:
                    mat3x2(-594.247, -1680.6582, -6376.4014, 8.1, 31.15, 867.255);
                    default:
                    1;
                    if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     continue;
                    if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     {
                      if(_GLF_WRAPPED_IF_TRUE(true))
                       {
                        if(_GLF_DEAD(false))
                         {
                          for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(7), int(7))) >> _GLF_IDENTITY(int(7), _GLF_IDENTITY(int(7), ~ (~ (int(7))))))); _injected_loop_counter ++)
                           {
                            return;
                           }
                         }
                       }
                      else
                       {
                       }
                      barrier();
                     }
                   }
                 }
               }
              if(_GLF_DEAD(false))
               return;
              vec4(-1.2, 6.9, -7.6, 21.27);
              if(_GLF_WRAPPED_IF_FALSE(false))
               {
               }
              else
               {
                while(_GLF_SWITCH_0_5v)
                 {
                  if(_GLF_WRAPPED_IF_TRUE(true))
                   {
                    ivec4(-66126, -99304, 7989, 57380);
                   }
                  else
                   {
                   }
                  do
                   {
                    if(_GLF_DEAD(false))
                     return;
                   }
                  while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                  mat3 _GLF_SWITCH_0_10v;
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   return;
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   break;
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   continue;
                  for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                   {
                    do
                     {
                      if(_GLF_DEAD(false))
                       continue;
                      do
                       {
                        if(_GLF_WRAPPED_IF_FALSE(false))
                         {
                         }
                        else
                         {
                          if(_GLF_DEAD(false))
                           continue;
                          for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 | 0)); _injected_loop_counter --)
                           {
                            ;
                           }
                          if(_GLF_DEAD(false))
                           return;
                          if(_GLF_DEAD(false))
                           return;
                         }
                        if(_GLF_DEAD(false))
                         break;
                       }
                      while(_GLF_WRAPPED_LOOP(false));
                      if(_GLF_DEAD(false))
                       break;
                     }
                    while(_GLF_WRAPPED_LOOP(false));
                   }
                  if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                   return;
                  if(_GLF_WRAPPED_IF_TRUE(true))
                   {
                    for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                     {
                      if(_GLF_WRAPPED_IF_TRUE(true))
                       {
                        ;
                       }
                      else
                       {
                       }
                      if(_GLF_DEAD(false))
                       continue;
                      if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                       break;
                     }
                   }
                  else
                   {
                   }
                  vec2(-4.0, -892.643);
                  if(_GLF_WRAPPED_IF_FALSE(false))
                   {
                   }
                  else
                   {
                    if(_GLF_DEAD(false))
                     return;
                    mat4x2(-4083.1855, -28.69, 2.0, 9.0, 8.5, -3.5, -41.51, 6.9);
                    if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                     return;
                   }
                  if(_GLF_WRAPPED_IF_FALSE(false))
                   {
                   }
                  else
                   {
                    if(_GLF_DEAD(false))
                     continue;
                    if(_GLF_DEAD(false))
                     continue;
                    (++ workgroup_id);
                   }
                  float _GLF_SWITCH_0_11v[36], _GLF_SWITCH_0_12v, _GLF_SWITCH_0_13v;
                  if(_GLF_DEAD(false))
                   continue;
                  if(_GLF_DEAD(false))
                   break;
                 }
                if(_GLF_DEAD(false))
                 return;
                if(_GLF_DEAD(false))
                 barrier();
               }
              if(_GLF_DEAD(false))
               return;
             }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              barrier();
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               if(_GLF_DEAD(false))
                barrier();
               mat3x4(5.1, -455.215, -8.6, 6.5, 6.1, -24.61, 6.5, 4873.0640, 2.5, -3.3, -5.6, 4.5);
              }
             else
              {
              }
             do
              {
               if(_GLF_DEAD(false))
                continue;
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(false))
                  {
                   switch(_GLF_SWITCH((0 | (int(_GLF_ZERO(0.0, injectionSwitch.x)) | int(_GLF_ZERO(0.0, injectionSwitch.x))))))
                    {
                     case 0:
                     for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        return;
                      }
                     return;
                     break;
                     case 71:
                     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                      {
                       notEqual(vec4(-176.169, -4.1, -3.6, -1.0), vec4(-143.210, -5179.0734, -38.84, -4.5));
                      }
                     else
                      {
                      }
                     case 33:
                     ivec4 _GLF_SWITCH_5_0v, _GLF_SWITCH_5_1v[99];
                     default:
                     1;
                    }
                  }
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  continue;
                 break;
                 if(_GLF_DEAD(false))
                  break;
                }
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                 if(_GLF_DEAD(false))
                  {
                   do
                    {
                     if(_GLF_DEAD(_GLF_IDENTITY(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y)), (_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))) || false)))
                      break;
                     do
                      {
                       barrier();
                      }
                     while(_GLF_WRAPPED_LOOP(false));
                     if(_GLF_DEAD(false))
                      {
                       switch(_GLF_SWITCH(0))
                        {
                         case 32:
                         mat4x3(mat2x4(-7846.6844, 333.834, 3.6, -4.1, -4563.6357, 4404.9947, -250.120, -6.2));
                         case 0:
                         case 56:
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          continue;
                         case 12:
                         case 57:
                         case 43:
                         case 66:
                         return;
                         break;
                         case 96:
                         ;
                         case 78:
                         mat4(-5.0, -3568.6970, 117.625, -4.5, 4811.3663, -7525.9725, 3.4, 1.5, -825.605, -661.047, 6.0, 38.60, -23.11, 71.91, -1.3, 53.11);
                         default:
                         1;
                        }
                      }
                    }
                   while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                   do
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                    }
                   while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                  }
                }
               else
                {
                 if(_GLF_DEAD(false))
                  break;
                 do
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    continue;
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                    }
                   else
                    {
                     switch(_GLF_SWITCH(0))
                      {
                       case 0:
                       if(_GLF_DEAD(false))
                        return;
                       if(_GLF_WRAPPED_IF_FALSE(false))
                        {
                        }
                       else
                        {
                         if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          {
                          }
                         else
                          {
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            return;
                           for(int _injected_loop_counter = ((0 << _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(6), (int(6)) | (int(6))))) << _GLF_IDENTITY(int(7), int(7))); _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(4), int(4))) >> _GLF_IDENTITY(int(4), int(4)))); _injected_loop_counter ++)
                            {
                             ;
                            }
                          }
                        }
                       if(_GLF_DEAD(false))
                        {
                         do
                          {
                           if(_GLF_DEAD(false))
                            return;
                          }
                         while(_GLF_WRAPPED_LOOP(false));
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_DEAD(false))
                            {
                             if(_GLF_WRAPPED_IF_FALSE(false))
                              {
                              }
                             else
                              {
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                return;
                              }
                             break;
                            }
                           continue;
                          }
                         if(_GLF_DEAD(false))
                          break;
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          continue;
                         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                          {
                           return;
                          }
                         else
                          {
                           if(_GLF_DEAD(false))
                            continue;
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            continue;
                          }
                        }
                       if(_GLF_DEAD(false))
                        return;
                       case 34:
                       if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
                        continue;
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        return;
                       do
                        {
                         if(_GLF_WRAPPED_IF_FALSE(false))
                          {
                          }
                         else
                          {
                           mat3(mat4(545.302, 60.73, -8.5, 79.03, -855.237, 1.3, 40.34, -9.3, -61.12, -4522.1739, -6.0, -7722.7698, -80.52, 60.66, 30.24, 636.557));
                          }
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          continue;
                        }
                       while(_GLF_WRAPPED_LOOP(false));
                       case 72:
                       if(_GLF_WRAPPED_IF_TRUE(true))
                        {
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          return;
                        }
                       else
                        {
                        }
                       case 92:
                       mat3 _GLF_SWITCH_0_14v[5], _GLF_SWITCH_0_15v, _GLF_SWITCH_0_16v;
                       (ivec4(40568, -97081, 95981, -39659) | ivec4(-16247, -53590, -46851, 80673));
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        break;
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        {
                         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                          {
                           return;
                          }
                         else
                          {
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            continue;
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            return;
                          }
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          break;
                         if(_GLF_DEAD(false))
                          return;
                        }
                       if(_GLF_DEAD(false))
                        break;
                       if(_GLF_DEAD(_GLF_IDENTITY(false, (false) || false)))
                        {
                         if(_GLF_DEAD(false))
                          break;
                         if(_GLF_DEAD(false))
                          break;
                         break;
                        }
                       if(_GLF_DEAD(false))
                        continue;
                       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                        {
                         mat3x2(-8.5, 789.920, 5885.6190, -4375.1406, 20.03, -3420.9772);
                        }
                       case 98:
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                          return;
                         continue;
                        }
                       vec4(13.95, -9.4, -5786.1753, -2.3);
                       ivec4 _GLF_SWITCH_0_17v[18], _GLF_SWITCH_0_18v;
                       ivec2 _GLF_SWITCH_0_19v[21];
                       if(_GLF_DEAD(false))
                        continue;
                       if(_GLF_DEAD(false))
                        continue;
                       break;
                       case 46:
                       do
                        {
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_WRAPPED_IF_FALSE(false))
                            {
                            }
                           else
                            {
                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              {
                               if(_GLF_DEAD(false))
                                {
                                 for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(3), int(3))) >> _GLF_IDENTITY(int(3), int(3))); _GLF_WRAPPED_LOOP(_injected_loop_counter != (0 >> _GLF_IDENTITY(int(0), _GLF_IDENTITY(int(0), (int(0)) / 1)))); _injected_loop_counter --)
                                  {
                                   return;
                                  }
                                }
                               barrier();
                               if(_GLF_DEAD(false))
                                barrier();
                              }
                            }
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            return;
                           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > _GLF_IDENTITY(int(_GLF_ZERO(0.0, injectionSwitch.x)), (int(_GLF_ZERO(0.0, injectionSwitch.x))) * 1)); _injected_loop_counter --)
                            {
                             barrier();
                            }
                          }
                        }
                       while(_GLF_WRAPPED_LOOP(false));
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(false))
                          break;
                         continue;
                        }
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        {
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          break;
                         if(_GLF_DEAD(false))
                          {
                           if(_GLF_DEAD(false))
                            break;
                           break;
                          }
                         return;
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          {
                           if(_GLF_DEAD(false))
                            return;
                           break;
                          }
                        }
                       ivec3 _GLF_SWITCH_1_0v;
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        continue;
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        {
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          {
                           if(_GLF_DEAD(false))
                            barrier();
                           return;
                          }
                         break;
                        }
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(false))
                          continue;
                         return;
                        }
                       default:
                       if(_GLF_DEAD(false))
                        continue;
                       1;
                      }
                    }
                   if(_GLF_DEAD(false))
                    break;
                   for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                    {
                     (_GLF_SWITCH_0_5v ? min(ivec3(92803, 82241, 51011), -90593) : ivec3(-88502, -12497, -68486));
                    }
                   if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (_GLF_IDENTITY(false, ! (! (false))))))))
                    {
                     switch(_GLF_SWITCH((0 << _GLF_IDENTITY(int(0), int(0)))))
                      {
                       case 31:
                       bvec4(false, true, true, true);
                       case 0:
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        continue;
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(_GLF_IDENTITY(false, true && (_GLF_IDENTITY(false, (false) || false)))))
                          continue;
                         if(_GLF_DEAD(false))
                          barrier();
                         continue;
                        }
                       for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                        {
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          continue;
                         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                          {
                           if(_GLF_DEAD(false))
                            return;
                           return;
                          }
                         else
                          {
                          }
                         for(int _injected_loop_counter = (0 | 0); _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                          {
                           if(_GLF_DEAD(false))
                            return;
                          }
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          return;
                        }
                       if(_GLF_DEAD(false))
                        barrier();
                       break;
                       default:
                       1;
                      }
                    }
                   exp(-6249.3340);
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    return;
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      break;
                     return;
                    }
                   int _GLF_SWITCH_0_20v[83], _GLF_SWITCH_0_21v, _GLF_SWITCH_0_22v;
                   if(_GLF_DEAD(false))
                    continue;
                   mat2(193.825, 96.93, -151.795, 11.51);
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      return;
                    }
                   else
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        break;
                       if(_GLF_DEAD(false))
                        break;
                       for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                        {
                         return;
                        }
                      }
                    }
                   if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                    {
                     if(_GLF_WRAPPED_IF_TRUE(true))
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        {
                         do
                          {
                           if(_GLF_DEAD(false))
                            barrier();
                           switch(_GLF_SWITCH(0))
                            {
                             case 91:
                             for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                              {
                               outerProduct(max(intBitsToFloat(ivec4(-53257, -95809, 72648, 95419)), vec4(-866.877, -7079.7739, 8461.4776, -1.1)), vec2(-353.694, -7109.8685));
                              }
                             case 3:
                             if(_GLF_WRAPPED_IF_FALSE(false))
                              {
                               if(_GLF_DEAD(false))
                                continue;
                              }
                             else
                              {
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                continue;
                               uvec3(104568u, 154433u, 131398u);
                              }
                             if(_GLF_DEAD(false))
                              continue;
                             case 0:
                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              break;
                             case 26:
                             if(_GLF_DEAD(false))
                              {
                               if(_GLF_DEAD(false))
                                continue;
                               if(_GLF_DEAD(false))
                                continue;
                               return;
                              }
                             case 86:
                             case 97:
                             do
                              {
                               if(_GLF_DEAD(false))
                                return;
                              }
                             while(_GLF_WRAPPED_LOOP(false));
                             case 79:
                             if(_GLF_DEAD(false))
                              return;
                             return;
                             break;
                             case 74:
                             if(_GLF_DEAD(false))
                              break;
                             for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                              {
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                break;
                               uvec4(150517u, 26021u, 145553u, 95778u);
                              }
                             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                              return;
                             case 7:
                             if(_GLF_DEAD(false))
                              barrier();
                             bvec2 _GLF_SWITCH_4_0v, _GLF_SWITCH_4_1v, _GLF_SWITCH_4_2v[82];
                             default:
                             if(_GLF_WRAPPED_IF_TRUE(true))
                              {
                               1;
                               if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                                break;
                              }
                             else
                              {
                               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                                break;
                              }
                            }
                          }
                         while(_GLF_WRAPPED_LOOP(false));
                         do
                          {
                           if(_GLF_DEAD(false))
                            return;
                          }
                         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                        }
                      }
                     else
                      {
                      }
                     if(_GLF_WRAPPED_IF_TRUE(true))
                      {
                       if(_GLF_DEAD(false))
                        {
                         do
                          {
                           return;
                          }
                         while(_GLF_WRAPPED_LOOP(false));
                        }
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        continue;
                      }
                     else
                      {
                      }
                     if(_GLF_DEAD(false))
                      return;
                     if(_GLF_DEAD(false))
                      {
                       if(_GLF_DEAD(false))
                        continue;
                       continue;
                      }
                    }
                   else
                    {
                     do
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        barrier();
                      }
                     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                     if(_GLF_DEAD(false))
                      continue;
                    }
                   ivec4 _GLF_SWITCH_0_23v[38], _GLF_SWITCH_0_24v[6], _GLF_SWITCH_0_25v[66];
                   if(_GLF_DEAD(false))
                    return;
                   if(_GLF_DEAD(false))
                    continue;
                  }
                 while((bvec2(true, true) == bvec2(true, false)));
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                }
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
             if(_GLF_DEAD(false))
              return;
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
               if(_GLF_DEAD(false))
                return;
              }
            }
           else
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               if(_GLF_DEAD(false))
                return;
              }
             do
              {
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_WRAPPED_IF_FALSE(false))
                      {
                      }
                     else
                      {
                       return;
                      }
                    }
                  }
                 if(_GLF_WRAPPED_IF_FALSE(false))
                  {
                  }
                 else
                  {
                   switch(_GLF_SWITCH(0))
                    {
                     case 0:
                     if(_GLF_DEAD(false))
                      return;
                     case 54:
                     if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                      {
                       return;
                      }
                     else
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        return;
                      }
                     if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        continue;
                       barrier();
                      }
                     break;
                     case 77:
                     if(_GLF_DEAD(false))
                      break;
                     ivec3 _GLF_SWITCH_4_0v;
                     if(_GLF_DEAD(false))
                      return;
                     case 14:
                     uvec3(30869u, 72355u, 145805u);
                     default:
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      barrier();
                     1;
                    }
                  }
                 if(_GLF_DEAD(false))
                  break;
                }
              }
             while(_GLF_WRAPPED_LOOP(false));
             switch(_GLF_SWITCH(0))
              {
               case 67:
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 for(int _injected_loop_counter = int(_GLF_ONE(1.0, injectionSwitch.y)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                  {
                   if(_GLF_DEAD(false))
                    return;
                  }
                 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                  }
                 else
                  {
                   return;
                  }
                }
               do
                {
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     do
                      {
                       barrier();
                      }
                     while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                    }
                   continue;
                  }
                 if(_GLF_DEAD(false))
                  continue;
                 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                  {
                   if(bvec3(false, false, true).t)
                    {
                     switch(_GLF_SWITCH(0))
                      {
                       case 72:
                       vec2 _GLF_SWITCH_5_0v[92], _GLF_SWITCH_5_1v[43], _GLF_SWITCH_5_2v;
                       case 78:
                       mat4(-5.6, -8813.7809, -66.25, 2.2, -79.55, -2107.1861, -5234.0296, 6521.0942, -69.11, 7908.2332, 3.7, 2668.4503, 18.69, -854.296, 2.8, 23.78);
                       case 0:
                       case 88:
                       if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, bool(bvec4(true, false, true, true)))))
                        {
                         do
                          {
                           if(_GLF_DEAD(false))
                            return;
                          }
                         while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                         (mat4x2(55.82, -662.843, 2.6, 316.481, 17.71, -949.229, -6351.7471, -398.712) == mat4x2(1.6, -3.8, -309.847, -8376.5838, -2.1, 237.465, 309.781, -50.17));
                        }
                       else
                        {
                        }
                       case 15:
                       case 56:
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        continue;
                       if(_GLF_DEAD(false))
                        return;
                       case 54:
                       case 66:
                       do
                        {
                         if(_GLF_WRAPPED_IF_FALSE(false))
                          {
                          }
                         else
                          {
                           if(_GLF_DEAD(false))
                            continue;
                           do
                            {
                             clamp(ivec2(-94334, 54270), ivec2(25119, 57152), ivec2(50381, -80491));
                            }
                           while(_GLF_WRAPPED_LOOP(false));
                          }
                         if(_GLF_DEAD(false))
                          return;
                        }
                       while(_GLF_WRAPPED_LOOP(false));
                       case 70:
                       case 47:
                       log2(atan(vec3(6.9, 6.4, -1.5), vec3(584.837, 70.47, -4957.3994)));
                       case 2:
                       case 73:
                       if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                        {
                         for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(6), (int(6)) >> int(_GLF_ZERO(0.0, injectionSwitch.x))))) >> _GLF_IDENTITY(int(6), int(6)))); _injected_loop_counter ++)
                          {
                           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                            return;
                          }
                         return;
                        }
                       break;
                       case 62:
                       findMSB(uvec4(125863u, 195676u, 70529u, 198435u));
                       case 37:
                       ivec2 _GLF_SWITCH_5_3v[77], _GLF_SWITCH_5_4v, _GLF_SWITCH_5_5v[75];
                       default:
                       1;
                      }
                    }
                   if(_GLF_DEAD(false))
                    break;
                  }
                 else
                  {
                  }
                }
               while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
               if(_GLF_DEAD(false))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                 if(_GLF_DEAD(false))
                  {
                   do
                    {
                     barrier();
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                  }
                 barrier();
                }
               if(_GLF_DEAD(false))
                return;
               case 4:
               for(int _injected_loop_counter = (int(_GLF_ZERO(0.0, injectionSwitch.x)) << _GLF_IDENTITY(int(0), int(0))); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
                {
                 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    break;
                   if(_GLF_DEAD(false))
                    return;
                  }
                 else
                  {
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                     if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                      return;
                    }
                   else
                    {
                     switch(_GLF_SWITCH(int(_GLF_ZERO(0.0, injectionSwitch.x))))
                      {
                       case 0:
                       if(false)
                        {
                        }
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                          break;
                         return;
                        }
                       break;
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                          barrier();
                         return;
                        }
                       if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
                        continue;
                       case 19:
                       ;
                       default:
                       do
                        {
                         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                          {
                           1;
                          }
                         else
                          {
                          }
                         do
                          {
                           if(_GLF_DEAD(false))
                            return;
                          }
                         while(_GLF_WRAPPED_LOOP(false));
                         if(_GLF_DEAD(false))
                          continue;
                        }
                       while(_GLF_WRAPPED_LOOP(false));
                      }
                    }
                   if(_GLF_DEAD(false))
                    break;
                   if(_GLF_WRAPPED_IF_TRUE(true))
                    {
                     if(_GLF_DEAD(false))
                      return;
                    }
                   else
                    {
                    }
                  }
                }
               case 0:
               if(_GLF_DEAD(_GLF_IDENTITY(false, _GLF_IDENTITY(bool(bvec4(false, false, true, false)), false || (bool(bvec4(false, false, true, false)))))))
                {
                 if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                  {
                   return;
                  }
                 else
                  {
                  }
                }
               do
                {
                 if(_GLF_DEAD(false))
                  barrier();
                 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                  {
                   uvec4(122384u, 185684u, 132319u, 111307u);
                  }
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_DEAD(false))
                    {
                     if(_GLF_DEAD(false))
                      continue;
                     continue;
                    }
                   break;
                  }
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   do
                    {
                     return;
                    }
                   while(_GLF_WRAPPED_LOOP(false));
                  }
                 if(_GLF_DEAD(_GLF_IDENTITY(false, true && (false))))
                  {
                   if(_GLF_DEAD(false))
                    continue;
                   if(_GLF_WRAPPED_IF_FALSE(false))
                    {
                    }
                   else
                    {
                     return;
                    }
                   if(_GLF_DEAD(false))
                    continue;
                  }
                }
               while(_GLF_WRAPPED_LOOP(false));
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                   if(_GLF_WRAPPED_IF_TRUE(true))
                    {
                     if(_GLF_DEAD(false))
                      barrier();
                    }
                   else
                    {
                    }
                   if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
                    return;
                  }
                 else
                  {
                   return;
                  }
                 if(_GLF_DEAD(false))
                  return;
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                {
                 do
                  {
                   return;
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                }
               break;
               if(_GLF_DEAD(false))
                {
                 for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
                  {
                   return;
                  }
                }
               if(_GLF_DEAD(false))
                {
                 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
                  {
                   return;
                  }
                }
               case 53:
               for(               uvec2(80052u, 52843u);
 (ivec3(17547, -58476, 75150) != ivec3(65901, -411, 51462)); mat4x3(1633.8771, -716.553, -824.688, 4.3, -3.8, 1.7, -901.718, -744.865, 255.721, -59.35, -6.6, -8.9))
                {
                 if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  return;
                 if(_GLF_DEAD(false))
                  return;
                 bool _GLF_SWITCH_2_0v[63], _GLF_SWITCH_2_1v, _GLF_SWITCH_2_2v;
                 uvec4 _GLF_SWITCH_2_3v, _GLF_SWITCH_2_4v;
                 if(_GLF_DEAD(false))
                  return;
                 for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter != ((1 << _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(6), 0 | (int(6))))) >> _GLF_IDENTITY(int(6), int(6)))); _injected_loop_counter ++)
                  {
                   (mat2x4(31.89, -672.125, 4.6, 5.3, -4.2, -3.8, -9.5, 2634.2662) - -0.0);
                  }
                 mat4 _GLF_SWITCH_2_5v, _GLF_SWITCH_2_6v, _GLF_SWITCH_2_7v;
                 if(_GLF_DEAD(false))
                  return;
                 if(_GLF_DEAD(false))
                  continue;
                 ;
                 if(_GLF_DEAD(false))
                  continue;
                 float _GLF_SWITCH_2_8v[78], _GLF_SWITCH_2_9v;
                }
               default:
               1;
              }
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             if(_GLF_DEAD(false))
              return;
             if(_GLF_DEAD(false))
              return;
            }
           case 33:
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
              {
               return;
              }
            }
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
             if(_GLF_WRAPPED_IF_FALSE(false))
              {
              }
             else
              {
               return;
              }
            }
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             bvec4(true, false, true, false);
            }
           else
            {
            }
           default:
           if(_GLF_DEAD(false))
            return;
           do
            {
             switch(_GLF_SWITCH((0 | 0)))
              {
               case 23:
               uvec2 _GLF_SWITCH_3_0v[29], _GLF_SWITCH_3_1v;
               if(_GLF_DEAD(false))
                break;
               case 92:
               if(false)
                {
                 floatBitsToInt(vec4(-5.2, -6938.4697, -140.082, 5459.8231));
                 float _GLF_SWITCH_3_2v, _GLF_SWITCH_3_3v, _GLF_SWITCH_3_4v[76];
                 if(_GLF_DEAD(false))
                  continue;
                 mat4x3(-9926.3682, 5.6, -3.5, -382.858, -4638.1978, -8.4, -648.039, 3482.2307, 7.3, 9.4, -94.55, 631.809);
                 if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                  {
                  }
                 else
                  {
                   for(int _injected_loop_counter = (0 & (-38558 % 83068)); _GLF_WRAPPED_LOOP(_injected_loop_counter != 1); _injected_loop_counter ++)
                    {
                     (-45298 + ivec2(-48460, 50740));
                    }
                   if(_GLF_DEAD(false))
                    {
                     do
                      {
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        return;
                      }
                     while(_GLF_WRAPPED_LOOP(false));
                     break;
                    }
                  }
                 uvec2 _GLF_SWITCH_3_5v[62], _GLF_SWITCH_3_6v;
                 bvec4 _GLF_SWITCH_3_7v;
                 ivec4 _GLF_SWITCH_3_8v, _GLF_SWITCH_3_9v;
                }
               else
                {
                 for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(1), int(1))) >> _GLF_IDENTITY(int(1), int(1))); _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
                  {
                   if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                    {
                     for(int _injected_loop_counter = ((1 << _GLF_IDENTITY(int(5), int(5))) >> _GLF_IDENTITY(int(5), int(5))); _GLF_WRAPPED_LOOP(_injected_loop_counter != int(_GLF_ZERO(0.0, injectionSwitch.x))); _injected_loop_counter --)
                      {
                       if(_GLF_DEAD(false))
                        {
                         if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                          {
                           return;
                          }
                         else
                          {
                          }
                        }
                       barrier();
                       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                        break;
                      }
                    }
                  }
                 uvec2 _GLF_SWITCH_3_10v, _GLF_SWITCH_3_11v, _GLF_SWITCH_3_12v[21];
                }
               case 0:
               case 70:
               case 45:
               case 40:
               case 73:
               if(_GLF_WRAPPED_IF_FALSE(false))
                {
                }
               else
                {
                 if(_GLF_DEAD(false))
                  return;
                }
               break;
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                break;
               default:
               if(_GLF_WRAPPED_IF_TRUE(true))
                {
                 do
                  {
                   1;
                  }
                 while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
                }
               else
                {
                }
               if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
                continue;
              }
            }
           while(_GLF_WRAPPED_LOOP(false));
           if(_GLF_WRAPPED_IF_TRUE(true))
            {
             if(_GLF_DEAD(false))
              return;
            }
           else
            {
            }
           if(_GLF_DEAD(_GLF_IDENTITY(false, (false) && true)))
            return;
           1;
          }
         break;
         case 87:
         if(false)
          {
          }
         case 6:
         bvec4(false, true, false, false);
         default:
         1;
        }
      }
    }
   else
    {
     switch(_GLF_SWITCH((54238 & 0)))
      {
       case 17:
       mat4x2 _GLF_SWITCH_6_0v, _GLF_SWITCH_6_1v;
       case 84:
       (- -38126);
       case 0:
       if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
        {
         if(_GLF_DEAD(false))
          return;
         return;
        }
       if(_GLF_DEAD(false))
        return;
       case 48:
       case 51:
       case 3:
       switch(_GLF_SWITCH(0))
        {
         case 0:
         if(_GLF_DEAD(false))
          {
           do
            {
             return;
            }
           while(_GLF_WRAPPED_LOOP(false));
          }
         atomicStore(buf[next_virtual_gid], uint(_GLF_struct_replacement_17._f5._f0.read_1 + 1 == read_2) + 1, 4, 64, 4);
         if(_GLF_WRAPPED_IF_TRUE(true))
          {
           if(_GLF_DEAD(false))
            return;
          }
         else
          {
          }
         case 4:
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
          {
           if(_GLF_DEAD(false))
            barrier();
           return;
          }
         if(_GLF_DEAD(false))
          return;
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(false))
            {
             do
              {
               return;
              }
             while(_GLF_WRAPPED_LOOP(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))));
            }
           return;
          }
         for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < 1); _injected_loop_counter ++)
          {
           if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
            break;
           if(_GLF_DEAD(false))
            {
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
              {
               if(_GLF_DEAD(false))
                return;
              }
             if(_GLF_DEAD(_GLF_IDENTITY(false, ! (! (false)))))
              return;
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
              {
               switch(_GLF_SWITCH((44908 & 0)))
                {
                 case 62:
                 (- mat4(-9.5, 9.1, -6.5, 9226.8392, -903.977, -7.5, 4.5, 5.9, -890.464, -506.799, 5.1, 7048.1615, 6698.6557, 368.328, 407.667, -320.249));
                 case 0:
                 case 54:
                 case 90:
                 case 15:
                 case 41:
                 return;
                 break;
                 case 7:
                 mat2x4 _GLF_SWITCH_5_0v;
                 default:
                 1;
                }
              }
            }
           for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter != 0); _injected_loop_counter --)
            {
             for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > 0); _injected_loop_counter --)
              {
               if(_GLF_WRAPPED_IF_TRUE(_GLF_TRUE(true, (injectionSwitch.x < injectionSwitch.y))))
                {
                 subgroupAll(true);
                }
               else
                {
                }
              }
            }
          }
         break;
         case 60:
         if(_GLF_DEAD(false))
          return;
         for(int _injected_loop_counter = 1; _GLF_WRAPPED_LOOP(_injected_loop_counter > (0 >> _GLF_IDENTITY(int(4), int(4)))); _injected_loop_counter --)
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            break;
           if(_GLF_WRAPPED_IF_FALSE(false))
            {
            }
           else
            {
             (vec3(8638.8525, -6848.8889, -6172.7485) * mat3(9.8, -162.809, 2.8, -3.7, -53.90, -31.89, 646.845, 9.7, -3.1));
            }
           for(int _injected_loop_counter = 0; _GLF_WRAPPED_LOOP(_injected_loop_counter < int(_GLF_ONE(1.0, injectionSwitch.y))); _injected_loop_counter ++)
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              continue;
             for(int _injected_loop_counter = int(_GLF_ZERO(0.0, injectionSwitch.x)); _GLF_WRAPPED_LOOP(_injected_loop_counter < ((1 << _GLF_IDENTITY(int(6), int(6))) >> _GLF_IDENTITY(int(6), _GLF_IDENTITY(int(6), max(int(6), int(6)))))); _injected_loop_counter ++)
              {
               if(_GLF_DEAD(_GLF_IDENTITY(false, false || (false))))
                {
                 if(_GLF_DEAD(false))
                  return;
                 return;
                 if(_GLF_DEAD(false))
                  {
                   if(_GLF_WRAPPED_IF_TRUE(true))
                    {
                     return;
                    }
                   else
                    {
                    }
                  }
                }
              }
            }
           if(_GLF_DEAD(false))
            {
             if(_GLF_DEAD(false))
              break;
             break;
            }
           if(_GLF_DEAD(false))
            return;
          }
         if(_GLF_DEAD(false))
          {
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            return;
           if(_GLF_DEAD(false))
            {
             if(_GLF_WRAPPED_IF_TRUE(true))
              {
               return;
              }
             else
              {
              }
            }
           do
            {
             if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
              return;
             if(_GLF_DEAD(false))
              break;
            }
           while(_GLF_WRAPPED_LOOP(false));
           barrier();
           if(_GLF_DEAD(false))
            return;
           if(_GLF_WRAPPED_IF_FALSE(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            {
            }
           else
            {
             if(_GLF_DEAD(false))
              return;
            }
           if(_GLF_DEAD(false))
            return;
          }
         default:
         do
          {
           1;
           if(_GLF_DEAD(_GLF_FALSE(false, (injectionSwitch.x > injectionSwitch.y))))
            continue;
          }
         while(_GLF_WRAPPED_LOOP(false));
         if(_GLF_WRAPPED_IF_TRUE(_GLF_IDENTITY(true, true && (true))))
          {
           if(_GLF_DEAD(false))
            return;
          }
         else
          {
          }
        }
       break;
       case 45:
       subgroup_size;
       default:
       1;
      }
    }
  }
 else
  {
  }
 if(_GLF_DEAD(false))
  return;
 if(_GLF_DEAD(false))
  return;
}
