#version 460

#ifndef REDUCER
#define _GLF_ZERO(X, Y)                   (Y)
#define _GLF_ONE(X, Y)                    (Y)
#define _GLF_FALSE(X, Y)                  (Y)
#define _GLF_TRUE(X, Y)                   (Y)
#define _GLF_IDENTITY(X, Y)               (Y)
#define _GLF_DEAD(X)                      (X)
#define _GLF_FUZZED(X)                    (X)
#define _GLF_WRAPPED_LOOP(X)              X
#define _GLF_WRAPPED_IF_TRUE(X)           X
#define _GLF_WRAPPED_IF_FALSE(X)          X
#define _GLF_SWITCH(X)                    X
#define _GLF_MAKE_IN_BOUNDS_INT(IDX, SZ)  clamp(IDX, 0, SZ - 1)
#define _GLF_MAKE_IN_BOUNDS_UINT(IDX, SZ) clamp(IDX, 0u, SZ - 1u)
#endif


layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer Checker {
 uint checker[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 uvec2 GLF_merged2_0_1_16_1_1_17next_virtual_gidsubgroup_local_id;
 uint subgroup_id = gl_SubgroupID;
uint subgroup_size = 16;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 GLF_merged2_0_1_16_1_1_17next_virtual_gidsubgroup_local_id.y = subgroup_local_id;
 uint num_workgroup = gl_NumWorkGroups.x;
 uint workgroup_size = gl_WorkGroupSize.x;
 uint workgroup_id = gl_WorkGroupID.x;
 uint workgroup_base = workgroup_size * workgroup_id;
 uint virtual_gid = workgroup_base + subgroup_id * subgroup_size + GLF_merged2_0_1_16_1_1_17next_virtual_gidsubgroup_local_id.y;
 uint next_virtual_gid = workgroup_base + subgroup_id * subgroup_size + ((GLF_merged2_0_1_16_1_1_17next_virtual_gidsubgroup_local_id.y + 1) % subgroup_size);
 GLF_merged2_0_1_16_1_1_17next_virtual_gidsubgroup_local_id.x = next_virtual_gid;
 atomicStore(buf[GLF_merged2_0_1_16_1_1_17next_virtual_gidsubgroup_local_id.x], uint(1), 4, 64, 4);
 uint read = atomicLoad(buf[virtual_gid], 4, 64, 0);
 if(GLF_merged2_0_1_16_1_1_17next_virtual_gidsubgroup_local_id.y + 1 < subgroup_size)
  {
   switch(_GLF_SWITCH(((0 ^ 1) ^ 1)))
    {
     case 0:
     case 75:
     case 87:
     case 60:
     case 67:
     case 57:
     atomicStore(checker[virtual_gid], read, 4, 64, 4);
     case 61:
     case 69:
     case 23:
     case 42:
     subgroupAll(false);
     break;
     default:
     1;
    }
  }
 else
  {
   switch(_GLF_SWITCH(((-8717 ^ -39154) & 0)))
    {
     case 27:
     66624;
     case 4:
     if(true)
      {
       ivec4(87271, -45560, 25398, -25734);
       do
        {
        }
       while(((- mat2(5.6, -48.18, -3493.8877, 1239.9569)) != mat2(-16.33, 36.01, -6.0, -5027.6387)));
       mat4 _GLF_SWITCH_1_0v, _GLF_SWITCH_1_1v[58];
       mat3x4 _GLF_SWITCH_1_2v, _GLF_SWITCH_1_3v[29];
      }
     case 0:
     case 47:
     case 71:
     case 36:
     case 15:
     case 62:
     case 74:
     atomicStore(checker[virtual_gid], read, 4, 64, 4);
     subgroupAll(true);
     break;
     case 56:
     {
      for(      injectionSwitch;
 (mat2x3(-846.274, -88.98, 5667.0413, -286.217, 407.202, -241.334) != (3261.7320 + mat2x3(-5245.4356, -493.095, 6.3, 1.4, 5.0, 106.481))); mat2x3(-759.585, -0.3, 8.3, 7.3, 3.2, -2.4))
       {
        mat4x3 _GLF_SWITCH_1_4v, _GLF_SWITCH_1_5v, _GLF_SWITCH_1_6v;
        if(false)
         {
          mat2(-5.9, 4.2, 7666.2019, 4.0);
          ;
          distance(8.9, -2.1);
          mat4 _GLF_SWITCH_1_7v, _GLF_SWITCH_1_8v;
          mat2x4(9.7, 87.61, -4.3, -608.114, 15.53, 85.43, 42.54, -92.81);
          lessThan(min(ivec2(-56499, -29958), ivec2(-14571, -80757)), ivec2(97177, 88964));
         }
        for(mat4x2 _GLF_SWITCH_1_9v, _GLF_SWITCH_1_10v, _GLF_SWITCH_1_11v[37]; any(bvec2(false, true)); ivec2(-91252, 98409))
         {
          ivec3 _GLF_SWITCH_1_12v;
         }
        {
         ivec3 _GLF_SWITCH_1_13v[55];
         GLF_merged2_0_1_16_1_1_17next_virtual_gidsubgroup_local_id;
         (outerProduct(ldexp(vec4(-95.14, -954.541, 2.8, -44.03), ivec4(-73830, 79551, 13452, 25946)), vec2(-440.934, 7.8)) * mat3x2(8817.5517, 410.405, -4.9, -5825.7324, -31.81, -3.9));
         ivec2 _GLF_SWITCH_1_14v, _GLF_SWITCH_1_15v, _GLF_SWITCH_1_16v;
         mix(mod(vec3(54.05, 95.78, 3.2), (+ vec3(66.92, -2657.5139, 7317.8693))), vec3(6637.3986, -50.78, -8024.4020), bvec3(true, true, true));
         float _GLF_SWITCH_1_17v;
        }
        if(false)
         {
          (mat4x2(-53.12, 7207.1090, -71.69, 538.918, -170.734, -485.696, -954.412, -7832.4289) / -6204.3935);
          ceil(injectionSwitch);
          (vec3(1.5, 7.9, -9.3) / vec3(991.762, 0.2, 1.1));
          mat2x4 _GLF_SWITCH_1_18v[34], _GLF_SWITCH_1_19v, _GLF_SWITCH_1_20v;
          ;
         }
        mat3x2(mat3x4(715.985, 98.45, 8.5, 44.13, 4.5, -889.024, -70.66, -3653.2001, 96.35, 53.62, -749.465, 3246.3700));
       }
     }
     case 96:
     for(     (max(subgroup_size, next_virtual_gid) % uvec4(30944u, 34947u, 197164u, 10761u));
 true; lessThanEqual(uvec3(2823u, 164689u, 107745u), uvec3(56660u, 154822u, 13035u)))
      {
       ivec3 _GLF_SWITCH_1_21v, _GLF_SWITCH_1_22v[52], _GLF_SWITCH_1_23v;
       ;
       mat3x2 _GLF_SWITCH_1_24v;
       vec3(-614.444, -99.25, 444.419);
       mat2x4 _GLF_SWITCH_1_25v, _GLF_SWITCH_1_26v, _GLF_SWITCH_1_27v;
      }
     default:
     1;
    }
  }
}
