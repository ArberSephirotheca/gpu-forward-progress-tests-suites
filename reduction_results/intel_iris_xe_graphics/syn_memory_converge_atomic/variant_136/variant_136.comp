#version 460

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer WriteVal {
 uint write_val;
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if(((! (bool((bvec2(bvec3(bvec2((! (! ((! ((false || (((((false || (((bool(bvec4(false, false, true, false))))))) && true) || false)))))))), true), true))))))))
  barrier();
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 if((false))
  barrier();
 uint num_workgroup = gl_NumWorkGroups.x;
 uint workgroup_size = gl_WorkGroupSize.x;
 uint workgroup_id = (((((~ (~ (gl_WorkGroupID.x)))) | (gl_WorkGroupID.x))) / uint((injectionSwitch.y)));
 uint workgroup_base = (((((min(workgroup_size, workgroup_size))) / 1u)) ^ 0u) * workgroup_id;
 if(((((min((1.0 * ((vec2(injectionSwitch[0], (clamp(injectionSwitch[((((injectionSwitch.x < injectionSwitch.y)) ? ((1) + 0) : (12935)))], injectionSwitch[1], injectionSwitch[1])))).x)), (clamp((vec2(injectionSwitch[0], (clamp(injectionSwitch[1], injectionSwitch[1], injectionSwitch[1])))).x, (vec2(injectionSwitch[0], (clamp(((injectionSwitch[1]) / determinant(mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, determinant(mat3(0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)), 0.0, 1.0))), injectionSwitch[1], injectionSwitch[1])))).x, (float(((false ? (mat2x3(82.43, - 7257.9605, - 483.949, - 19.56, - 2.8, 968.284)) : mat2x3((float(mat2x3((vec2(injectionSwitch[(clamp(0, 0, 0))], (clamp(injectionSwitch[1], injectionSwitch[1], injectionSwitch[1])))).x, length(vec2(0.0, 0.0)), 1.0, 0.0, 1.0, 0.0))), 1.0, 0.0, (injectionSwitch.x), 0.0, 1.0))))))))) > injectionSwitch.y))))
  barrier();
 uint virtual_gid = ((max(((((uint(uvec2((uint(uint(workgroup_base))) + subgroup_id * subgroup_size, 1u)))) >> 0u) + ((((subgroup_local_id) ^ 0u)) >> 0u)), ((((uint(uvec2((uint(uint(workgroup_base))) + subgroup_id * subgroup_size, 1u)))) >> 0u) + ((((subgroup_local_id) ^ 0u)) >> 0u)))) ^ 0u);
 if(((((((bool(bool(! (! (((! (! ((! (! ((bool(bvec3(false, true, ((! (! ((false || ((bool(bvec2(bool(bvec4(((true) || (! ((true && (! ((bool(bvec2(false, true))))))))), true, true, false)), true)))))))))))))))))))))))))) && ((true) || false))) && true))
  barrier();
 atomicStore(write_val, uint(virtual_gid), ((min((min((4), (min((4), (0 | ((4))))))) >> int(((clamp((vec2((clamp(injectionSwitch[0], injectionSwitch[0], injectionSwitch[0])), injectionSwitch[1])), injectionSwitch, injectionSwitch)).x)), ((false ? ((true ? (- 81604) : (mix(8056, 19541, (- 91.83 < 2540.3069))))) : (4) >> ((int((injectionSwitch.x))) ^ 0)))))), ((false ? (((int(((ivec4((((max((- 79615), (- 79615)))) / 1), 0, 1, 1)) / ivec4(1, 1, 1, 1)))) | (0 >> (int(((3) | (3))))))) : (min((0 | (64)), 64)))), (min(0, 0)));
 uint read_val = atomicLoad(write_val, 4, 64, 0);
 buf[virtual_gid] = uint(subgroupAllEqual(read_val));
}
