#version 460

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer WriteVal {
 uint write_val;
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if((false))
  barrier();
 uint subgroup_id = gl_SubgroupID;
 if(((((false || ((((true && (((bool(bvec3(bool(bvec2(false, true)), ((false) || false), true))))))))))) || false) || (((clamp(((injectionSwitch.x) / 1.0), (float(mat2x3(injectionSwitch.x, 1.0, 1.0, determinant(mat2(0.0, 0.0, 0.0, 0.0)), 0.0, 0.0))), injectionSwitch.x)) > injectionSwitch.y))))
  {
   if((false))
    barrier();
   barrier();
  }
 if(((bool(bvec2(((injectionSwitch.x > injectionSwitch.y)), false)))))
  barrier();
 if((false))
  {
   if((false || ((((injectionSwitch.x > ((injectionSwitch.y) / 1.0)))))))
    barrier();
   barrier();
  }
 uint subgroup_size = gl_SubgroupSize;
 if((false))
  {
   if((((false)) || false))
    barrier();
   if((false))
    {
     if((false))
      barrier();
     barrier();
    }
   if((bool(bvec3((((false) || false)), true, false))))
    barrier();
   barrier();
   if((false))
    barrier();
   if(((! (! ((bool((((bvec3(bvec4(bvec3(bvec4(bvec3(bvec4(bvec3(false, true, false), true)), false)), false))))))))))))
    barrier();
   if((false))
    barrier();
  }
 if((false))
  {
   if((false))
    barrier();
   if(((! (! (false)))))
    {
     if((false))
      barrier();
     barrier();
     if((false))
      barrier();
    }
   if((false))
    barrier();
   barrier();
  }
 if((! (! ((bool(bvec2((false), false)))))))
  {
   if((false || (((true && (false))))))
    barrier();
   barrier();
  }
 if((false))
  barrier();
 if((false))
  {
   if((false))
    {
     if((false))
      barrier();
     barrier();
    }
   if((false))
    barrier();
   if((false))
    barrier();
   if((((injectionSwitch.x > injectionSwitch.y))))
    barrier();
   barrier();
   if((false))
    barrier();
  }
 if(((! (! (((injectionSwitch.x > injectionSwitch.y)))))))
  barrier();
 uint subgroup_local_id = gl_SubgroupInvocationID;
 if(((! (! (false)))))
  barrier();
 if((false))
  {
   if(((bool(bvec3((true && (false)), true, true)))))
    barrier();
   barrier();
  }
 if((false))
  {
   if((false))
    barrier();
   if((((injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if((false))
    barrier();
   if((((false)) && true))
    barrier();
   if((! ((((true && (! ((false))))) && true))))
    barrier();
   if((false))
    barrier();
   barrier();
  }
 if((((((bool(bvec4(((false || (! (! (bool(bool((true && (((bool(bvec4(((false || (injectionSwitch.x > injectionSwitch.y))), (bool(bool(true))), true, ((injectionSwitch.x < injectionSwitch.y))))))))))))))), false, ((injectionSwitch.x < injectionSwitch.y)), false))) || false)))))
  barrier();
 uint num_workgroup = ((gl_NumWorkGroups) << (((clamp(uvec3((injectionSwitch.x), ((false ? (742.971) : (min((mix(float((6.5)), float((injectionSwitch.x)), bool(true))), (injectionSwitch.x))))), (((true ? injectionSwitch : (injectionSwitch))).x)), uvec3((injectionSwitch.x), ((true ? ((float((mat2(0.0, 0.0, 0.0, 0.0) + (mat2((clamp(injectionSwitch.x, injectionSwitch.x, (1.0 * ((clamp(injectionSwitch.x, injectionSwitch.x, injectionSwitch.x)))))), 0.0, 1.0, 1.0)))))) : (6.9))), (injectionSwitch.x)), uvec3((mix(float((((1.0 * (((clamp(((injectionSwitch.x) - 0.0), injectionSwitch.x, injectionSwitch.x)))))) - 0.0)), float((52.85)), (true && (bool(false))))), (injectionSwitch.x), ((min(injectionSwitch.x, ((min(float(mat2(injectionSwitch.x, 1.0, 1.0, 1.0)), float(mat2(injectionSwitch.x, 1.0, 1.0, 1.0))))))))))) - (uvec3(((0u) ^ 0u), 0u, 0u) ^ (uvec3(0u, 0u, ((0u) * 1u))))))).x;
 uint workgroup_size = gl_WorkGroupSize.x;
 if((false))
  barrier();
 if((false))
  barrier();
 if((false))
  {
   if((false))
    barrier();
   if((false))
    barrier();
   if((((injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if((false))
    barrier();
   if((false))
    barrier();
   if((false))
    {
     if((false))
      {
       if(((bool(((((bool(((false) && true))) && (! (! ((((injectionSwitch.x < injectionSwitch.y)) && (true))))))) && true)))))
        barrier();
       if((false))
        barrier();
       barrier();
       if(((false || (false))))
        barrier();
      }
     barrier();
    }
   barrier();
  }
 if((false))
  barrier();
 uint workgroup_id = (0u ^ (((false ? (((uint(uvec4(uint((max(uvec3(subgroup_size, 1u, 0u), uvec3(subgroup_size, 1u, 0u)))), 1u, 1u, 1u))))) : ((gl_WorkGroupID.x) / 1u)))));
 if((false))
  {
   if((false))
    barrier();
   if((((injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if((false))
    {
     if((false))
      barrier();
     if((false))
      {
       if(((! (((! (! ((! (bool(bool(((true && (false || ((false))))))))))))) || false))))
        barrier();
       barrier();
       if((((bool(bvec3(true && (((injectionSwitch.x > injectionSwitch.y))), false, ((injectionSwitch.x < injectionSwitch.y))))))))
        barrier();
      }
     if((((((injectionSwitch.x > (min(injectionSwitch, injectionSwitch)).y) || false)))))
      barrier();
     if((false))
      {
       if((((injectionSwitch.x > injectionSwitch.y))))
        barrier();
       barrier();
      }
     barrier();
    }
   if((false))
    barrier();
   if((false))
    {
     if(((((! ((((! (false || ((! ((bool(bvec4(! (false), true, ((((((true) || false)) && true) && true)), (bool(bvec2((bool(bool((false || (true))))), false)))))))))))) && true))) && true))))
      {
       if((((injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(((false || (bool(bvec3((((false) || ((injectionSwitch.x > injectionSwitch.y)))), false, true))))))
        barrier();
       barrier();
       if((((injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     if((false))
      barrier();
     barrier();
    }
   if((false))
    {
     if((((injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if((false))
      barrier();
     if((((injectionSwitch.x > (max(injectionSwitch, injectionSwitch)).y))))
      barrier();
     if((false))
      barrier();
     if((false))
      barrier();
     barrier();
     if((false))
      barrier();
     if((false))
      barrier();
     if(((((injectionSwitch.x > injectionSwitch.y)) || ((true && (((false || (bool(bool(false)))))))))))
      barrier();
    }
   barrier();
   if((false))
    barrier();
  }
 if(((bool(bvec3(false, true, false)))))
  barrier();
 if((false))
  barrier();
 if((false))
  barrier();
 if(((false || ((bool(bvec4(false, false, false, ((injectionSwitch.x < injectionSwitch.y)))))))))
  barrier();
 if((((injectionSwitch.x > injectionSwitch.y))))
  {
   if((((injectionSwitch.x > injectionSwitch.y))))
    barrier();
   barrier();
   if((false))
    barrier();
  }
 uint workgroup_base = ((((workgroup_size) << 0u)) * (0u | (uint((injectionSwitch.y))))) * workgroup_id;
 if((false))
  barrier();
 if((false))
  barrier();
 uint virtual_gid = workgroup_base + subgroup_id * subgroup_size + subgroup_local_id;
 atomicStore(write_val, ((uint(virtual_gid)) ^ ((((min(((max(min(0u, 0u), min(0u, 0u)))), 0u))) | 0u) | 0u)), 4, 64, (clamp(0, 0, ((0) | ((~ (~ (0))))))));
 uint read_val = atomicLoad(write_val, 4, 64, 0);
 if(((((! (! (((((((((((((injectionSwitch.x > injectionSwitch.y)) ? (mat2(39.13, - 2.8, - 4878.4113, - 4.7)) : mat2(1.0))) * (((min((((mix(vec2(((min(injectionSwitch, injectionSwitch)))[0], (- 10.25)), vec2((85.28), ((min(injectionSwitch, injectionSwitch)))[1]), bvec2(((false || ((injectionSwitch.x > (mix(vec2((45.64), (injectionSwitch)[1]), vec2((injectionSwitch)[0], (0.4)), bvec2(true, false))).y)))), true)))) + vec2(0.0, 0.0)), (mix(vec2((3581.7452), (- 3.6)), vec2((injectionSwitch)[((0) | (0))], (injectionSwitch)[1]), bvec2(true, ((injectionSwitch.x < injectionSwitch.y)))))))) * (mat2(mat4(mat2(1.0))))))) - vec2(0.0, 0.0))).x) / 1.0) > injectionSwitch.y)))))) && true)))
  {
   if((false))
    barrier();
   if((false))
    barrier();
   if((((((injectionSwitch.x > injectionSwitch.y))) && true)))
    {
     if((false))
      barrier();
     if((false))
      barrier();
     if((false))
      barrier();
     barrier();
    }
   barrier();
   if((false))
    {
     if((! (! ((((bool(bvec4((false), false, false, true))) || false))))))
      barrier();
     if((false))
      barrier();
     if((false))
      barrier();
     barrier();
    }
  }
 if((((injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if((bool(((bvec2(bvec4((bvec2(bvec3(bvec2(bvec3((bvec2(bvec3(bvec2((false), false), false))), ((injectionSwitch.x < injectionSwitch.y)))), true))), false, true)))))))
  {
   if(((! (((bool(bvec3(bool(bvec2(! ((! (! (! (! (((false || ((bool(bvec2(false, false))))) || ((bool((bvec3(bvec4(bvec3((false), (((false || (bool((bool(bool((bool(bvec3(bool(bool(bvec4(true, (bool(bool(false))), false, true))), false, false))))))))))), true), (true && (((injectionSwitch.x < injectionSwitch.y))))))))))))))))), true)), true, false))))))))
    {
     if((false))
      barrier();
     barrier();
    }
   if((false))
    barrier();
   if((false))
    {
     if((((((((injectionSwitch.x > injectionSwitch.y)))) || false)) && true))
      barrier();
     barrier();
    }
   barrier();
   if((false))
    barrier();
   if(((true && (bool(bool((false)))))))
    {
     if((((injectionSwitch.x > (vec2(1.0, 1.0) * ((vec2((mix(vec3((81.29), (0.8), ((8.4))), vec3(((clamp(vec3((min((clamp((vec2(0.0, 0.0) + ((min((mix(vec2((1.7), (injectionSwitch)[1]), vec2((injectionSwitch)[0], (45.48)), bvec2(true, false))), (mix(vec2((1.7), (injectionSwitch)[1]), vec2((injectionSwitch)[0], (45.48)), bvec2(true, false))))))), (mix(vec2((1.7), (injectionSwitch)[1]), vec2((injectionSwitch)[0], (45.48)), bvec2(true, false))), (mix(vec2((1.7), (injectionSwitch)[1]), vec2((injectionSwitch)[0], (45.48)), bvec2(true, false))))), injectionSwitch)), 1.0), vec3((min(injectionSwitch, injectionSwitch)), 1.0), vec3((min(injectionSwitch, injectionSwitch)), 1.0))))[0], (cross(vec3(67.94, 97.12, 948.592), vec3(67.94, 97.12, 948.592)) + (((((min(vec3((min(injectionSwitch, injectionSwitch)), 1.0), vec3((min(injectionSwitch, injectionSwitch)), 1.0))))) - vec3(0.0, 0.0, 0.0))))[1], (mix(float(((- - 565.209))), float((mix(float((4.0)), float((vec3((min(injectionSwitch, injectionSwitch)), 1.0))[2]), bool(true)))), bool(true)))), bvec3(true, true, true))))))).y))))
      {
       if((bool(bool((false)))))
        barrier();
       if((false))
        {
         if((false))
          barrier();
         barrier();
        }
       if((((injectionSwitch.x > injectionSwitch.y))))
        barrier();
       barrier();
      }
     barrier();
     if((false))
      barrier();
    }
   if((false))
    barrier();
   if(((((((! (! (injectionSwitch.x > ((((((true ? true ? ((injectionSwitch) * mat2((injectionSwitch.y))).y : (1708.3071) : (- 451.170)))) - 0.0))))))) && true)))))
    barrier();
   if((false))
    barrier();
   if((false))
    barrier();
   if((false))
    barrier();
   if(((! ((bool(bvec4(! ((bool(bvec3((! (! (((false) && true)))), false, false)))), false, true, false)))))))
    {
     if((bool(bvec4((true && ((false))), false, false, true))))
      barrier();
     if(((true && ((bool(bvec3(false, true, ((injectionSwitch.x > injectionSwitch.y)))))))))
      barrier();
     if((false))
      barrier();
     if((false))
      barrier();
     barrier();
    }
   if((false))
    barrier();
   if((false))
    barrier();
   if((false))
    barrier();
  }
 if((((injectionSwitch.x > injectionSwitch.y))))
  barrier();
 ((((true ? buf[virtual_gid] = uint(subgroupAllEqual(((true ? (((((((max(~ (~ ((((true ? ((((read_val) - 0u)) / ((1u << (uint(6u))) >> (uint(6u)))) : (workgroup_base)) | (true ? ((((read_val) - 0u)) / ((1u << (uint(6u))) >> (uint(6u)))) : (workgroup_base)))))), ~ (~ ((true ? ((read_val) - 0u) : (workgroup_base))))))) | ((min(~ (~ ((true ? ((read_val) - 0u) : (workgroup_base)))), ~ (~ ((true ? ((((read_val) - 0u)) | 0u) : (workgroup_base)))))))))) << (14093u & (uint((injectionSwitch.x)) | (0u))))) : (((write_val)) >> 0u))))) : ((read_val ++)))) / 1u));
 if((false))
  barrier();
 if((false))
  barrier();
}
