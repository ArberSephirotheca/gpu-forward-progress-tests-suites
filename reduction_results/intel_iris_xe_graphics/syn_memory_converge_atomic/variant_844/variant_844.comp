#version 460

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer WriteVal {
 uint write_val;
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if(((bool(bool(((injectionSwitch.x > injectionSwitch.y)))))))
  return;
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 if(((((! (bool(bvec3((! (false)), true, false)))) && ((injectionSwitch.x < injectionSwitch.y))))))
  return;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = (uvec3(0u, 0u, (1u * (0u))) | ((max(((gl_NumWorkGroups) << uvec3(0u, 0u, (uint(uvec4((((max(((min((((0u) / (~ (((~ (uint((injectionSwitch.y)))) * 1u))))), (~ (~ ((clamp((max((((0u)) - 0u), (~ (~ ((((0u)) - 0u)))))), (0u), (0u)))))))) << 0u), min((((0u) / (~ (((~ (uint(((vec2(0.0, 0.0) + (injectionSwitch)).y)))) * 1u))))), (~ (~ ((clamp((((0u)) - 0u), (0u), (0u)))))))))) << 0u), (0u | (1u)), (((max(((0u | (min((((false ? (subgroup_local_id) : (~ (~ ((((clamp(0u >> (uint(6u)), ((0u >> (uint(6u))) ^ 0u), 0u >> (uint(6u))))) | (max((1u * ((((((((0u) << 0u)) >> 0u) >> (uint(6u))))) >> 0u)), (((0u | ((0u) >> 0u))) >> (uint(6u)))))))))))), (((((false ? (subgroup_local_id) : (~ (~ ((((clamp(0u >> (uint(6u)), ((0u >> (uint(6u))) ^ 0u), 0u >> (uint(6u))))) | (max((1u * ((((((((0u) << 0u)) >> 0u) >> (uint(6u))))) >> 0u)), (((0u | ((0u) >> 0u))) >> (uint(6u))))))))))))) + 0u))))), ((0u | (min((((false ? (subgroup_local_id) : (~ (~ ((((clamp(0u >> (uint(6u)), ((0u >> (uint(6u))) ^ 0u), 0u >> (uint(6u))))) | (max((1u * ((((((((0u) << 0u)) >> 0u) >> (uint(6u))))) >> 0u)), (((0u | ((0u) >> 0u))) >> (uint(6u)))))))))))), (((((false ? (subgroup_local_id) : (~ (~ ((((clamp(0u >> (uint(6u)), ((0u >> (uint(6u))) ^ 0u), 0u >> (uint(6u))))) | (max((1u * ((((((((0u) << 0u)) >> 0u) >> (uint(6u))))) >> 0u)), (((0u | ((0u) >> 0u))) >> (uint(6u))))))))))))) + 0u))))))) | 0u)), 0u))))), gl_NumWorkGroups)))).x;
 uint workgroup_size = (clamp((clamp(((((uvec3(uvec3(false ? (uvec3(64300u, 93192u, 143541u)) : (gl_WorkGroupSize) | uvec3(0u, 0u, 0u))))))), gl_WorkGroupSize, (min(gl_WorkGroupSize, gl_WorkGroupSize)))), gl_WorkGroupSize, gl_WorkGroupSize)).x;
 uint workgroup_id = gl_WorkGroupID.x;
 uint workgroup_base = ((((((workgroup_size) ^ 0u)) << ((clamp(uint(uvec2(((((0u) / 1u) | ((0u) / 1u))), 0u)), uint((uvec2(1u, 1u) * (uvec2(((0u + ((((false ? (164551u) : 0u))) / 1u))), 0u)))), uint(uvec2(((max((0u), (0u))) / 1u), 0u)))))) >> 0u)) * ((clamp(uint(uvec3(workgroup_id, 0u, (0u + ((0u << (uint(6u))))))), uint((((~ (~ (uvec3((max(((false ? (subgroup_local_id) : (uint((((uvec3(uvec3(uvec3(workgroup_id, 0u, 0u))))) + uvec3((injectionSwitch.x), (injectionSwitch.x), (injectionSwitch.x))))))), workgroup_id)), 0u, ((clamp((((max(((false ? (subgroup_local_id) : 0u) | (false ? (subgroup_local_id) : 0u)), false ? (subgroup_local_id) : 0u)))) << (uint(6u)), (((! (! (false))) ? (subgroup_local_id) : 0u)) << (uint(6u)), ((((false ? (subgroup_local_id) : 0u)) << (uint(6u))) | (((false ? (subgroup_local_id) : 0u)) << (uint(6u)))))))))))) ^ uvec3(0u, 0u, 0u))), uint(uvec3(((workgroup_id) >> 0u), 0u, (0u << (((uint(6u)) ^ 0u))))))));
 uint virtual_gid = (0u | ((0u | ((0u | ((~ (~ (workgroup_base))) + subgroup_id * subgroup_size + ((subgroup_local_id) / (1u & 1u))))))));
 atomicStore(write_val, uint(virtual_gid), ((4) ^ int((injectionSwitch.x))), 64, 0);
 uint read_val = atomicLoad(write_val, 4, (max(64, 64)), 0);
 buf[virtual_gid] = uint(subgroupAllEqual(read_val));
}
