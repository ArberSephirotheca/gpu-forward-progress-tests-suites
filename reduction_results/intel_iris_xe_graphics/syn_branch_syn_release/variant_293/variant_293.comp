#version 460

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if((false))
  return;
 uvec2 GLF_merged2_0_1_16_1_1_13next_virtual_gidnum_workgroup;
 if((false))
  return;
 if((! (! (((bool(bvec4(false, false, false, false))))))))
  {
   if((((false) && true)))
    return;
   return;
  }
 if(((((min(injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y))))
  return;
 if((false))
  return;
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 if((! (! (((true && (((false) || false))))))))
  return;
 if(((((! (! (bool(bvec2((((false) && ((true) || false))), false))))))) && true))
  return;
 if((((((injectionSwitch) * mat2(1.0)).x > injectionSwitch.y))))
  return;
 if((((injectionSwitch.x > injectionSwitch.y))))
  return;
 if((false))
  return;
 if(((! (! (false)))))
  return;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 if((((((injectionSwitch.x > (min(injectionSwitch.y, injectionSwitch.y))))) || false)))
  return;
 if((false))
  {
   if((false))
    return;
   return;
  }
 if((((((injectionSwitch.x < injectionSwitch.y)) && ((false)))) || ((injectionSwitch.x > injectionSwitch.y))))
  return;
 uint num_workgroup = ((((gl_NumWorkGroups.x) * 1u)) + (0u | 0u));
 if((false || ((false))))
  return;
 if((false))
  {
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   return;
   if(((bool(bvec3(((injectionSwitch.x > (((clamp(injectionSwitch, injectionSwitch, injectionSwitch))) / vec2(1.0, 1.0)).y)), true, false)))))
    return;
  }
 GLF_merged2_0_1_16_1_1_13next_virtual_gidnum_workgroup.y = num_workgroup;
 uint workgroup_size = gl_WorkGroupSize.x;
 if((false))
  return;
 uint workgroup_id = gl_WorkGroupID.x;
 if(((((bool(bvec3(((false) && true), false, true))) && true))))
  return;
 if(((bool((bvec3(bvec4(bvec3(false, false, true), true)))))))
  {
   if((false))
    {
     if((false))
      return;
     return;
    }
   return;
  }
 uint workgroup_base = workgroup_size * workgroup_id;
 if((false))
  return;
 if((false))
  return;
 if((! (! ((! (! ((false))))))))
  {
   if(((((bool(bvec4(injectionSwitch.x > injectionSwitch.y, true, ((injectionSwitch.x > injectionSwitch.y)), true)))))))
    return;
   if(((bool((bvec2(bvec4(bvec2((bool(bvec4((bool(bvec2(false, true))), false, ((false) && true), false))), true), ((injectionSwitch.x < injectionSwitch.y)), true)))))))
    {
     if(((! (false || ((false || ((! (false)))))))))
      return;
     return;
    }
   if((false))
    return;
   if((false))
    return;
   return;
  }
 if((false))
  return;
 if(((bool(bool(false)))))
  {
   if((! (! ((((bool(bvec3((false), true, false)))) || false)))))
    {
     if((false))
      return;
     return;
    }
   for(int _injected_loop_counter = 1; (((injectionSwitch.x < injectionSwitch.y)) && (((bool(bool(bool(bvec4(_injected_loop_counter != (clamp(0, 0, 0)), true, true, false)))))))); _injected_loop_counter --)
    {
     return;
    }
  }
 uint virtual_gid = ((clamp((workgroup_base + subgroup_id * subgroup_size) + 0u, (min((workgroup_base + subgroup_id * subgroup_size) + 0u, (~ (~ ((workgroup_base + subgroup_id * subgroup_size) + 0u))))), (workgroup_base + subgroup_id * subgroup_size) + 0u))) + subgroup_local_id;
 if(((! ((false || ((! (! (! (false))))))))))
  return;
 if((((false) || false)))
  {
   if((false))
    return;
   if((false))
    {
     if(((((true && ((bool(bool((! (! (injectionSwitch.x > ((injectionSwitch) - vec2(0.0, 0.0)).y))))))))))))
      return;
     return;
    }
   if((((injectionSwitch.x > injectionSwitch.y))))
    {
     if((false))
      return;
     return;
    }
   return;
  }
 uint next_virtual_gid = workgroup_base + (min((((~ ((((((((clamp((((true ? (clamp(uint(uvec3(~ ((uint(((uint(((subgroup_id)) - 0u)) - (((max(0u, 0u))) + 0u))))), 0u, (((uint(uvec3(1u, uint((injectionSwitch.y)), 0u))) << ((0u ^ (uint((max(1u, 1u))))))) >> (uint(1u))))), ((uint(uvec3(~ ((uint(((uint(((subgroup_id)) - 0u)) - 0u)))), 0u, ((1u << ((0u ^ (uint(1u))))) >> (~ (~ ((uint(1u))))))))) * ((uint((injectionSwitch.y)) << (uint(1u))) >> (uint(1u)))), uint(uvec3(~ ((uint((1u * (((uint(((true ? ((subgroup_id)) - 0u : (49553u))))) - 0u)))))), 0u, ((1u << ((0u ^ (uint(1u))))) >> (uint(1u))))))) : (num_workgroup)))), ~ ((uint(((uint(((subgroup_id)) - 0u)) - 0u)))), ~ ((uint(((uint(((~ (((~ ((subgroup_id))) >> 0u)))) - 0u)) - 0u))))))) << (min(0u, (((max(0u, 0u))) / 1u))))))) << 0u) * (((((0u ^ 1u) - (1u ^ uint((injectionSwitch.y)))))) - (0u >> (uint(5u))))))) | 0u), subgroup_id)) * subgroup_size + (((true ? (min(1u * (((clamp((uint(uint((subgroup_local_id + ((1) + 0))))), (uint((uint((((min(uvec4(uint((max((subgroup_local_id + 1), (((subgroup_local_id + 1)) - 0u)))), 0u, 0u, 1u), uvec4(uint((subgroup_local_id + 1)), 0u, 0u, 1u)))) - uvec4(0u, 0u, 0u, 0u)))))), (subgroup_local_id + 1))) % subgroup_size)), ((1u * (((clamp((uint(uint((subgroup_local_id + ((1) + 0))))), (uint((uint((((min(uvec4(uint((max((subgroup_local_id + 1), (((subgroup_local_id + 1)) - 0u)))), 0u, 0u, 1u), uvec4(uint((subgroup_local_id + 1)), 0u, 0u, 1u)))) - uvec4(0u, 0u, 0u, 0u)))))), (subgroup_local_id + 1))) % subgroup_size))) << 0u))) : (num_workgroup))));
 if((false))
  return;
 ((((GLF_merged2_0_1_16_1_1_13next_virtual_gidnum_workgroup.x = next_virtual_gid) << (0u + (0u)))) >> 0u);
 if((((false) && true)))
  return;
 if((false))
  {
   if(((true && (((injectionSwitch.x > injectionSwitch.y))))))
    return;
   if((false))
    return;
   return;
   if((false))
    return;
   if((false))
    return;
  }
 buf[virtual_gid] = 1;
 if((false))
  return;
 if(subgroup_local_id + 1 < subgroup_size)
  {
   if((false))
    return;
   int i = 0;
   atomicStore(buf[GLF_merged2_0_1_16_1_1_13next_virtual_gidnum_workgroup.x], uint(((((((int(ivec3((((2) ^ 0)), 1, 1))) | 0))) * 1) / 1)), 4, 64, 4);
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   if((false))
    return;
   if((false))
    return;
  }
 else
  {
   atomicStore(buf[GLF_merged2_0_1_16_1_1_13next_virtual_gidnum_workgroup.x], ((uint(2)) | (((((uint(2)) / 1u)) | (uint(((true ? (clamp(2, 2, 2)) : (7881)))))))), 4, 64, ((1 & 1) * (((false ? (34056) : 4)))));
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   if((false))
    {
     if((false))
      return;
     if((false))
      return;
     if(((((! (! (injectionSwitch.x > injectionSwitch.y)))))))
      return;
     return;
    }
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 if((((false) && ((true) && true))))
  return;
 if((((((true && ((false)))) && true) && true)))
  return;
}
