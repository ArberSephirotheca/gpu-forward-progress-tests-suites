#version 460

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if(((! (! (false)))))
  barrier();
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 if((((false)) || false))
  {
   if(((((false || (((! ((! (! (bool((! (bool(bvec4((! (bool((! (((false || ((((injectionSwitch.x < injectionSwitch.y)) && ((bool(bvec4(((((false || (((injectionSwitch.x) / 1.0) > injectionSwitch.y))) || false)), (true && (true)), true, false))))))))))))), false, true, ((injectionSwitch.x < injectionSwitch.y))))))))))))))) && true)) || false))
    {
     if((false))
      barrier();
     if(((((((clamp(((max(abs(vec2(1.0, 1.0)) * (injectionSwitch), abs(vec2(1.0, 1.0)) * (injectionSwitch)))).x, ((((max(abs(vec2(1.0, 1.0)) * (injectionSwitch), abs(vec2(1.0, 1.0)) * ((vec2(mat2(injectionSwitch, cos(0.0), 1.0))))))).x) + 0.0), (mix(float(((max(abs(vec2(1.0, 1.0)) * (injectionSwitch), abs(vec2(1.0, 1.0)) * (injectionSwitch)))).x), float((- 5270.8625)), bool(false))))) > injectionSwitch.y))) && true)))
      barrier();
    }
   else
    {
     barrier();
    }
  }
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = gl_NumWorkGroups.x;
 uint workgroup_size = (uvec3(gl_WorkGroupSize[0], (0u ^ ((max((clamp(gl_WorkGroupSize[1], gl_WorkGroupSize[1], gl_WorkGroupSize[1])), (clamp(gl_WorkGroupSize[1], gl_WorkGroupSize[1], gl_WorkGroupSize[1])))))), gl_WorkGroupSize[2])).x;
 uint workgroup_id = gl_WorkGroupID.x;
 if(((((! (! (injectionSwitch.x > injectionSwitch.y)))))))
  barrier();
 uint workgroup_base = ((true ? workgroup_size : (103344u))) * workgroup_id;
 uint virtual_gid = (max(workgroup_base + subgroup_id * (~ (~ (subgroup_size))), workgroup_base + subgroup_id * (~ (~ (subgroup_size))))) + (((min(subgroup_local_id, subgroup_local_id))) - 0u);
 uint next_virtual_gid = workgroup_base + subgroup_id * (clamp((((((uint(uvec2(subgroup_size, uint((injectionSwitch.y)))))) | (((subgroup_size) ^ uint((injectionSwitch.x)))))) >> 0u), (((uint(uvec2(subgroup_size, uint((injectionSwitch.y)))))) | (((((((subgroup_size)) ^ 0u)) - uint(((true ? (injectionSwitch.x) : (447.395))))) ^ uint((injectionSwitch.x))))), (((true ? ((uint(uvec2(subgroup_size, uint((injectionSwitch.y)))))) : (103635u))) | (((subgroup_size) ^ uint((injectionSwitch.x))))))) + ((((0u | 0u) | (subgroup_local_id + ((((((1) | 0)) | (1))) >> 0)))) % subgroup_size);
 buf[virtual_gid] = 1;
 atomicStore(buf[next_virtual_gid], uint(2), (~ ((max(~ (((4) | (max(0, 0)))), ~ (((4) | 0)))))), (~ ((int(ivec2(((~ (64)) << 0), 0))))), 4);
}
