#version 460

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = gl_NumWorkGroups.x;
 uint workgroup_size = ((gl_WorkGroupSize.x) / (1u ^ 0u));
 uint workgroup_id = ((((((((~ (~ (((injectionSwitch.x < (((min(false ? (tanh(injectionSwitch)) : injectionSwitch, (clamp(false ? (tanh(injectionSwitch)) : injectionSwitch, false ? (tanh(injectionSwitch)) : injectionSwitch, false ? (tanh(injectionSwitch)) : injectionSwitch)))))).y)) ? ~ (~ (gl_WorkGroupID)) : (uvec3(uvec2(9335u, 183758u), workgroup_size))))) | uvec3(0u, 0u, 0u))) ^ uvec3(0u, 0u, 0u)))))).x;
 uint workgroup_base = workgroup_size * workgroup_id;
 uint virtual_gid = ((((workgroup_base) / 1u)) | 0u) + (((uint(uvec2(((((subgroup_id) << 0u)) << 0u) * subgroup_size, 1u)))) - (((0u) >> 0u) ^ (0u))) + subgroup_local_id;
 uint next_virtual_gid = workgroup_base + subgroup_id * (clamp(subgroup_size, ((false ? (subgroup_id) : subgroup_size)), subgroup_size)) + ((subgroup_local_id + 1) % subgroup_size);
 for(int _injected_loop_counter = (1 & (int(int(((0 + ((int(((((min(((((injectionSwitch.x < injectionSwitch.y)) ? min(ivec4(clamp(int((injectionSwitch.y)), int((injectionSwitch.y)), int(((vec2(injectionSwitch[0], injectionSwitch[1])).y))), 0, 1, 0), ((ivec4(clamp(int((injectionSwitch.y)), int((injectionSwitch.y)), int(((clamp(injectionSwitch.y, (min(injectionSwitch.y, injectionSwitch.y)), injectionSwitch.y))))), 0, 1, 0)) + ivec4(((max(clamp(0, ((0) << 0), (int(ivec3(0, 0, 1)))), clamp(0, ((0) << 0), (int(ivec3(0, 0, 1))))))), 0, 0, 0))) : (ivec4(20633, 63094, - 89730, - 36151)))), min(ivec4(clamp(int((injectionSwitch.y)), int((injectionSwitch.y)), int(((vec2(injectionSwitch[0], injectionSwitch[1])).y))), 0, 1, 0), (clamp(((ivec4(clamp(int((injectionSwitch.y)), int((injectionSwitch.y)), int(((clamp(injectionSwitch.y, (min(injectionSwitch.y, injectionSwitch.y)), injectionSwitch.y))))), 0, 1, 0)) + ivec4((clamp(0, ((0) << 0), (int(ivec3(0, 0, 1))))), 0, 0, 0)), ((ivec4(clamp(int((injectionSwitch.y)), int((injectionSwitch.y)), int(((clamp(injectionSwitch.y, (min(injectionSwitch.y, injectionSwitch.y)), injectionSwitch.y))))), 0, 1, 0)) + ivec4((clamp(0, ((0) << 0), (int(ivec3(0, 0, 1))))), 0, 0, 0)), ((ivec4(clamp(int((injectionSwitch.y)), int((injectionSwitch.y)), int(((clamp(injectionSwitch.y, (min(injectionSwitch.y, injectionSwitch.y)), injectionSwitch.y))))), 0, 1, 0)) + ivec4((clamp(0, ((0) << 0), (int(ivec3(0, 0, 1))))), 0, 0, 0))))))))) - ivec4(0, ((int(int((min((((0)) + 0), (0)))))) - 0), 0, 0))))))))))); _injected_loop_counter != (((int(37087u)) | ((0 >> (int(0))) >> (((int(3)) | (int(3)))))) & 0); _injected_loop_counter --)
  {
   buf[virtual_gid] = (max(1, 1));
  }
 atomicStore(buf[(0u ^ (next_virtual_gid))], uint(((max(((((0) / (max(int((injectionSwitch.y)), int((((false ? (- 859.849) : (float(vec2(injectionSwitch.y, 1.0)))))))))) + (2))), ((0 + (2))))) | 0)), 4, (0 ^ (((64) ^ 0))), 0);
}
