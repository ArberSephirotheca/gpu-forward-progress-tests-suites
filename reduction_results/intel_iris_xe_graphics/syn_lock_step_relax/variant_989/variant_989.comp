#version 460

struct _GLF_struct_10 {
 int _f0;
 bool _f1;
 mat2 _f2;
 uint virtual_gid;
} ;

struct _GLF_struct_7 {
 mat2x3 _f0;
 mat4x2 _f1;
} ;

struct _GLF_struct_6 {
 uvec4 _f0;
 mat4x2 _f1;
} ;

struct _GLF_struct_8 {
 _GLF_struct_6 _f0;
 _GLF_struct_7 _f1;
 vec2 _f2;
} ;

struct _GLF_struct_4 {
 vec2 _f0;
} ;

struct _GLF_struct_3 {
 uint subgroup_size;
 mat4x2 _f0;
 mat2x4 _f1;
 mat4x3 _f2;
 uvec3 _f3;
 uvec4 _f4;
} ;

struct _GLF_struct_2 {
 mat4x2 _f0;
 ivec4 _f1;
 mat4x2 _f2;
} ;

struct _GLF_struct_1 {
 mat2x3 _f0;
 bvec4 _f1;
 uvec2 _f2;
 float _f3;
 vec3 _f4;
 ivec2 _f5;
 int _f6;
} ;

struct _GLF_struct_0 {
 vec4 _f0;
 float _f1;
 vec4 _f2;
 mat2x3 _f3;
 mat4x2 _f4;
 vec3 _f5;
} ;

struct _GLF_struct_5 {
 _GLF_struct_0 _f0;
 _GLF_struct_1 _f1;
 ivec3 _f2;
 _GLF_struct_2 _f3;
 _GLF_struct_3 _f4;
 _GLF_struct_4 _f5;
} ;

struct _GLF_struct_9 {
 vec3 _f0;
 _GLF_struct_5 _f1;
 _GLF_struct_8 _f2;
 float _f3;
} ;

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 for(int _injected_loop_counter = (min(0, 0)); _injected_loop_counter < 1; _injected_loop_counter ++)
  {
   if((((injectionSwitch.x > injectionSwitch.y))))
    {
     if((((((min(injectionSwitch.x, injectionSwitch.x)) > injectionSwitch.y) && true))))
      {
      }
     else
      {
       if(((injectionSwitch.x < injectionSwitch.y)))
        {
         if((((injectionSwitch.x > injectionSwitch.y))))
          return;
        }
       else
        {
        }
       return;
      }
     if((false))
      continue;
    }
   if((((false) || false)))
    continue;
  }
 if(true)
  {
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
  }
 else
  {
  }
 for(int _injected_loop_counter = 1; _injected_loop_counter > (0 << (int(2))); _injected_loop_counter --)
  {
   if((false))
    {
     for(int _injected_loop_counter = (79881 & 0); _injected_loop_counter < 1; _injected_loop_counter ++)
      {
       return;
      }
    }
  }
 uint subgroup_id = gl_SubgroupID;
 _GLF_struct_9 _GLF_struct_replacement_9 = _GLF_struct_9(vec3(1.0), _GLF_struct_5(_GLF_struct_0(vec4(1.0), 1.0, vec4(1.0), mat2x3(1.0), mat4x2(1.0), vec3(1.0)), _GLF_struct_1(mat2x3(1.0), bvec4(true), uvec2(1u), 1.0, vec3(1.0), ivec2(1), 1), ivec3(1), _GLF_struct_2(mat4x2(1.0), ivec4(1), mat4x2(((mix(float((- 3.7)), float((mix(float(mix(float((- 7801.6600)), float((clamp(1.0, 1.0, 1.0))), bool(true))), float((7.0)), bool(false)))), bool(true)))))), _GLF_struct_3(gl_SubgroupSize, mat4x2((mix(float((- 9483.5525)), float(1.0), bool(true)))), mat2x4(1.0), mat4x3(1.0), uvec3(1u), uvec4(1u)), _GLF_struct_4(vec2(1.0))), _GLF_struct_8(_GLF_struct_6(uvec4(1u), mat4x2(1.0)), _GLF_struct_7(mat2x3(1.0), mat4x2((min(1.0, 1.0)))), ((mix(vec2(((((false ? (vec2(- 595.154, 6.0)) : vec2(1.0)))))[0], (min(((((false ? (vec2(- 595.154, 6.0)) : vec2(1.0)))))[1], ((((false ? (vec2(- 595.154, 6.0)) : vec2(1.0)))))[1]))), vec2((7.9), (- 86.33)), bvec2(false, false))) / vec2(1.0, 1.0))), ((((injectionSwitch.x < (max((clamp(injectionSwitch, injectionSwitch, injectionSwitch)).y, (max(injectionSwitch.y, injectionSwitch.y)))))) ? 1.0 : (mix(- 845.626, atanh((mix(float((min(- 80.09, - 80.09))), float((- 1.0)), bool(false)))), true)))));
 if((((injectionSwitch.x > injectionSwitch.y))))
  return;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = gl_NumWorkGroups.x;
 uint workgroup_size = (clamp((1u * (gl_WorkGroupSize.x)), (1u * ((((uint(uint(gl_WorkGroupSize.x)))) / 1u))), (1u * (gl_WorkGroupSize.x))));
 if((((injectionSwitch.x > injectionSwitch.y))))
  return;
 if((false))
  {
   if((((false || (((true && (((bool(bvec4(false, false, false, true))) && true))))))) || false))
    {
     do
      {
       if((((injectionSwitch.x > injectionSwitch.y))))
        return;
      }
     while(((false || (bool((bvec3(bvec3(bvec3(false, false, true)))))))));
    }
   else
    {
     return;
    }
   if((((! (! (((((max((((min(injectionSwitch, injectionSwitch)) * mat2(1.0))).x, (((max((min(injectionSwitch, injectionSwitch)) * mat2(1.0), (min(injectionSwitch, injectionSwitch)) * mat2(1.0))))).x)) > injectionSwitch.y))))))) && true))
    {
     do
      {
       return;
      }
     while((((bool(bvec3(injectionSwitch.x > injectionSwitch.y, true, true))))));
    }
   do
    {
     if((((injectionSwitch.x > injectionSwitch.y))))
      {
       for(int _injected_loop_counter = 0; _injected_loop_counter != 1; _injected_loop_counter ++)
        {
         return;
        }
      }
    }
   while(false);
   if((false))
    {
     for(int _injected_loop_counter = (0 << ((0 ^ ((max(((int(3)) << 0), int(3))))))); _injected_loop_counter != 1; _injected_loop_counter ++)
      {
       return;
      }
    }
   if((false))
    {
     do
      {
       return;
      }
     while(((injectionSwitch.x > injectionSwitch.y)));
    }
   for(int _injected_loop_counter = (((min((0 << (int(1))), (0 << (int(1))))) | 0)); (! (! (_injected_loop_counter < ((((((min(((((0 | 1) | 0)) >> 0), 0 | 1))) << (((int(6))) << 0)) >> ((((((max(0 << (int(7)), 0 << (int(7))))) ^ 0)) ^ ((int(ivec2(((int(6))), 1))))) | (0 + (((((((int(6))) >> 0)) >> 0)))))) << ((((injectionSwitch.x < injectionSwitch.y)) ? (((int(5)) << 0)) : (2988)))) >> (((1 * ((int(5)) / (1 & 1))))))))); _injected_loop_counter ++)
    {
     if(((! ((! ((false || (! (! (false))))))))))
      {
       for(int _injected_loop_counter = 1; _injected_loop_counter > 0; _injected_loop_counter --)
        {
         return;
        }
       if((false))
        break;
      }
    }
  }
 if((true && (((bool(bvec2(((injectionSwitch.x > injectionSwitch.y)), true)))))))
  return;
 if(true)
  {
   if((false))
    {
     for(int _injected_loop_counter = 0; _injected_loop_counter < 1; _injected_loop_counter ++)
      {
       return;
      }
    }
  }
 else
  {
  }
 uint workgroup_id = gl_WorkGroupID.x;
 uint workgroup_base = workgroup_size * workgroup_id;
 _GLF_struct_10 _GLF_struct_replacement_10 = _GLF_struct_10(((1) << (0 | 0)), (! (! ((bool(bvec2(((true) && true), true)))))), mat2(((1.0) / 1.0)), workgroup_base + subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size + (min(subgroup_local_id, (uint(uvec3(((subgroup_local_id) | 0u), 1u, 0u))))));
 do
  {
   if((false))
    {
     if((false))
      continue;
     return;
    }
   if((false))
    break;
  }
 while(false);
 if((false))
  {
   if(false)
    {
    }
   else
    {
     return;
    }
  }
 if((((injectionSwitch.x > (clamp(injectionSwitch, injectionSwitch, ((injectionSwitch) * vec2(1.0, 1.0)))).y))))
  return;
 uint next_virtual_gid = (~ (~ (0u ^ (((((clamp((((max((((uint(uvec2((max(workgroup_base + subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size, workgroup_base + subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size)), 0u)))) - 0u) + (((uint(uint(((subgroup_local_id + 1) % (max((max(_GLF_struct_replacement_9._f1._f4.subgroup_size, _GLF_struct_replacement_9._f1._f4.subgroup_size)), _GLF_struct_replacement_9._f1._f4.subgroup_size)))))) / 1u)), workgroup_base + subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size + ((((subgroup_local_id + 1)) | 0u) % _GLF_struct_replacement_9._f1._f4.subgroup_size)))) / 1u), (((max((((uint(uvec2((max(workgroup_base + subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size, ((workgroup_base + ((subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size) / uint((injectionSwitch.y)))) * 1u))), 0u)))) - 0u) + (((uint(uint(((subgroup_local_id + 1) % (max((max(_GLF_struct_replacement_9._f1._f4.subgroup_size, _GLF_struct_replacement_9._f1._f4.subgroup_size)), _GLF_struct_replacement_9._f1._f4.subgroup_size)))))) / 1u)), workgroup_base + (((max(subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size, ((subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size) >> 0u)))) | ((max(subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size, ((subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size) >> 0u))))) + ((subgroup_local_id + 1) % _GLF_struct_replacement_9._f1._f4.subgroup_size)))) / 1u), ((true ? (((max((((uint(uvec2((((max(workgroup_base + subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size, workgroup_base + subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size))) - (0u & 57691u)), 0u)))) - 0u) + (((uint(uint(((subgroup_local_id + 1) % (max((max((max(_GLF_struct_replacement_9._f1._f4.subgroup_size, _GLF_struct_replacement_9._f1._f4.subgroup_size)), (max(_GLF_struct_replacement_9._f1._f4.subgroup_size, _GLF_struct_replacement_9._f1._f4.subgroup_size)))), _GLF_struct_replacement_9._f1._f4.subgroup_size)))))) / 1u)), workgroup_base + subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size + ((subgroup_local_id + 1) % (min(_GLF_struct_replacement_9._f1._f4.subgroup_size, _GLF_struct_replacement_9._f1._f4.subgroup_size)))))) / 1u) : (151313u))))))) | (((clamp((((max((((uint(uvec2((max(workgroup_base + subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size, workgroup_base + subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size)), 0u)))) - 0u) + (((uint(uint(((subgroup_local_id + 1) % (max((max(_GLF_struct_replacement_9._f1._f4.subgroup_size, _GLF_struct_replacement_9._f1._f4.subgroup_size)), _GLF_struct_replacement_9._f1._f4.subgroup_size)))))) / 1u)), workgroup_base + subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size + ((((subgroup_local_id + 1)) | 0u) % _GLF_struct_replacement_9._f1._f4.subgroup_size)))) / 1u), (((max((((uint(uvec2((max(workgroup_base + subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size, ((workgroup_base + ((subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size) / uint((injectionSwitch.y)))) * 1u))), 0u)))) - 0u) + (((uint(uint(((subgroup_local_id + 1) % (max((max(_GLF_struct_replacement_9._f1._f4.subgroup_size, _GLF_struct_replacement_9._f1._f4.subgroup_size)), _GLF_struct_replacement_9._f1._f4.subgroup_size)))))) / 1u)), workgroup_base + (((max(subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size, ((subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size) >> 0u)))) | ((max(subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size, ((subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size) >> 0u))))) + ((subgroup_local_id + 1) % _GLF_struct_replacement_9._f1._f4.subgroup_size)))) / 1u), ((true ? (((max((((uint(uvec2((((max(workgroup_base + subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size, workgroup_base + subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size))) - (0u & 57691u)), 0u)))) - 0u) + (((uint(uint(((subgroup_local_id + 1) % (max((max((max(_GLF_struct_replacement_9._f1._f4.subgroup_size, _GLF_struct_replacement_9._f1._f4.subgroup_size)), (max(_GLF_struct_replacement_9._f1._f4.subgroup_size, _GLF_struct_replacement_9._f1._f4.subgroup_size)))), _GLF_struct_replacement_9._f1._f4.subgroup_size)))))) / 1u)), workgroup_base + subgroup_id * _GLF_struct_replacement_9._f1._f4.subgroup_size + ((subgroup_local_id + 1) % (min(_GLF_struct_replacement_9._f1._f4.subgroup_size, _GLF_struct_replacement_9._f1._f4.subgroup_size)))))) / 1u) : (151313u))))))))))));
 ((buf[_GLF_struct_replacement_10.virtual_gid] = 1) << 0u);
 for(int _injected_loop_counter = 0; _injected_loop_counter != 1; _injected_loop_counter ++)
  {
   atomicStore(buf[next_virtual_gid], uint(2), 4, 64, ((((((0)) * 1)) - (0 << (int(2)))) << 0));
  }
}
