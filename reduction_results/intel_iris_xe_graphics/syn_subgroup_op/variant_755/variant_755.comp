#version 460

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 uvec2 GLF_merged2_0_1_11_1_1_14virtual_gidworkgroup_size;
 uvec2 GLF_merged2_0_1_16_1_1_14next_virtual_gidworkgroup_size;
 if((false))
  barrier();
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 if(((((false || (false || ((bool(bvec3((! ((bool(bvec4(! (bool((bool((bvec2(bvec3((bvec2(bvec4(bvec2(bool(false), true), true, true))), false))))))), (bool(bvec3((! (! ((true && (false))))), true, false))), false, false))))), true, ((injectionSwitch.x > injectionSwitch.y))))))))))))
  barrier();
 uint subgroup_local_id = gl_SubgroupInvocationID;
 if((false))
  barrier();
 if((((false) && true)))
  barrier();
 uint num_workgroup = gl_NumWorkGroups.x;
 uint workgroup_size = gl_WorkGroupSize.x;
 GLF_merged2_0_1_11_1_1_14virtual_gidworkgroup_size.y = workgroup_size;
 GLF_merged2_0_1_16_1_1_14next_virtual_gidworkgroup_size.y = GLF_merged2_0_1_11_1_1_14virtual_gidworkgroup_size.y;
 uint workgroup_id = gl_WorkGroupID.x;
 uint workgroup_base = (~ (~ (0u | ((((GLF_merged2_0_1_16_1_1_14next_virtual_gidworkgroup_size.y)) ^ 0u))))) * workgroup_id;
 if((false))
  barrier();
 uint virtual_gid = workgroup_base + subgroup_id * subgroup_size + subgroup_local_id;
 if((false))
  {
   if((false))
    {
     if((false))
      {
       if((((injectionSwitch.x > injectionSwitch.y))))
        barrier();
       barrier();
       if((((injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
     barrier();
    }
   barrier();
  }
 if((false))
  {
   if(((((! (! (((bool(bvec3(((! (! (((injectionSwitch.x > (mix(float((- 9518.5164)), float((clamp((((false ? (vec2(4.7, 1.3)) : (injectionSwitch) * mat2((injectionSwitch.y))))).y, injectionSwitch.y, injectionSwitch.y))), bool(true))))))))) && true, false, ((injectionSwitch.x > injectionSwitch.y))))))))) || ((false || (bool(bvec3((bool(bool(((injectionSwitch.x > (vec2(mat4x3((clamp(injectionSwitch, injectionSwitch, injectionSwitch)), 1.0, (max(((clamp(dot(vec2(1.0, 0.0), vec2(1.0, 0.0)), dot(vec2(1.0, 0.0), vec2(1.0, 0.0)), dot(vec2(1.0, 0.0), vec2(1.0, 0.0))))), ((clamp(dot(vec2(1.0, 0.0), vec2(1.0, 0.0)), dot(vec2(1.0, 0.0), vec2(1.0, 0.0)), dot(vec2(1.0, 0.0), vec2(1.0, 0.0))))))), 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, (0.0 + (1.0)), 0.0))).y))))), true, (false || (true)))))))))))
    barrier();
   if(((! (! (false)))))
    barrier();
   if((false))
    barrier();
   barrier();
  }
 if((false))
  {
   if((false))
    barrier();
   if((false))
    barrier();
   barrier();
  }
 GLF_merged2_0_1_11_1_1_14virtual_gidworkgroup_size.x = (((((((uint(uvec3(virtual_gid, 1u, 1u))) >> 0u)) / 1u))) | 0u);
 uint next_virtual_gid = (min(((max(((0u + (workgroup_base))) | (workgroup_base), (((min((max(0u + (workgroup_base), 0u + (workgroup_base))), 0u + (workgroup_base))))) | (workgroup_base)))), ((max(((0u + (workgroup_base))) | (((workgroup_base)) | (0u << ((max(uint(0u), uint(0u)))))), (((min((max(0u + (workgroup_base), ((false ? (156050u) : ((0u + (workgroup_base)) | (0u + (workgroup_base))))))), 0u + (workgroup_base))))) | (workgroup_base)))))) + (((uint((clamp(uint(subgroup_id), uint(subgroup_id), uint(subgroup_id))))) * (0u + (max((subgroup_size), (subgroup_size))))) | (uint(uint((subgroup_id * (0u + (max((((clamp((min(uint(uvec3((min(((subgroup_size) - 0u), subgroup_size)), 0u, 1u)), uint(uvec3((min(((subgroup_size) - 0u), subgroup_size)), 0u, 1u)))), uint(uvec3(subgroup_size, 0u, 1u)), uint(uvec3(subgroup_size, 0u, 1u)))))), (subgroup_size))))))))) + (~ (~ ((((0u + ((clamp(((subgroup_local_id + 1) % subgroup_size), (((uint(uint(subgroup_local_id + 1)))) % subgroup_size), ((subgroup_local_id + 1) % subgroup_size))))))) / 1u)));
 GLF_merged2_0_1_16_1_1_14next_virtual_gidworkgroup_size.x = next_virtual_gid;
 if((false))
  barrier();
 if((bool(bvec3((((injectionSwitch.x > injectionSwitch.y))), false, false))))
  barrier();
 for(int _injected_loop_counter = 0; (0 + ((int(ivec3((clamp(((((0 ^ (int(((int((~ (~ (_injected_loop_counter))))) >> 0)))))) >> (0 + (0))), (((int(ivec4(((0 ^ (max((int(((int(_injected_loop_counter)) >> 0))), (int(((int(_injected_loop_counter)) >> 0))))))), 1, ((false ? (_injected_loop_counter) : int((injectionSwitch.y)))), 0)))) >> 0), (max(((false ? (97047) : (int(ivec2(((((0 ^ (int(((int(_injected_loop_counter)) >> 0)))))) >> 0), 1))))), (1 * (((((0 ^ (int(((int(_injected_loop_counter)) >> 0)))))) >> 0))))))), 0, 1))))) != 1; ((((0 + ((((_injected_loop_counter ++) / int((injectionSwitch.y))))))) * 1) >> 0))
  {
   for(int _injected_loop_counter = ((((0 | (1 * ((int(ivec4(0, 0, 1, 1)))))) ^ (clamp(1, 1, (((int(int(1)))) - (((~ (~ (0)))) | 0)))))) - 0); (false || ((((((false || ((int(int(_injected_loop_counter))) > 0)) || false))) || false))); _injected_loop_counter --)
    {
     for(int _injected_loop_counter = 1; _injected_loop_counter != ((0 << (int(5))) ^ 0); ((_injected_loop_counter --) - 0))
      {
       buf[GLF_merged2_0_1_11_1_1_14virtual_gidworkgroup_size.x] = (int(int((clamp(1, 1, 1)))));
       if((false))
        barrier();
       if((((injectionSwitch.x > injectionSwitch.y))))
        barrier();
      }
    }
   if((false))
    barrier();
  }
 if((min(subgroup_local_id + 1, subgroup_local_id + 1)) < subgroup_size)
  {
   do
    {
     (~ ((((0u | ((0u + (~ (buf[GLF_merged2_0_1_16_1_1_14next_virtual_gidworkgroup_size.x] = 2)))))) ^ 0u)));
     if((((! (! ((false)))) && (! (! ((bool(bvec3((bool(bvec4(true, true, false, true))), true, false)))))))))
      barrier();
    }
   while((bool((((bvec2(bvec4(bvec2(bvec4(bvec2(bvec2(bvec2(false, true))), true, false)), false, false))))))));
   subgroupAll(false);
  }
 else
  {
   buf[GLF_merged2_0_1_16_1_1_14next_virtual_gidworkgroup_size.x] = 2;
   if((((! (! (! (! (false))))))))
    {
     if((((injectionSwitch.x > injectionSwitch.y))))
      barrier();
     barrier();
    }
   subgroupAll(true);
   if((false))
    barrier();
  }
}
