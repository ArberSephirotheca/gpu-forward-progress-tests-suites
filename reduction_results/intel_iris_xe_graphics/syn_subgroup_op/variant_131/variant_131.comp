#version 460

struct _GLF_struct_1 {
 vec4 _f0;
} ;

struct _GLF_struct_0 {
 vec4 _f0;
 ivec2 _f1;
} ;

struct _GLF_struct_2 {
 _GLF_struct_0 _f0;
 bvec3 _f1;
 uvec2 _f2;
 mat4x3 _f3;
 _GLF_struct_1 _f4;
} ;

struct _GLF_struct_3 {
 float _f0;
 uint virtual_gid;
 _GLF_struct_2 _f1;
} ;

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if((((injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if((false))
  {
   if((false))
    barrier();
   barrier();
   if((! (! ((false)))))
    barrier();
  }
 uint subgroup_id = gl_SubgroupID;
 if((false))
  barrier();
 if((false))
  barrier();
 uint subgroup_size = gl_SubgroupSize;
 if((false))
  {
   if((false))
    barrier();
   if((! (((! ((bool((bvec2(bvec4(bvec2((((injectionSwitch.x > injectionSwitch.y))), false), true, false))))))) || false))))
    barrier();
   barrier();
  }
 if(((((((float(mat3x4((vec2(mat2x4(injectionSwitch, 1.0, 1.0, (dot(vec2(sin(0.0), 1.0), vec2(0.0, 1.0))), 0.0, 0.0, (injectionSwitch.y)))).x, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0)))) * 1.0) > (vec2(injectionSwitch[0], (float(mat2x3(injectionSwitch[1], sin(0.0), 1.0, 0.0, 1.0, 0.0))))).y))))
  barrier();
 if((((false) || false)))
  barrier();
 if((false))
  {
   if((false))
    barrier();
   barrier();
  }
 uint subgroup_local_id = gl_SubgroupInvocationID;
 if((((injectionSwitch.x > injectionSwitch.y))))
  barrier();
 uint num_workgroup = gl_NumWorkGroups.x;
 uint workgroup_size = gl_WorkGroupSize.x;
 if((false))
  {
   if((false))
    barrier();
   barrier();
  }
 if((false))
  barrier();
 if((((false) || false)))
  {
   if((((injectionSwitch.x > injectionSwitch.y))))
    {
     if((false))
      barrier();
     barrier();
    }
   if((((injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(((false || (false))))
    {
     if(((((clamp(injectionSwitch.x, injectionSwitch.x, (float(vec4(injectionSwitch.x, 0.0, 1.0, 1.0))))) > injectionSwitch.y))))
      barrier();
     barrier();
    }
   barrier();
  }
 if((false))
  barrier();
 if(((((bool(bvec4(((((! (! ((bool(bvec3(true, false, true))))))) || ((false) && true)) && ((! (((! (((injectionSwitch.x > injectionSwitch.y))))) && true)))), true, false, false)))) || false)))
  {
   if((false))
    barrier();
   barrier();
  }
 uint workgroup_id = gl_WorkGroupID.x;
 uint workgroup_base = workgroup_size * workgroup_id;
 if((false))
  barrier();
 if(((false || (((injectionSwitch.x > injectionSwitch.y))))))
  {
   if((false))
    barrier();
   if(((true && (false))))
    {
     if((false))
      barrier();
     barrier();
    }
   barrier();
   if((false))
    barrier();
   if(((bool(bool(false)))))
    barrier();
  }
 if((false))
  barrier();
 _GLF_struct_3 _GLF_struct_replacement_3 = _GLF_struct_3(1.0, (max(((workgroup_base) - 0u), ((workgroup_base) - 0u))) + subgroup_id * subgroup_size + subgroup_local_id, _GLF_struct_2(_GLF_struct_0(vec4(1.0), ivec2(1)), ((bvec3(bvec4(bvec3(bvec3(bvec3(true))), true)))), uvec2((~ ((uint(uvec3(~ (1u), 0u, (1u & 1u))))))), mat4x3(1.0), _GLF_struct_1(vec4(1.0))));
 if((((injectionSwitch.x > injectionSwitch.y))))
  {
   if((false))
    barrier();
   barrier();
  }
 if((false))
  {
   if((((injectionSwitch.x > injectionSwitch.y))))
    barrier();
   barrier();
  }
 if((false))
  barrier();
 if((false))
  barrier();
 if((false))
  {
   if((false))
    barrier();
   barrier();
   if((false))
    barrier();
  }
 if((false))
  barrier();
 if((false))
  barrier();
 if(((((vec2(0.0, 0.0) + (injectionSwitch)).x > injectionSwitch.y))))
  {
   if((false))
    barrier();
   barrier();
  }
 uint next_virtual_gid = workgroup_base + (uint(uvec2(subgroup_id * ((~ (~ ((true ? ((~ (~ (uint((((((uvec2(0u, 0u) | (false ? (uvec2(51184u, 69099u)) : uvec2((max((max(((subgroup_size) - uint((clamp((injectionSwitch.x), (injectionSwitch.x), (max((injectionSwitch.x), (clamp((injectionSwitch.x), (injectionSwitch.x), (injectionSwitch.x))))))))), subgroup_size)), (min(subgroup_size, subgroup_size)))), 0u)))) >> uvec2(0u, 0u))))))))) : (workgroup_id)))))), 0u))) + ((subgroup_local_id + (((true ? (false ? (((318)) / 1) : ((1) | 0)) : (52894))))) % (max(subgroup_size, ((subgroup_size) / 1u))));
 (0u ^ (buf[_GLF_struct_replacement_3.virtual_gid] = 1));
 if(((! (! (false)))))
  barrier();
 if((! ((! ((false || (! (! (subgroup_local_id + ((max(0, 0)) ^ (1)) < (min(subgroup_size, ((subgroup_size) | (subgroup_size)))))))))))))
  {
   if((((injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(((! (! (false)))))
    barrier();
   if((false))
    barrier();
   (~ ((0u | (0u ^ ((~ (buf[next_virtual_gid] = 2)))))));
   if((((injectionSwitch.x > injectionSwitch.y))))
    barrier();
   subgroupAll(false);
   if(((true && ((((! (! (false)))) || false)))))
    barrier();
   if((false))
    barrier();
  }
 else
  {
   if((false))
    {
     if(((((mix(float((((float(mat4x2((min((6995.5183), (6995.5183))), 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, exp(0.0))))) * 1.0)), float(injectionSwitch.x), bool(true))) > injectionSwitch.y))))
      barrier();
     if((((injectionSwitch.x > injectionSwitch.y))))
      barrier();
     if((((injectionSwitch.x > injectionSwitch.y))))
      {
       if((false))
        barrier();
       barrier();
      }
     barrier();
    }
   (0u ^ (buf[next_virtual_gid] = 2));
   subgroupAll(true);
   if((false))
    barrier();
   if((((injectionSwitch.x > injectionSwitch.y))))
    barrier();
   if(((bool(bvec4(false, true, true, false)))))
    barrier();
   if((((injectionSwitch.x > injectionSwitch.y))))
    barrier();
  }
}
