#version 460

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(set = 0, binding = 2) buffer WriteVal {
 uint write_val;
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if((false))
  return;
 if((((false || ((((injectionSwitch.x > injectionSwitch.y)))))) && true))
  return;
 if((((injectionSwitch.x > injectionSwitch.y))))
  return;
 if((false))
  return;
 if((false))
  return;
 uvec4 GLF_merged4_0_1_11_1_1_13_2_1_11_3_1_14subgroup_idsubgroup_sizevirtual_gidworkgroup_base;
 if((false))
  return;
 if((((injectionSwitch.x > (vec2(vec2(injectionSwitch))).y))))
  {
   if((false))
    return;
   return;
  }
 if((false))
  {
   if(((true && (false))))
    return;
   if((false))
    return;
   if((false))
    return;
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   return;
  }
 if((((((injectionSwitch.x > injectionSwitch.y)) || (((true && ((true && ((! ((bool(bvec2((bool(bool(! ((false || ((bool(bool(injectionSwitch.x > injectionSwitch.y))))))))), false)))))))))))))))
  {
   if((false))
    return;
   return;
  }
 if(((((min((min(injectionSwitch.x, injectionSwitch.x)), injectionSwitch.x)) > injectionSwitch.y))))
  return;
 if((((injectionSwitch.x > injectionSwitch.y))))
  {
   if((((false) || false)))
    return;
   return;
  }
 if((((injectionSwitch.x > injectionSwitch.y))))
  return;
 if((false))
  return;
 uint subgroup_id = gl_SubgroupID;
 if((! (! ((((bool((bvec2(bvec3(bvec2((((((false)) && true) && true)), true), true))))) || false))))))
  return;
 if((((injectionSwitch.x > injectionSwitch.y))))
  return;
 if((false))
  {
   if((false))
    return;
   return;
  }
 GLF_merged4_0_1_11_1_1_13_2_1_11_3_1_14subgroup_idsubgroup_sizevirtual_gidworkgroup_base.x = subgroup_id;
 if((false))
  return;
 if((false))
  {
   if((false))
    {
     if((false))
      return;
     return;
    }
   return;
  }
 if((true && ((false))))
  {
   if(((bool(bvec3((bool(bvec3(false, true, true))), false, true)))))
    return;
   if((((false) && true)))
    {
     if((false))
      return;
     if((false))
      return;
     return;
    }
   if(((true && (false))))
    {
     if(((bool(bvec2(false, true)))))
      return;
     return;
    }
   return;
  }
 if((false))
  return;
 if(((! (! (false)))))
  {
   if((false))
    return;
   if((false))
    return;
   if(((((0.0 + ((min(injectionSwitch, ((mix(vec2((max((((vec2(mat4x3(injectionSwitch, (injectionSwitch.x), 1.0, exp(0.0), 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0)))) * vec2(1.0, 1.0))[0], ((injectionSwitch) * (((max(vec2(1.0, 1.0), vec2(1.0, 1.0)))) + vec2(0.0, 0.0)))[0])), (- 6840.5227)), vec2((- 33.64), ((injectionSwitch) * vec2(((max(float(mat4x3(1.0, 0.0, 0.0, determinant(mat2(1.0, 1.0, 0.0, sqrt(1.0))), 0.0, 0.0, 0.0, abs(length(vec4(0.0, 0.0, 0.0, 0.0))), 0.0, 1.0, 1.0, (dot(vec2(1.0, (dot(vec2(1.0, 1.0), vec2(0.0, 0.0)))), vec2(1.0, 0.0))))), float(mat4x3(1.0, 0.0, 0.0, determinant(mat2(1.0, 1.0, 0.0, sqrt(1.0))), 0.0, 0.0, 0.0, abs(length(vec4(0.0, 0.0, 0.0, 0.0))), 0.0, 1.0, 1.0, (dot(vec2(1.0, (dot(vec2(1.0, 1.0), vec2(0.0, 0.0)))), vec2(1.0, 0.0)))))))), 1.0))[1]), bvec2(false, true)))))).x)) > injectionSwitch.y))))
    {
     if((false))
      {
       if((false))
        return;
       return;
      }
     return;
    }
   return;
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   if((false))
    {
     if(((! (! (false)))))
      return;
     if((false))
      return;
     return;
    }
   if(((! (! (false)))))
    return;
  }
 uint subgroup_size = gl_SubgroupSize;
 if((! (! ((bool(bvec2((false), true)))))))
  return;
 if((((injectionSwitch.x > injectionSwitch.y))))
  return;
 if((false))
  return;
 if((! ((bool(bool((((true && (! ((false))))) || ((injectionSwitch.x > injectionSwitch.y)))))))))
  {
   if((false))
    return;
   return;
  }
 GLF_merged4_0_1_11_1_1_13_2_1_11_3_1_14subgroup_idsubgroup_sizevirtual_gidworkgroup_base.y = subgroup_size;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = gl_NumWorkGroups.x;
 if((false))
  {
   if((false))
    return;
   return;
  }
 if((((injectionSwitch.x > ((false ? (47.36) : ((float(vec4(min(injectionSwitch.y, injectionSwitch.y), 0.0, 0.0, 1.0))))))))))
  {
   if((false))
    return;
   if((false))
    return;
   return;
   if((false))
    return;
  }
 if((((injectionSwitch.x > injectionSwitch.y))))
  return;
 if(((bool(bvec2(false, true)))))
  return;
 if((false))
  return;
 if((((false)) || false))
  return;
 if((false))
  return;
 uint workgroup_size = gl_WorkGroupSize.x;
 uint workgroup_id = gl_WorkGroupID.x;
 uint workgroup_base = workgroup_size * ((min(((((~ (~ (workgroup_id)))) >> 0u)), ((((clamp((uint(((uvec2((~ ((uint(uvec4(~ (workgroup_id), uint((injectionSwitch.x)), 0u, 1u))))), 0u)) ^ uvec2(0u, 0u)))), (~ (~ (workgroup_id))), ((((injectionSwitch.x > injectionSwitch.y)) ? (atomicOr(workgroup_id, subgroup_local_id)) : (~ (~ (workgroup_id)))))))) >> 0u)))) / (min(1u, 1u)));
 if((false))
  {
   if((false))
    return;
   return;
  }
 GLF_merged4_0_1_11_1_1_13_2_1_11_3_1_14subgroup_idsubgroup_sizevirtual_gidworkgroup_base.w = workgroup_base;
 if((false))
  return;
 uint virtual_gid = ((((GLF_merged4_0_1_11_1_1_13_2_1_11_3_1_14subgroup_idsubgroup_sizevirtual_gidworkgroup_base) - (uvec4(0u, 0u, 0u, 0u) | uvec4(0u, 0u, 0u, 0u))).w + GLF_merged4_0_1_11_1_1_13_2_1_11_3_1_14subgroup_idsubgroup_sizevirtual_gidworkgroup_base.x * GLF_merged4_0_1_11_1_1_13_2_1_11_3_1_14subgroup_idsubgroup_sizevirtual_gidworkgroup_base.y) | 0u) + subgroup_local_id;
 if((false))
  return;
 GLF_merged4_0_1_11_1_1_13_2_1_11_3_1_14subgroup_idsubgroup_sizevirtual_gidworkgroup_base.z = virtual_gid;
 atomicStore(write_val, uint(GLF_merged4_0_1_11_1_1_13_2_1_11_3_1_14subgroup_idsubgroup_sizevirtual_gidworkgroup_base.z), 4, 64, 0);
 if((((injectionSwitch.x > injectionSwitch.y))))
  return;
 if((false))
  return;
 if((false))
  {
   if((((injectionSwitch.x > injectionSwitch.y))))
    return;
   return;
  }
 if((false))
  return;
 uint read_val = atomicLoad(write_val, ((((clamp((((((~ (~ ((4) << ((0) * (0 | 1)))))) - 0)) | 0), (4) << 0, (4) << 0))) / 1)), (max(64, 64)), ((false ? (((98074)) / 1) : (int((max(int((max((1 * (((false ? (- 20674) : ((min((0), ((~ (~ (0)))))) / 1))))), ((false ? (54794) : (((1) >> (0 << (int(5)))) * (((false ? (- 20674) : ((min((0), (0))) / 1)))))))))), (max(int((1 * (clamp((~ ((clamp(~ ((min((0), (0)))), ~ (0 + (((min((0), (0)))))), ~ ((((((min((0), (0))) - (~ (~ (0))))) ^ 0))))))), (min((0), (0))), (min((0), (0))))))), (0 | (int((1 * (clamp((~ ((clamp(~ ((min((0), (0)))), ~ (0 + (((min((0), (0)))))), ~ ((((((min((0), (0))) - (~ (~ (0))))) ^ 0))))))), (min((0), (0))), (min((0), (0))))))))))))))))));
 if((false))
  return;
 if((false))
  {
   if((((injectionSwitch.x > injectionSwitch.y))))
    {
     if((false))
      return;
     return;
     if((false))
      return;
    }
   if(((bool(bvec3(false, true, true)))))
    return;
   if((false || ((((false) || false)))))
    {
     if((false))
      return;
     return;
     if((false))
      return;
    }
   return;
   if((false))
    return;
  }
 if((((false) && true)))
  return;
 ((buf[GLF_merged4_0_1_11_1_1_13_2_1_11_3_1_14subgroup_idsubgroup_sizevirtual_gidworkgroup_base.z] = uint(subgroupAllEqual(read_val))) ^ 0u);
 if((false))
  return;
 if((false))
  return;
 if((false))
  {
   if((false))
    return;
   return;
  }
 if((false))
  {
   if((false))
    return;
   return;
  }
 if((false))
  return;
 if((false))
  {
   if((((injectionSwitch.x < injectionSwitch.y)) && ((false))))
    {
     if((((injectionSwitch.x > injectionSwitch.y))))
      return;
     if((false))
      return;
     if((false))
      return;
     return;
    }
   if((false))
    {
     if((((injectionSwitch.x > injectionSwitch.y))))
      return;
     if((((injectionSwitch.x > injectionSwitch.y))))
      {
       if((false))
        return;
       return;
      }
     if((false))
      return;
     if((false))
      return;
     return;
     if((false))
      {
       if((((injectionSwitch.x > injectionSwitch.y))))
        return;
       return;
      }
    }
   return;
  }
 if((false))
  return;
}
