#version 460

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 if((false))
  return;
 uint num_workgroup = gl_NumWorkGroups.x;
 uint workgroup_size = gl_WorkGroupSize.x;
 uint workgroup_id = gl_WorkGroupID.x;
 uint workgroup_base = workgroup_size * workgroup_id;
 uint virtual_gid = ((((((((((((workgroup_base + subgroup_id * ((((max(1u, 1u)) * (subgroup_size))) / 1u)) / ((false ? (workgroup_size) : 1u))) | ((0u + ((min((((! ((bool(((bool(((bool(bvec4((! ((true && (bool((bvec2((bvec3(bvec3(bvec3(bvec2(((((((vec2(injectionSwitch[0], ((injectionSwitch) + tan(sin(vec2(0.0, 0.0))))[1])).x < injectionSwitch.y))) || false)), true), true))))))))))), false, true, ((true) || false)))) || (true && (false))))) && true))))) ? ((max((((~ (((0u >> (uint(0u))) + ((clamp((true ? (~ (workgroup_base)) : (subgroup_size)), (true ? (~ (workgroup_base)) : (subgroup_size)), (true ? (~ (workgroup_base)) : (subgroup_size))))))))) >> 0u), workgroup_base)) + subgroup_id * subgroup_size) : (mix(subgroup_size, 136168u, false)))), (((((! ((bool(((bool(((bool(bvec4((! ((true && (bool((bvec2((bvec3(bvec3(bvec3(bvec2(((((((vec2(injectionSwitch[0], ((injectionSwitch) + tan(sin(vec2(0.0, 0.0))))[1])).x < injectionSwitch.y))) || false)), true), true))))))))))), false, true, ((true) || false)))) || (true && (false))))) && true))))) ? ((max((((~ (((0u >> (uint(0u))) + ((clamp((true ? (~ (workgroup_base)) : (subgroup_size)), (true ? (~ (workgroup_base)) : (subgroup_size)), (true ? (~ (workgroup_base)) : (subgroup_size))))))))) >> 0u), workgroup_base)) + subgroup_id * subgroup_size) : (mix(subgroup_size, 136168u, false))))) ^ 0u))))) / 1u))) * 1u))) - 0u)) / 1u) + subgroup_local_id) << (0u >> (uint(4u))));
 uint next_virtual_gid = ((0u ^ ((((workgroup_base) * uint((injectionSwitch.y))) + subgroup_id * ((((((subgroup_size) | (((clamp(0u | (min((subgroup_size), (subgroup_size))), (0u | (0u | (min((subgroup_size), (subgroup_size))))), 0u | (min((subgroup_size), (subgroup_size))))))))) << 0u)) | ((((uint((((~ (~ ((uvec2(0u, 0u) ^ ((uvec2(uvec3(uvec2(((subgroup_size) | ((0u | (min((subgroup_size), (subgroup_size)))))), (uint(uvec3(0u, 0u, 0u)))), 1u)))))))) | (uvec2(uvec3(uvec2(((subgroup_size) | ((0u | (min((subgroup_size), (subgroup_size)))))), (uint(uvec3(0u, 0u, 0u)))), 1u)))))))) << 0u)))))) | (((workgroup_base) * uint((injectionSwitch.y))) + subgroup_id * (((((max(uint((uvec2(uvec4(uvec2((subgroup_size), 0u), 0u, 1u)))), uint((uvec2(uvec4(uvec2((subgroup_size), 0u), 0u, 1u))))))) | ((0u | (min((subgroup_size), (subgroup_size))))))) << 0u))) + ((subgroup_local_id + 1) % subgroup_size);
 buf[virtual_gid] = 1;
 if(subgroup_local_id + 1 < subgroup_size)
  {
   int i = 0;
   atomicStore(buf[next_virtual_gid], uint(2), 4, ((1 * (~ ((((((max((0 ^ (((~ (((64) >> (1 ^ 1)))) | 0))), (0 ^ (((~ (((64) >> (1 ^ 1)))) | 0)))))) | 0)) | ((((max((0 ^ (((~ (((64) >> (1 ^ 1)))) | 0))), (0 ^ (((~ (((64) >> (1 ^ 1)))) | 0)))))) | 0))))))), 4);
  }
 else
  {
   if((((injectionSwitch.x > (mix((clamp((((false ? (length(vec4(24.24, 32.08, - 6.7, 1218.2041))) : max(float((8060.7200)), float((8060.7200)))))), float((8060.7200)), float((8060.7200)))), float(injectionSwitch.y), bool(true)))))))
    return;
   atomicStore(buf[next_virtual_gid], uint(2), (((true ? ((true ? ((((clamp((min(4, ((4) | (4)))), 4, 4)))) ^ 0) : (86811))) : (30835))) | (0 << (int((int(ivec2(5, 1))))))), 64, 4);
   if((false))
    return;
   if((false))
    return;
  }
}
