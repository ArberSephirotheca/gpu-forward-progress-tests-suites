#version 460

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 if((((injectionSwitch.x > injectionSwitch.y))))
  barrier();
 uint subgroup_id = gl_SubgroupID;
 if((false))
  barrier();
 if(((! ((! (! (! (false))))))))
  barrier();
 if((false))
  barrier();
 if((((false)) || false))
  barrier();
 if((((! (! ((((injectionSwitch.x > injectionSwitch.y))))))) && true))
  {
   do
    {
     if(true)
      {
       barrier();
      }
     else
      {
      }
    }
   while(false);
   if((((((vec2(0.0, 0.0) + (((max(injectionSwitch, ((injectionSwitch) * mat2(1.0))))))) - vec2(0.0, 0.0)).x > injectionSwitch.y))))
    barrier();
   if((false))
    barrier();
  }
 do
  {
   for(int _injected_loop_counter = 0; _injected_loop_counter < (int(ivec2((((true ? min(int((injectionSwitch.y)), (min(int((injectionSwitch.y)), int((injectionSwitch.y))))) : (- 80337)))), 0))); _injected_loop_counter ++)
    {
     if(((injectionSwitch.x < injectionSwitch.y)))
      {
       if(((injectionSwitch.x > injectionSwitch.y)))
        {
        }
       else
        {
         if(((((bool(bool((((min(((false ? (vec2(- 4.1, 39.12)) : (mat2(1.0) * (injectionSwitch)))), (mat2(1.0) * (injectionSwitch)))).x > injectionSwitch.y) || false))))))))
          {
           do
            {
             if((((((injectionSwitch.x < injectionSwitch.y)) && ((bool(bvec2(true && ((! (! (false)))), true))))))))
              {
               if(((injectionSwitch.x > injectionSwitch.y)))
                {
                 if((((((injectionSwitch.x > injectionSwitch.y)))) || false))
                  barrier();
                }
               else
                {
                 if((((false) && true)))
                  {
                   if((false))
                    barrier();
                   barrier();
                  }
                }
               if((false))
                barrier();
               if((false))
                barrier();
               barrier();
              }
            }
           while((((vec2(mat3(injectionSwitch, 1.0, 1.0, 1.0, 0.0, cos(0.0), 0.0, (dot(vec4((dot(vec2(0.0, 0.0), vec2(1.0, 1.0))), 0.0, 0.0, 0.0), vec4(1.0, 1.0, 1.0, 1.0)))))).x > injectionSwitch.y)));
           barrier();
           if(false)
            {
            }
           else
            {
             if((((! (! ((false || ((injectionSwitch.x > (min(injectionSwitch, (min(injectionSwitch, injectionSwitch)))).y)))))))))
              barrier();
            }
          }
        }
      }
     else
      {
      }
     if((((injectionSwitch.x > injectionSwitch.y))))
      barrier();
    }
   if((false))
    barrier();
   if((((injectionSwitch.x > injectionSwitch.y))))
    {
     if(((injectionSwitch.x > injectionSwitch.y)))
      {
       if(true)
        {
         if((false))
          {
           if((false))
            barrier();
           barrier();
          }
        }
       else
        {
        }
      }
     else
      {
       if((false))
        barrier();
       if((((injectionSwitch.x > ((false ? (vec2(1196.3653, 6.1)) : injectionSwitch)).y))))
        barrier();
       if(false)
        {
        }
       else
        {
         if((((injectionSwitch.x > injectionSwitch.y))))
          barrier();
        }
       barrier();
      }
    }
  }
 while((bool(bvec4((true && (((! (! ((injectionSwitch.x > injectionSwitch.y))))))), true, true, (bool(bool((((((true && ((bool(bvec4(false, false, false, true)))))) && true)) && ((injectionSwitch.x < injectionSwitch.y))))))))));
 uint subgroup_size = gl_SubgroupSize;
 if((false))
  barrier();
 uint subgroup_local_id = gl_SubgroupInvocationID;
 if((((injectionSwitch.x > injectionSwitch.y))))
  barrier();
 if(((((((bool(bvec4(bool(bvec2((((mix(float((269.120)), ((false ? (min(- 16.27, - 6.4)) : float(0.0))), bool(true))) + ((mix(((false ? (mix(mix(623.968, 113.953, 79.58), - 7145.7127, 1.3)) : float(((false ? (7497.5638) : injectionSwitch.x))))), float((float(22351))), bool(false))))) > injectionSwitch.y), false)), false, false, false)))) && true)))))
  barrier();
 if((! (! ((false)))))
  return;
 if(((false || ((! (! ((false || (false)))))))))
  barrier();
 if(true)
  {
   do
    {
     if((false))
      barrier();
    }
   while((! (! (false))));
  }
 else
  {
  }
 for(int _injected_loop_counter = int((injectionSwitch.x)); ((_injected_loop_counter) >> 0) != (max(1, 1)); (((((bool(bvec4(injectionSwitch.x < injectionSwitch.y, false, false, false))))) ? ((((_injected_loop_counter ++) << 0)) - 0) : (- 61394))))
  {
   if((false))
    barrier();
   if(false)
    {
    }
   else
    {
     if((((false) || false)))
      {
       if(false)
        {
        }
       else
        {
         barrier();
        }
      }
    }
   if((false))
    {
     if((((injectionSwitch.x > injectionSwitch.y))))
      barrier();
     barrier();
    }
   if(((true && ((bool(bvec3(((injectionSwitch.x > injectionSwitch.y)), true, false)))))))
    {
     if(false)
      {
      }
     else
      {
       barrier();
      }
    }
  }
 if(((true) && true))
  {
   if((((! (! ((bool(bvec4(((min((((((vec2(mat2x3(injectionSwitch, 0.0, abs(0.0), 0.0, 1.0)))) - vec2(0.0, 0.0))) - vec2(0.0, 0.0)), injectionSwitch)).x > injectionSwitch.y), true, true, false)))))))))
    {
     if(true)
      {
       barrier();
      }
     else
      {
      }
    }
  }
 else
  {
  }
 if((((false)) && true))
  barrier();
 uint num_workgroup = gl_NumWorkGroups.x;
 if(((((injectionSwitch.x) - log(1.0)) < injectionSwitch.y)))
  {
   if((((injectionSwitch.x > injectionSwitch.y))))
    barrier();
  }
 else
  {
  }
 uint workgroup_size = gl_WorkGroupSize.x;
 if((((! (! (true)))) && true))
  {
   if((! (! ((((bool((bool((bool((bool(bool(bool(bool(bool(((injectionSwitch.x > injectionSwitch.y)) || (false)))))))))))))))))))
    barrier();
   if(((! (! (false)))))
    {
     if((false))
      {
       for(int _injected_loop_counter = 1; _injected_loop_counter > (0 >> (int(7))); _injected_loop_counter --)
        {
         for(int _injected_loop_counter = (((- 53419 & 0) << (int(7))) >> (((((int(3)) / 1)) | (int(3))))); _injected_loop_counter < 1; _injected_loop_counter ++)
          {
           if((true && (((! (! (bool(bvec3(false, (bool(bvec4(true, true, true, false))), false)))))))))
            {
             if((false))
              {
               if(((injectionSwitch.x < ((true ? injectionSwitch : (vec2(9.9, 99.49)))).y)))
                {
                 barrier();
                }
               else
                {
                }
              }
             do
              {
               if((false))
                {
                 if(((injectionSwitch.x < (((clamp(injectionSwitch.y, injectionSwitch.y, injectionSwitch.y))) / 1.0))))
                  {
                   barrier();
                  }
                 else
                  {
                  }
                }
              }
             while(((injectionSwitch.x > injectionSwitch.y)));
             if((false))
              barrier();
            }
           else
            {
             if((false))
              {
               for(int _injected_loop_counter = 0; _injected_loop_counter != 1; _injected_loop_counter ++)
                {
                 barrier();
                }
               if((false))
                barrier();
              }
             if((false))
              {
               if(((! (! (false)))))
                barrier();
               barrier();
              }
            }
          }
        }
       for(int _injected_loop_counter = 0; (false || (_injected_loop_counter < ((((1 << (int(((3) - int(((clamp(float(vec3((injectionSwitch.x), 0.0, 0.0)), float(vec3((injectionSwitch.x), 0.0, 0.0)), float(vec3((injectionSwitch.x), 0.0, 0.0)))))))))) >> (((int(3)) << 0))) << (int(3))) >> (int(3))))); _injected_loop_counter ++)
        {
         if(((true) && true))
          {
           barrier();
           if((bool(bvec3(false, true, false))))
            {
            }
           else
            {
             if((((((false)) && true)) || false))
              {
               if((false || ((bool(bool((false)))))))
                barrier();
               barrier();
              }
             if((((injectionSwitch.x > injectionSwitch.y))))
              barrier();
            }
           do
            {
             if(((((max((max(injectionSwitch.x, injectionSwitch.x)), injectionSwitch.x)) > injectionSwitch.y))))
              barrier();
            }
           while(false);
          }
         else
          {
          }
        }
       if((((injectionSwitch.x > injectionSwitch.y))))
        barrier();
       if(((! (! (false)))))
        {
         for(int _injected_loop_counter = 1; _injected_loop_counter > (int((injectionSwitch.x)) ^ 0); _injected_loop_counter --)
          {
           barrier();
          }
        }
       if(false)
        {
        }
       else
        {
         if((false))
          {
           for(int _injected_loop_counter = 0; (false || (_injected_loop_counter < int((injectionSwitch.y)))); _injected_loop_counter ++)
            {
             barrier();
            }
          }
        }
      }
     if(false)
      {
      }
     else
      {
       barrier();
       if((false))
        barrier();
      }
     if(((! (! (false)))))
      {
       do
        {
         barrier();
         if(((bool(bool(false)))))
          barrier();
        }
       while(false);
       if((false))
        {
         if((false))
          barrier();
         barrier();
        }
      }
     if((false))
      barrier();
    }
  }
 else
  {
   if((false))
    barrier();
  }
 if((((injectionSwitch.x > injectionSwitch.y))))
  barrier();
 for(int _injected_loop_counter = 0; _injected_loop_counter != ((((1 << (int(2))) >> (int(2)))) ^ 0); _injected_loop_counter ++)
  {
   for(int _injected_loop_counter = ((1 << (int(0))) >> (int(0))); _injected_loop_counter != ((true ? 0 : (atomicXor(_injected_loop_counter, 24789)))); _injected_loop_counter --)
    {
     if((false))
      {
       if((((injectionSwitch.x > (clamp(injectionSwitch.y, injectionSwitch.y, injectionSwitch.y))))))
        barrier();
       barrier();
      }
    }
  }
 if((false))
  {
   if((false))
    barrier();
   barrier();
  }
 if((false))
  barrier();
 uint workgroup_id = gl_WorkGroupID.x;
 if(true)
  {
   if(false)
    {
    }
   else
    {
     if(((bool((bvec2(bvec4(bvec2(((bool(bvec2(bool(bvec4(((false || (((! (! (((((((injectionSwitch.x < (min(injectionSwitch, injectionSwitch)).y)) && ((true && ((false) && true)))))) && ((((injectionSwitch.x) * 1.0) < injectionSwitch.y))))))))) && ((injectionSwitch.x < injectionSwitch.y))), true, true, ((true) && true))), true)))), false), false, ((true) || (bool(bvec2(false, false)))))))))))
      {
       for(int _injected_loop_counter = (0 & 81931); (clamp(_injected_loop_counter, _injected_loop_counter, _injected_loop_counter)) != (1 & 1); _injected_loop_counter ++)
        {
         for(int _injected_loop_counter = 1; _injected_loop_counter != 0; _injected_loop_counter --)
          {
           if((((injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if((false))
            barrier();
           if(((bool(bvec4((! (! ((bool(bvec4(false, false, false, false)))))), false, true, true)))))
            barrier();
           barrier();
           if((((injectionSwitch.x > injectionSwitch.y))))
            barrier();
           if((false))
            barrier();
           if((false))
            {
             if(((bool(bvec2(false, false)))))
              {
               if((false))
                barrier();
               barrier();
              }
             if(true)
              {
               barrier();
              }
             else
              {
              }
            }
          }
        }
      }
     if(((bool(bvec2(((injectionSwitch.x > ((max(mat2(1.0) * (injectionSwitch), mat2(1.0) * (injectionSwitch)))).y)), false)))))
      {
       do
        {
         barrier();
        }
       while(false);
      }
    }
   if((false))
    barrier();
   do
    {
     if((false))
      barrier();
    }
   while(false);
  }
 else
  {
   if((false))
    barrier();
   if((((injectionSwitch.x > (max(((injectionSwitch) * mat2(1.0)), injectionSwitch)).y))))
    {
     if(((injectionSwitch.x > injectionSwitch.y)))
      {
      }
     else
      {
       if(true)
        {
         if((((injectionSwitch.x > injectionSwitch.y))))
          {
           do
            {
             barrier();
            }
           while(false);
          }
         barrier();
        }
       else
        {
        }
      }
     if((((((injectionSwitch.x) - log(1.0)) > injectionSwitch.y))))
      barrier();
    }
   do
    {
     if(((bool(bvec4(((injectionSwitch.x > injectionSwitch.y)), true, true, false)))))
      barrier();
     if(((injectionSwitch.x > injectionSwitch.y)))
      {
      }
     else
      {
       if((false))
        {
         if((false))
          {
           for(int _injected_loop_counter = (0 >> (int(5))); _injected_loop_counter < 1; _injected_loop_counter ++)
            {
             barrier();
            }
          }
         if((((injectionSwitch.x > injectionSwitch.y))))
          barrier();
         for(int _injected_loop_counter = 1; _injected_loop_counter != (0 >> (int(8))); _injected_loop_counter --)
          {
           if(true)
            {
             if(false)
              {
              }
             else
              {
               if((false))
                barrier();
              }
            }
           else
            {
            }
          }
         barrier();
        }
      }
    }
   while((! (! ((true && (false))))));
  }
 for(int _injected_loop_counter = int((injectionSwitch.x)); _injected_loop_counter < int((injectionSwitch.y)); _injected_loop_counter ++)
  {
   if(((((injectionSwitch.x > (vec2(injectionSwitch[0], injectionSwitch[1])).y))) || false))
    {
    }
   else
    {
     if((false))
      barrier();
    }
  }
 if(((injectionSwitch.x > injectionSwitch.y)))
  {
  }
 else
  {
   if((false))
    barrier();
  }
 if((true && ((((injectionSwitch.x > injectionSwitch.y))))))
  barrier();
 if(((injectionSwitch.x < (vec2(injectionSwitch[0], injectionSwitch[1])).y)))
  {
   if((bool(bvec4((((false)) || false), (! (! (false))), true, false))))
    barrier();
   if((false))
    barrier();
   if((! (! ((((injectionSwitch.x > injectionSwitch.y)))))))
    barrier();
  }
 else
  {
  }
 if(false)
  {
  }
 else
  {
   do
    {
     if((false))
      barrier();
     if((((true && (bool((bvec3(bvec3((bvec3(bvec3(bvec3(((injectionSwitch.x > injectionSwitch.y)), false, (((mix(float((- 9.0)), float(injectionSwitch.x), bool(true))) > injectionSwitch.y)))))))))))))))
      barrier();
     if((false))
      {
       if(true)
        {
         for(int _injected_loop_counter = ((((0) * (min(((1) >> 0), 1)))) >> 0); _injected_loop_counter < int((1.0 * ((injectionSwitch.y)))); _injected_loop_counter ++)
          {
           if(((injectionSwitch.x < injectionSwitch.y)))
            {
             if(false)
              {
              }
             else
              {
               if((false))
                {
                 for(int _injected_loop_counter = int((injectionSwitch.x)); _injected_loop_counter != ((int((injectionSwitch.y)) << (int(3))) >> (max((int(3)), (int(3))))); _injected_loop_counter ++)
                  {
                   barrier();
                  }
                }
              }
            }
           else
            {
            }
           if(true)
            {
             barrier();
            }
           else
            {
            }
          }
        }
       else
        {
        }
      }
    }
   while(((bool(bvec4((false), true, false, false))) || false));
  }
 uint workgroup_base = workgroup_size * ((workgroup_id) - 0u);
 uint virtual_gid = (((max(((workgroup_base + (min(((true ? subgroup_id * subgroup_size : (subgroup_id))), subgroup_id * subgroup_size)) + subgroup_local_id) + 0u), (max(((workgroup_base) | 0u) + subgroup_id * (((true ? (uint(uint(((((~ ((min(~ ((((uint(((uvec4(subgroup_size, 0u, 0u, 0u)) | (uvec4(subgroup_size, 0u, 0u, 0u))))) / uint((injectionSwitch.y))))), ~ (subgroup_size))))))) >> 0u)))) : (subgroup_local_id))) ^ (20873u & 0u)), workgroup_base + subgroup_id * (((~ ((min(~ ((((((uint(((uvec4(subgroup_size, 0u, 0u, 0u)) | (uvec4((~ (~ (subgroup_size))), 0u, 0u, 0u))))) << 0u)) / uint((injectionSwitch.y))))), ~ (subgroup_size)))))) ^ (20873u & 0u)))) + (clamp(((((injectionSwitch.x < injectionSwitch.y)) ? subgroup_local_id : (80071u))), subgroup_local_id, subgroup_local_id))))) | (workgroup_base + subgroup_id * subgroup_size + subgroup_local_id));
 uint next_virtual_gid = ((~ (~ (clamp(workgroup_base, workgroup_base, workgroup_base))))) + subgroup_id * subgroup_size + (((~ (~ ((~ (~ (subgroup_local_id + 1))))))) % subgroup_size);
 buf[virtual_gid] = 1;
 atomicStore(buf[next_virtual_gid], uint(2), (int(ivec3(((4) | (4)), 0, 0))), 64, (min(4, 4)));
 if((false))
  {
   do
    {
     barrier();
    }
   while(false);
  }
 if((! (! ((! (! ((bool((bvec2(bvec2(bvec2(((false || (false))), true)))))))))))))
  {
   if(true)
    {
     if(((true) || false))
      {
       for(int _injected_loop_counter = 1; _injected_loop_counter != 0; _injected_loop_counter --)
        {
         barrier();
        }
      }
     else
      {
      }
     if((false))
      barrier();
    }
   else
    {
    }
   if(false)
    {
    }
   else
    {
     if((bool(bvec4((false), ((injectionSwitch.x < injectionSwitch.y)), true, false))))
      barrier();
    }
  }
 for(int _injected_loop_counter = int((injectionSwitch.y)); _injected_loop_counter > 0; _injected_loop_counter --)
  {
   if((false))
    {
     if((false))
      barrier();
     if((false))
      {
       if(((! (! (false)))))
        barrier();
       do
        {
         barrier();
         if((false))
          barrier();
        }
       while(false);
       if((false))
        barrier();
      }
     barrier();
    }
  }
 if((((injectionSwitch.x > injectionSwitch.y))))
  barrier();
}
