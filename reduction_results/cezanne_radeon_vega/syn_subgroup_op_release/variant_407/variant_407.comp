#version 460

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = (uvec3(gl_NumWorkGroups[0], (uvec3((0u | (gl_NumWorkGroups[0])), gl_NumWorkGroups[(min(1, 1))], gl_NumWorkGroups[((false ? (0 | ((((40338)) >> 0))) : 2))]))[((true ? 1 : ((clamp(((false ? (- 95588) : 74524)), 74524, 74524)))))], gl_NumWorkGroups[2])).x;
 uint workgroup_size = (clamp(gl_WorkGroupSize, gl_WorkGroupSize, gl_WorkGroupSize)).x;
 uint workgroup_id = ((gl_WorkGroupID.x) - (0u >> (uint(2u))));
 uint workgroup_base = workgroup_size * workgroup_id;
 uint virtual_gid = (((((clamp((((clamp((~ (~ (workgroup_base))), ((workgroup_base) ^ 0u), workgroup_base)) | ((clamp(clamp((~ (~ (workgroup_base))), ((workgroup_base) ^ 0u), workgroup_base), clamp((~ (~ (workgroup_base))), ((workgroup_base) ^ 0u), workgroup_base), clamp((~ (~ (workgroup_base))), ((workgroup_base) ^ 0u), workgroup_base)))))) | (clamp((~ (~ (((workgroup_base) >> 0u)))), ((workgroup_base) ^ 0u), workgroup_base)), (((clamp((~ (~ (workgroup_base))), ((workgroup_base) ^ 0u), workgroup_base)) | ((clamp(clamp((~ (~ (workgroup_base))), ((workgroup_base) ^ 0u), workgroup_base), clamp((~ (~ (workgroup_base))), ((workgroup_base) ^ 0u), workgroup_base), clamp((~ (~ (workgroup_base))), ((workgroup_base) ^ 0u), workgroup_base)))))) | (clamp((~ (~ (((workgroup_base) >> 0u)))), ((workgroup_base) ^ 0u), workgroup_base)), (((clamp((~ (~ (workgroup_base))), ((workgroup_base) ^ 0u), workgroup_base)) | ((clamp(clamp((~ (~ (workgroup_base))), ((workgroup_base) ^ 0u), workgroup_base), clamp((~ (~ (workgroup_base))), ((workgroup_base) ^ 0u), workgroup_base), clamp((~ (~ (workgroup_base))), ((workgroup_base) ^ 0u), workgroup_base)))))) | (clamp((~ (~ (((workgroup_base) >> 0u)))), ((workgroup_base) ^ 0u), workgroup_base)))))) + ((subgroup_id) | 0u) * subgroup_size + (clamp((0u ^ (((min(((((max(subgroup_local_id, subgroup_local_id)) + 0u))) << 0u, ((((max(subgroup_local_id, subgroup_local_id)) + 0u))) << 0u))))), (0u ^ ((uint(uvec2((((((max(subgroup_local_id, subgroup_local_id)) + 0u))) << 0u), 1u))))), (min((0u ^ ((((((max(subgroup_local_id, subgroup_local_id)) + 0u))) << 0u))), (0u ^ ((((((max(subgroup_local_id, (max(((~ (~ (uint(uvec4(subgroup_local_id, 1u, 1u, 0u)))))), subgroup_local_id)))) + 0u))) << 0u)))))))) / uint((injectionSwitch.y)));
 uint next_virtual_gid = workgroup_base + subgroup_id * subgroup_size + (0u ^ ((((max(subgroup_local_id + 1, (~ ((~ ((clamp((clamp((min(~ (((~ (subgroup_local_id + 1)) | (~ (subgroup_local_id + 1)))), ~ (((~ (subgroup_local_id + 1)) | (~ (subgroup_local_id + 1)))))), (min(~ (((~ (subgroup_local_id + 1)) | (~ (subgroup_local_id + 1)))), ~ (((~ (subgroup_local_id + 1)) | (~ (subgroup_local_id + 1)))))), (min(~ (((~ (subgroup_local_id + 1)) | (~ (subgroup_local_id + 1)))), ~ (((~ (subgroup_local_id + 1)) | (~ (subgroup_local_id + 1)))))))), (0u | ((min(~ (((~ (subgroup_local_id + 1)) | (~ (subgroup_local_id + 1)))), ~ (((~ (subgroup_local_id + 1)) | (~ (subgroup_local_id + 1)))))))), (((min(~ (((~ (subgroup_local_id + 1)) | (~ (subgroup_local_id + 1)))), ~ (((~ (subgroup_local_id + 1)) | (~ (subgroup_local_id + 1))))))) - (0u & 35101u))))))))))) % subgroup_size)));
 buf[virtual_gid] = 1;
 do
  {
   if(((subgroup_local_id + 1) | (((~ (~ (clamp(((subgroup_local_id) << 0u) + 1, subgroup_local_id + 1, (0u | (subgroup_local_id + 1))))))))) < subgroup_size)
    {
     atomicStore(buf[(clamp(next_virtual_gid, next_virtual_gid, next_virtual_gid))], ((1u * (((max(uint(2), uint(2)))) | (~ (~ ((0u ^ ((min((((false ? (subgroup_size) : (uint(uint(uint(2))))))), (((false ? (subgroup_size) : (uint(uint(uint(2))))))))))))))))), 4, 64, 4);
     if(true)
      {
       subgroupAll(false);
      }
     else
      {
      }
    }
   else
    {
     do
      {
       atomicStore(buf[next_virtual_gid], (clamp(uint(2), uint(2), uint(2))), 4, 64, ((((false) || false) ? (((69260) + (0 ^ ((max((~ (~ (((0) | (0))))), 0)))))) : ((((4) | ((min(4, 4)))) + (~ (~ (0))))))));
      }
     while((! (! (true && (((((((true && (((injectionSwitch.x > ((min(((clamp(injectionSwitch, (clamp(injectionSwitch, injectionSwitch, (min(injectionSwitch, injectionSwitch)))), (vec2(injectionSwitch[0], injectionSwitch[1]))))), ((clamp(injectionSwitch, (clamp(injectionSwitch, injectionSwitch, (min((min((clamp(injectionSwitch, (mix(vec2((injectionSwitch)[0], (injectionSwitch)[1]), vec2((- 3989.2811), (9.2)), bvec2(false, false))), injectionSwitch)), (vec2(mat4(injectionSwitch, 0.0, 0.0, cos(0.0), 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0))))), injectionSwitch)))), (vec2(injectionSwitch[0], injectionSwitch[1]))))))) * mat2(1.0)).y)))) && true)) && true))))))));
     subgroupAll(true);
    }
  }
 while(((((false || (true && ((((true && (true)) && ((((injectionSwitch.x > injectionSwitch.y) || false)))))))))) && true));
}
