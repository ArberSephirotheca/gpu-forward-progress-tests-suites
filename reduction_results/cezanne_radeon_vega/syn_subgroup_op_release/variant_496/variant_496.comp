#version 460

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 if((((! (! (! (! ((bool((bvec2(bvec4(bvec2(false, ((injectionSwitch.x > (float(vec4(injectionSwitch.y, 0.0, 0.0, 1.0)))))), true, true)))))))))))))
  return;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = (((((max((((uvec3(1u, 1u, 1u) << (uvec3(5u))) >> (uvec3(5u))) * ((~ (~ (((((((gl_NumWorkGroups) | (gl_NumWorkGroups))) | (((uvec3(uvec4((gl_NumWorkGroups), 1u))) - uvec3(((0u) / 1u), 0u, 0u)))) - uvec3(0u, 0u, 0u)))))))) - uvec3(0u, 0u, ((0u) - 0u)), ((((uvec3((((true ? (uvec4((uvec3(uvec3((((gl_NumWorkGroups) | (gl_NumWorkGroups))) | (((uvec3(uvec4((gl_NumWorkGroups), 1u))) - uvec3(0u, 0u, 0u)))))), 1u)) ^ uvec4(0u, 0u, 0u, 0u) : (uvec4(125400u, 40663u, 2046u, 15211u)))))))) - uvec3(0u, (clamp(0u, 0u, 0u)), 0u))) - uvec3((~ ((~ (((~ (~ (0u))) << 0u))))), (max(0u, 0u)), 0u)))) | ((~ (~ ((max((((uvec3(1u, 1u, 1u) << (uvec3(5u))) >> (uvec3(5u))) * ((~ (~ (((((((gl_NumWorkGroups) | (gl_NumWorkGroups))) | (((uvec3(uvec4((gl_NumWorkGroups), 1u))) - uvec3(((0u) / 1u), 0u, 0u)))) - uvec3(0u, 0u, 0u)))))))) - uvec3(0u, 0u, ((0u) - 0u)), ((((uvec3((((true ? (uvec4((uvec3(uvec3((((gl_NumWorkGroups) | (gl_NumWorkGroups))) | (((uvec3(uvec4((gl_NumWorkGroups), 1u))) - uvec3(0u, 0u, 0u)))))), 1u)) ^ uvec4(0u, 0u, 0u, 0u) : (uvec4(125400u, 40663u, 2046u, 15211u)))))))) - uvec3(0u, (clamp(0u, 0u, 0u)), 0u))) - uvec3((~ ((~ (((~ (~ (0u))) << 0u))))), (max(0u, 0u)), 0u)))))))))).x;
 uint workgroup_size = ((clamp(1u * ((false ? (subgroup_size) : (gl_WorkGroupSize.x))), (~ ((~ (~ (~ ((clamp(((1u * (((((((injectionSwitch.x > injectionSwitch.y)) || ((false || (false))))) && true) ? ((~ ((0u | (~ ((min(subgroup_size, subgroup_size)))))))) : (gl_WorkGroupSize.x)))) - 0u), ((1u * (((((((injectionSwitch.x > injectionSwitch.y)) || ((false || (false))))) && true) ? ((~ ((0u | (~ ((min(subgroup_size, subgroup_size)))))))) : (gl_WorkGroupSize.x)))) - 0u), ((1u * (((((((injectionSwitch.x > injectionSwitch.y)) || ((false || (false))))) && true) ? ((~ ((0u | (~ ((min(subgroup_size, subgroup_size)))))))) : (gl_WorkGroupSize.x)))) - 0u))))))))), 1u * ((false ? (subgroup_size) : (gl_WorkGroupSize.x))))));
 uint workgroup_id = (((clamp(gl_WorkGroupID.x, gl_WorkGroupID.x, gl_WorkGroupID.x))) | (max((max((max((((((uint(uvec4((gl_WorkGroupID.x), 0u, 0u, 0u))) << (max(0u, 0u))) | 0u))), (~ (~ (((((((~ (((~ ((uvec3(uvec4(gl_WorkGroupID, 1u))))) / uvec3(1u, 1u, 1u)))) << uvec3(0u, 0u, 0u)))) >> uvec3((injectionSwitch.x), (injectionSwitch.x), (injectionSwitch.x))).x)))))), ((~ (((~ (gl_WorkGroupID.x)) | 0u)))))), ((((~ (~ ((min(gl_WorkGroupID.x, gl_WorkGroupID.x)))))) >> ((((0u) - 0u)) ^ 0u))))));
 uint workgroup_base = workgroup_size * workgroup_id;
 uint virtual_gid = workgroup_base + subgroup_id * (((min(subgroup_size, (~ (~ (subgroup_size)))))) << 0u) + subgroup_local_id;
 if(((((bool((bvec3(bvec3(bvec3((((bool(bvec4(injectionSwitch.x > injectionSwitch.y, ((((injectionSwitch.x < injectionSwitch.y)) || false)), true, ((injectionSwitch.x > injectionSwitch.y))))))), (false || (((injectionSwitch.x < injectionSwitch.y)))), true)))))))) && true))
  return;
 uint next_virtual_gid = workgroup_base + subgroup_id * subgroup_size + ((subgroup_local_id + 1) % subgroup_size);
 buf[virtual_gid] = 1;
 if(((((bool(bvec3(false, true, false))) || (injectionSwitch.x < ((false ? ((min((max(9604.4650, 9604.4650)), ((true ? 9604.4650 : (- 23.23)))))) : injectionSwitch.y)))))))
  {
   if((false || ((false))))
    return;
   if((uint((injectionSwitch.x)) ^ (~ (~ ((subgroup_local_id + 1))))) < ((((uint((injectionSwitch.x)) ^ (max(subgroup_size, subgroup_size))))) | ((~ (~ ((((0u) / 1u)) * 1u))))))
    {
     atomicStore(buf[next_virtual_gid], uint(2), (0 | (4)), 64, 4);
     if((false))
      return;
     subgroupAll(false);
    }
   else
    {
     atomicStore(buf[next_virtual_gid], ((uint(2)) ^ 0u), 4, 64, (((min(false ? (((14667) - 0)) : ((4) | (4)), false ? ((int(((ivec3(((14667) - 0), 0, 1)) | (ivec3(((14667) - 0), 0, 1)))))) : ((max((4), (4))) | (4)))))));
     subgroupAll(true);
    }
  }
 else
  {
  }
}
