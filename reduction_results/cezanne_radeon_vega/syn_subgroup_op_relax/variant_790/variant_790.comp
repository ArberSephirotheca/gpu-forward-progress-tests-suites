#version 460

// Contents of injectionSwitch: [0.0, 1.0]
layout(set = 0, binding = 1) uniform buf1 {
 vec2 injectionSwitch;
};
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(set = 0, binding = 0) buffer Buf {
 uint buf[];
};
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main()
{
 uint subgroup_id = gl_SubgroupID;
 uint subgroup_size = gl_SubgroupSize;
 uint subgroup_local_id = gl_SubgroupInvocationID;
 uint num_workgroup = gl_NumWorkGroups.x;
 uint workgroup_size = gl_WorkGroupSize.x;
 uint workgroup_id = ((((gl_WorkGroupID)) << (uvec3(0u, 0u, 0u) | uvec3(0u, 0u, 0u))) ^ uvec3(0u, 0u, 0u)).x;
 uint workgroup_base = ((true ? ((((0u) << (196288u & 0u)) | ((workgroup_size * (min(workgroup_id, workgroup_id))))) | (workgroup_size * workgroup_id)) : (subgroup_size)));
 uint virtual_gid = workgroup_base + subgroup_id * subgroup_size + subgroup_local_id;
 uint next_virtual_gid = (uint(uint((0u ^ (workgroup_base + subgroup_id * subgroup_size + ((max((subgroup_local_id + 1), (subgroup_local_id + 1))) % subgroup_size))))));
 ((((buf[virtual_gid] = 1) ^ (uint(uvec4(0u, ((((1u << (uint(5u))) >> (uint(5u))) << (uint(3u))) >> (uint(3u))), 0u, 1u))))) * (1u | 1u));
 if(((((((((injectionSwitch.x < injectionSwitch.y)) ? 0u >> (uint(0u)) : (bitfieldInsert(81261u, workgroup_base, - 37311, 41965))))) | ((true ? (min(((0u + (((~ (~ ((~ (uint(uvec4((~ (uint((((uvec4((injectionSwitch.x), (injectionSwitch.x), ((mix(float((vec2(- 4.5, - 6.3).s)), float(injectionSwitch.x), bool(true)))), (injectionSwitch.x)) ^ (uvec4((clamp(subgroup_local_id + 1, subgroup_local_id + 1, (1u * (subgroup_local_id + 1)))), 1u, 1u, 0u)))) + uvec4(0u, 0u, (0u + (0u)), 0u))))), 1u, 0u, (0u << ((uint(uint(uint(4u)))))))))))))) << 0u))), ((min((uint(uvec4((clamp(subgroup_local_id + 1, subgroup_local_id + 1, (1u * (subgroup_local_id + 1)))), (~ (~ (1u))), 1u, 0u))) << 0u, (uint(uvec4((clamp((0u + (subgroup_local_id)) + 1, (clamp(subgroup_local_id + 1, subgroup_local_id + 1, subgroup_local_id + 1)), (1u * (subgroup_local_id + 1)))), 1u, 1u, 0u))) << 0u))))) : (((uint((injectionSwitch.x)) | ((max(subgroup_id, subgroup_id)))) << workgroup_id))))))) < subgroup_size)
  {
   atomicStore(buf[next_virtual_gid], (~ (~ (uint(2)))), ((4) - 0), 64, 0);
   subgroupAll(false);
  }
 else
  {
   atomicStore(buf[(((clamp(next_virtual_gid, next_virtual_gid, (((((true ? (~ (((false ? (workgroup_size) : uint(uvec3((~ (clamp(((((next_virtual_gid) ^ uint((injectionSwitch.x)))) * 1u), ((next_virtual_gid) ^ uint((injectionSwitch.x))), (uint(uvec2(((((((((injectionSwitch.x < injectionSwitch.y)) ? next_virtual_gid : (workgroup_base)))) << 0u)) ^ uint((injectionSwitch.x))), ((1u << (uint(1u))) >> (uint(1u))))))))), 0u, (0u >> (uint(0u))))))))) : (virtual_gid)))) - 0u))))) ^ 0u)], uint(2), 4, ((min(min(64, 64), min(64, 64)))), 0);
   subgroupAll(true);
  }
}
